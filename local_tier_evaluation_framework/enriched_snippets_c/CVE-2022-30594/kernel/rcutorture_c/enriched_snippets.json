[
  {
    "function_name": "rcu_torture_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "3079-3322",
    "snippet": "static int __init\nrcu_torture_init(void)\n{\n\tlong i;\n\tint cpu;\n\tint firsterr = 0;\n\tint flags = 0;\n\tunsigned long gp_seq = 0;\n\tstatic struct rcu_torture_ops *torture_ops[] = {\n\t\t&rcu_ops, &rcu_busted_ops, &srcu_ops, &srcud_ops,\n\t\t&busted_srcud_ops, &tasks_ops, &tasks_rude_ops,\n\t\t&tasks_tracing_ops, &trivial_ops,\n\t};\n\n\tif (!torture_init_begin(torture_type, verbose))\n\t\treturn -EBUSY;\n\n\t/* Process args and tell the world that the torturer is on the job. */\n\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++) {\n\t\tcur_ops = torture_ops[i];\n\t\tif (strcmp(torture_type, cur_ops->name) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(torture_ops)) {\n\t\tpr_alert(\"rcu-torture: invalid torture type: \\\"%s\\\"\\n\",\n\t\t\t torture_type);\n\t\tpr_alert(\"rcu-torture types:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++)\n\t\t\tpr_cont(\" %s\", torture_ops[i]->name);\n\t\tpr_cont(\"\\n\");\n\t\tfirsterr = -EINVAL;\n\t\tcur_ops = NULL;\n\t\tgoto unwind;\n\t}\n\tif (cur_ops->fqs == NULL && fqs_duration != 0) {\n\t\tpr_alert(\"rcu-torture: ->fqs NULL and non-zero fqs_duration, fqs disabled.\\n\");\n\t\tfqs_duration = 0;\n\t}\n\tif (cur_ops->init)\n\t\tcur_ops->init();\n\n\tif (nreaders >= 0) {\n\t\tnrealreaders = nreaders;\n\t} else {\n\t\tnrealreaders = num_online_cpus() - 2 - nreaders;\n\t\tif (nrealreaders <= 0)\n\t\t\tnrealreaders = 1;\n\t}\n\trcu_torture_print_module_parms(cur_ops, \"Start of test\");\n\trcutorture_get_gp_data(cur_ops->ttype, &flags, &gp_seq);\n\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp, &flags, &gp_seq);\n\tstart_gp_seq = gp_seq;\n\tpr_alert(\"%s:  Start-test grace-period state: g%ld f%#x\\n\",\n\t\t cur_ops->name, (long)gp_seq, flags);\n\n\t/* Set up the freelist. */\n\n\tINIT_LIST_HEAD(&rcu_torture_freelist);\n\tfor (i = 0; i < ARRAY_SIZE(rcu_tortures); i++) {\n\t\trcu_tortures[i].rtort_mbtest = 0;\n\t\tlist_add_tail(&rcu_tortures[i].rtort_free,\n\t\t\t      &rcu_torture_freelist);\n\t}\n\n\t/* Initialize the statistics so that each run gets its own numbers. */\n\n\trcu_torture_current = NULL;\n\trcu_torture_current_version = 0;\n\tatomic_set(&n_rcu_torture_alloc, 0);\n\tatomic_set(&n_rcu_torture_alloc_fail, 0);\n\tatomic_set(&n_rcu_torture_free, 0);\n\tatomic_set(&n_rcu_torture_mberror, 0);\n\tatomic_set(&n_rcu_torture_mbchk_fail, 0);\n\tatomic_set(&n_rcu_torture_mbchk_tries, 0);\n\tatomic_set(&n_rcu_torture_error, 0);\n\tn_rcu_torture_barrier_error = 0;\n\tn_rcu_torture_boost_ktrerror = 0;\n\tn_rcu_torture_boost_rterror = 0;\n\tn_rcu_torture_boost_failure = 0;\n\tn_rcu_torture_boosts = 0;\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tatomic_set(&rcu_torture_wcount[i], 0);\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tper_cpu(rcu_torture_count, cpu)[i] = 0;\n\t\t\tper_cpu(rcu_torture_batch, cpu)[i] = 0;\n\t\t}\n\t}\n\terr_segs_recorded = 0;\n\trt_read_nsegs = 0;\n\n\t/* Start up the kthreads. */\n\n\trcu_torture_write_types();\n\tfirsterr = torture_create_kthread(rcu_torture_writer, NULL,\n\t\t\t\t\t  writer_task);\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\tif (nfakewriters > 0) {\n\t\tfakewriter_tasks = kcalloc(nfakewriters,\n\t\t\t\t\t   sizeof(fakewriter_tasks[0]),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (fakewriter_tasks == NULL) {\n\t\t\tTOROUT_ERRSTRING(\"out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\tfor (i = 0; i < nfakewriters; i++) {\n\t\tfirsterr = torture_create_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t\t  NULL, fakewriter_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\treader_tasks = kcalloc(nrealreaders, sizeof(reader_tasks[0]),\n\t\t\t       GFP_KERNEL);\n\trcu_torture_reader_mbchk = kcalloc(nrealreaders, sizeof(*rcu_torture_reader_mbchk),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!reader_tasks || !rcu_torture_reader_mbchk) {\n\t\tTOROUT_ERRSTRING(\"out of memory\");\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\tfor (i = 0; i < nrealreaders; i++) {\n\t\trcu_torture_reader_mbchk[i].rtc_chkrdr = -1;\n\t\tfirsterr = torture_create_kthread(rcu_torture_reader, (void *)i,\n\t\t\t\t\t\t  reader_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tnrealnocbers = nocbs_nthreads;\n\tif (WARN_ON(nrealnocbers < 0))\n\t\tnrealnocbers = 1;\n\tif (WARN_ON(nocbs_toggle < 0))\n\t\tnocbs_toggle = HZ;\n\tif (nrealnocbers > 0) {\n\t\tnocb_tasks = kcalloc(nrealnocbers, sizeof(nocb_tasks[0]), GFP_KERNEL);\n\t\tif (nocb_tasks == NULL) {\n\t\t\tTOROUT_ERRSTRING(\"out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t} else {\n\t\tnocb_tasks = NULL;\n\t}\n\tfor (i = 0; i < nrealnocbers; i++) {\n\t\tfirsterr = torture_create_kthread(rcu_nocb_toggle, NULL, nocb_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (stat_interval > 0) {\n\t\tfirsterr = torture_create_kthread(rcu_torture_stats, NULL,\n\t\t\t\t\t\t  stats_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (test_no_idle_hz && shuffle_interval > 0) {\n\t\tfirsterr = torture_shuffle_init(shuffle_interval * HZ);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (stutter < 0)\n\t\tstutter = 0;\n\tif (stutter) {\n\t\tint t;\n\n\t\tt = cur_ops->stall_dur ? cur_ops->stall_dur() : stutter * HZ;\n\t\tfirsterr = torture_stutter_init(stutter * HZ, t);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (fqs_duration < 0)\n\t\tfqs_duration = 0;\n\tif (fqs_duration) {\n\t\t/* Create the fqs thread */\n\t\tfirsterr = torture_create_kthread(rcu_torture_fqs, NULL,\n\t\t\t\t\t\t  fqs_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (test_boost_interval < 1)\n\t\ttest_boost_interval = 1;\n\tif (test_boost_duration < 2)\n\t\ttest_boost_duration = 2;\n\tif (rcu_torture_can_boost()) {\n\n\t\tboost_starttime = jiffies + test_boost_interval * HZ;\n\n\t\tfirsterr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"RCU_TORTURE\",\n\t\t\t\t\t     rcutorture_booster_init,\n\t\t\t\t\t     rcutorture_booster_cleanup);\n\t\trcutor_hp = firsterr;\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\n\t\t// Testing RCU priority boosting requires rcutorture do\n\t\t// some serious abuse.  Counter this by running ksoftirqd\n\t\t// at higher priority.\n\t\tif (IS_BUILTIN(CONFIG_RCU_TORTURE_TEST)) {\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tstruct sched_param sp;\n\t\t\t\tstruct task_struct *t;\n\n\t\t\t\tt = per_cpu(ksoftirqd, cpu);\n\t\t\t\tWARN_ON_ONCE(!t);\n\t\t\t\tsp.sched_priority = 2;\n\t\t\t\tsched_setscheduler_nocheck(t, SCHED_FIFO, &sp);\n\t\t\t}\n\t\t}\n\t}\n\tshutdown_jiffies = jiffies + shutdown_secs * HZ;\n\tfirsterr = torture_shutdown_init(shutdown_secs, rcu_torture_cleanup);\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\tfirsterr = torture_onoff_init(onoff_holdoff * HZ, onoff_interval,\n\t\t\t\t      rcutorture_sync);\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\tfirsterr = rcu_torture_stall_init();\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\tfirsterr = rcu_torture_fwd_prog_init();\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\tfirsterr = rcu_torture_barrier_init();\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\tfirsterr = rcu_torture_read_exit_init();\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\tif (object_debug)\n\t\trcu_test_debug_objects();\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\trcu_torture_cleanup();\n\tif (shutdown_secs) {\n\t\tWARN_ON(!IS_MODULE(CONFIG_RCU_TORTURE_TEST));\n\t\tkernel_power_off();\n\t}\n\treturn firsterr;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_TORTURE_PIPE_LEN 10"
    ],
    "globals_used": [
      "static char *torture_type = \"rcu\";",
      "static int nrealnocbers;",
      "static int nrealreaders;",
      "static struct task_struct *writer_task;",
      "static struct task_struct **fakewriter_tasks;",
      "static struct task_struct **reader_tasks;",
      "static struct task_struct **nocb_tasks;",
      "static struct task_struct *stats_task;",
      "static struct task_struct *fqs_task;",
      "static LIST_HEAD(rcu_torture_freelist);",
      "static struct rcu_torture __rcu *rcu_torture_current;",
      "static unsigned long rcu_torture_current_version;",
      "static struct rcu_torture rcu_tortures[10 * RCU_TORTURE_PIPE_LEN];",
      "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];",
      "static struct rcu_torture_reader_check *rcu_torture_reader_mbchk;",
      "static atomic_t n_rcu_torture_alloc;",
      "static atomic_t n_rcu_torture_alloc_fail;",
      "static atomic_t n_rcu_torture_free;",
      "static atomic_t n_rcu_torture_mberror;",
      "static atomic_t n_rcu_torture_mbchk_fail;",
      "static atomic_t n_rcu_torture_mbchk_tries;",
      "static atomic_t n_rcu_torture_error;",
      "static long n_rcu_torture_barrier_error;",
      "static long n_rcu_torture_boost_ktrerror;",
      "static long n_rcu_torture_boost_rterror;",
      "static long n_rcu_torture_boost_failure;",
      "static long n_rcu_torture_boosts;",
      "static unsigned long shutdown_jiffies;",
      "static unsigned long start_gp_seq;",
      "static int err_segs_recorded;",
      "static int rt_read_nsegs;",
      "static unsigned long boost_starttime;",
      "static struct rcu_torture_ops *cur_ops;",
      "static struct rcu_torture_ops rcu_ops = {\n\t.ttype\t\t\t= RCU_FLAVOR,\n\t.init\t\t\t= rcu_sync_torture_init,\n\t.readlock\t\t= rcu_torture_read_lock,\n\t.read_delay\t\t= rcu_read_delay,\n\t.readunlock\t\t= rcu_torture_read_unlock,\n\t.readlock_held\t\t= torture_readlock_not_held,\n\t.get_gp_seq\t\t= rcu_get_gp_seq,\n\t.gp_diff\t\t= rcu_seq_diff,\n\t.deferred_free\t\t= rcu_torture_deferred_free,\n\t.sync\t\t\t= synchronize_rcu,\n\t.exp_sync\t\t= synchronize_rcu_expedited,\n\t.get_gp_state\t\t= get_state_synchronize_rcu,\n\t.start_gp_poll\t\t= start_poll_synchronize_rcu,\n\t.poll_gp_state\t\t= poll_state_synchronize_rcu,\n\t.cond_sync\t\t= cond_synchronize_rcu,\n\t.call\t\t\t= call_rcu,\n\t.cb_barrier\t\t= rcu_barrier,\n\t.fqs\t\t\t= rcu_force_quiescent_state,\n\t.stats\t\t\t= NULL,\n\t.gp_kthread_dbg\t\t= show_rcu_gp_kthreads,\n\t.check_boost_failed\t= rcu_check_boost_fail,\n\t.stall_dur\t\t= rcu_jiffies_till_stall_check,\n\t.irq_capable\t\t= 1,\n\t.can_boost\t\t= IS_ENABLED(CONFIG_RCU_BOOST),\n\t.extendables\t\t= RCUTORTURE_MAX_EXTEND,\n\t.name\t\t\t= \"rcu\"\n};",
      "static struct rcu_torture_ops rcu_busted_ops = {\n\t.ttype\t\t= INVALID_RCU_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= rcu_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= rcu_torture_read_unlock,\n\t.readlock_held\t= torture_readlock_not_held,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_busted_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_busted,\n\t.exp_sync\t= synchronize_rcu_busted,\n\t.call\t\t= call_rcu_busted,\n\t.cb_barrier\t= NULL,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"busted\"\n};",
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;",
      "static struct rcu_torture_ops srcu_ops = {\n\t.ttype\t\t= SRCU_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= srcu_torture_read_lock,\n\t.read_delay\t= srcu_read_delay,\n\t.readunlock\t= srcu_torture_read_unlock,\n\t.readlock_held\t= torture_srcu_read_lock_held,\n\t.get_gp_seq\t= srcu_torture_completed,\n\t.deferred_free\t= srcu_torture_deferred_free,\n\t.sync\t\t= srcu_torture_synchronize,\n\t.exp_sync\t= srcu_torture_synchronize_expedited,\n\t.get_gp_state\t= srcu_torture_get_gp_state,\n\t.start_gp_poll\t= srcu_torture_start_gp_poll,\n\t.poll_gp_state\t= srcu_torture_poll_gp_state,\n\t.call\t\t= srcu_torture_call,\n\t.cb_barrier\t= srcu_torture_barrier,\n\t.stats\t\t= srcu_torture_stats,\n\t.irq_capable\t= 1,\n\t.no_pi_lock\t= IS_ENABLED(CONFIG_TINY_SRCU),\n\t.name\t\t= \"srcu\"\n};",
      "static struct rcu_torture_ops srcud_ops = {\n\t.ttype\t\t= SRCU_FLAVOR,\n\t.init\t\t= srcu_torture_init,\n\t.cleanup\t= srcu_torture_cleanup,\n\t.readlock\t= srcu_torture_read_lock,\n\t.read_delay\t= srcu_read_delay,\n\t.readunlock\t= srcu_torture_read_unlock,\n\t.readlock_held\t= torture_srcu_read_lock_held,\n\t.get_gp_seq\t= srcu_torture_completed,\n\t.deferred_free\t= srcu_torture_deferred_free,\n\t.sync\t\t= srcu_torture_synchronize,\n\t.exp_sync\t= srcu_torture_synchronize_expedited,\n\t.call\t\t= srcu_torture_call,\n\t.cb_barrier\t= srcu_torture_barrier,\n\t.stats\t\t= srcu_torture_stats,\n\t.irq_capable\t= 1,\n\t.no_pi_lock\t= IS_ENABLED(CONFIG_TINY_SRCU),\n\t.name\t\t= \"srcud\"\n};",
      "static struct rcu_torture_ops busted_srcud_ops = {\n\t.ttype\t\t= SRCU_FLAVOR,\n\t.init\t\t= srcu_torture_init,\n\t.cleanup\t= srcu_torture_cleanup,\n\t.readlock\t= srcu_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,\n\t.readunlock\t= srcu_torture_read_unlock,\n\t.readlock_held\t= torture_srcu_read_lock_held,\n\t.get_gp_seq\t= srcu_torture_completed,\n\t.deferred_free\t= srcu_torture_deferred_free,\n\t.sync\t\t= srcu_torture_synchronize,\n\t.exp_sync\t= srcu_torture_synchronize_expedited,\n\t.call\t\t= srcu_torture_call,\n\t.cb_barrier\t= srcu_torture_barrier,\n\t.stats\t\t= srcu_torture_stats,\n\t.irq_capable\t= 1,\n\t.no_pi_lock\t= IS_ENABLED(CONFIG_TINY_SRCU),\n\t.extendables\t= RCUTORTURE_MAX_EXTEND,\n\t.name\t\t= \"busted_srcud\"\n};",
      "static struct rcu_torture_ops tasks_ops = {\n\t.ttype\t\t= RCU_TASKS_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= tasks_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= tasks_torture_read_unlock,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_tasks_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_tasks,\n\t.exp_sync\t= synchronize_rcu_mult_test,\n\t.call\t\t= call_rcu_tasks,\n\t.cb_barrier\t= rcu_barrier_tasks,\n\t.gp_kthread_dbg\t= show_rcu_tasks_classic_gp_kthread,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.slow_gps\t= 1,\n\t.name\t\t= \"tasks\"\n};",
      "static struct rcu_torture_ops trivial_ops = {\n\t.ttype\t\t= RCU_TRIVIAL_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= rcu_torture_read_lock_trivial,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= rcu_torture_read_unlock_trivial,\n\t.readlock_held\t= torture_readlock_not_held,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.sync\t\t= synchronize_rcu_trivial,\n\t.exp_sync\t= synchronize_rcu_trivial,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"trivial\"\n};",
      "static struct rcu_torture_ops tasks_rude_ops = {\n\t.ttype\t\t= RCU_TASKS_RUDE_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= rcu_torture_read_lock_trivial,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= rcu_torture_read_unlock_trivial,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_tasks_rude_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_tasks_rude,\n\t.exp_sync\t= synchronize_rcu_tasks_rude,\n\t.call\t\t= call_rcu_tasks_rude,\n\t.cb_barrier\t= rcu_barrier_tasks_rude,\n\t.gp_kthread_dbg\t= show_rcu_tasks_rude_gp_kthread,\n\t.cbflood_max\t= 50000,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"tasks-rude\"\n};",
      "static struct rcu_torture_ops tasks_tracing_ops = {\n\t.ttype\t\t= RCU_TASKS_TRACING_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= tasks_tracing_torture_read_lock,\n\t.read_delay\t= srcu_read_delay,  /* just reuse srcu's version. */\n\t.readunlock\t= tasks_tracing_torture_read_unlock,\n\t.readlock_held\t= rcu_read_lock_trace_held,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_tasks_tracing_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_tasks_trace,\n\t.exp_sync\t= synchronize_rcu_tasks_trace,\n\t.call\t\t= call_rcu_tasks_trace,\n\t.cb_barrier\t= rcu_barrier_tasks_trace,\n\t.gp_kthread_dbg\t= show_rcu_tasks_trace_gp_kthread,\n\t.cbflood_max\t= 50000,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.slow_gps\t= 1,\n\t.name\t\t= \"tasks-tracing\"\n};",
      "static enum cpuhp_state rcutor_hp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_power_off",
          "args": [],
          "line": 3319
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_power_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "289-299",
          "snippet": "void kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void (*pm_power_off_prepare)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid (*pm_power_off_prepare)(void);\n\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!IS_MODULE(CONFIG_RCU_TORTURE_TEST)"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MODULE",
          "args": [
            "CONFIG_RCU_TORTURE_TEST"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_cleanup",
          "args": [],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2899-3008",
          "snippet": "static void\nrcu_torture_cleanup(void)\n{\n\tint firsttime;\n\tint flags = 0;\n\tunsigned long gp_seq = 0;\n\tint i;\n\n\tif (torture_cleanup_begin()) {\n\t\tif (cur_ops->cb_barrier != NULL)\n\t\t\tcur_ops->cb_barrier();\n\t\treturn;\n\t}\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (cur_ops->gp_kthread_dbg)\n\t\tcur_ops->gp_kthread_dbg();\n\trcu_torture_read_exit_cleanup();\n\trcu_torture_barrier_cleanup();\n\trcu_torture_fwd_prog_cleanup();\n\ttorture_stop_kthread(rcu_torture_stall, stall_task);\n\ttorture_stop_kthread(rcu_torture_writer, writer_task);\n\n\tif (nocb_tasks) {\n\t\tfor (i = 0; i < nrealnocbers; i++)\n\t\t\ttorture_stop_kthread(rcu_nocb_toggle, nocb_tasks[i]);\n\t\tkfree(nocb_tasks);\n\t\tnocb_tasks = NULL;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t\treader_tasks = NULL;\n\t}\n\tkfree(rcu_torture_reader_mbchk);\n\trcu_torture_reader_mbchk = NULL;\n\n\tif (fakewriter_tasks) {\n\t\tfor (i = 0; i < nfakewriters; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t     fakewriter_tasks[i]);\n\t\tkfree(fakewriter_tasks);\n\t\tfakewriter_tasks = NULL;\n\t}\n\n\trcutorture_get_gp_data(cur_ops->ttype, &flags, &gp_seq);\n\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp, &flags, &gp_seq);\n\tpr_alert(\"%s:  End-test grace-period state: g%ld f%#x total-gps=%ld\\n\",\n\t\t cur_ops->name, (long)gp_seq, flags,\n\t\t rcutorture_seq_diff(gp_seq, start_gp_seq));\n\ttorture_stop_kthread(rcu_torture_stats, stats_task);\n\ttorture_stop_kthread(rcu_torture_fqs, fqs_task);\n\tif (rcu_torture_can_boost() && rcutor_hp >= 0)\n\t\tcpuhp_remove_state(rcutor_hp);\n\n\t/*\n\t * Wait for all RCU callbacks to fire, then do torture-type-specific\n\t * cleanup operations.\n\t */\n\tif (cur_ops->cb_barrier != NULL)\n\t\tcur_ops->cb_barrier();\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\trcu_torture_mem_dump_obj();\n\n\trcu_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (err_segs_recorded) {\n\t\tpr_alert(\"Failure/close-call rcutorture reader segments:\\n\");\n\t\tif (rt_read_nsegs == 0)\n\t\t\tpr_alert(\"\\t: No segments recorded!!!\\n\");\n\t\tfirsttime = 1;\n\t\tfor (i = 0; i < rt_read_nsegs; i++) {\n\t\t\tpr_alert(\"\\t%d: %#x \", i, err_segs[i].rt_readstate);\n\t\t\tif (err_segs[i].rt_delay_jiffies != 0) {\n\t\t\t\tpr_cont(\"%s%ldjiffies\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_jiffies);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_ms != 0) {\n\t\t\t\tpr_cont(\"%s%ldms\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_ms);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_us != 0) {\n\t\t\t\tpr_cont(\"%s%ldus\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_us);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tpr_cont(\"%s\\n\",\n\t\t\t\terr_segs[i].rt_preempted ? \"preempted\" : \"\");\n\n\t\t}\n\t}\n\tif (atomic_read(&n_rcu_torture_error) || n_rcu_torture_barrier_error)\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\trcu_torture_print_module_parms(cur_ops,\n\t\t\t\t\t       \"End of test: RCU_HOTPLUG\");\n\telse\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: SUCCESS\");\n\ttorture_cleanup_end();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nrealnocbers;",
            "static int nrealreaders;",
            "static struct task_struct *writer_task;",
            "static struct task_struct **fakewriter_tasks;",
            "static struct task_struct **reader_tasks;",
            "static struct task_struct **nocb_tasks;",
            "static struct task_struct *stats_task;",
            "static struct task_struct *fqs_task;",
            "static struct task_struct *stall_task;",
            "static struct rcu_torture_reader_check *rcu_torture_reader_mbchk;",
            "static atomic_t n_rcu_torture_error;",
            "static long n_rcu_torture_barrier_error;",
            "static unsigned long start_gp_seq;",
            "static int err_segs_recorded;",
            "static struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];",
            "static int rt_read_nsegs;",
            "static struct rcu_torture_ops *cur_ops;",
            "static struct srcu_struct *srcu_ctlp = &srcu_ctl;",
            "static enum cpuhp_state rcutor_hp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int nrealnocbers;\nstatic int nrealreaders;\nstatic struct task_struct *writer_task;\nstatic struct task_struct **fakewriter_tasks;\nstatic struct task_struct **reader_tasks;\nstatic struct task_struct **nocb_tasks;\nstatic struct task_struct *stats_task;\nstatic struct task_struct *fqs_task;\nstatic struct task_struct *stall_task;\nstatic struct rcu_torture_reader_check *rcu_torture_reader_mbchk;\nstatic atomic_t n_rcu_torture_error;\nstatic long n_rcu_torture_barrier_error;\nstatic unsigned long start_gp_seq;\nstatic int err_segs_recorded;\nstatic struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];\nstatic int rt_read_nsegs;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\nstatic enum cpuhp_state rcutor_hp;\n\nstatic void\nrcu_torture_cleanup(void)\n{\n\tint firsttime;\n\tint flags = 0;\n\tunsigned long gp_seq = 0;\n\tint i;\n\n\tif (torture_cleanup_begin()) {\n\t\tif (cur_ops->cb_barrier != NULL)\n\t\t\tcur_ops->cb_barrier();\n\t\treturn;\n\t}\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (cur_ops->gp_kthread_dbg)\n\t\tcur_ops->gp_kthread_dbg();\n\trcu_torture_read_exit_cleanup();\n\trcu_torture_barrier_cleanup();\n\trcu_torture_fwd_prog_cleanup();\n\ttorture_stop_kthread(rcu_torture_stall, stall_task);\n\ttorture_stop_kthread(rcu_torture_writer, writer_task);\n\n\tif (nocb_tasks) {\n\t\tfor (i = 0; i < nrealnocbers; i++)\n\t\t\ttorture_stop_kthread(rcu_nocb_toggle, nocb_tasks[i]);\n\t\tkfree(nocb_tasks);\n\t\tnocb_tasks = NULL;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t\treader_tasks = NULL;\n\t}\n\tkfree(rcu_torture_reader_mbchk);\n\trcu_torture_reader_mbchk = NULL;\n\n\tif (fakewriter_tasks) {\n\t\tfor (i = 0; i < nfakewriters; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t     fakewriter_tasks[i]);\n\t\tkfree(fakewriter_tasks);\n\t\tfakewriter_tasks = NULL;\n\t}\n\n\trcutorture_get_gp_data(cur_ops->ttype, &flags, &gp_seq);\n\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp, &flags, &gp_seq);\n\tpr_alert(\"%s:  End-test grace-period state: g%ld f%#x total-gps=%ld\\n\",\n\t\t cur_ops->name, (long)gp_seq, flags,\n\t\t rcutorture_seq_diff(gp_seq, start_gp_seq));\n\ttorture_stop_kthread(rcu_torture_stats, stats_task);\n\ttorture_stop_kthread(rcu_torture_fqs, fqs_task);\n\tif (rcu_torture_can_boost() && rcutor_hp >= 0)\n\t\tcpuhp_remove_state(rcutor_hp);\n\n\t/*\n\t * Wait for all RCU callbacks to fire, then do torture-type-specific\n\t * cleanup operations.\n\t */\n\tif (cur_ops->cb_barrier != NULL)\n\t\tcur_ops->cb_barrier();\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\trcu_torture_mem_dump_obj();\n\n\trcu_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (err_segs_recorded) {\n\t\tpr_alert(\"Failure/close-call rcutorture reader segments:\\n\");\n\t\tif (rt_read_nsegs == 0)\n\t\t\tpr_alert(\"\\t: No segments recorded!!!\\n\");\n\t\tfirsttime = 1;\n\t\tfor (i = 0; i < rt_read_nsegs; i++) {\n\t\t\tpr_alert(\"\\t%d: %#x \", i, err_segs[i].rt_readstate);\n\t\t\tif (err_segs[i].rt_delay_jiffies != 0) {\n\t\t\t\tpr_cont(\"%s%ldjiffies\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_jiffies);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_ms != 0) {\n\t\t\t\tpr_cont(\"%s%ldms\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_ms);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_us != 0) {\n\t\t\t\tpr_cont(\"%s%ldus\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_us);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tpr_cont(\"%s\\n\",\n\t\t\t\terr_segs[i].rt_preempted ? \"preempted\" : \"\");\n\n\t\t}\n\t}\n\tif (atomic_read(&n_rcu_torture_error) || n_rcu_torture_barrier_error)\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\trcu_torture_print_module_parms(cur_ops,\n\t\t\t\t\t       \"End of test: RCU_HOTPLUG\");\n\telse\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: SUCCESS\");\n\ttorture_cleanup_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_end",
          "args": [],
          "line": 3315
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "835-839",
          "snippet": "void torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(fullstop_mutex);",
            "static struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(fullstop_mutex);\nstatic struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};\n\nvoid torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_test_debug_objects",
          "args": [],
          "line": 3310
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_test_debug_objects",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "3035-3069",
          "snippet": "static void rcu_test_debug_objects(void)\n{\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\n\tstruct rcu_head rh1;\n\tstruct rcu_head rh2;\n\tstruct rcu_head *rhp = kmalloc(sizeof(*rhp), GFP_KERNEL);\n\n\tinit_rcu_head_on_stack(&rh1);\n\tinit_rcu_head_on_stack(&rh2);\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test starting.\\n\", KBUILD_MODNAME);\n\n\t/* Try to queue the rh2 pair of callbacks for the same grace period. */\n\tpreempt_disable(); /* Prevent preemption from interrupting test. */\n\trcu_read_lock(); /* Make it impossible to finish a grace period. */\n\tcall_rcu(&rh1, rcu_torture_leak_cb); /* Start grace period. */\n\tlocal_irq_disable(); /* Make it harder to start a new grace period. */\n\tcall_rcu(&rh2, rcu_torture_leak_cb);\n\tcall_rcu(&rh2, rcu_torture_err_cb); /* Duplicate callback. */\n\tif (rhp) {\n\t\tcall_rcu(rhp, rcu_torture_leak_cb);\n\t\tcall_rcu(rhp, rcu_torture_err_cb); /* Another duplicate callback. */\n\t}\n\tlocal_irq_enable();\n\trcu_read_unlock();\n\tpreempt_enable();\n\n\t/* Wait for them all to get done so we can safely return. */\n\trcu_barrier();\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test complete.\\n\", KBUILD_MODNAME);\n\tdestroy_rcu_head_on_stack(&rh1);\n\tdestroy_rcu_head_on_stack(&rh2);\n#else /* #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n\tpr_alert(\"%s: !CONFIG_DEBUG_OBJECTS_RCU_HEAD, not testing duplicate call_rcu()\\n\", KBUILD_MODNAME);\n#endif /* #else #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_test_debug_objects(void)\n{\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\n\tstruct rcu_head rh1;\n\tstruct rcu_head rh2;\n\tstruct rcu_head *rhp = kmalloc(sizeof(*rhp), GFP_KERNEL);\n\n\tinit_rcu_head_on_stack(&rh1);\n\tinit_rcu_head_on_stack(&rh2);\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test starting.\\n\", KBUILD_MODNAME);\n\n\t/* Try to queue the rh2 pair of callbacks for the same grace period. */\n\tpreempt_disable(); /* Prevent preemption from interrupting test. */\n\trcu_read_lock(); /* Make it impossible to finish a grace period. */\n\tcall_rcu(&rh1, rcu_torture_leak_cb); /* Start grace period. */\n\tlocal_irq_disable(); /* Make it harder to start a new grace period. */\n\tcall_rcu(&rh2, rcu_torture_leak_cb);\n\tcall_rcu(&rh2, rcu_torture_err_cb); /* Duplicate callback. */\n\tif (rhp) {\n\t\tcall_rcu(rhp, rcu_torture_leak_cb);\n\t\tcall_rcu(rhp, rcu_torture_err_cb); /* Another duplicate callback. */\n\t}\n\tlocal_irq_enable();\n\trcu_read_unlock();\n\tpreempt_enable();\n\n\t/* Wait for them all to get done so we can safely return. */\n\trcu_barrier();\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test complete.\\n\", KBUILD_MODNAME);\n\tdestroy_rcu_head_on_stack(&rh1);\n\tdestroy_rcu_head_on_stack(&rh2);\n#else /* #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n\tpr_alert(\"%s: !CONFIG_DEBUG_OBJECTS_RCU_HEAD, not testing duplicate call_rcu()\\n\", KBUILD_MODNAME);\n#endif /* #else #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_read_exit_init",
          "args": [],
          "line": 3306
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_read_exit_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2876-2885",
          "snippet": "static int rcu_torture_read_exit_init(void)\n{\n\tif (read_exit_burst <= 0)\n\t\treturn 0;\n\tinit_waitqueue_head(&read_exit_wq);\n\tread_exit_child_stop = false;\n\tread_exit_child_stopped = false;\n\treturn torture_create_kthread(rcu_torture_read_exit, NULL,\n\t\t\t\t      read_exit_task);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *read_exit_task;",
            "static bool read_exit_child_stop;",
            "static bool read_exit_child_stopped;",
            "static wait_queue_head_t read_exit_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *read_exit_task;\nstatic bool read_exit_child_stop;\nstatic bool read_exit_child_stopped;\nstatic wait_queue_head_t read_exit_wq;\n\nstatic int rcu_torture_read_exit_init(void)\n{\n\tif (read_exit_burst <= 0)\n\t\treturn 0;\n\tinit_waitqueue_head(&read_exit_wq);\n\tread_exit_child_stop = false;\n\tread_exit_child_stopped = false;\n\treturn torture_create_kthread(rcu_torture_read_exit, NULL,\n\t\t\t\t      read_exit_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_barrier_init",
          "args": [],
          "line": 3303
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_barrier_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2723-2757",
          "snippet": "static int rcu_torture_barrier_init(void)\n{\n\tint i;\n\tint ret;\n\n\tif (n_barrier_cbs <= 0)\n\t\treturn 0;\n\tif (cur_ops->call == NULL || cur_ops->cb_barrier == NULL) {\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" Call or barrier ops missing for %s,\\n\",\n\t\t\t torture_type, cur_ops->name);\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" RCU barrier testing omitted from run.\\n\",\n\t\t\t torture_type);\n\t\treturn 0;\n\t}\n\tatomic_set(&barrier_cbs_count, 0);\n\tatomic_set(&barrier_cbs_invoked, 0);\n\tbarrier_cbs_tasks =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_tasks[0]),\n\t\t\tGFP_KERNEL);\n\tbarrier_cbs_wq =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_wq[0]), GFP_KERNEL);\n\tif (barrier_cbs_tasks == NULL || !barrier_cbs_wq)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < n_barrier_cbs; i++) {\n\t\tinit_waitqueue_head(&barrier_cbs_wq[i]);\n\t\tret = torture_create_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     (void *)(long)i,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn torture_create_kthread(rcu_torture_barrier, NULL, barrier_task);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type = \"rcu\";",
            "static struct task_struct **barrier_cbs_tasks;",
            "static struct task_struct *barrier_task;",
            "static atomic_t barrier_cbs_count;",
            "static atomic_t barrier_cbs_invoked;",
            "static wait_queue_head_t *barrier_cbs_wq;",
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type = \"rcu\";\nstatic struct task_struct **barrier_cbs_tasks;\nstatic struct task_struct *barrier_task;\nstatic atomic_t barrier_cbs_count;\nstatic atomic_t barrier_cbs_invoked;\nstatic wait_queue_head_t *barrier_cbs_wq;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcu_torture_barrier_init(void)\n{\n\tint i;\n\tint ret;\n\n\tif (n_barrier_cbs <= 0)\n\t\treturn 0;\n\tif (cur_ops->call == NULL || cur_ops->cb_barrier == NULL) {\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" Call or barrier ops missing for %s,\\n\",\n\t\t\t torture_type, cur_ops->name);\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" RCU barrier testing omitted from run.\\n\",\n\t\t\t torture_type);\n\t\treturn 0;\n\t}\n\tatomic_set(&barrier_cbs_count, 0);\n\tatomic_set(&barrier_cbs_invoked, 0);\n\tbarrier_cbs_tasks =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_tasks[0]),\n\t\t\tGFP_KERNEL);\n\tbarrier_cbs_wq =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_wq[0]), GFP_KERNEL);\n\tif (barrier_cbs_tasks == NULL || !barrier_cbs_wq)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < n_barrier_cbs; i++) {\n\t\tinit_waitqueue_head(&barrier_cbs_wq[i]);\n\t\tret = torture_create_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     (void *)(long)i,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn torture_create_kthread(rcu_torture_barrier, NULL, barrier_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_fwd_prog_init",
          "args": [],
          "line": 3300
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_fwd_prog_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2541-2600",
          "snippet": "static int __init rcu_torture_fwd_prog_init(void)\n{\n\tint i;\n\tint ret = 0;\n\tstruct rcu_fwd *rfp;\n\n\tif (!fwd_progress)\n\t\treturn 0; /* Not requested, so don't do it. */\n\tif (fwd_progress >= nr_cpu_ids) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Limiting fwd_progress to # CPUs.\\n\");\n\t\tfwd_progress = nr_cpu_ids;\n\t} else if (fwd_progress < 0) {\n\t\tfwd_progress = nr_cpu_ids;\n\t}\n\tif ((!cur_ops->sync && !cur_ops->call) ||\n\t    (!cur_ops->cbflood_max && (!cur_ops->stall_dur || cur_ops->stall_dur() <= 0)) ||\n\t    cur_ops == &rcu_busted_ops) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, unsupported by RCU flavor under test\");\n\t\tfwd_progress = 0;\n\t\treturn 0;\n\t}\n\tif (stall_cpu > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, conflicts with CPU-stall testing\");\n\t\tfwd_progress = 0;\n\t\tif (IS_MODULE(CONFIG_RCU_TORTURE_TEST))\n\t\t\treturn -EINVAL; /* In module, can fail back to user. */\n\t\tWARN_ON(1); /* Make sure rcutorture notices conflict. */\n\t\treturn 0;\n\t}\n\tif (fwd_progress_holdoff <= 0)\n\t\tfwd_progress_holdoff = 1;\n\tif (fwd_progress_div <= 0)\n\t\tfwd_progress_div = 4;\n\trfp = kcalloc(fwd_progress, sizeof(*rfp), GFP_KERNEL);\n\tfwd_prog_tasks = kcalloc(fwd_progress, sizeof(*fwd_prog_tasks), GFP_KERNEL);\n\tif (!rfp || !fwd_prog_tasks) {\n\t\tkfree(rfp);\n\t\tkfree(fwd_prog_tasks);\n\t\tfwd_prog_tasks = NULL;\n\t\tfwd_progress = 0;\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fwd_progress; i++) {\n\t\tspin_lock_init(&rfp[i].rcu_fwd_lock);\n\t\trfp[i].rcu_fwd_cb_tail = &rfp[i].rcu_fwd_cb_head;\n\t\trfp[i].rcu_fwd_id = i;\n\t}\n\tmutex_lock(&rcu_fwd_mutex);\n\trcu_fwds = rfp;\n\tmutex_unlock(&rcu_fwd_mutex);\n\tregister_oom_notifier(&rcutorture_oom_nb);\n\tfor (i = 0; i < fwd_progress; i++) {\n\t\tret = torture_create_kthread(rcu_torture_fwd_prog, &rcu_fwds[i], fwd_prog_tasks[i]);\n\t\tif (ret) {\n\t\t\tfwd_progress = i;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct **fwd_prog_tasks;",
            "static struct rcu_torture_ops *cur_ops;",
            "static struct rcu_torture_ops rcu_busted_ops = {\n\t.ttype\t\t= INVALID_RCU_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= rcu_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= rcu_torture_read_unlock,\n\t.readlock_held\t= torture_readlock_not_held,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_busted_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_busted,\n\t.exp_sync\t= synchronize_rcu_busted,\n\t.call\t\t= call_rcu_busted,\n\t.cb_barrier\t= NULL,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"busted\"\n};",
            "static DEFINE_MUTEX(rcu_fwd_mutex);",
            "static struct rcu_fwd *rcu_fwds;",
            "static struct notifier_block rcutorture_oom_nb = {\n\t.notifier_call = rcutorture_oom_notify\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct **fwd_prog_tasks;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct rcu_torture_ops rcu_busted_ops = {\n\t.ttype\t\t= INVALID_RCU_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= rcu_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= rcu_torture_read_unlock,\n\t.readlock_held\t= torture_readlock_not_held,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_busted_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_busted,\n\t.exp_sync\t= synchronize_rcu_busted,\n\t.call\t\t= call_rcu_busted,\n\t.cb_barrier\t= NULL,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"busted\"\n};\nstatic DEFINE_MUTEX(rcu_fwd_mutex);\nstatic struct rcu_fwd *rcu_fwds;\nstatic struct notifier_block rcutorture_oom_nb = {\n\t.notifier_call = rcutorture_oom_notify\n};\n\nstatic int __init rcu_torture_fwd_prog_init(void)\n{\n\tint i;\n\tint ret = 0;\n\tstruct rcu_fwd *rfp;\n\n\tif (!fwd_progress)\n\t\treturn 0; /* Not requested, so don't do it. */\n\tif (fwd_progress >= nr_cpu_ids) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Limiting fwd_progress to # CPUs.\\n\");\n\t\tfwd_progress = nr_cpu_ids;\n\t} else if (fwd_progress < 0) {\n\t\tfwd_progress = nr_cpu_ids;\n\t}\n\tif ((!cur_ops->sync && !cur_ops->call) ||\n\t    (!cur_ops->cbflood_max && (!cur_ops->stall_dur || cur_ops->stall_dur() <= 0)) ||\n\t    cur_ops == &rcu_busted_ops) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, unsupported by RCU flavor under test\");\n\t\tfwd_progress = 0;\n\t\treturn 0;\n\t}\n\tif (stall_cpu > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, conflicts with CPU-stall testing\");\n\t\tfwd_progress = 0;\n\t\tif (IS_MODULE(CONFIG_RCU_TORTURE_TEST))\n\t\t\treturn -EINVAL; /* In module, can fail back to user. */\n\t\tWARN_ON(1); /* Make sure rcutorture notices conflict. */\n\t\treturn 0;\n\t}\n\tif (fwd_progress_holdoff <= 0)\n\t\tfwd_progress_holdoff = 1;\n\tif (fwd_progress_div <= 0)\n\t\tfwd_progress_div = 4;\n\trfp = kcalloc(fwd_progress, sizeof(*rfp), GFP_KERNEL);\n\tfwd_prog_tasks = kcalloc(fwd_progress, sizeof(*fwd_prog_tasks), GFP_KERNEL);\n\tif (!rfp || !fwd_prog_tasks) {\n\t\tkfree(rfp);\n\t\tkfree(fwd_prog_tasks);\n\t\tfwd_prog_tasks = NULL;\n\t\tfwd_progress = 0;\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fwd_progress; i++) {\n\t\tspin_lock_init(&rfp[i].rcu_fwd_lock);\n\t\trfp[i].rcu_fwd_cb_tail = &rfp[i].rcu_fwd_cb_head;\n\t\trfp[i].rcu_fwd_id = i;\n\t}\n\tmutex_lock(&rcu_fwd_mutex);\n\trcu_fwds = rfp;\n\tmutex_unlock(&rcu_fwd_mutex);\n\tregister_oom_notifier(&rcutorture_oom_nb);\n\tfor (i = 0; i < fwd_progress; i++) {\n\t\tret = torture_create_kthread(rcu_torture_fwd_prog, &rcu_fwds[i], fwd_prog_tasks[i]);\n\t\tif (ret) {\n\t\t\tfwd_progress = i;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_stall_init",
          "args": [],
          "line": 3297
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_stall_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2108-2113",
          "snippet": "static int __init rcu_torture_stall_init(void)\n{\n\tif (stall_cpu <= 0 && stall_gp_kthread <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(rcu_torture_stall, NULL, stall_task);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *stall_task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *stall_task;\n\nstatic int __init rcu_torture_stall_init(void)\n{\n\tif (stall_cpu <= 0 && stall_gp_kthread <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(rcu_torture_stall, NULL, stall_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_onoff_init",
          "args": [
            "onoff_holdoff * HZ",
            "onoff_interval",
            "rcutorture_sync"
          ],
          "line": 3293
        },
        "resolved": true,
        "details": {
          "function_name": "torture_onoff_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "382-394",
          "snippet": "int torture_onoff_init(long ooholdoff, long oointerval, torture_ofl_func *f)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tonoff_holdoff = ooholdoff;\n\tonoff_interval = oointerval;\n\tonoff_f = f;\n\tif (onoff_interval <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(torture_onoff, NULL, onoff_task);\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn 0;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_onoff_init(long ooholdoff, long oointerval, torture_ofl_func *f)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tonoff_holdoff = ooholdoff;\n\tonoff_interval = oointerval;\n\tonoff_f = f;\n\tif (onoff_interval <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(torture_onoff, NULL, onoff_task);\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn 0;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_shutdown_init",
          "args": [
            "shutdown_secs",
            "rcu_torture_cleanup"
          ],
          "line": 3290
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "661-670",
          "snippet": "int torture_shutdown_init(int ssecs, void (*cleanup)(void))\n{\n\ttorture_shutdown_hook = cleanup;\n\tif (ssecs > 0) {\n\t\tshutdown_time = ktime_add(ktime_get(), ktime_set(ssecs, 0));\n\t\treturn torture_create_kthread(torture_shutdown, NULL,\n\t\t\t\t\t     shutdown_task);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *shutdown_task;",
            "static ktime_t shutdown_time;",
            "static void (*torture_shutdown_hook)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *shutdown_task;\nstatic ktime_t shutdown_time;\nstatic void (*torture_shutdown_hook)(void);\n\nint torture_shutdown_init(int ssecs, void (*cleanup)(void))\n{\n\ttorture_shutdown_hook = cleanup;\n\tif (ssecs > 0) {\n\t\tshutdown_time = ktime_add(ktime_get(), ktime_set(ssecs, 0));\n\t\treturn torture_create_kthread(torture_shutdown, NULL,\n\t\t\t\t\t     shutdown_task);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_setscheduler_nocheck",
          "args": [
            "t",
            "SCHED_FIFO",
            "&sp"
          ],
          "line": 3285
        },
        "resolved": true,
        "details": {
          "function_name": "sched_setscheduler_nocheck",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7565-7569",
          "snippet": "int sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!t"
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "ksoftirqd",
            "cpu"
          ],
          "line": 3282
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_BUILTIN",
          "args": [
            "CONFIG_RCU_TORTURE_TEST"
          ],
          "line": 3277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"RCU_TORTURE\"",
            "rcutorture_booster_init",
            "rcutorture_booster_cleanup"
          ],
          "line": 3267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_can_boost",
          "args": [],
          "line": 3263
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_can_boost",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2778-2802",
          "snippet": "static bool rcu_torture_can_boost(void)\n{\n\tstatic int boost_warn_once;\n\tint prio;\n\n\tif (!(test_boost == 1 && cur_ops->can_boost) && test_boost != 2)\n\t\treturn false;\n\tif (!cur_ops->start_gp_poll || !cur_ops->poll_gp_state)\n\t\treturn false;\n\n\tprio = rcu_get_gp_kthreads_prio();\n\tif (!prio)\n\t\treturn false;\n\n\tif (prio < 2) {\n\t\tif (boost_warn_once == 1)\n\t\t\treturn false;\n\n\t\tpr_alert(\"%s: WARN: RCU kthread priority too low to test boosting.  Skipping RCU boost test. Try passing rcutree.kthread_prio > 1 on the kernel command line.\\n\", KBUILD_MODNAME);\n\t\tboost_warn_once = 1;\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic bool rcu_torture_can_boost(void)\n{\n\tstatic int boost_warn_once;\n\tint prio;\n\n\tif (!(test_boost == 1 && cur_ops->can_boost) && test_boost != 2)\n\t\treturn false;\n\tif (!cur_ops->start_gp_poll || !cur_ops->poll_gp_state)\n\t\treturn false;\n\n\tprio = rcu_get_gp_kthreads_prio();\n\tif (!prio)\n\t\treturn false;\n\n\tif (prio < 2) {\n\t\tif (boost_warn_once == 1)\n\t\t\treturn false;\n\n\t\tpr_alert(\"%s: WARN: RCU kthread priority too low to test boosting.  Skipping RCU boost test. Try passing rcutree.kthread_prio > 1 on the kernel command line.\\n\", KBUILD_MODNAME);\n\t\tboost_warn_once = 1;\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_fqs",
            "NULL",
            "fqs_task"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_stutter_init",
          "args": [
            "stutter * HZ",
            "t"
          ],
          "line": 3246
        },
        "resolved": true,
        "details": {
          "function_name": "torture_stutter_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "786-791",
          "snippet": "int torture_stutter_init(const int s, const int sgap)\n{\n\tstutter = s;\n\tstutter_gap = sgap;\n\treturn torture_create_kthread(torture_stutter, NULL, stutter_task);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *stutter_task;",
            "static int stutter;",
            "static int stutter_gap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *stutter_task;\nstatic int stutter;\nstatic int stutter_gap;\n\nint torture_stutter_init(const int s, const int sgap)\n{\n\tstutter = s;\n\tstutter_gap = sgap;\n\treturn torture_create_kthread(torture_stutter, NULL, stutter_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->stall_dur",
          "args": [],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_shuffle_init",
          "args": [
            "shuffle_interval * HZ"
          ],
          "line": 3236
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shuffle_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "566-579",
          "snippet": "int torture_shuffle_init(long shuffint)\n{\n\tshuffle_interval = shuffint;\n\n\tshuffle_idle_cpu = -1;\n\n\tif (!alloc_cpumask_var(&shuffle_tmp_mask, GFP_KERNEL)) {\n\t\tTOROUT_ERRSTRING(\"Failed to alloc mask\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Create the shuffler thread */\n\treturn torture_create_kthread(torture_shuffle, NULL, shuffler_task);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long shuffle_interval;",
            "static struct task_struct *shuffler_task;",
            "static cpumask_var_t shuffle_tmp_mask;",
            "static int shuffle_idle_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic long shuffle_interval;\nstatic struct task_struct *shuffler_task;\nstatic cpumask_var_t shuffle_tmp_mask;\nstatic int shuffle_idle_cpu;\n\nint torture_shuffle_init(long shuffint)\n{\n\tshuffle_interval = shuffint;\n\n\tshuffle_idle_cpu = -1;\n\n\tif (!alloc_cpumask_var(&shuffle_tmp_mask, GFP_KERNEL)) {\n\t\tTOROUT_ERRSTRING(\"Failed to alloc mask\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Create the shuffler thread */\n\treturn torture_create_kthread(torture_shuffle, NULL, shuffler_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_stats",
            "NULL",
            "stats_task"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_nocb_toggle",
            "NULL",
            "nocb_tasks[i]"
          ],
          "line": 3225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TOROUT_ERRSTRING",
          "args": [
            "\"out of memory\""
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nrealnocbers",
            "sizeof(nocb_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "nocbs_toggle < 0"
          ],
          "line": 3212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "nrealnocbers < 0"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_reader",
            "(void *)i",
            "reader_tasks[i]"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TOROUT_ERRSTRING",
          "args": [
            "\"out of memory\""
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nrealreaders",
            "sizeof(*rcu_torture_reader_mbchk)",
            "GFP_KERNEL"
          ],
          "line": 3195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nrealreaders",
            "sizeof(reader_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_fakewriter",
            "NULL",
            "fakewriter_tasks[i]"
          ],
          "line": 3188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TOROUT_ERRSTRING",
          "args": [
            "\"out of memory\""
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nfakewriters",
            "sizeof(fakewriter_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_writer",
            "NULL",
            "writer_task"
          ],
          "line": 3173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_write_types",
          "args": [],
          "line": 3172
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_write_types",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1111-1149",
          "snippet": "static void rcu_torture_write_types(void)\n{\n\tbool gp_cond1 = gp_cond, gp_exp1 = gp_exp, gp_normal1 = gp_normal;\n\tbool gp_poll1 = gp_poll, gp_sync1 = gp_sync;\n\n\t/* Initialize synctype[] array.  If none set, take default. */\n\tif (!gp_cond1 && !gp_exp1 && !gp_normal1 && !gp_poll1 && !gp_sync1)\n\t\tgp_cond1 = gp_exp1 = gp_normal1 = gp_poll1 = gp_sync1 = true;\n\tif (gp_cond1 && cur_ops->get_gp_state && cur_ops->cond_sync) {\n\t\tsynctype[nsynctypes++] = RTWS_COND_GET;\n\t\tpr_info(\"%s: Testing conditional GPs.\\n\", __func__);\n\t} else if (gp_cond && (!cur_ops->get_gp_state || !cur_ops->cond_sync)) {\n\t\tpr_alert(\"%s: gp_cond without primitives.\\n\", __func__);\n\t}\n\tif (gp_exp1 && cur_ops->exp_sync) {\n\t\tsynctype[nsynctypes++] = RTWS_EXP_SYNC;\n\t\tpr_info(\"%s: Testing expedited GPs.\\n\", __func__);\n\t} else if (gp_exp && !cur_ops->exp_sync) {\n\t\tpr_alert(\"%s: gp_exp without primitives.\\n\", __func__);\n\t}\n\tif (gp_normal1 && cur_ops->deferred_free) {\n\t\tsynctype[nsynctypes++] = RTWS_DEF_FREE;\n\t\tpr_info(\"%s: Testing asynchronous GPs.\\n\", __func__);\n\t} else if (gp_normal && !cur_ops->deferred_free) {\n\t\tpr_alert(\"%s: gp_normal without primitives.\\n\", __func__);\n\t}\n\tif (gp_poll1 && cur_ops->start_gp_poll && cur_ops->poll_gp_state) {\n\t\tsynctype[nsynctypes++] = RTWS_POLL_GET;\n\t\tpr_info(\"%s: Testing polling GPs.\\n\", __func__);\n\t} else if (gp_poll && (!cur_ops->start_gp_poll || !cur_ops->poll_gp_state)) {\n\t\tpr_alert(\"%s: gp_poll without primitives.\\n\", __func__);\n\t}\n\tif (gp_sync1 && cur_ops->sync) {\n\t\tsynctype[nsynctypes++] = RTWS_SYNC;\n\t\tpr_info(\"%s: Testing normal GPs.\\n\", __func__);\n\t} else if (gp_sync && !cur_ops->sync) {\n\t\tpr_alert(\"%s: gp_sync without primitives.\\n\", __func__);\n\t}\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RTWS_SYNC\t\t9",
            "#define RTWS_POLL_GET\t\t7",
            "#define RTWS_COND_GET\t\t5",
            "#define RTWS_EXP_SYNC\t\t4",
            "#define RTWS_DEF_FREE\t\t3"
          ],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;",
            "static int synctype[] = { RTWS_DEF_FREE, RTWS_EXP_SYNC, RTWS_COND_GET, RTWS_POLL_GET, RTWS_SYNC };",
            "static int nsynctypes;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RTWS_SYNC\t\t9\n#define RTWS_POLL_GET\t\t7\n#define RTWS_COND_GET\t\t5\n#define RTWS_EXP_SYNC\t\t4\n#define RTWS_DEF_FREE\t\t3\n\nstatic struct rcu_torture_ops *cur_ops;\nstatic int synctype[] = { RTWS_DEF_FREE, RTWS_EXP_SYNC, RTWS_COND_GET, RTWS_POLL_GET, RTWS_SYNC };\nstatic int nsynctypes;\n\nstatic void rcu_torture_write_types(void)\n{\n\tbool gp_cond1 = gp_cond, gp_exp1 = gp_exp, gp_normal1 = gp_normal;\n\tbool gp_poll1 = gp_poll, gp_sync1 = gp_sync;\n\n\t/* Initialize synctype[] array.  If none set, take default. */\n\tif (!gp_cond1 && !gp_exp1 && !gp_normal1 && !gp_poll1 && !gp_sync1)\n\t\tgp_cond1 = gp_exp1 = gp_normal1 = gp_poll1 = gp_sync1 = true;\n\tif (gp_cond1 && cur_ops->get_gp_state && cur_ops->cond_sync) {\n\t\tsynctype[nsynctypes++] = RTWS_COND_GET;\n\t\tpr_info(\"%s: Testing conditional GPs.\\n\", __func__);\n\t} else if (gp_cond && (!cur_ops->get_gp_state || !cur_ops->cond_sync)) {\n\t\tpr_alert(\"%s: gp_cond without primitives.\\n\", __func__);\n\t}\n\tif (gp_exp1 && cur_ops->exp_sync) {\n\t\tsynctype[nsynctypes++] = RTWS_EXP_SYNC;\n\t\tpr_info(\"%s: Testing expedited GPs.\\n\", __func__);\n\t} else if (gp_exp && !cur_ops->exp_sync) {\n\t\tpr_alert(\"%s: gp_exp without primitives.\\n\", __func__);\n\t}\n\tif (gp_normal1 && cur_ops->deferred_free) {\n\t\tsynctype[nsynctypes++] = RTWS_DEF_FREE;\n\t\tpr_info(\"%s: Testing asynchronous GPs.\\n\", __func__);\n\t} else if (gp_normal && !cur_ops->deferred_free) {\n\t\tpr_alert(\"%s: gp_normal without primitives.\\n\", __func__);\n\t}\n\tif (gp_poll1 && cur_ops->start_gp_poll && cur_ops->poll_gp_state) {\n\t\tsynctype[nsynctypes++] = RTWS_POLL_GET;\n\t\tpr_info(\"%s: Testing polling GPs.\\n\", __func__);\n\t} else if (gp_poll && (!cur_ops->start_gp_poll || !cur_ops->poll_gp_state)) {\n\t\tpr_alert(\"%s: gp_poll without primitives.\\n\", __func__);\n\t}\n\tif (gp_sync1 && cur_ops->sync) {\n\t\tsynctype[nsynctypes++] = RTWS_SYNC;\n\t\tpr_info(\"%s: Testing normal GPs.\\n\", __func__);\n\t} else if (gp_sync && !cur_ops->sync) {\n\t\tpr_alert(\"%s: gp_sync without primitives.\\n\", __func__);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rcu_torture_wcount[i]",
            "0"
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_torture_error",
            "0"
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_torture_mbchk_tries",
            "0"
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_torture_mbchk_fail",
            "0"
          ],
          "line": 3151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_torture_mberror",
            "0"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_torture_free",
            "0"
          ],
          "line": 3149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_torture_alloc_fail",
            "0"
          ],
          "line": 3148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_torture_alloc",
            "0"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&rcu_tortures[i].rtort_free",
            "&rcu_torture_freelist"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "rcu_tortures"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rcu_torture_freelist"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s:  Start-test grace-period state: g%ld f%#x\\n\"",
            "cur_ops->name",
            "(long)gp_seq",
            "flags"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcutorture_get_gp_data",
          "args": [
            "cur_ops->ttype",
            "srcu_ctlp",
            "&flags",
            "&gp_seq"
          ],
          "line": 3129
        },
        "resolved": true,
        "details": {
          "function_name": "srcutorture_get_gp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1329-1337",
          "snippet": "void srcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t     struct srcu_struct *ssp, int *flags,\n\t\t\t     unsigned long *gp_seq)\n{\n\tif (test_type != SRCU_FLAVOR)\n\t\treturn;\n\t*flags = 0;\n\t*gp_seq = rcu_seq_current(&ssp->srcu_gp_seq);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid srcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t     struct srcu_struct *ssp, int *flags,\n\t\t\t     unsigned long *gp_seq)\n{\n\tif (test_type != SRCU_FLAVOR)\n\t\treturn;\n\t*flags = 0;\n\t*gp_seq = rcu_seq_current(&ssp->srcu_gp_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcutorture_get_gp_data",
          "args": [
            "cur_ops->ttype",
            "&flags",
            "&gp_seq"
          ],
          "line": 3128
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_get_gp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "472-477",
          "snippet": "static inline void rcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t\t\t  int *flags, unsigned long *gp_seq)\n{\n\t*flags = 0;\n\t*gp_seq = 0;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t\t\t  int *flags, unsigned long *gp_seq)\n{\n\t*flags = 0;\n\t*gp_seq = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_print_module_parms",
          "args": [
            "cur_ops",
            "\"Start of test\""
          ],
          "line": 3127
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_print_module_parms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1977-2004",
          "snippet": "static void\nrcu_torture_print_module_parms(struct rcu_torture_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s: nreaders=%d nfakewriters=%d \"\n\t\t \"stat_interval=%d verbose=%d test_no_idle_hz=%d \"\n\t\t \"shuffle_interval=%d stutter=%d irqreader=%d \"\n\t\t \"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"\n\t\t \"test_boost=%d/%d test_boost_interval=%d \"\n\t\t \"test_boost_duration=%d shutdown_secs=%d \"\n\t\t \"stall_cpu=%d stall_cpu_holdoff=%d stall_cpu_irqsoff=%d \"\n\t\t \"stall_cpu_block=%d \"\n\t\t \"n_barrier_cbs=%d \"\n\t\t \"onoff_interval=%d onoff_holdoff=%d \"\n\t\t \"read_exit_delay=%d read_exit_burst=%d \"\n\t\t \"nocbs_nthreads=%d nocbs_toggle=%d\\n\",\n\t\t torture_type, tag, nrealreaders, nfakewriters,\n\t\t stat_interval, verbose, test_no_idle_hz, shuffle_interval,\n\t\t stutter, irqreader, fqs_duration, fqs_holdoff, fqs_stutter,\n\t\t test_boost, cur_ops->can_boost,\n\t\t test_boost_interval, test_boost_duration, shutdown_secs,\n\t\t stall_cpu, stall_cpu_holdoff, stall_cpu_irqsoff,\n\t\t stall_cpu_block,\n\t\t n_barrier_cbs,\n\t\t onoff_interval, onoff_holdoff,\n\t\t read_exit_delay, read_exit_burst,\n\t\t nocbs_nthreads, nocbs_toggle);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type = \"rcu\";",
            "static int nrealreaders;",
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type = \"rcu\";\nstatic int nrealreaders;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void\nrcu_torture_print_module_parms(struct rcu_torture_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s: nreaders=%d nfakewriters=%d \"\n\t\t \"stat_interval=%d verbose=%d test_no_idle_hz=%d \"\n\t\t \"shuffle_interval=%d stutter=%d irqreader=%d \"\n\t\t \"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"\n\t\t \"test_boost=%d/%d test_boost_interval=%d \"\n\t\t \"test_boost_duration=%d shutdown_secs=%d \"\n\t\t \"stall_cpu=%d stall_cpu_holdoff=%d stall_cpu_irqsoff=%d \"\n\t\t \"stall_cpu_block=%d \"\n\t\t \"n_barrier_cbs=%d \"\n\t\t \"onoff_interval=%d onoff_holdoff=%d \"\n\t\t \"read_exit_delay=%d read_exit_burst=%d \"\n\t\t \"nocbs_nthreads=%d nocbs_toggle=%d\\n\",\n\t\t torture_type, tag, nrealreaders, nfakewriters,\n\t\t stat_interval, verbose, test_no_idle_hz, shuffle_interval,\n\t\t stutter, irqreader, fqs_duration, fqs_holdoff, fqs_stutter,\n\t\t test_boost, cur_ops->can_boost,\n\t\t test_boost_interval, test_boost_duration, shutdown_secs,\n\t\t stall_cpu, stall_cpu_holdoff, stall_cpu_irqsoff,\n\t\t stall_cpu_block,\n\t\t n_barrier_cbs,\n\t\t onoff_interval, onoff_holdoff,\n\t\t read_exit_delay, read_exit_burst,\n\t\t nocbs_nthreads, nocbs_toggle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 3123
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->init",
          "args": [],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"rcu-torture: ->fqs NULL and non-zero fqs_duration, fqs disabled.\\n\""
          ],
          "line": 3114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 3108
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %s\"",
            "torture_ops[i]->name"
          ],
          "line": 3107
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "torture_ops"
          ],
          "line": 3106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"rcu-torture types:\""
          ],
          "line": 3105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"rcu-torture: invalid torture type: \\\"%s\\\"\\n\"",
            "torture_type"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "torture_ops"
          ],
          "line": 3102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "torture_type",
            "cur_ops->name"
          ],
          "line": 3099
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "torture_ops"
          ],
          "line": 3097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_begin",
          "args": [
            "torture_type",
            "verbose"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "815-829",
          "snippet": "bool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"%s: Refusing %s init: %s running.\\n\",\n\t\t\t  __func__, ttype, torture_type);\n\t\tpr_alert(\"%s: One torture test at a time!\\n\", __func__);\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static char *torture_type;",
            "static int verbose;",
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic char *torture_type;\nstatic int verbose;\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"%s: Refusing %s init: %s running.\\n\",\n\t\t\t  __func__, ttype, torture_type);\n\t\tpr_alert(\"%s: One torture test at a time!\\n\", __func__);\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic char *torture_type = \"rcu\";\nstatic int nrealnocbers;\nstatic int nrealreaders;\nstatic struct task_struct *writer_task;\nstatic struct task_struct **fakewriter_tasks;\nstatic struct task_struct **reader_tasks;\nstatic struct task_struct **nocb_tasks;\nstatic struct task_struct *stats_task;\nstatic struct task_struct *fqs_task;\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic unsigned long rcu_torture_current_version;\nstatic struct rcu_torture rcu_tortures[10 * RCU_TORTURE_PIPE_LEN];\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\nstatic struct rcu_torture_reader_check *rcu_torture_reader_mbchk;\nstatic atomic_t n_rcu_torture_alloc;\nstatic atomic_t n_rcu_torture_alloc_fail;\nstatic atomic_t n_rcu_torture_free;\nstatic atomic_t n_rcu_torture_mberror;\nstatic atomic_t n_rcu_torture_mbchk_fail;\nstatic atomic_t n_rcu_torture_mbchk_tries;\nstatic atomic_t n_rcu_torture_error;\nstatic long n_rcu_torture_barrier_error;\nstatic long n_rcu_torture_boost_ktrerror;\nstatic long n_rcu_torture_boost_rterror;\nstatic long n_rcu_torture_boost_failure;\nstatic long n_rcu_torture_boosts;\nstatic unsigned long shutdown_jiffies;\nstatic unsigned long start_gp_seq;\nstatic int err_segs_recorded;\nstatic int rt_read_nsegs;\nstatic unsigned long boost_starttime;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct rcu_torture_ops rcu_ops = {\n\t.ttype\t\t\t= RCU_FLAVOR,\n\t.init\t\t\t= rcu_sync_torture_init,\n\t.readlock\t\t= rcu_torture_read_lock,\n\t.read_delay\t\t= rcu_read_delay,\n\t.readunlock\t\t= rcu_torture_read_unlock,\n\t.readlock_held\t\t= torture_readlock_not_held,\n\t.get_gp_seq\t\t= rcu_get_gp_seq,\n\t.gp_diff\t\t= rcu_seq_diff,\n\t.deferred_free\t\t= rcu_torture_deferred_free,\n\t.sync\t\t\t= synchronize_rcu,\n\t.exp_sync\t\t= synchronize_rcu_expedited,\n\t.get_gp_state\t\t= get_state_synchronize_rcu,\n\t.start_gp_poll\t\t= start_poll_synchronize_rcu,\n\t.poll_gp_state\t\t= poll_state_synchronize_rcu,\n\t.cond_sync\t\t= cond_synchronize_rcu,\n\t.call\t\t\t= call_rcu,\n\t.cb_barrier\t\t= rcu_barrier,\n\t.fqs\t\t\t= rcu_force_quiescent_state,\n\t.stats\t\t\t= NULL,\n\t.gp_kthread_dbg\t\t= show_rcu_gp_kthreads,\n\t.check_boost_failed\t= rcu_check_boost_fail,\n\t.stall_dur\t\t= rcu_jiffies_till_stall_check,\n\t.irq_capable\t\t= 1,\n\t.can_boost\t\t= IS_ENABLED(CONFIG_RCU_BOOST),\n\t.extendables\t\t= RCUTORTURE_MAX_EXTEND,\n\t.name\t\t\t= \"rcu\"\n};\nstatic struct rcu_torture_ops rcu_busted_ops = {\n\t.ttype\t\t= INVALID_RCU_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= rcu_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= rcu_torture_read_unlock,\n\t.readlock_held\t= torture_readlock_not_held,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_busted_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_busted,\n\t.exp_sync\t= synchronize_rcu_busted,\n\t.call\t\t= call_rcu_busted,\n\t.cb_barrier\t= NULL,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"busted\"\n};\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\nstatic struct rcu_torture_ops srcu_ops = {\n\t.ttype\t\t= SRCU_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= srcu_torture_read_lock,\n\t.read_delay\t= srcu_read_delay,\n\t.readunlock\t= srcu_torture_read_unlock,\n\t.readlock_held\t= torture_srcu_read_lock_held,\n\t.get_gp_seq\t= srcu_torture_completed,\n\t.deferred_free\t= srcu_torture_deferred_free,\n\t.sync\t\t= srcu_torture_synchronize,\n\t.exp_sync\t= srcu_torture_synchronize_expedited,\n\t.get_gp_state\t= srcu_torture_get_gp_state,\n\t.start_gp_poll\t= srcu_torture_start_gp_poll,\n\t.poll_gp_state\t= srcu_torture_poll_gp_state,\n\t.call\t\t= srcu_torture_call,\n\t.cb_barrier\t= srcu_torture_barrier,\n\t.stats\t\t= srcu_torture_stats,\n\t.irq_capable\t= 1,\n\t.no_pi_lock\t= IS_ENABLED(CONFIG_TINY_SRCU),\n\t.name\t\t= \"srcu\"\n};\nstatic struct rcu_torture_ops srcud_ops = {\n\t.ttype\t\t= SRCU_FLAVOR,\n\t.init\t\t= srcu_torture_init,\n\t.cleanup\t= srcu_torture_cleanup,\n\t.readlock\t= srcu_torture_read_lock,\n\t.read_delay\t= srcu_read_delay,\n\t.readunlock\t= srcu_torture_read_unlock,\n\t.readlock_held\t= torture_srcu_read_lock_held,\n\t.get_gp_seq\t= srcu_torture_completed,\n\t.deferred_free\t= srcu_torture_deferred_free,\n\t.sync\t\t= srcu_torture_synchronize,\n\t.exp_sync\t= srcu_torture_synchronize_expedited,\n\t.call\t\t= srcu_torture_call,\n\t.cb_barrier\t= srcu_torture_barrier,\n\t.stats\t\t= srcu_torture_stats,\n\t.irq_capable\t= 1,\n\t.no_pi_lock\t= IS_ENABLED(CONFIG_TINY_SRCU),\n\t.name\t\t= \"srcud\"\n};\nstatic struct rcu_torture_ops busted_srcud_ops = {\n\t.ttype\t\t= SRCU_FLAVOR,\n\t.init\t\t= srcu_torture_init,\n\t.cleanup\t= srcu_torture_cleanup,\n\t.readlock\t= srcu_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,\n\t.readunlock\t= srcu_torture_read_unlock,\n\t.readlock_held\t= torture_srcu_read_lock_held,\n\t.get_gp_seq\t= srcu_torture_completed,\n\t.deferred_free\t= srcu_torture_deferred_free,\n\t.sync\t\t= srcu_torture_synchronize,\n\t.exp_sync\t= srcu_torture_synchronize_expedited,\n\t.call\t\t= srcu_torture_call,\n\t.cb_barrier\t= srcu_torture_barrier,\n\t.stats\t\t= srcu_torture_stats,\n\t.irq_capable\t= 1,\n\t.no_pi_lock\t= IS_ENABLED(CONFIG_TINY_SRCU),\n\t.extendables\t= RCUTORTURE_MAX_EXTEND,\n\t.name\t\t= \"busted_srcud\"\n};\nstatic struct rcu_torture_ops tasks_ops = {\n\t.ttype\t\t= RCU_TASKS_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= tasks_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= tasks_torture_read_unlock,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_tasks_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_tasks,\n\t.exp_sync\t= synchronize_rcu_mult_test,\n\t.call\t\t= call_rcu_tasks,\n\t.cb_barrier\t= rcu_barrier_tasks,\n\t.gp_kthread_dbg\t= show_rcu_tasks_classic_gp_kthread,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.slow_gps\t= 1,\n\t.name\t\t= \"tasks\"\n};\nstatic struct rcu_torture_ops trivial_ops = {\n\t.ttype\t\t= RCU_TRIVIAL_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= rcu_torture_read_lock_trivial,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= rcu_torture_read_unlock_trivial,\n\t.readlock_held\t= torture_readlock_not_held,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.sync\t\t= synchronize_rcu_trivial,\n\t.exp_sync\t= synchronize_rcu_trivial,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"trivial\"\n};\nstatic struct rcu_torture_ops tasks_rude_ops = {\n\t.ttype\t\t= RCU_TASKS_RUDE_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= rcu_torture_read_lock_trivial,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= rcu_torture_read_unlock_trivial,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_tasks_rude_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_tasks_rude,\n\t.exp_sync\t= synchronize_rcu_tasks_rude,\n\t.call\t\t= call_rcu_tasks_rude,\n\t.cb_barrier\t= rcu_barrier_tasks_rude,\n\t.gp_kthread_dbg\t= show_rcu_tasks_rude_gp_kthread,\n\t.cbflood_max\t= 50000,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"tasks-rude\"\n};\nstatic struct rcu_torture_ops tasks_tracing_ops = {\n\t.ttype\t\t= RCU_TASKS_TRACING_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= tasks_tracing_torture_read_lock,\n\t.read_delay\t= srcu_read_delay,  /* just reuse srcu's version. */\n\t.readunlock\t= tasks_tracing_torture_read_unlock,\n\t.readlock_held\t= rcu_read_lock_trace_held,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_tasks_tracing_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_tasks_trace,\n\t.exp_sync\t= synchronize_rcu_tasks_trace,\n\t.call\t\t= call_rcu_tasks_trace,\n\t.cb_barrier\t= rcu_barrier_tasks_trace,\n\t.gp_kthread_dbg\t= show_rcu_tasks_trace_gp_kthread,\n\t.cbflood_max\t= 50000,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.slow_gps\t= 1,\n\t.name\t\t= \"tasks-tracing\"\n};\nstatic enum cpuhp_state rcutor_hp;\n\nstatic int __init\nrcu_torture_init(void)\n{\n\tlong i;\n\tint cpu;\n\tint firsterr = 0;\n\tint flags = 0;\n\tunsigned long gp_seq = 0;\n\tstatic struct rcu_torture_ops *torture_ops[] = {\n\t\t&rcu_ops, &rcu_busted_ops, &srcu_ops, &srcud_ops,\n\t\t&busted_srcud_ops, &tasks_ops, &tasks_rude_ops,\n\t\t&tasks_tracing_ops, &trivial_ops,\n\t};\n\n\tif (!torture_init_begin(torture_type, verbose))\n\t\treturn -EBUSY;\n\n\t/* Process args and tell the world that the torturer is on the job. */\n\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++) {\n\t\tcur_ops = torture_ops[i];\n\t\tif (strcmp(torture_type, cur_ops->name) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(torture_ops)) {\n\t\tpr_alert(\"rcu-torture: invalid torture type: \\\"%s\\\"\\n\",\n\t\t\t torture_type);\n\t\tpr_alert(\"rcu-torture types:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++)\n\t\t\tpr_cont(\" %s\", torture_ops[i]->name);\n\t\tpr_cont(\"\\n\");\n\t\tfirsterr = -EINVAL;\n\t\tcur_ops = NULL;\n\t\tgoto unwind;\n\t}\n\tif (cur_ops->fqs == NULL && fqs_duration != 0) {\n\t\tpr_alert(\"rcu-torture: ->fqs NULL and non-zero fqs_duration, fqs disabled.\\n\");\n\t\tfqs_duration = 0;\n\t}\n\tif (cur_ops->init)\n\t\tcur_ops->init();\n\n\tif (nreaders >= 0) {\n\t\tnrealreaders = nreaders;\n\t} else {\n\t\tnrealreaders = num_online_cpus() - 2 - nreaders;\n\t\tif (nrealreaders <= 0)\n\t\t\tnrealreaders = 1;\n\t}\n\trcu_torture_print_module_parms(cur_ops, \"Start of test\");\n\trcutorture_get_gp_data(cur_ops->ttype, &flags, &gp_seq);\n\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp, &flags, &gp_seq);\n\tstart_gp_seq = gp_seq;\n\tpr_alert(\"%s:  Start-test grace-period state: g%ld f%#x\\n\",\n\t\t cur_ops->name, (long)gp_seq, flags);\n\n\t/* Set up the freelist. */\n\n\tINIT_LIST_HEAD(&rcu_torture_freelist);\n\tfor (i = 0; i < ARRAY_SIZE(rcu_tortures); i++) {\n\t\trcu_tortures[i].rtort_mbtest = 0;\n\t\tlist_add_tail(&rcu_tortures[i].rtort_free,\n\t\t\t      &rcu_torture_freelist);\n\t}\n\n\t/* Initialize the statistics so that each run gets its own numbers. */\n\n\trcu_torture_current = NULL;\n\trcu_torture_current_version = 0;\n\tatomic_set(&n_rcu_torture_alloc, 0);\n\tatomic_set(&n_rcu_torture_alloc_fail, 0);\n\tatomic_set(&n_rcu_torture_free, 0);\n\tatomic_set(&n_rcu_torture_mberror, 0);\n\tatomic_set(&n_rcu_torture_mbchk_fail, 0);\n\tatomic_set(&n_rcu_torture_mbchk_tries, 0);\n\tatomic_set(&n_rcu_torture_error, 0);\n\tn_rcu_torture_barrier_error = 0;\n\tn_rcu_torture_boost_ktrerror = 0;\n\tn_rcu_torture_boost_rterror = 0;\n\tn_rcu_torture_boost_failure = 0;\n\tn_rcu_torture_boosts = 0;\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tatomic_set(&rcu_torture_wcount[i], 0);\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tper_cpu(rcu_torture_count, cpu)[i] = 0;\n\t\t\tper_cpu(rcu_torture_batch, cpu)[i] = 0;\n\t\t}\n\t}\n\terr_segs_recorded = 0;\n\trt_read_nsegs = 0;\n\n\t/* Start up the kthreads. */\n\n\trcu_torture_write_types();\n\tfirsterr = torture_create_kthread(rcu_torture_writer, NULL,\n\t\t\t\t\t  writer_task);\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\tif (nfakewriters > 0) {\n\t\tfakewriter_tasks = kcalloc(nfakewriters,\n\t\t\t\t\t   sizeof(fakewriter_tasks[0]),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (fakewriter_tasks == NULL) {\n\t\t\tTOROUT_ERRSTRING(\"out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\tfor (i = 0; i < nfakewriters; i++) {\n\t\tfirsterr = torture_create_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t\t  NULL, fakewriter_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\treader_tasks = kcalloc(nrealreaders, sizeof(reader_tasks[0]),\n\t\t\t       GFP_KERNEL);\n\trcu_torture_reader_mbchk = kcalloc(nrealreaders, sizeof(*rcu_torture_reader_mbchk),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!reader_tasks || !rcu_torture_reader_mbchk) {\n\t\tTOROUT_ERRSTRING(\"out of memory\");\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\tfor (i = 0; i < nrealreaders; i++) {\n\t\trcu_torture_reader_mbchk[i].rtc_chkrdr = -1;\n\t\tfirsterr = torture_create_kthread(rcu_torture_reader, (void *)i,\n\t\t\t\t\t\t  reader_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tnrealnocbers = nocbs_nthreads;\n\tif (WARN_ON(nrealnocbers < 0))\n\t\tnrealnocbers = 1;\n\tif (WARN_ON(nocbs_toggle < 0))\n\t\tnocbs_toggle = HZ;\n\tif (nrealnocbers > 0) {\n\t\tnocb_tasks = kcalloc(nrealnocbers, sizeof(nocb_tasks[0]), GFP_KERNEL);\n\t\tif (nocb_tasks == NULL) {\n\t\t\tTOROUT_ERRSTRING(\"out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t} else {\n\t\tnocb_tasks = NULL;\n\t}\n\tfor (i = 0; i < nrealnocbers; i++) {\n\t\tfirsterr = torture_create_kthread(rcu_nocb_toggle, NULL, nocb_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (stat_interval > 0) {\n\t\tfirsterr = torture_create_kthread(rcu_torture_stats, NULL,\n\t\t\t\t\t\t  stats_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (test_no_idle_hz && shuffle_interval > 0) {\n\t\tfirsterr = torture_shuffle_init(shuffle_interval * HZ);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (stutter < 0)\n\t\tstutter = 0;\n\tif (stutter) {\n\t\tint t;\n\n\t\tt = cur_ops->stall_dur ? cur_ops->stall_dur() : stutter * HZ;\n\t\tfirsterr = torture_stutter_init(stutter * HZ, t);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (fqs_duration < 0)\n\t\tfqs_duration = 0;\n\tif (fqs_duration) {\n\t\t/* Create the fqs thread */\n\t\tfirsterr = torture_create_kthread(rcu_torture_fqs, NULL,\n\t\t\t\t\t\t  fqs_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (test_boost_interval < 1)\n\t\ttest_boost_interval = 1;\n\tif (test_boost_duration < 2)\n\t\ttest_boost_duration = 2;\n\tif (rcu_torture_can_boost()) {\n\n\t\tboost_starttime = jiffies + test_boost_interval * HZ;\n\n\t\tfirsterr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"RCU_TORTURE\",\n\t\t\t\t\t     rcutorture_booster_init,\n\t\t\t\t\t     rcutorture_booster_cleanup);\n\t\trcutor_hp = firsterr;\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\n\t\t// Testing RCU priority boosting requires rcutorture do\n\t\t// some serious abuse.  Counter this by running ksoftirqd\n\t\t// at higher priority.\n\t\tif (IS_BUILTIN(CONFIG_RCU_TORTURE_TEST)) {\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tstruct sched_param sp;\n\t\t\t\tstruct task_struct *t;\n\n\t\t\t\tt = per_cpu(ksoftirqd, cpu);\n\t\t\t\tWARN_ON_ONCE(!t);\n\t\t\t\tsp.sched_priority = 2;\n\t\t\t\tsched_setscheduler_nocheck(t, SCHED_FIFO, &sp);\n\t\t\t}\n\t\t}\n\t}\n\tshutdown_jiffies = jiffies + shutdown_secs * HZ;\n\tfirsterr = torture_shutdown_init(shutdown_secs, rcu_torture_cleanup);\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\tfirsterr = torture_onoff_init(onoff_holdoff * HZ, onoff_interval,\n\t\t\t\t      rcutorture_sync);\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\tfirsterr = rcu_torture_stall_init();\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\tfirsterr = rcu_torture_fwd_prog_init();\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\tfirsterr = rcu_torture_barrier_init();\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\tfirsterr = rcu_torture_read_exit_init();\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\tif (object_debug)\n\t\trcu_test_debug_objects();\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\trcu_torture_cleanup();\n\tif (shutdown_secs) {\n\t\tWARN_ON(!IS_MODULE(CONFIG_RCU_TORTURE_TEST));\n\t\tkernel_power_off();\n\t}\n\treturn firsterr;\n}"
  },
  {
    "function_name": "rcutorture_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "3071-3077",
    "snippet": "static void rcutorture_sync(void)\n{\n\tstatic unsigned long n;\n\n\tif (cur_ops->sync && !(++n & 0xfff))\n\t\tcur_ops->sync();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_ops->sync",
          "args": [],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void rcutorture_sync(void)\n{\n\tstatic unsigned long n;\n\n\tif (cur_ops->sync && !(++n & 0xfff))\n\t\tcur_ops->sync();\n}"
  },
  {
    "function_name": "rcu_test_debug_objects",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "3035-3069",
    "snippet": "static void rcu_test_debug_objects(void)\n{\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\n\tstruct rcu_head rh1;\n\tstruct rcu_head rh2;\n\tstruct rcu_head *rhp = kmalloc(sizeof(*rhp), GFP_KERNEL);\n\n\tinit_rcu_head_on_stack(&rh1);\n\tinit_rcu_head_on_stack(&rh2);\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test starting.\\n\", KBUILD_MODNAME);\n\n\t/* Try to queue the rh2 pair of callbacks for the same grace period. */\n\tpreempt_disable(); /* Prevent preemption from interrupting test. */\n\trcu_read_lock(); /* Make it impossible to finish a grace period. */\n\tcall_rcu(&rh1, rcu_torture_leak_cb); /* Start grace period. */\n\tlocal_irq_disable(); /* Make it harder to start a new grace period. */\n\tcall_rcu(&rh2, rcu_torture_leak_cb);\n\tcall_rcu(&rh2, rcu_torture_err_cb); /* Duplicate callback. */\n\tif (rhp) {\n\t\tcall_rcu(rhp, rcu_torture_leak_cb);\n\t\tcall_rcu(rhp, rcu_torture_err_cb); /* Another duplicate callback. */\n\t}\n\tlocal_irq_enable();\n\trcu_read_unlock();\n\tpreempt_enable();\n\n\t/* Wait for them all to get done so we can safely return. */\n\trcu_barrier();\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test complete.\\n\", KBUILD_MODNAME);\n\tdestroy_rcu_head_on_stack(&rh1);\n\tdestroy_rcu_head_on_stack(&rh2);\n#else /* #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n\tpr_alert(\"%s: !CONFIG_DEBUG_OBJECTS_RCU_HEAD, not testing duplicate call_rcu()\\n\", KBUILD_MODNAME);\n#endif /* #else #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: !CONFIG_DEBUG_OBJECTS_RCU_HEAD, not testing duplicate call_rcu()\\n\"",
            "KBUILD_MODNAME"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_rcu_head_on_stack",
          "args": [
            "&rh2"
          ],
          "line": 3065
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_rcu_head_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "455-458",
          "snippet": "void destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: WARN: Duplicate call_rcu() test complete.\\n\"",
            "KBUILD_MODNAME"
          ],
          "line": 3063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 3062
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1569-1572",
          "snippet": "void rcu_barrier_tasks_trace(void)\n{\n\trcu_barrier_tasks_generic(&rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid rcu_barrier_tasks_trace(void)\n{\n\trcu_barrier_tasks_generic(&rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3058
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "rhp",
            "rcu_torture_err_cb"
          ],
          "line": 3055
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_busted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "541-546",
          "snippet": "static void\ncall_rcu_busted(struct rcu_head *head, rcu_callback_t func)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\tfunc(head);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void\ncall_rcu_busted(struct rcu_head *head, rcu_callback_t func)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\tfunc(head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 3050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "torture_srcu_read_lock_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "604-607",
          "snippet": "static int torture_srcu_read_lock_held(void)\n{\n\treturn srcu_read_lock_held(srcu_ctlp);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic int torture_srcu_read_lock_held(void)\n{\n\treturn srcu_read_lock_held(srcu_ctlp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 3047
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: WARN: Duplicate call_rcu() test starting.\\n\"",
            "KBUILD_MODNAME"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rcu_head_on_stack",
          "args": [
            "&rh2"
          ],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "init_rcu_head_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "438-441",
          "snippet": "void init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*rhp)",
            "GFP_KERNEL"
          ],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_test_debug_objects(void)\n{\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\n\tstruct rcu_head rh1;\n\tstruct rcu_head rh2;\n\tstruct rcu_head *rhp = kmalloc(sizeof(*rhp), GFP_KERNEL);\n\n\tinit_rcu_head_on_stack(&rh1);\n\tinit_rcu_head_on_stack(&rh2);\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test starting.\\n\", KBUILD_MODNAME);\n\n\t/* Try to queue the rh2 pair of callbacks for the same grace period. */\n\tpreempt_disable(); /* Prevent preemption from interrupting test. */\n\trcu_read_lock(); /* Make it impossible to finish a grace period. */\n\tcall_rcu(&rh1, rcu_torture_leak_cb); /* Start grace period. */\n\tlocal_irq_disable(); /* Make it harder to start a new grace period. */\n\tcall_rcu(&rh2, rcu_torture_leak_cb);\n\tcall_rcu(&rh2, rcu_torture_err_cb); /* Duplicate callback. */\n\tif (rhp) {\n\t\tcall_rcu(rhp, rcu_torture_leak_cb);\n\t\tcall_rcu(rhp, rcu_torture_err_cb); /* Another duplicate callback. */\n\t}\n\tlocal_irq_enable();\n\trcu_read_unlock();\n\tpreempt_enable();\n\n\t/* Wait for them all to get done so we can safely return. */\n\trcu_barrier();\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test complete.\\n\", KBUILD_MODNAME);\n\tdestroy_rcu_head_on_stack(&rh1);\n\tdestroy_rcu_head_on_stack(&rh2);\n#else /* #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n\tpr_alert(\"%s: !CONFIG_DEBUG_OBJECTS_RCU_HEAD, not testing duplicate call_rcu()\\n\", KBUILD_MODNAME);\n#endif /* #else #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n}"
  },
  {
    "function_name": "rcu_torture_err_cb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "3015-3027",
    "snippet": "static void rcu_torture_err_cb(struct rcu_head *rhp)\n{\n\t/*\n\t * This -might- happen due to race conditions, but is unlikely.\n\t * The scenario that leads to this happening is that the\n\t * first of the pair of duplicate callbacks is queued,\n\t * someone else starts a grace period that includes that\n\t * callback, then the second of the pair must wait for the\n\t * next grace period.  Unlikely, but can happen.  If it\n\t * does happen, the debug-objects subsystem won't have splatted.\n\t */\n\tpr_alert(\"%s: duplicated callback was invoked.\\n\", KBUILD_MODNAME);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: duplicated callback was invoked.\\n\"",
            "KBUILD_MODNAME"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_err_cb(struct rcu_head *rhp)\n{\n\t/*\n\t * This -might- happen due to race conditions, but is unlikely.\n\t * The scenario that leads to this happening is that the\n\t * first of the pair of duplicate callbacks is queued,\n\t * someone else starts a grace period that includes that\n\t * callback, then the second of the pair must wait for the\n\t * next grace period.  Unlikely, but can happen.  If it\n\t * does happen, the debug-objects subsystem won't have splatted.\n\t */\n\tpr_alert(\"%s: duplicated callback was invoked.\\n\", KBUILD_MODNAME);\n}"
  },
  {
    "function_name": "rcu_torture_leak_cb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "3011-3013",
    "snippet": "static void rcu_torture_leak_cb(struct rcu_head *rhp)\n{\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_leak_cb(struct rcu_head *rhp)\n{\n}"
  },
  {
    "function_name": "rcu_torture_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2899-3008",
    "snippet": "static void\nrcu_torture_cleanup(void)\n{\n\tint firsttime;\n\tint flags = 0;\n\tunsigned long gp_seq = 0;\n\tint i;\n\n\tif (torture_cleanup_begin()) {\n\t\tif (cur_ops->cb_barrier != NULL)\n\t\t\tcur_ops->cb_barrier();\n\t\treturn;\n\t}\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (cur_ops->gp_kthread_dbg)\n\t\tcur_ops->gp_kthread_dbg();\n\trcu_torture_read_exit_cleanup();\n\trcu_torture_barrier_cleanup();\n\trcu_torture_fwd_prog_cleanup();\n\ttorture_stop_kthread(rcu_torture_stall, stall_task);\n\ttorture_stop_kthread(rcu_torture_writer, writer_task);\n\n\tif (nocb_tasks) {\n\t\tfor (i = 0; i < nrealnocbers; i++)\n\t\t\ttorture_stop_kthread(rcu_nocb_toggle, nocb_tasks[i]);\n\t\tkfree(nocb_tasks);\n\t\tnocb_tasks = NULL;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t\treader_tasks = NULL;\n\t}\n\tkfree(rcu_torture_reader_mbchk);\n\trcu_torture_reader_mbchk = NULL;\n\n\tif (fakewriter_tasks) {\n\t\tfor (i = 0; i < nfakewriters; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t     fakewriter_tasks[i]);\n\t\tkfree(fakewriter_tasks);\n\t\tfakewriter_tasks = NULL;\n\t}\n\n\trcutorture_get_gp_data(cur_ops->ttype, &flags, &gp_seq);\n\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp, &flags, &gp_seq);\n\tpr_alert(\"%s:  End-test grace-period state: g%ld f%#x total-gps=%ld\\n\",\n\t\t cur_ops->name, (long)gp_seq, flags,\n\t\t rcutorture_seq_diff(gp_seq, start_gp_seq));\n\ttorture_stop_kthread(rcu_torture_stats, stats_task);\n\ttorture_stop_kthread(rcu_torture_fqs, fqs_task);\n\tif (rcu_torture_can_boost() && rcutor_hp >= 0)\n\t\tcpuhp_remove_state(rcutor_hp);\n\n\t/*\n\t * Wait for all RCU callbacks to fire, then do torture-type-specific\n\t * cleanup operations.\n\t */\n\tif (cur_ops->cb_barrier != NULL)\n\t\tcur_ops->cb_barrier();\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\trcu_torture_mem_dump_obj();\n\n\trcu_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (err_segs_recorded) {\n\t\tpr_alert(\"Failure/close-call rcutorture reader segments:\\n\");\n\t\tif (rt_read_nsegs == 0)\n\t\t\tpr_alert(\"\\t: No segments recorded!!!\\n\");\n\t\tfirsttime = 1;\n\t\tfor (i = 0; i < rt_read_nsegs; i++) {\n\t\t\tpr_alert(\"\\t%d: %#x \", i, err_segs[i].rt_readstate);\n\t\t\tif (err_segs[i].rt_delay_jiffies != 0) {\n\t\t\t\tpr_cont(\"%s%ldjiffies\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_jiffies);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_ms != 0) {\n\t\t\t\tpr_cont(\"%s%ldms\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_ms);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_us != 0) {\n\t\t\t\tpr_cont(\"%s%ldus\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_us);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tpr_cont(\"%s\\n\",\n\t\t\t\terr_segs[i].rt_preempted ? \"preempted\" : \"\");\n\n\t\t}\n\t}\n\tif (atomic_read(&n_rcu_torture_error) || n_rcu_torture_barrier_error)\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\trcu_torture_print_module_parms(cur_ops,\n\t\t\t\t\t       \"End of test: RCU_HOTPLUG\");\n\telse\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: SUCCESS\");\n\ttorture_cleanup_end();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nrealnocbers;",
      "static int nrealreaders;",
      "static struct task_struct *writer_task;",
      "static struct task_struct **fakewriter_tasks;",
      "static struct task_struct **reader_tasks;",
      "static struct task_struct **nocb_tasks;",
      "static struct task_struct *stats_task;",
      "static struct task_struct *fqs_task;",
      "static struct task_struct *stall_task;",
      "static struct rcu_torture_reader_check *rcu_torture_reader_mbchk;",
      "static atomic_t n_rcu_torture_error;",
      "static long n_rcu_torture_barrier_error;",
      "static unsigned long start_gp_seq;",
      "static int err_segs_recorded;",
      "static struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];",
      "static int rt_read_nsegs;",
      "static struct rcu_torture_ops *cur_ops;",
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;",
      "static enum cpuhp_state rcutor_hp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_cleanup_end",
          "args": [],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "876-881",
          "snippet": "void torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nvoid torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_print_module_parms",
          "args": [
            "cur_ops",
            "\"End of test: SUCCESS\""
          ],
          "line": 3006
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_print_module_parms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1977-2004",
          "snippet": "static void\nrcu_torture_print_module_parms(struct rcu_torture_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s: nreaders=%d nfakewriters=%d \"\n\t\t \"stat_interval=%d verbose=%d test_no_idle_hz=%d \"\n\t\t \"shuffle_interval=%d stutter=%d irqreader=%d \"\n\t\t \"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"\n\t\t \"test_boost=%d/%d test_boost_interval=%d \"\n\t\t \"test_boost_duration=%d shutdown_secs=%d \"\n\t\t \"stall_cpu=%d stall_cpu_holdoff=%d stall_cpu_irqsoff=%d \"\n\t\t \"stall_cpu_block=%d \"\n\t\t \"n_barrier_cbs=%d \"\n\t\t \"onoff_interval=%d onoff_holdoff=%d \"\n\t\t \"read_exit_delay=%d read_exit_burst=%d \"\n\t\t \"nocbs_nthreads=%d nocbs_toggle=%d\\n\",\n\t\t torture_type, tag, nrealreaders, nfakewriters,\n\t\t stat_interval, verbose, test_no_idle_hz, shuffle_interval,\n\t\t stutter, irqreader, fqs_duration, fqs_holdoff, fqs_stutter,\n\t\t test_boost, cur_ops->can_boost,\n\t\t test_boost_interval, test_boost_duration, shutdown_secs,\n\t\t stall_cpu, stall_cpu_holdoff, stall_cpu_irqsoff,\n\t\t stall_cpu_block,\n\t\t n_barrier_cbs,\n\t\t onoff_interval, onoff_holdoff,\n\t\t read_exit_delay, read_exit_burst,\n\t\t nocbs_nthreads, nocbs_toggle);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type = \"rcu\";",
            "static int nrealreaders;",
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type = \"rcu\";\nstatic int nrealreaders;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void\nrcu_torture_print_module_parms(struct rcu_torture_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s: nreaders=%d nfakewriters=%d \"\n\t\t \"stat_interval=%d verbose=%d test_no_idle_hz=%d \"\n\t\t \"shuffle_interval=%d stutter=%d irqreader=%d \"\n\t\t \"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"\n\t\t \"test_boost=%d/%d test_boost_interval=%d \"\n\t\t \"test_boost_duration=%d shutdown_secs=%d \"\n\t\t \"stall_cpu=%d stall_cpu_holdoff=%d stall_cpu_irqsoff=%d \"\n\t\t \"stall_cpu_block=%d \"\n\t\t \"n_barrier_cbs=%d \"\n\t\t \"onoff_interval=%d onoff_holdoff=%d \"\n\t\t \"read_exit_delay=%d read_exit_burst=%d \"\n\t\t \"nocbs_nthreads=%d nocbs_toggle=%d\\n\",\n\t\t torture_type, tag, nrealreaders, nfakewriters,\n\t\t stat_interval, verbose, test_no_idle_hz, shuffle_interval,\n\t\t stutter, irqreader, fqs_duration, fqs_holdoff, fqs_stutter,\n\t\t test_boost, cur_ops->can_boost,\n\t\t test_boost_interval, test_boost_duration, shutdown_secs,\n\t\t stall_cpu, stall_cpu_holdoff, stall_cpu_irqsoff,\n\t\t stall_cpu_block,\n\t\t n_barrier_cbs,\n\t\t onoff_interval, onoff_holdoff,\n\t\t read_exit_delay, read_exit_burst,\n\t\t nocbs_nthreads, nocbs_toggle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_onoff_failures",
          "args": [],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "torture_onoff_failures",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "430-438",
          "snippet": "bool torture_onoff_failures(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\treturn n_online_successes != n_online_attempts ||\n\t       n_offline_successes != n_offline_attempts;\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn false;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool torture_onoff_failures(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\treturn n_online_successes != n_online_attempts ||\n\t       n_offline_successes != n_offline_attempts;\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn false;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_error"
          ],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s\\n\"",
            "err_segs[i].rt_preempted ? \"preempted\" : \"\""
          ],
          "line": 2995
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s%ldus\"",
            "firsttime ? \"\" : \"+\"",
            "err_segs[i].rt_delay_us"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s%ldms\"",
            "firsttime ? \"\" : \"+\"",
            "err_segs[i].rt_delay_ms"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s%ldjiffies\"",
            "firsttime ? \"\" : \"+\"",
            "err_segs[i].rt_delay_jiffies"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"\\t%d: %#x \"",
            "i",
            "err_segs[i].rt_readstate"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"\\t: No segments recorded!!!\\n\""
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"Failure/close-call rcutorture reader segments:\\n\""
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_stats_print",
          "args": [],
          "line": 2971
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_stats_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1805-1918",
          "snippet": "static void\nrcu_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong pipesummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tlong batchsummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tstruct rcu_torture *rtcp;\n\tstatic unsigned long rtcv_snap = ULONG_MAX;\n\tstatic bool splatted;\n\tstruct task_struct *wtp;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tpipesummary[i] += READ_ONCE(per_cpu(rcu_torture_count, cpu)[i]);\n\t\t\tbatchsummary[i] += READ_ONCE(per_cpu(rcu_torture_batch, cpu)[i]);\n\t\t}\n\t}\n\tfor (i = RCU_TORTURE_PIPE_LEN - 1; i >= 0; i--) {\n\t\tif (pipesummary[i] != 0)\n\t\t\tbreak;\n\t}\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\trtcp = rcu_access_pointer(rcu_torture_current);\n\tpr_cont(\"rtc: %p %s: %lu tfle: %d rta: %d rtaf: %d rtf: %d \",\n\t\trtcp,\n\t\trtcp && !rcu_stall_is_suppressed_at_boot() ? \"ver\" : \"VER\",\n\t\trcu_torture_current_version,\n\t\tlist_empty(&rcu_torture_freelist),\n\t\tatomic_read(&n_rcu_torture_alloc),\n\t\tatomic_read(&n_rcu_torture_alloc_fail),\n\t\tatomic_read(&n_rcu_torture_free));\n\tpr_cont(\"rtmbe: %d rtmbkf: %d/%d rtbe: %ld rtbke: %ld rtbre: %ld \",\n\t\tatomic_read(&n_rcu_torture_mberror),\n\t\tatomic_read(&n_rcu_torture_mbchk_fail), atomic_read(&n_rcu_torture_mbchk_tries),\n\t\tn_rcu_torture_barrier_error,\n\t\tn_rcu_torture_boost_ktrerror,\n\t\tn_rcu_torture_boost_rterror);\n\tpr_cont(\"rtbf: %ld rtb: %ld nt: %ld \",\n\t\tn_rcu_torture_boost_failure,\n\t\tn_rcu_torture_boosts,\n\t\tatomic_long_read(&n_rcu_torture_timers));\n\ttorture_onoff_stats();\n\tpr_cont(\"barrier: %ld/%ld:%ld \",\n\t\tdata_race(n_barrier_successes),\n\t\tdata_race(n_barrier_attempts),\n\t\tdata_race(n_rcu_torture_barrier_error));\n\tpr_cont(\"read-exits: %ld \", data_race(n_read_exits)); // Statistic.\n\tpr_cont(\"nocb-toggles: %ld:%ld\\n\",\n\t\tatomic_long_read(&n_nocb_offload), atomic_long_read(&n_nocb_deoffload));\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tif (atomic_read(&n_rcu_torture_mberror) ||\n\t    atomic_read(&n_rcu_torture_mbchk_fail) ||\n\t    n_rcu_torture_barrier_error || n_rcu_torture_boost_ktrerror ||\n\t    n_rcu_torture_boost_rterror || n_rcu_torture_boost_failure ||\n\t    i > 1) {\n\t\tpr_cont(\"%s\", \"!!! \");\n\t\tatomic_inc(&n_rcu_torture_error);\n\t\tWARN_ON_ONCE(atomic_read(&n_rcu_torture_mberror));\n\t\tWARN_ON_ONCE(atomic_read(&n_rcu_torture_mbchk_fail));\n\t\tWARN_ON_ONCE(n_rcu_torture_barrier_error);  // rcu_barrier()\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_ktrerror); // no boost kthread\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_rterror); // can't set RT prio\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_failure); // boost failed (TIMER_SOFTIRQ RT prio?)\n\t\tWARN_ON_ONCE(i > 1); // Too-short grace period\n\t}\n\tpr_cont(\"Reader Pipe: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", pipesummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Reader Batch: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", batchsummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Free-Block Circulation: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\tpr_cont(\" %d\", atomic_read(&rcu_torture_wcount[i]));\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (cur_ops->stats)\n\t\tcur_ops->stats();\n\tif (rtcv_snap == rcu_torture_current_version &&\n\t    rcu_access_pointer(rcu_torture_current) &&\n\t    !rcu_stall_is_suppressed()) {\n\t\tint __maybe_unused flags = 0;\n\t\tunsigned long __maybe_unused gp_seq = 0;\n\n\t\trcutorture_get_gp_data(cur_ops->ttype,\n\t\t\t\t       &flags, &gp_seq);\n\t\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp,\n\t\t\t\t\t&flags, &gp_seq);\n\t\twtp = READ_ONCE(writer_task);\n\t\tpr_alert(\"??? Writer stall state %s(%d) g%lu f%#x ->state %#x cpu %d\\n\",\n\t\t\t rcu_torture_writer_state_getname(),\n\t\t\t rcu_torture_writer_state, gp_seq, flags,\n\t\t\t wtp == NULL ? ~0U : wtp->__state,\n\t\t\t wtp == NULL ? -1 : (int)task_cpu(wtp));\n\t\tif (!splatted && wtp) {\n\t\t\tsched_show_task(wtp);\n\t\t\tsplatted = true;\n\t\t}\n\t\tif (cur_ops->gp_kthread_dbg)\n\t\t\tcur_ops->gp_kthread_dbg();\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\trtcv_snap = rcu_torture_current_version;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_TORTURE_PIPE_LEN 10"
          ],
          "globals_used": [
            "static char *torture_type = \"rcu\";",
            "static struct task_struct *writer_task;",
            "static LIST_HEAD(rcu_torture_freelist);",
            "static struct rcu_torture __rcu *rcu_torture_current;",
            "static unsigned long rcu_torture_current_version;",
            "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];",
            "static atomic_t n_rcu_torture_alloc;",
            "static atomic_t n_rcu_torture_alloc_fail;",
            "static atomic_t n_rcu_torture_free;",
            "static atomic_t n_rcu_torture_mberror;",
            "static atomic_t n_rcu_torture_mbchk_fail;",
            "static atomic_t n_rcu_torture_mbchk_tries;",
            "static atomic_t n_rcu_torture_error;",
            "static long n_rcu_torture_barrier_error;",
            "static long n_rcu_torture_boost_ktrerror;",
            "static long n_rcu_torture_boost_rterror;",
            "static long n_rcu_torture_boost_failure;",
            "static long n_rcu_torture_boosts;",
            "static atomic_long_t n_rcu_torture_timers;",
            "static long n_barrier_attempts;",
            "static long n_barrier_successes;",
            "static unsigned long n_read_exits;",
            "static atomic_long_t n_nocb_offload;",
            "static atomic_long_t n_nocb_deoffload;",
            "static int rcu_torture_writer_state;",
            "static struct rcu_torture_ops *cur_ops;",
            "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic char *torture_type = \"rcu\";\nstatic struct task_struct *writer_task;\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic unsigned long rcu_torture_current_version;\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\nstatic atomic_t n_rcu_torture_alloc;\nstatic atomic_t n_rcu_torture_alloc_fail;\nstatic atomic_t n_rcu_torture_free;\nstatic atomic_t n_rcu_torture_mberror;\nstatic atomic_t n_rcu_torture_mbchk_fail;\nstatic atomic_t n_rcu_torture_mbchk_tries;\nstatic atomic_t n_rcu_torture_error;\nstatic long n_rcu_torture_barrier_error;\nstatic long n_rcu_torture_boost_ktrerror;\nstatic long n_rcu_torture_boost_rterror;\nstatic long n_rcu_torture_boost_failure;\nstatic long n_rcu_torture_boosts;\nstatic atomic_long_t n_rcu_torture_timers;\nstatic long n_barrier_attempts;\nstatic long n_barrier_successes;\nstatic unsigned long n_read_exits;\nstatic atomic_long_t n_nocb_offload;\nstatic atomic_long_t n_nocb_deoffload;\nstatic int rcu_torture_writer_state;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void\nrcu_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong pipesummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tlong batchsummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tstruct rcu_torture *rtcp;\n\tstatic unsigned long rtcv_snap = ULONG_MAX;\n\tstatic bool splatted;\n\tstruct task_struct *wtp;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tpipesummary[i] += READ_ONCE(per_cpu(rcu_torture_count, cpu)[i]);\n\t\t\tbatchsummary[i] += READ_ONCE(per_cpu(rcu_torture_batch, cpu)[i]);\n\t\t}\n\t}\n\tfor (i = RCU_TORTURE_PIPE_LEN - 1; i >= 0; i--) {\n\t\tif (pipesummary[i] != 0)\n\t\t\tbreak;\n\t}\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\trtcp = rcu_access_pointer(rcu_torture_current);\n\tpr_cont(\"rtc: %p %s: %lu tfle: %d rta: %d rtaf: %d rtf: %d \",\n\t\trtcp,\n\t\trtcp && !rcu_stall_is_suppressed_at_boot() ? \"ver\" : \"VER\",\n\t\trcu_torture_current_version,\n\t\tlist_empty(&rcu_torture_freelist),\n\t\tatomic_read(&n_rcu_torture_alloc),\n\t\tatomic_read(&n_rcu_torture_alloc_fail),\n\t\tatomic_read(&n_rcu_torture_free));\n\tpr_cont(\"rtmbe: %d rtmbkf: %d/%d rtbe: %ld rtbke: %ld rtbre: %ld \",\n\t\tatomic_read(&n_rcu_torture_mberror),\n\t\tatomic_read(&n_rcu_torture_mbchk_fail), atomic_read(&n_rcu_torture_mbchk_tries),\n\t\tn_rcu_torture_barrier_error,\n\t\tn_rcu_torture_boost_ktrerror,\n\t\tn_rcu_torture_boost_rterror);\n\tpr_cont(\"rtbf: %ld rtb: %ld nt: %ld \",\n\t\tn_rcu_torture_boost_failure,\n\t\tn_rcu_torture_boosts,\n\t\tatomic_long_read(&n_rcu_torture_timers));\n\ttorture_onoff_stats();\n\tpr_cont(\"barrier: %ld/%ld:%ld \",\n\t\tdata_race(n_barrier_successes),\n\t\tdata_race(n_barrier_attempts),\n\t\tdata_race(n_rcu_torture_barrier_error));\n\tpr_cont(\"read-exits: %ld \", data_race(n_read_exits)); // Statistic.\n\tpr_cont(\"nocb-toggles: %ld:%ld\\n\",\n\t\tatomic_long_read(&n_nocb_offload), atomic_long_read(&n_nocb_deoffload));\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tif (atomic_read(&n_rcu_torture_mberror) ||\n\t    atomic_read(&n_rcu_torture_mbchk_fail) ||\n\t    n_rcu_torture_barrier_error || n_rcu_torture_boost_ktrerror ||\n\t    n_rcu_torture_boost_rterror || n_rcu_torture_boost_failure ||\n\t    i > 1) {\n\t\tpr_cont(\"%s\", \"!!! \");\n\t\tatomic_inc(&n_rcu_torture_error);\n\t\tWARN_ON_ONCE(atomic_read(&n_rcu_torture_mberror));\n\t\tWARN_ON_ONCE(atomic_read(&n_rcu_torture_mbchk_fail));\n\t\tWARN_ON_ONCE(n_rcu_torture_barrier_error);  // rcu_barrier()\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_ktrerror); // no boost kthread\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_rterror); // can't set RT prio\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_failure); // boost failed (TIMER_SOFTIRQ RT prio?)\n\t\tWARN_ON_ONCE(i > 1); // Too-short grace period\n\t}\n\tpr_cont(\"Reader Pipe: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", pipesummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Reader Batch: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", batchsummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Free-Block Circulation: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\tpr_cont(\" %d\", atomic_read(&rcu_torture_wcount[i]));\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (cur_ops->stats)\n\t\tcur_ops->stats();\n\tif (rtcv_snap == rcu_torture_current_version &&\n\t    rcu_access_pointer(rcu_torture_current) &&\n\t    !rcu_stall_is_suppressed()) {\n\t\tint __maybe_unused flags = 0;\n\t\tunsigned long __maybe_unused gp_seq = 0;\n\n\t\trcutorture_get_gp_data(cur_ops->ttype,\n\t\t\t\t       &flags, &gp_seq);\n\t\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp,\n\t\t\t\t\t&flags, &gp_seq);\n\t\twtp = READ_ONCE(writer_task);\n\t\tpr_alert(\"??? Writer stall state %s(%d) g%lu f%#x ->state %#x cpu %d\\n\",\n\t\t\t rcu_torture_writer_state_getname(),\n\t\t\t rcu_torture_writer_state, gp_seq, flags,\n\t\t\t wtp == NULL ? ~0U : wtp->__state,\n\t\t\t wtp == NULL ? -1 : (int)task_cpu(wtp));\n\t\tif (!splatted && wtp) {\n\t\t\tsched_show_task(wtp);\n\t\t\tsplatted = true;\n\t\t}\n\t\tif (cur_ops->gp_kthread_dbg)\n\t\t\tcur_ops->gp_kthread_dbg();\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\trtcv_snap = rcu_torture_current_version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_mem_dump_obj",
          "args": [],
          "line": 2969
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_mem_dump_obj",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1938-1975",
          "snippet": "static void rcu_torture_mem_dump_obj(void)\n{\n\tstruct rcu_head *rhp;\n\tstruct kmem_cache *kcp;\n\tstatic int z;\n\n\tkcp = kmem_cache_create(\"rcuscale\", 136, 8, SLAB_STORE_USER, NULL);\n\trhp = kmem_cache_alloc(kcp, GFP_KERNEL);\n\tpr_alert(\"mem_dump_obj() slab test: rcu_torture_stats = %px, &rhp = %px, rhp = %px, &z = %px\\n\", stats_task, &rhp, rhp, &z);\n\tpr_alert(\"mem_dump_obj(ZERO_SIZE_PTR):\");\n\tmem_dump_obj(ZERO_SIZE_PTR);\n\tpr_alert(\"mem_dump_obj(NULL):\");\n\tmem_dump_obj(NULL);\n\tpr_alert(\"mem_dump_obj(%px):\", &rhp);\n\tmem_dump_obj(&rhp);\n\tpr_alert(\"mem_dump_obj(%px):\", rhp);\n\tmem_dump_obj(rhp);\n\tpr_alert(\"mem_dump_obj(%px):\", &rhp->func);\n\tmem_dump_obj(&rhp->func);\n\tpr_alert(\"mem_dump_obj(%px):\", &z);\n\tmem_dump_obj(&z);\n\tkmem_cache_free(kcp, rhp);\n\tkmem_cache_destroy(kcp);\n\trhp = kmalloc(sizeof(*rhp), GFP_KERNEL);\n\tpr_alert(\"mem_dump_obj() kmalloc test: rcu_torture_stats = %px, &rhp = %px, rhp = %px\\n\", stats_task, &rhp, rhp);\n\tpr_alert(\"mem_dump_obj(kmalloc %px):\", rhp);\n\tmem_dump_obj(rhp);\n\tpr_alert(\"mem_dump_obj(kmalloc %px):\", &rhp->func);\n\tmem_dump_obj(&rhp->func);\n\tkfree(rhp);\n\trhp = vmalloc(4096);\n\tpr_alert(\"mem_dump_obj() vmalloc test: rcu_torture_stats = %px, &rhp = %px, rhp = %px\\n\", stats_task, &rhp, rhp);\n\tpr_alert(\"mem_dump_obj(vmalloc %px):\", rhp);\n\tmem_dump_obj(rhp);\n\tpr_alert(\"mem_dump_obj(vmalloc %px):\", &rhp->func);\n\tmem_dump_obj(&rhp->func);\n\tvfree(rhp);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *stats_task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *stats_task;\n\nstatic void rcu_torture_mem_dump_obj(void)\n{\n\tstruct rcu_head *rhp;\n\tstruct kmem_cache *kcp;\n\tstatic int z;\n\n\tkcp = kmem_cache_create(\"rcuscale\", 136, 8, SLAB_STORE_USER, NULL);\n\trhp = kmem_cache_alloc(kcp, GFP_KERNEL);\n\tpr_alert(\"mem_dump_obj() slab test: rcu_torture_stats = %px, &rhp = %px, rhp = %px, &z = %px\\n\", stats_task, &rhp, rhp, &z);\n\tpr_alert(\"mem_dump_obj(ZERO_SIZE_PTR):\");\n\tmem_dump_obj(ZERO_SIZE_PTR);\n\tpr_alert(\"mem_dump_obj(NULL):\");\n\tmem_dump_obj(NULL);\n\tpr_alert(\"mem_dump_obj(%px):\", &rhp);\n\tmem_dump_obj(&rhp);\n\tpr_alert(\"mem_dump_obj(%px):\", rhp);\n\tmem_dump_obj(rhp);\n\tpr_alert(\"mem_dump_obj(%px):\", &rhp->func);\n\tmem_dump_obj(&rhp->func);\n\tpr_alert(\"mem_dump_obj(%px):\", &z);\n\tmem_dump_obj(&z);\n\tkmem_cache_free(kcp, rhp);\n\tkmem_cache_destroy(kcp);\n\trhp = kmalloc(sizeof(*rhp), GFP_KERNEL);\n\tpr_alert(\"mem_dump_obj() kmalloc test: rcu_torture_stats = %px, &rhp = %px, rhp = %px\\n\", stats_task, &rhp, rhp);\n\tpr_alert(\"mem_dump_obj(kmalloc %px):\", rhp);\n\tmem_dump_obj(rhp);\n\tpr_alert(\"mem_dump_obj(kmalloc %px):\", &rhp->func);\n\tmem_dump_obj(&rhp->func);\n\tkfree(rhp);\n\trhp = vmalloc(4096);\n\tpr_alert(\"mem_dump_obj() vmalloc test: rcu_torture_stats = %px, &rhp = %px, rhp = %px\\n\", stats_task, &rhp, rhp);\n\tpr_alert(\"mem_dump_obj(vmalloc %px):\", rhp);\n\tmem_dump_obj(rhp);\n\tpr_alert(\"mem_dump_obj(vmalloc %px):\", &rhp->func);\n\tmem_dump_obj(&rhp->func);\n\tvfree(rhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->cleanup",
          "args": [],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_remove_state",
          "args": [
            "rcutor_hp"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_can_boost",
          "args": [],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_can_boost",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2778-2802",
          "snippet": "static bool rcu_torture_can_boost(void)\n{\n\tstatic int boost_warn_once;\n\tint prio;\n\n\tif (!(test_boost == 1 && cur_ops->can_boost) && test_boost != 2)\n\t\treturn false;\n\tif (!cur_ops->start_gp_poll || !cur_ops->poll_gp_state)\n\t\treturn false;\n\n\tprio = rcu_get_gp_kthreads_prio();\n\tif (!prio)\n\t\treturn false;\n\n\tif (prio < 2) {\n\t\tif (boost_warn_once == 1)\n\t\t\treturn false;\n\n\t\tpr_alert(\"%s: WARN: RCU kthread priority too low to test boosting.  Skipping RCU boost test. Try passing rcutree.kthread_prio > 1 on the kernel command line.\\n\", KBUILD_MODNAME);\n\t\tboost_warn_once = 1;\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic bool rcu_torture_can_boost(void)\n{\n\tstatic int boost_warn_once;\n\tint prio;\n\n\tif (!(test_boost == 1 && cur_ops->can_boost) && test_boost != 2)\n\t\treturn false;\n\tif (!cur_ops->start_gp_poll || !cur_ops->poll_gp_state)\n\t\treturn false;\n\n\tprio = rcu_get_gp_kthreads_prio();\n\tif (!prio)\n\t\treturn false;\n\n\tif (prio < 2) {\n\t\tif (boost_warn_once == 1)\n\t\t\treturn false;\n\n\t\tpr_alert(\"%s: WARN: RCU kthread priority too low to test boosting.  Skipping RCU boost test. Try passing rcutree.kthread_prio > 1 on the kernel command line.\\n\", KBUILD_MODNAME);\n\t\tboost_warn_once = 1;\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "rcu_torture_fqs",
            "fqs_task"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "948-955",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s:  End-test grace-period state: g%ld f%#x total-gps=%ld\\n\"",
            "cur_ops->name",
            "(long)gp_seq",
            "flags",
            "rcutorture_seq_diff(gp_seq, start_gp_seq)"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutorture_seq_diff",
          "args": [
            "gp_seq",
            "start_gp_seq"
          ],
          "line": 2954
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_seq_diff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "894-899",
          "snippet": "static unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcutorture_get_gp_data",
          "args": [
            "cur_ops->ttype",
            "srcu_ctlp",
            "&flags",
            "&gp_seq"
          ],
          "line": 2951
        },
        "resolved": true,
        "details": {
          "function_name": "srcutorture_get_gp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1329-1337",
          "snippet": "void srcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t     struct srcu_struct *ssp, int *flags,\n\t\t\t     unsigned long *gp_seq)\n{\n\tif (test_type != SRCU_FLAVOR)\n\t\treturn;\n\t*flags = 0;\n\t*gp_seq = rcu_seq_current(&ssp->srcu_gp_seq);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid srcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t     struct srcu_struct *ssp, int *flags,\n\t\t\t     unsigned long *gp_seq)\n{\n\tif (test_type != SRCU_FLAVOR)\n\t\treturn;\n\t*flags = 0;\n\t*gp_seq = rcu_seq_current(&ssp->srcu_gp_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcutorture_get_gp_data",
          "args": [
            "cur_ops->ttype",
            "&flags",
            "&gp_seq"
          ],
          "line": 2950
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_get_gp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "472-477",
          "snippet": "static inline void rcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t\t\t  int *flags, unsigned long *gp_seq)\n{\n\t*flags = 0;\n\t*gp_seq = 0;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t\t\t  int *flags, unsigned long *gp_seq)\n{\n\t*flags = 0;\n\t*gp_seq = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fakewriter_tasks"
          ],
          "line": 2946
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "736-747",
          "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t shutdown_wq;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_ended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_fwd_prog_cleanup",
          "args": [],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_fwd_prog_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2602-2619",
          "snippet": "static void rcu_torture_fwd_prog_cleanup(void)\n{\n\tint i;\n\tstruct rcu_fwd *rfp;\n\n\tif (!rcu_fwds || !fwd_prog_tasks)\n\t\treturn;\n\tfor (i = 0; i < fwd_progress; i++)\n\t\ttorture_stop_kthread(rcu_torture_fwd_prog, fwd_prog_tasks[i]);\n\tunregister_oom_notifier(&rcutorture_oom_nb);\n\tmutex_lock(&rcu_fwd_mutex);\n\trfp = rcu_fwds;\n\trcu_fwds = NULL;\n\tmutex_unlock(&rcu_fwd_mutex);\n\tkfree(rfp);\n\tkfree(fwd_prog_tasks);\n\tfwd_prog_tasks = NULL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct **fwd_prog_tasks;",
            "static DEFINE_MUTEX(rcu_fwd_mutex);",
            "static struct rcu_fwd *rcu_fwds;",
            "static struct notifier_block rcutorture_oom_nb = {\n\t.notifier_call = rcutorture_oom_notify\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct **fwd_prog_tasks;\nstatic DEFINE_MUTEX(rcu_fwd_mutex);\nstatic struct rcu_fwd *rcu_fwds;\nstatic struct notifier_block rcutorture_oom_nb = {\n\t.notifier_call = rcutorture_oom_notify\n};\n\nstatic void rcu_torture_fwd_prog_cleanup(void)\n{\n\tint i;\n\tstruct rcu_fwd *rfp;\n\n\tif (!rcu_fwds || !fwd_prog_tasks)\n\t\treturn;\n\tfor (i = 0; i < fwd_progress; i++)\n\t\ttorture_stop_kthread(rcu_torture_fwd_prog, fwd_prog_tasks[i]);\n\tunregister_oom_notifier(&rcutorture_oom_nb);\n\tmutex_lock(&rcu_fwd_mutex);\n\trfp = rcu_fwds;\n\trcu_fwds = NULL;\n\tmutex_unlock(&rcu_fwd_mutex);\n\tkfree(rfp);\n\tkfree(fwd_prog_tasks);\n\tfwd_prog_tasks = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_barrier_cleanup",
          "args": [],
          "line": 2920
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_barrier_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2760-2776",
          "snippet": "static void rcu_torture_barrier_cleanup(void)\n{\n\tint i;\n\n\ttorture_stop_kthread(rcu_torture_barrier, barrier_task);\n\tif (barrier_cbs_tasks != NULL) {\n\t\tfor (i = 0; i < n_barrier_cbs; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tkfree(barrier_cbs_tasks);\n\t\tbarrier_cbs_tasks = NULL;\n\t}\n\tif (barrier_cbs_wq != NULL) {\n\t\tkfree(barrier_cbs_wq);\n\t\tbarrier_cbs_wq = NULL;\n\t}\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct **barrier_cbs_tasks;",
            "static struct task_struct *barrier_task;",
            "static wait_queue_head_t *barrier_cbs_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct **barrier_cbs_tasks;\nstatic struct task_struct *barrier_task;\nstatic wait_queue_head_t *barrier_cbs_wq;\n\nstatic void rcu_torture_barrier_cleanup(void)\n{\n\tint i;\n\n\ttorture_stop_kthread(rcu_torture_barrier, barrier_task);\n\tif (barrier_cbs_tasks != NULL) {\n\t\tfor (i = 0; i < n_barrier_cbs; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tkfree(barrier_cbs_tasks);\n\t\tbarrier_cbs_tasks = NULL;\n\t}\n\tif (barrier_cbs_wq != NULL) {\n\t\tkfree(barrier_cbs_wq);\n\t\tbarrier_cbs_wq = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_read_exit_cleanup",
          "args": [],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_read_exit_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2887-2895",
          "snippet": "static void rcu_torture_read_exit_cleanup(void)\n{\n\tif (!read_exit_task)\n\t\treturn;\n\tWRITE_ONCE(read_exit_child_stop, true);\n\tsmp_mb(); // Above write before wait.\n\twait_event(read_exit_wq, smp_load_acquire(&read_exit_child_stopped));\n\ttorture_stop_kthread(rcutorture_read_exit, read_exit_task);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *read_exit_task;",
            "static bool read_exit_child_stop;",
            "static bool read_exit_child_stopped;",
            "static wait_queue_head_t read_exit_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *read_exit_task;\nstatic bool read_exit_child_stop;\nstatic bool read_exit_child_stopped;\nstatic wait_queue_head_t read_exit_wq;\n\nstatic void rcu_torture_read_exit_cleanup(void)\n{\n\tif (!read_exit_task)\n\t\treturn;\n\tWRITE_ONCE(read_exit_child_stop, true);\n\tsmp_mb(); // Above write before wait.\n\twait_event(read_exit_wq, smp_load_acquire(&read_exit_child_stopped));\n\ttorture_stop_kthread(rcutorture_read_exit, read_exit_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->gp_kthread_dbg",
          "args": [],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_cleanup_begin",
          "args": [],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "857-873",
          "snippet": "bool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */",
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int nrealnocbers;\nstatic int nrealreaders;\nstatic struct task_struct *writer_task;\nstatic struct task_struct **fakewriter_tasks;\nstatic struct task_struct **reader_tasks;\nstatic struct task_struct **nocb_tasks;\nstatic struct task_struct *stats_task;\nstatic struct task_struct *fqs_task;\nstatic struct task_struct *stall_task;\nstatic struct rcu_torture_reader_check *rcu_torture_reader_mbchk;\nstatic atomic_t n_rcu_torture_error;\nstatic long n_rcu_torture_barrier_error;\nstatic unsigned long start_gp_seq;\nstatic int err_segs_recorded;\nstatic struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];\nstatic int rt_read_nsegs;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\nstatic enum cpuhp_state rcutor_hp;\n\nstatic void\nrcu_torture_cleanup(void)\n{\n\tint firsttime;\n\tint flags = 0;\n\tunsigned long gp_seq = 0;\n\tint i;\n\n\tif (torture_cleanup_begin()) {\n\t\tif (cur_ops->cb_barrier != NULL)\n\t\t\tcur_ops->cb_barrier();\n\t\treturn;\n\t}\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (cur_ops->gp_kthread_dbg)\n\t\tcur_ops->gp_kthread_dbg();\n\trcu_torture_read_exit_cleanup();\n\trcu_torture_barrier_cleanup();\n\trcu_torture_fwd_prog_cleanup();\n\ttorture_stop_kthread(rcu_torture_stall, stall_task);\n\ttorture_stop_kthread(rcu_torture_writer, writer_task);\n\n\tif (nocb_tasks) {\n\t\tfor (i = 0; i < nrealnocbers; i++)\n\t\t\ttorture_stop_kthread(rcu_nocb_toggle, nocb_tasks[i]);\n\t\tkfree(nocb_tasks);\n\t\tnocb_tasks = NULL;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t\treader_tasks = NULL;\n\t}\n\tkfree(rcu_torture_reader_mbchk);\n\trcu_torture_reader_mbchk = NULL;\n\n\tif (fakewriter_tasks) {\n\t\tfor (i = 0; i < nfakewriters; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t     fakewriter_tasks[i]);\n\t\tkfree(fakewriter_tasks);\n\t\tfakewriter_tasks = NULL;\n\t}\n\n\trcutorture_get_gp_data(cur_ops->ttype, &flags, &gp_seq);\n\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp, &flags, &gp_seq);\n\tpr_alert(\"%s:  End-test grace-period state: g%ld f%#x total-gps=%ld\\n\",\n\t\t cur_ops->name, (long)gp_seq, flags,\n\t\t rcutorture_seq_diff(gp_seq, start_gp_seq));\n\ttorture_stop_kthread(rcu_torture_stats, stats_task);\n\ttorture_stop_kthread(rcu_torture_fqs, fqs_task);\n\tif (rcu_torture_can_boost() && rcutor_hp >= 0)\n\t\tcpuhp_remove_state(rcutor_hp);\n\n\t/*\n\t * Wait for all RCU callbacks to fire, then do torture-type-specific\n\t * cleanup operations.\n\t */\n\tif (cur_ops->cb_barrier != NULL)\n\t\tcur_ops->cb_barrier();\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\trcu_torture_mem_dump_obj();\n\n\trcu_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (err_segs_recorded) {\n\t\tpr_alert(\"Failure/close-call rcutorture reader segments:\\n\");\n\t\tif (rt_read_nsegs == 0)\n\t\t\tpr_alert(\"\\t: No segments recorded!!!\\n\");\n\t\tfirsttime = 1;\n\t\tfor (i = 0; i < rt_read_nsegs; i++) {\n\t\t\tpr_alert(\"\\t%d: %#x \", i, err_segs[i].rt_readstate);\n\t\t\tif (err_segs[i].rt_delay_jiffies != 0) {\n\t\t\t\tpr_cont(\"%s%ldjiffies\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_jiffies);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_ms != 0) {\n\t\t\t\tpr_cont(\"%s%ldms\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_ms);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_us != 0) {\n\t\t\t\tpr_cont(\"%s%ldus\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_us);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tpr_cont(\"%s\\n\",\n\t\t\t\terr_segs[i].rt_preempted ? \"preempted\" : \"\");\n\n\t\t}\n\t}\n\tif (atomic_read(&n_rcu_torture_error) || n_rcu_torture_barrier_error)\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\trcu_torture_print_module_parms(cur_ops,\n\t\t\t\t\t       \"End of test: RCU_HOTPLUG\");\n\telse\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: SUCCESS\");\n\ttorture_cleanup_end();\n}"
  },
  {
    "function_name": "rcu_torture_read_exit_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2887-2895",
    "snippet": "static void rcu_torture_read_exit_cleanup(void)\n{\n\tif (!read_exit_task)\n\t\treturn;\n\tWRITE_ONCE(read_exit_child_stop, true);\n\tsmp_mb(); // Above write before wait.\n\twait_event(read_exit_wq, smp_load_acquire(&read_exit_child_stopped));\n\ttorture_stop_kthread(rcutorture_read_exit, read_exit_task);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *read_exit_task;",
      "static bool read_exit_child_stop;",
      "static bool read_exit_child_stopped;",
      "static wait_queue_head_t read_exit_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "rcutorture_read_exit",
            "read_exit_task"
          ],
          "line": 2894
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "948-955",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "read_exit_wq",
            "smp_load_acquire(&read_exit_child_stopped)"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&read_exit_child_stopped"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "read_exit_child_stop",
            "true"
          ],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *read_exit_task;\nstatic bool read_exit_child_stop;\nstatic bool read_exit_child_stopped;\nstatic wait_queue_head_t read_exit_wq;\n\nstatic void rcu_torture_read_exit_cleanup(void)\n{\n\tif (!read_exit_task)\n\t\treturn;\n\tWRITE_ONCE(read_exit_child_stop, true);\n\tsmp_mb(); // Above write before wait.\n\twait_event(read_exit_wq, smp_load_acquire(&read_exit_child_stopped));\n\ttorture_stop_kthread(rcutorture_read_exit, read_exit_task);\n}"
  },
  {
    "function_name": "rcu_torture_read_exit_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2876-2885",
    "snippet": "static int rcu_torture_read_exit_init(void)\n{\n\tif (read_exit_burst <= 0)\n\t\treturn 0;\n\tinit_waitqueue_head(&read_exit_wq);\n\tread_exit_child_stop = false;\n\tread_exit_child_stopped = false;\n\treturn torture_create_kthread(rcu_torture_read_exit, NULL,\n\t\t\t\t      read_exit_task);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *read_exit_task;",
      "static bool read_exit_child_stop;",
      "static bool read_exit_child_stopped;",
      "static wait_queue_head_t read_exit_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_read_exit",
            "NULL",
            "read_exit_task"
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&read_exit_wq"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *read_exit_task;\nstatic bool read_exit_child_stop;\nstatic bool read_exit_child_stopped;\nstatic wait_queue_head_t read_exit_wq;\n\nstatic int rcu_torture_read_exit_init(void)\n{\n\tif (read_exit_burst <= 0)\n\t\treturn 0;\n\tinit_waitqueue_head(&read_exit_wq);\n\tread_exit_child_stop = false;\n\tread_exit_child_stopped = false;\n\treturn torture_create_kthread(rcu_torture_read_exit, NULL,\n\t\t\t\t      read_exit_task);\n}"
  },
  {
    "function_name": "rcu_torture_read_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2822-2874",
    "snippet": "static int rcu_torture_read_exit(void *unused)\n{\n\tint count = 0;\n\tbool errexit = false;\n\tint i;\n\tstruct task_struct *tsp;\n\tDEFINE_TORTURE_RANDOM(trs);\n\n\t// Allocate and initialize.\n\tset_user_nice(current, MAX_NICE);\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_read_exit: Start of test\");\n\n\t// Each pass through this loop does one read-exit episode.\n\tdo {\n\t\tif (++count > read_exit_burst) {\n\t\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_read_exit: End of episode\");\n\t\t\trcu_barrier(); // Wait for task_struct free, avoid OOM.\n\t\t\tfor (i = 0; i < read_exit_delay; i++) {\n\t\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\t\tif (READ_ONCE(read_exit_child_stop))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!READ_ONCE(read_exit_child_stop))\n\t\t\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_read_exit: Start of episode\");\n\t\t\tcount = 0;\n\t\t}\n\t\tif (READ_ONCE(read_exit_child_stop))\n\t\t\tbreak;\n\t\t// Spawn child.\n\t\ttsp = kthread_run(rcu_torture_read_exit_child,\n\t\t\t\t     &trs, \"%s\",\n\t\t\t\t     \"rcu_torture_read_exit_child\");\n\t\tif (IS_ERR(tsp)) {\n\t\t\tTOROUT_ERRSTRING(\"out of memory\");\n\t\t\terrexit = true;\n\t\t\ttsp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tcond_resched();\n\t\tkthread_stop(tsp);\n\t\tn_read_exits ++;\n\t\tstutter_wait(\"rcu_torture_read_exit\");\n\t} while (!errexit && !READ_ONCE(read_exit_child_stop));\n\n\t// Clean up and exit.\n\tsmp_store_release(&read_exit_child_stopped, true); // After reaping.\n\tsmp_mb(); // Store before wakeup.\n\twake_up(&read_exit_wq);\n\twhile (!torture_must_stop())\n\t\tschedule_timeout_uninterruptible(1);\n\ttorture_kthread_stopping(\"rcu_torture_read_exit\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long n_read_exits;",
      "static bool read_exit_child_stop;",
      "static bool read_exit_child_stopped;",
      "static wait_queue_head_t read_exit_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_read_exit\""
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 2870
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&read_exit_wq"
          ],
          "line": 2869
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&read_exit_child_stopped",
            "true"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "read_exit_child_stop"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_torture_read_exit\""
          ],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "722-749",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "tsp"
          ],
          "line": 2861
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2860
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TOROUT_ERRSTRING",
          "args": [
            "\"out of memory\""
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tsp"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "rcu_torture_read_exit_child",
            "&trs",
            "\"%s\"",
            "\"rcu_torture_read_exit_child\""
          ],
          "line": 2851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "read_exit_child_stop"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_read_exit: Start of episode\""
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "read_exit_child_stop"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "read_exit_child_stop"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 2838
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1569-1572",
          "snippet": "void rcu_barrier_tasks_trace(void)\n{\n\trcu_barrier_tasks_generic(&rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid rcu_barrier_tasks_trace(void)\n{\n\trcu_barrier_tasks_generic(&rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_read_exit: End of episode\""
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_read_exit: Start of test\""
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_TORTURE_RANDOM",
          "args": [
            "trs"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long n_read_exits;\nstatic bool read_exit_child_stop;\nstatic bool read_exit_child_stopped;\nstatic wait_queue_head_t read_exit_wq;\n\nstatic int rcu_torture_read_exit(void *unused)\n{\n\tint count = 0;\n\tbool errexit = false;\n\tint i;\n\tstruct task_struct *tsp;\n\tDEFINE_TORTURE_RANDOM(trs);\n\n\t// Allocate and initialize.\n\tset_user_nice(current, MAX_NICE);\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_read_exit: Start of test\");\n\n\t// Each pass through this loop does one read-exit episode.\n\tdo {\n\t\tif (++count > read_exit_burst) {\n\t\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_read_exit: End of episode\");\n\t\t\trcu_barrier(); // Wait for task_struct free, avoid OOM.\n\t\t\tfor (i = 0; i < read_exit_delay; i++) {\n\t\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\t\tif (READ_ONCE(read_exit_child_stop))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!READ_ONCE(read_exit_child_stop))\n\t\t\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_read_exit: Start of episode\");\n\t\t\tcount = 0;\n\t\t}\n\t\tif (READ_ONCE(read_exit_child_stop))\n\t\t\tbreak;\n\t\t// Spawn child.\n\t\ttsp = kthread_run(rcu_torture_read_exit_child,\n\t\t\t\t     &trs, \"%s\",\n\t\t\t\t     \"rcu_torture_read_exit_child\");\n\t\tif (IS_ERR(tsp)) {\n\t\t\tTOROUT_ERRSTRING(\"out of memory\");\n\t\t\terrexit = true;\n\t\t\ttsp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tcond_resched();\n\t\tkthread_stop(tsp);\n\t\tn_read_exits ++;\n\t\tstutter_wait(\"rcu_torture_read_exit\");\n\t} while (!errexit && !READ_ONCE(read_exit_child_stop));\n\n\t// Clean up and exit.\n\tsmp_store_release(&read_exit_child_stopped, true); // After reaping.\n\tsmp_mb(); // Store before wakeup.\n\twake_up(&read_exit_wq);\n\twhile (!torture_must_stop())\n\t\tschedule_timeout_uninterruptible(1);\n\ttorture_kthread_stopping(\"rcu_torture_read_exit\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_read_exit_child",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2809-2819",
    "snippet": "static int rcu_torture_read_exit_child(void *trsp_in)\n{\n\tstruct torture_random_state *trsp = trsp_in;\n\n\tset_user_nice(current, MAX_NICE);\n\t// Minimize time between reading and exiting.\n\twhile (!kthread_should_stop())\n\t\tschedule_timeout_uninterruptible(1);\n\t(void)rcu_torture_one_read(trsp, -1);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_torture_one_read",
          "args": [
            "trsp",
            "-1"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_one_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1607-1682",
          "snippet": "static bool rcu_torture_one_read(struct torture_random_state *trsp, long myid)\n{\n\tunsigned long cookie;\n\tint i;\n\tunsigned long started;\n\tunsigned long completed;\n\tint newstate;\n\tstruct rcu_torture *p;\n\tint pipe_count;\n\tint readstate = 0;\n\tstruct rt_read_seg rtseg[RCUTORTURE_RDR_MAX_SEGS] = { { 0 } };\n\tstruct rt_read_seg *rtrsp = &rtseg[0];\n\tstruct rt_read_seg *rtrsp1;\n\tunsigned long long ts;\n\n\tWARN_ON_ONCE(!rcu_is_watching());\n\tnewstate = rcutorture_extend_mask(readstate, trsp);\n\trcutorture_one_extend(&readstate, newstate, trsp, rtrsp++);\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tcookie = cur_ops->get_gp_state();\n\tstarted = cur_ops->get_gp_seq();\n\tts = rcu_trace_clock_local();\n\tp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t  !cur_ops->readlock_held || cur_ops->readlock_held());\n\tif (p == NULL) {\n\t\t/* Wait for rcu_torture_writer to get underway */\n\t\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\t\treturn false;\n\t}\n\tif (p->rtort_mbtest == 0)\n\t\tatomic_inc(&n_rcu_torture_mberror);\n\trcu_torture_reader_do_mbchk(myid, p, trsp);\n\trtrsp = rcutorture_loop_extend(&readstate, trsp, rtrsp);\n\tpreempt_disable();\n\tpipe_count = READ_ONCE(p->rtort_pipe_count);\n\tif (pipe_count > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tpipe_count = RCU_TORTURE_PIPE_LEN;\n\t}\n\tcompleted = cur_ops->get_gp_seq();\n\tif (pipe_count > 1) {\n\t\tdo_trace_rcu_torture_read(cur_ops->name, &p->rtort_rcu,\n\t\t\t\t\t  ts, started, completed);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\t__this_cpu_inc(rcu_torture_count[pipe_count]);\n\tcompleted = rcutorture_seq_diff(completed, started);\n\tif (completed > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tcompleted = RCU_TORTURE_PIPE_LEN;\n\t}\n\t__this_cpu_inc(rcu_torture_batch[completed]);\n\tpreempt_enable();\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tWARN_ONCE(cur_ops->poll_gp_state(cookie),\n\t\t\t  \"%s: Cookie check 2 failed %s(%d) %lu->%lu\\n\",\n\t\t\t  __func__,\n\t\t\t  rcu_torture_writer_state_getname(),\n\t\t\t  rcu_torture_writer_state,\n\t\t\t  cookie, cur_ops->get_gp_state());\n\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\tWARN_ON_ONCE(readstate);\n\t// This next splat is expected behavior if leakpointer, especially\n\t// for CONFIG_RCU_STRICT_GRACE_PERIOD=y kernels.\n\tWARN_ON_ONCE(leakpointer && READ_ONCE(p->rtort_pipe_count) > 1);\n\n\t/* If error or close call, record the sequence of reader protections. */\n\tif ((pipe_count > 1 || completed > 1) && !xchg(&err_segs_recorded, 1)) {\n\t\ti = 0;\n\t\tfor (rtrsp1 = &rtseg[0]; rtrsp1 < rtrsp; rtrsp1++)\n\t\t\terr_segs[i++] = *rtrsp1;\n\t\trt_read_nsegs = i;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_TORTURE_PIPE_LEN 10",
            "#define RCUTORTURE_RDR_MAX_SEGS (RCUTORTURE_RDR_MAX_LOOPS + 3)"
          ],
          "globals_used": [
            "static struct rcu_torture __rcu *rcu_torture_current;",
            "static atomic_t n_rcu_torture_mberror;",
            "static int rcu_torture_writer_state;",
            "static int err_segs_recorded;",
            "static struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];",
            "static int rt_read_nsegs;",
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n#define RCUTORTURE_RDR_MAX_SEGS (RCUTORTURE_RDR_MAX_LOOPS + 3)\n\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic atomic_t n_rcu_torture_mberror;\nstatic int rcu_torture_writer_state;\nstatic int err_segs_recorded;\nstatic struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];\nstatic int rt_read_nsegs;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic bool rcu_torture_one_read(struct torture_random_state *trsp, long myid)\n{\n\tunsigned long cookie;\n\tint i;\n\tunsigned long started;\n\tunsigned long completed;\n\tint newstate;\n\tstruct rcu_torture *p;\n\tint pipe_count;\n\tint readstate = 0;\n\tstruct rt_read_seg rtseg[RCUTORTURE_RDR_MAX_SEGS] = { { 0 } };\n\tstruct rt_read_seg *rtrsp = &rtseg[0];\n\tstruct rt_read_seg *rtrsp1;\n\tunsigned long long ts;\n\n\tWARN_ON_ONCE(!rcu_is_watching());\n\tnewstate = rcutorture_extend_mask(readstate, trsp);\n\trcutorture_one_extend(&readstate, newstate, trsp, rtrsp++);\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tcookie = cur_ops->get_gp_state();\n\tstarted = cur_ops->get_gp_seq();\n\tts = rcu_trace_clock_local();\n\tp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t  !cur_ops->readlock_held || cur_ops->readlock_held());\n\tif (p == NULL) {\n\t\t/* Wait for rcu_torture_writer to get underway */\n\t\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\t\treturn false;\n\t}\n\tif (p->rtort_mbtest == 0)\n\t\tatomic_inc(&n_rcu_torture_mberror);\n\trcu_torture_reader_do_mbchk(myid, p, trsp);\n\trtrsp = rcutorture_loop_extend(&readstate, trsp, rtrsp);\n\tpreempt_disable();\n\tpipe_count = READ_ONCE(p->rtort_pipe_count);\n\tif (pipe_count > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tpipe_count = RCU_TORTURE_PIPE_LEN;\n\t}\n\tcompleted = cur_ops->get_gp_seq();\n\tif (pipe_count > 1) {\n\t\tdo_trace_rcu_torture_read(cur_ops->name, &p->rtort_rcu,\n\t\t\t\t\t  ts, started, completed);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\t__this_cpu_inc(rcu_torture_count[pipe_count]);\n\tcompleted = rcutorture_seq_diff(completed, started);\n\tif (completed > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tcompleted = RCU_TORTURE_PIPE_LEN;\n\t}\n\t__this_cpu_inc(rcu_torture_batch[completed]);\n\tpreempt_enable();\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tWARN_ONCE(cur_ops->poll_gp_state(cookie),\n\t\t\t  \"%s: Cookie check 2 failed %s(%d) %lu->%lu\\n\",\n\t\t\t  __func__,\n\t\t\t  rcu_torture_writer_state_getname(),\n\t\t\t  rcu_torture_writer_state,\n\t\t\t  cookie, cur_ops->get_gp_state());\n\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\tWARN_ON_ONCE(readstate);\n\t// This next splat is expected behavior if leakpointer, especially\n\t// for CONFIG_RCU_STRICT_GRACE_PERIOD=y kernels.\n\tWARN_ON_ONCE(leakpointer && READ_ONCE(p->rtort_pipe_count) > 1);\n\n\t/* If error or close call, record the sequence of reader protections. */\n\tif ((pipe_count > 1 || completed > 1) && !xchg(&err_segs_recorded, 1)) {\n\t\ti = 0;\n\t\tfor (rtrsp1 = &rtseg[0]; rtrsp1 < rtrsp; rtrsp1++)\n\t\t\terr_segs[i++] = *rtrsp1;\n\t\trt_read_nsegs = i;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 2815
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 2813
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_torture_read_exit_child(void *trsp_in)\n{\n\tstruct torture_random_state *trsp = trsp_in;\n\n\tset_user_nice(current, MAX_NICE);\n\t// Minimize time between reading and exiting.\n\twhile (!kthread_should_stop())\n\t\tschedule_timeout_uninterruptible(1);\n\t(void)rcu_torture_one_read(trsp, -1);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_can_boost",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2778-2802",
    "snippet": "static bool rcu_torture_can_boost(void)\n{\n\tstatic int boost_warn_once;\n\tint prio;\n\n\tif (!(test_boost == 1 && cur_ops->can_boost) && test_boost != 2)\n\t\treturn false;\n\tif (!cur_ops->start_gp_poll || !cur_ops->poll_gp_state)\n\t\treturn false;\n\n\tprio = rcu_get_gp_kthreads_prio();\n\tif (!prio)\n\t\treturn false;\n\n\tif (prio < 2) {\n\t\tif (boost_warn_once == 1)\n\t\t\treturn false;\n\n\t\tpr_alert(\"%s: WARN: RCU kthread priority too low to test boosting.  Skipping RCU boost test. Try passing rcutree.kthread_prio > 1 on the kernel command line.\\n\", KBUILD_MODNAME);\n\t\tboost_warn_once = 1;\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: WARN: RCU kthread priority too low to test boosting.  Skipping RCU boost test. Try passing rcutree.kthread_prio > 1 on the kernel command line.\\n\"",
            "KBUILD_MODNAME"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_gp_kthreads_prio",
          "args": [],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_gp_kthreads_prio",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "524-524",
          "snippet": "static inline int rcu_get_gp_kthreads_prio(void) { return 0; }",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline int rcu_get_gp_kthreads_prio(void) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic bool rcu_torture_can_boost(void)\n{\n\tstatic int boost_warn_once;\n\tint prio;\n\n\tif (!(test_boost == 1 && cur_ops->can_boost) && test_boost != 2)\n\t\treturn false;\n\tif (!cur_ops->start_gp_poll || !cur_ops->poll_gp_state)\n\t\treturn false;\n\n\tprio = rcu_get_gp_kthreads_prio();\n\tif (!prio)\n\t\treturn false;\n\n\tif (prio < 2) {\n\t\tif (boost_warn_once == 1)\n\t\t\treturn false;\n\n\t\tpr_alert(\"%s: WARN: RCU kthread priority too low to test boosting.  Skipping RCU boost test. Try passing rcutree.kthread_prio > 1 on the kernel command line.\\n\", KBUILD_MODNAME);\n\t\tboost_warn_once = 1;\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "rcu_torture_barrier_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2760-2776",
    "snippet": "static void rcu_torture_barrier_cleanup(void)\n{\n\tint i;\n\n\ttorture_stop_kthread(rcu_torture_barrier, barrier_task);\n\tif (barrier_cbs_tasks != NULL) {\n\t\tfor (i = 0; i < n_barrier_cbs; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tkfree(barrier_cbs_tasks);\n\t\tbarrier_cbs_tasks = NULL;\n\t}\n\tif (barrier_cbs_wq != NULL) {\n\t\tkfree(barrier_cbs_wq);\n\t\tbarrier_cbs_wq = NULL;\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct **barrier_cbs_tasks;",
      "static struct task_struct *barrier_task;",
      "static wait_queue_head_t *barrier_cbs_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "barrier_cbs_wq"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "736-747",
          "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t shutdown_wq;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_ended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "rcu_torture_barrier_cbs",
            "barrier_cbs_tasks[i]"
          ],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "948-955",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct **barrier_cbs_tasks;\nstatic struct task_struct *barrier_task;\nstatic wait_queue_head_t *barrier_cbs_wq;\n\nstatic void rcu_torture_barrier_cleanup(void)\n{\n\tint i;\n\n\ttorture_stop_kthread(rcu_torture_barrier, barrier_task);\n\tif (barrier_cbs_tasks != NULL) {\n\t\tfor (i = 0; i < n_barrier_cbs; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tkfree(barrier_cbs_tasks);\n\t\tbarrier_cbs_tasks = NULL;\n\t}\n\tif (barrier_cbs_wq != NULL) {\n\t\tkfree(barrier_cbs_wq);\n\t\tbarrier_cbs_wq = NULL;\n\t}\n}"
  },
  {
    "function_name": "rcu_torture_barrier_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2723-2757",
    "snippet": "static int rcu_torture_barrier_init(void)\n{\n\tint i;\n\tint ret;\n\n\tif (n_barrier_cbs <= 0)\n\t\treturn 0;\n\tif (cur_ops->call == NULL || cur_ops->cb_barrier == NULL) {\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" Call or barrier ops missing for %s,\\n\",\n\t\t\t torture_type, cur_ops->name);\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" RCU barrier testing omitted from run.\\n\",\n\t\t\t torture_type);\n\t\treturn 0;\n\t}\n\tatomic_set(&barrier_cbs_count, 0);\n\tatomic_set(&barrier_cbs_invoked, 0);\n\tbarrier_cbs_tasks =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_tasks[0]),\n\t\t\tGFP_KERNEL);\n\tbarrier_cbs_wq =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_wq[0]), GFP_KERNEL);\n\tif (barrier_cbs_tasks == NULL || !barrier_cbs_wq)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < n_barrier_cbs; i++) {\n\t\tinit_waitqueue_head(&barrier_cbs_wq[i]);\n\t\tret = torture_create_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     (void *)(long)i,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn torture_create_kthread(rcu_torture_barrier, NULL, barrier_task);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *torture_type = \"rcu\";",
      "static struct task_struct **barrier_cbs_tasks;",
      "static struct task_struct *barrier_task;",
      "static atomic_t barrier_cbs_count;",
      "static atomic_t barrier_cbs_invoked;",
      "static wait_queue_head_t *barrier_cbs_wq;",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_barrier",
            "NULL",
            "barrier_task"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_barrier_cbs",
            "(void *)(long)i",
            "barrier_cbs_tasks[i]"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&barrier_cbs_wq[i]"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "n_barrier_cbs",
            "sizeof(barrier_cbs_wq[0])",
            "GFP_KERNEL"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "n_barrier_cbs",
            "sizeof(barrier_cbs_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&barrier_cbs_invoked",
            "0"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&barrier_cbs_count",
            "0"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\" TORTURE_FLAG\n\t\t\t \" RCU barrier testing omitted from run.\\n\"",
            "torture_type"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\" TORTURE_FLAG\n\t\t\t \" Call or barrier ops missing for %s,\\n\"",
            "torture_type",
            "cur_ops->name"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type = \"rcu\";\nstatic struct task_struct **barrier_cbs_tasks;\nstatic struct task_struct *barrier_task;\nstatic atomic_t barrier_cbs_count;\nstatic atomic_t barrier_cbs_invoked;\nstatic wait_queue_head_t *barrier_cbs_wq;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcu_torture_barrier_init(void)\n{\n\tint i;\n\tint ret;\n\n\tif (n_barrier_cbs <= 0)\n\t\treturn 0;\n\tif (cur_ops->call == NULL || cur_ops->cb_barrier == NULL) {\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" Call or barrier ops missing for %s,\\n\",\n\t\t\t torture_type, cur_ops->name);\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" RCU barrier testing omitted from run.\\n\",\n\t\t\t torture_type);\n\t\treturn 0;\n\t}\n\tatomic_set(&barrier_cbs_count, 0);\n\tatomic_set(&barrier_cbs_invoked, 0);\n\tbarrier_cbs_tasks =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_tasks[0]),\n\t\t\tGFP_KERNEL);\n\tbarrier_cbs_wq =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_wq[0]), GFP_KERNEL);\n\tif (barrier_cbs_tasks == NULL || !barrier_cbs_wq)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < n_barrier_cbs; i++) {\n\t\tinit_waitqueue_head(&barrier_cbs_wq[i]);\n\t\tret = torture_create_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     (void *)(long)i,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn torture_create_kthread(rcu_torture_barrier, NULL, barrier_task);\n}"
  },
  {
    "function_name": "rcu_torture_barrier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2674-2720",
    "snippet": "static int rcu_torture_barrier(void *arg)\n{\n\tint i;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_barrier task starting\");\n\tdo {\n\t\tatomic_set(&barrier_cbs_invoked, 0);\n\t\tatomic_set(&barrier_cbs_count, n_barrier_cbs);\n\t\t/* Ensure barrier_phase ordered after prior assignments. */\n\t\tsmp_store_release(&barrier_phase, !barrier_phase);\n\t\tfor (i = 0; i < n_barrier_cbs; i++)\n\t\t\twake_up(&barrier_cbs_wq[i]);\n\t\twait_event(barrier_wq,\n\t\t\t   atomic_read(&barrier_cbs_count) == 0 ||\n\t\t\t   torture_must_stop());\n\t\tif (torture_must_stop())\n\t\t\tbreak;\n\t\tn_barrier_attempts++;\n\t\tcur_ops->cb_barrier(); /* Implies smp_mb() for wait_event(). */\n\t\tif (atomic_read(&barrier_cbs_invoked) != n_barrier_cbs) {\n\t\t\tn_rcu_torture_barrier_error++;\n\t\t\tpr_err(\"barrier_cbs_invoked = %d, n_barrier_cbs = %d\\n\",\n\t\t\t       atomic_read(&barrier_cbs_invoked),\n\t\t\t       n_barrier_cbs);\n\t\t\tWARN_ON(1);\n\t\t\t// Wait manually for the remaining callbacks\n\t\t\ti = 0;\n\t\t\tdo {\n\t\t\t\tif (WARN_ON(i++ > HZ))\n\t\t\t\t\ti = INT_MIN;\n\t\t\t\tschedule_timeout_interruptible(1);\n\t\t\t\tcur_ops->cb_barrier();\n\t\t\t} while (atomic_read(&barrier_cbs_invoked) !=\n\t\t\t\t n_barrier_cbs &&\n\t\t\t\t !torture_must_stop());\n\t\t\tsmp_mb(); // Can't trust ordering if broken.\n\t\t\tif (!torture_must_stop())\n\t\t\t\tpr_err(\"Recovered: barrier_cbs_invoked = %d\\n\",\n\t\t\t\t       atomic_read(&barrier_cbs_invoked));\n\t\t} else {\n\t\t\tn_barrier_successes++;\n\t\t}\n\t\tschedule_timeout_interruptible(HZ / 10);\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_torture_barrier\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long n_rcu_torture_barrier_error;",
      "static long n_barrier_attempts;",
      "static long n_barrier_successes;",
      "static atomic_t barrier_cbs_count;",
      "static bool barrier_phase;",
      "static atomic_t barrier_cbs_invoked;",
      "static wait_queue_head_t *barrier_cbs_wq;",
      "static DECLARE_WAIT_QUEUE_HEAD(barrier_wq);",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_barrier\""
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 2717
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "HZ / 10"
          ],
          "line": 2716
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Recovered: barrier_cbs_invoked = %d\\n\"",
            "atomic_read(&barrier_cbs_invoked)"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&barrier_cbs_invoked"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&barrier_cbs_invoked"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "i++ > HZ"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"barrier_cbs_invoked = %d, n_barrier_cbs = %d\\n\"",
            "atomic_read(&barrier_cbs_invoked)",
            "n_barrier_cbs"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&barrier_cbs_invoked"
          ],
          "line": 2696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&barrier_cbs_invoked"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "barrier_wq",
            "atomic_read(&barrier_cbs_count) == 0 ||\n\t\t\t   torture_must_stop()"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&barrier_cbs_count"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&barrier_cbs_wq[i]"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&barrier_phase",
            "!barrier_phase"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&barrier_cbs_count",
            "n_barrier_cbs"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&barrier_cbs_invoked",
            "0"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_barrier task starting\""
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic long n_rcu_torture_barrier_error;\nstatic long n_barrier_attempts;\nstatic long n_barrier_successes;\nstatic atomic_t barrier_cbs_count;\nstatic bool barrier_phase;\nstatic atomic_t barrier_cbs_invoked;\nstatic wait_queue_head_t *barrier_cbs_wq;\nstatic DECLARE_WAIT_QUEUE_HEAD(barrier_wq);\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcu_torture_barrier(void *arg)\n{\n\tint i;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_barrier task starting\");\n\tdo {\n\t\tatomic_set(&barrier_cbs_invoked, 0);\n\t\tatomic_set(&barrier_cbs_count, n_barrier_cbs);\n\t\t/* Ensure barrier_phase ordered after prior assignments. */\n\t\tsmp_store_release(&barrier_phase, !barrier_phase);\n\t\tfor (i = 0; i < n_barrier_cbs; i++)\n\t\t\twake_up(&barrier_cbs_wq[i]);\n\t\twait_event(barrier_wq,\n\t\t\t   atomic_read(&barrier_cbs_count) == 0 ||\n\t\t\t   torture_must_stop());\n\t\tif (torture_must_stop())\n\t\t\tbreak;\n\t\tn_barrier_attempts++;\n\t\tcur_ops->cb_barrier(); /* Implies smp_mb() for wait_event(). */\n\t\tif (atomic_read(&barrier_cbs_invoked) != n_barrier_cbs) {\n\t\t\tn_rcu_torture_barrier_error++;\n\t\t\tpr_err(\"barrier_cbs_invoked = %d, n_barrier_cbs = %d\\n\",\n\t\t\t       atomic_read(&barrier_cbs_invoked),\n\t\t\t       n_barrier_cbs);\n\t\t\tWARN_ON(1);\n\t\t\t// Wait manually for the remaining callbacks\n\t\t\ti = 0;\n\t\t\tdo {\n\t\t\t\tif (WARN_ON(i++ > HZ))\n\t\t\t\t\ti = INT_MIN;\n\t\t\t\tschedule_timeout_interruptible(1);\n\t\t\t\tcur_ops->cb_barrier();\n\t\t\t} while (atomic_read(&barrier_cbs_invoked) !=\n\t\t\t\t n_barrier_cbs &&\n\t\t\t\t !torture_must_stop());\n\t\t\tsmp_mb(); // Can't trust ordering if broken.\n\t\t\tif (!torture_must_stop())\n\t\t\t\tpr_err(\"Recovered: barrier_cbs_invoked = %d\\n\",\n\t\t\t\t       atomic_read(&barrier_cbs_invoked));\n\t\t} else {\n\t\t\tn_barrier_successes++;\n\t\t}\n\t\tschedule_timeout_interruptible(HZ / 10);\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_torture_barrier\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_barrier_cbs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2636-2671",
    "snippet": "static int rcu_torture_barrier_cbs(void *arg)\n{\n\tlong myid = (long)arg;\n\tbool lastphase = false;\n\tbool newphase;\n\tstruct rcu_head rcu;\n\n\tinit_rcu_head_on_stack(&rcu);\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_barrier_cbs task started\");\n\tset_user_nice(current, MAX_NICE);\n\tdo {\n\t\twait_event(barrier_cbs_wq[myid],\n\t\t\t   (newphase =\n\t\t\t    smp_load_acquire(&barrier_phase)) != lastphase ||\n\t\t\t   torture_must_stop());\n\t\tlastphase = newphase;\n\t\tif (torture_must_stop())\n\t\t\tbreak;\n\t\t/*\n\t\t * The above smp_load_acquire() ensures barrier_phase load\n\t\t * is ordered before the following ->call().\n\t\t */\n\t\tif (smp_call_function_single(myid, rcu_torture_barrier1cb,\n\t\t\t\t\t     &rcu, 1)) {\n\t\t\t// IPI failed, so use direct call from current CPU.\n\t\t\tcur_ops->call(&rcu, rcu_torture_barrier_cbf);\n\t\t}\n\t\tif (atomic_dec_and_test(&barrier_cbs_count))\n\t\t\twake_up(&barrier_wq);\n\t} while (!torture_must_stop());\n\tif (cur_ops->cb_barrier != NULL)\n\t\tcur_ops->cb_barrier();\n\tdestroy_rcu_head_on_stack(&rcu);\n\ttorture_kthread_stopping(\"rcu_torture_barrier_cbs\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t barrier_cbs_count;",
      "static bool barrier_phase;",
      "static wait_queue_head_t *barrier_cbs_wq;",
      "static DECLARE_WAIT_QUEUE_HEAD(barrier_wq);",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_barrier_cbs\""
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_rcu_head_on_stack",
          "args": [
            "&rcu"
          ],
          "line": 2668
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_rcu_head_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "455-458",
          "snippet": "void destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&barrier_wq"
          ],
          "line": 2664
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&barrier_cbs_count"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->call",
          "args": [
            "&rcu",
            "rcu_torture_barrier_cbf"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "myid",
            "rcu_torture_barrier1cb",
            "&rcu",
            "1"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/up.c",
          "lines": "12-25",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "barrier_cbs_wq[myid]",
            "(newphase =\n\t\t\t    smp_load_acquire(&barrier_phase)) != lastphase ||\n\t\t\t   torture_must_stop()"
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&barrier_phase"
          ],
          "line": 2649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_barrier_cbs task started\""
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rcu_head_on_stack",
          "args": [
            "&rcu"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "init_rcu_head_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "438-441",
          "snippet": "void init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t barrier_cbs_count;\nstatic bool barrier_phase;\nstatic wait_queue_head_t *barrier_cbs_wq;\nstatic DECLARE_WAIT_QUEUE_HEAD(barrier_wq);\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcu_torture_barrier_cbs(void *arg)\n{\n\tlong myid = (long)arg;\n\tbool lastphase = false;\n\tbool newphase;\n\tstruct rcu_head rcu;\n\n\tinit_rcu_head_on_stack(&rcu);\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_barrier_cbs task started\");\n\tset_user_nice(current, MAX_NICE);\n\tdo {\n\t\twait_event(barrier_cbs_wq[myid],\n\t\t\t   (newphase =\n\t\t\t    smp_load_acquire(&barrier_phase)) != lastphase ||\n\t\t\t   torture_must_stop());\n\t\tlastphase = newphase;\n\t\tif (torture_must_stop())\n\t\t\tbreak;\n\t\t/*\n\t\t * The above smp_load_acquire() ensures barrier_phase load\n\t\t * is ordered before the following ->call().\n\t\t */\n\t\tif (smp_call_function_single(myid, rcu_torture_barrier1cb,\n\t\t\t\t\t     &rcu, 1)) {\n\t\t\t// IPI failed, so use direct call from current CPU.\n\t\t\tcur_ops->call(&rcu, rcu_torture_barrier_cbf);\n\t\t}\n\t\tif (atomic_dec_and_test(&barrier_cbs_count))\n\t\t\twake_up(&barrier_wq);\n\t} while (!torture_must_stop());\n\tif (cur_ops->cb_barrier != NULL)\n\t\tcur_ops->cb_barrier();\n\tdestroy_rcu_head_on_stack(&rcu);\n\ttorture_kthread_stopping(\"rcu_torture_barrier_cbs\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_barrier1cb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2628-2633",
    "snippet": "static void rcu_torture_barrier1cb(void *rcu_void)\n{\n\tstruct rcu_head *rhp = rcu_void;\n\n\tcur_ops->call(rhp, rcu_torture_barrier_cbf);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_ops->call",
          "args": [
            "rhp",
            "rcu_torture_barrier_cbf"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void rcu_torture_barrier1cb(void *rcu_void)\n{\n\tstruct rcu_head *rhp = rcu_void;\n\n\tcur_ops->call(rhp, rcu_torture_barrier_cbf);\n}"
  },
  {
    "function_name": "rcu_torture_barrier_cbf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2622-2625",
    "snippet": "static void rcu_torture_barrier_cbf(struct rcu_head *rcu)\n{\n\tatomic_inc(&barrier_cbs_invoked);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t barrier_cbs_invoked;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&barrier_cbs_invoked"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t barrier_cbs_invoked;\n\nstatic void rcu_torture_barrier_cbf(struct rcu_head *rcu)\n{\n\tatomic_inc(&barrier_cbs_invoked);\n}"
  },
  {
    "function_name": "rcu_torture_fwd_prog_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2602-2619",
    "snippet": "static void rcu_torture_fwd_prog_cleanup(void)\n{\n\tint i;\n\tstruct rcu_fwd *rfp;\n\n\tif (!rcu_fwds || !fwd_prog_tasks)\n\t\treturn;\n\tfor (i = 0; i < fwd_progress; i++)\n\t\ttorture_stop_kthread(rcu_torture_fwd_prog, fwd_prog_tasks[i]);\n\tunregister_oom_notifier(&rcutorture_oom_nb);\n\tmutex_lock(&rcu_fwd_mutex);\n\trfp = rcu_fwds;\n\trcu_fwds = NULL;\n\tmutex_unlock(&rcu_fwd_mutex);\n\tkfree(rfp);\n\tkfree(fwd_prog_tasks);\n\tfwd_prog_tasks = NULL;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct **fwd_prog_tasks;",
      "static DEFINE_MUTEX(rcu_fwd_mutex);",
      "static struct rcu_fwd *rcu_fwds;",
      "static struct notifier_block rcutorture_oom_nb = {\n\t.notifier_call = rcutorture_oom_notify\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fwd_prog_tasks"
          ],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "736-747",
          "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t shutdown_wq;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_ended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rcu_fwd_mutex"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rcu_fwd_mutex"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_oom_notifier",
          "args": [
            "&rcutorture_oom_nb"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "rcu_torture_fwd_prog",
            "fwd_prog_tasks[i]"
          ],
          "line": 2610
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "948-955",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct **fwd_prog_tasks;\nstatic DEFINE_MUTEX(rcu_fwd_mutex);\nstatic struct rcu_fwd *rcu_fwds;\nstatic struct notifier_block rcutorture_oom_nb = {\n\t.notifier_call = rcutorture_oom_notify\n};\n\nstatic void rcu_torture_fwd_prog_cleanup(void)\n{\n\tint i;\n\tstruct rcu_fwd *rfp;\n\n\tif (!rcu_fwds || !fwd_prog_tasks)\n\t\treturn;\n\tfor (i = 0; i < fwd_progress; i++)\n\t\ttorture_stop_kthread(rcu_torture_fwd_prog, fwd_prog_tasks[i]);\n\tunregister_oom_notifier(&rcutorture_oom_nb);\n\tmutex_lock(&rcu_fwd_mutex);\n\trfp = rcu_fwds;\n\trcu_fwds = NULL;\n\tmutex_unlock(&rcu_fwd_mutex);\n\tkfree(rfp);\n\tkfree(fwd_prog_tasks);\n\tfwd_prog_tasks = NULL;\n}"
  },
  {
    "function_name": "rcu_torture_fwd_prog_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2541-2600",
    "snippet": "static int __init rcu_torture_fwd_prog_init(void)\n{\n\tint i;\n\tint ret = 0;\n\tstruct rcu_fwd *rfp;\n\n\tif (!fwd_progress)\n\t\treturn 0; /* Not requested, so don't do it. */\n\tif (fwd_progress >= nr_cpu_ids) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Limiting fwd_progress to # CPUs.\\n\");\n\t\tfwd_progress = nr_cpu_ids;\n\t} else if (fwd_progress < 0) {\n\t\tfwd_progress = nr_cpu_ids;\n\t}\n\tif ((!cur_ops->sync && !cur_ops->call) ||\n\t    (!cur_ops->cbflood_max && (!cur_ops->stall_dur || cur_ops->stall_dur() <= 0)) ||\n\t    cur_ops == &rcu_busted_ops) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, unsupported by RCU flavor under test\");\n\t\tfwd_progress = 0;\n\t\treturn 0;\n\t}\n\tif (stall_cpu > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, conflicts with CPU-stall testing\");\n\t\tfwd_progress = 0;\n\t\tif (IS_MODULE(CONFIG_RCU_TORTURE_TEST))\n\t\t\treturn -EINVAL; /* In module, can fail back to user. */\n\t\tWARN_ON(1); /* Make sure rcutorture notices conflict. */\n\t\treturn 0;\n\t}\n\tif (fwd_progress_holdoff <= 0)\n\t\tfwd_progress_holdoff = 1;\n\tif (fwd_progress_div <= 0)\n\t\tfwd_progress_div = 4;\n\trfp = kcalloc(fwd_progress, sizeof(*rfp), GFP_KERNEL);\n\tfwd_prog_tasks = kcalloc(fwd_progress, sizeof(*fwd_prog_tasks), GFP_KERNEL);\n\tif (!rfp || !fwd_prog_tasks) {\n\t\tkfree(rfp);\n\t\tkfree(fwd_prog_tasks);\n\t\tfwd_prog_tasks = NULL;\n\t\tfwd_progress = 0;\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fwd_progress; i++) {\n\t\tspin_lock_init(&rfp[i].rcu_fwd_lock);\n\t\trfp[i].rcu_fwd_cb_tail = &rfp[i].rcu_fwd_cb_head;\n\t\trfp[i].rcu_fwd_id = i;\n\t}\n\tmutex_lock(&rcu_fwd_mutex);\n\trcu_fwds = rfp;\n\tmutex_unlock(&rcu_fwd_mutex);\n\tregister_oom_notifier(&rcutorture_oom_nb);\n\tfor (i = 0; i < fwd_progress; i++) {\n\t\tret = torture_create_kthread(rcu_torture_fwd_prog, &rcu_fwds[i], fwd_prog_tasks[i]);\n\t\tif (ret) {\n\t\t\tfwd_progress = i;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct **fwd_prog_tasks;",
      "static struct rcu_torture_ops *cur_ops;",
      "static struct rcu_torture_ops rcu_busted_ops = {\n\t.ttype\t\t= INVALID_RCU_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= rcu_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= rcu_torture_read_unlock,\n\t.readlock_held\t= torture_readlock_not_held,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_busted_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_busted,\n\t.exp_sync\t= synchronize_rcu_busted,\n\t.call\t\t= call_rcu_busted,\n\t.cb_barrier\t= NULL,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"busted\"\n};",
      "static DEFINE_MUTEX(rcu_fwd_mutex);",
      "static struct rcu_fwd *rcu_fwds;",
      "static struct notifier_block rcutorture_oom_nb = {\n\t.notifier_call = rcutorture_oom_notify\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_fwd_prog",
            "&rcu_fwds[i]",
            "fwd_prog_tasks[i]"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_oom_notifier",
          "args": [
            "&rcutorture_oom_nb"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rcu_fwd_mutex"
          ],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rcu_fwd_mutex"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&rfp[i].rcu_fwd_lock"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fwd_prog_tasks"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "736-747",
          "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t shutdown_wq;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_ended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "fwd_progress",
            "sizeof(*fwd_prog_tasks)",
            "GFP_KERNEL"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "fwd_progress",
            "sizeof(*rfp)",
            "GFP_KERNEL"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MODULE",
          "args": [
            "CONFIG_RCU_TORTURE_TEST"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_fwd_prog_init: Disabled, conflicts with CPU-stall testing\""
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_fwd_prog_init: Disabled, unsupported by RCU flavor under test\""
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->stall_dur",
          "args": [],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_fwd_prog_init: Limiting fwd_progress to # CPUs.\\n\""
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct **fwd_prog_tasks;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct rcu_torture_ops rcu_busted_ops = {\n\t.ttype\t\t= INVALID_RCU_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= rcu_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= rcu_torture_read_unlock,\n\t.readlock_held\t= torture_readlock_not_held,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_busted_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_busted,\n\t.exp_sync\t= synchronize_rcu_busted,\n\t.call\t\t= call_rcu_busted,\n\t.cb_barrier\t= NULL,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"busted\"\n};\nstatic DEFINE_MUTEX(rcu_fwd_mutex);\nstatic struct rcu_fwd *rcu_fwds;\nstatic struct notifier_block rcutorture_oom_nb = {\n\t.notifier_call = rcutorture_oom_notify\n};\n\nstatic int __init rcu_torture_fwd_prog_init(void)\n{\n\tint i;\n\tint ret = 0;\n\tstruct rcu_fwd *rfp;\n\n\tif (!fwd_progress)\n\t\treturn 0; /* Not requested, so don't do it. */\n\tif (fwd_progress >= nr_cpu_ids) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Limiting fwd_progress to # CPUs.\\n\");\n\t\tfwd_progress = nr_cpu_ids;\n\t} else if (fwd_progress < 0) {\n\t\tfwd_progress = nr_cpu_ids;\n\t}\n\tif ((!cur_ops->sync && !cur_ops->call) ||\n\t    (!cur_ops->cbflood_max && (!cur_ops->stall_dur || cur_ops->stall_dur() <= 0)) ||\n\t    cur_ops == &rcu_busted_ops) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, unsupported by RCU flavor under test\");\n\t\tfwd_progress = 0;\n\t\treturn 0;\n\t}\n\tif (stall_cpu > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, conflicts with CPU-stall testing\");\n\t\tfwd_progress = 0;\n\t\tif (IS_MODULE(CONFIG_RCU_TORTURE_TEST))\n\t\t\treturn -EINVAL; /* In module, can fail back to user. */\n\t\tWARN_ON(1); /* Make sure rcutorture notices conflict. */\n\t\treturn 0;\n\t}\n\tif (fwd_progress_holdoff <= 0)\n\t\tfwd_progress_holdoff = 1;\n\tif (fwd_progress_div <= 0)\n\t\tfwd_progress_div = 4;\n\trfp = kcalloc(fwd_progress, sizeof(*rfp), GFP_KERNEL);\n\tfwd_prog_tasks = kcalloc(fwd_progress, sizeof(*fwd_prog_tasks), GFP_KERNEL);\n\tif (!rfp || !fwd_prog_tasks) {\n\t\tkfree(rfp);\n\t\tkfree(fwd_prog_tasks);\n\t\tfwd_prog_tasks = NULL;\n\t\tfwd_progress = 0;\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fwd_progress; i++) {\n\t\tspin_lock_init(&rfp[i].rcu_fwd_lock);\n\t\trfp[i].rcu_fwd_cb_tail = &rfp[i].rcu_fwd_cb_head;\n\t\trfp[i].rcu_fwd_id = i;\n\t}\n\tmutex_lock(&rcu_fwd_mutex);\n\trcu_fwds = rfp;\n\tmutex_unlock(&rcu_fwd_mutex);\n\tregister_oom_notifier(&rcutorture_oom_nb);\n\tfor (i = 0; i < fwd_progress; i++) {\n\t\tret = torture_create_kthread(rcu_torture_fwd_prog, &rcu_fwds[i], fwd_prog_tasks[i]);\n\t\tif (ret) {\n\t\t\tfwd_progress = i;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_fwd_prog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2489-2538",
    "snippet": "static int rcu_torture_fwd_prog(void *args)\n{\n\tbool firsttime = true;\n\tlong max_cbs;\n\tint oldnice = task_nice(current);\n\tunsigned long oldseq = READ_ONCE(rcu_fwd_seq);\n\tstruct rcu_fwd *rfp = args;\n\tint tested = 0;\n\tint tested_tries = 0;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_progress task started\");\n\trcu_bind_current_to_nocb();\n\tif (!IS_ENABLED(CONFIG_SMP) || !IS_ENABLED(CONFIG_RCU_BOOST))\n\t\tset_user_nice(current, MAX_NICE);\n\tdo {\n\t\tif (!rfp->rcu_fwd_id) {\n\t\t\tschedule_timeout_interruptible(fwd_progress_holdoff * HZ);\n\t\t\tWRITE_ONCE(rcu_fwd_emergency_stop, false);\n\t\t\tif (!firsttime) {\n\t\t\t\tmax_cbs = atomic_long_xchg(&rcu_fwd_max_cbs, 0);\n\t\t\t\tpr_alert(\"%s n_max_cbs: %ld\\n\", __func__, max_cbs);\n\t\t\t}\n\t\t\tfirsttime = false;\n\t\t\tWRITE_ONCE(rcu_fwd_seq, rcu_fwd_seq + 1);\n\t\t} else {\n\t\t\twhile (READ_ONCE(rcu_fwd_seq) == oldseq)\n\t\t\t\tschedule_timeout_interruptible(1);\n\t\t\toldseq = READ_ONCE(rcu_fwd_seq);\n\t\t}\n\t\tpr_alert(\"%s: Starting forward-progress test %d\\n\", __func__, rfp->rcu_fwd_id);\n\t\tif (rcu_inkernel_boot_has_ended() && torture_num_online_cpus() > rfp->rcu_fwd_id)\n\t\t\trcu_torture_fwd_prog_cr(rfp);\n\t\tif ((cur_ops->stall_dur && cur_ops->stall_dur() > 0) &&\n\t\t    (!IS_ENABLED(CONFIG_TINY_RCU) ||\n\t\t     (rcu_inkernel_boot_has_ended() &&\n\t\t      torture_num_online_cpus() > rfp->rcu_fwd_id)))\n\t\t\trcu_torture_fwd_prog_nr(rfp, &tested, &tested_tries);\n\n\t\t/* Avoid slow periods, better to test when busy. */\n\t\tif (stutter_wait(\"rcu_torture_fwd_prog\"))\n\t\t\tsched_set_normal(current, oldnice);\n\t} while (!torture_must_stop());\n\t/* Short runs might not contain a valid forward-progress attempt. */\n\tif (!rfp->rcu_fwd_id) {\n\t\tWARN_ON(!tested && tested_tries >= 5);\n\t\tpr_alert(\"%s: tested %d tested_tries %d\\n\", __func__, tested, tested_tries);\n\t}\n\ttorture_kthread_stopping(\"rcu_torture_fwd_prog\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;",
      "static unsigned long rcu_fwd_seq;",
      "static atomic_long_t rcu_fwd_max_cbs;",
      "static bool rcu_fwd_emergency_stop;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_fwd_prog\""
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: tested %d tested_tries %d\\n\"",
            "__func__",
            "tested",
            "tested_tries"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!tested && tested_tries >= 5"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_set_normal",
          "args": [
            "current",
            "oldnice"
          ],
          "line": 2529
        },
        "resolved": true,
        "details": {
          "function_name": "sched_set_normal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7606-7613",
          "snippet": "void sched_set_normal(struct task_struct *p, int nice)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t\t.sched_nice = nice,\n\t};\n\tWARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_set_normal(struct task_struct *p, int nice)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t\t.sched_nice = nice,\n\t};\n\tWARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_torture_fwd_prog\""
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "722-749",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_fwd_prog_nr",
          "args": [
            "rfp",
            "&tested",
            "&tested_tries"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_fwd_prog_nr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2270-2337",
          "snippet": "static void rcu_torture_fwd_prog_nr(struct rcu_fwd *rfp,\n\t\t\t\t    int *tested, int *tested_tries)\n{\n\tunsigned long cver;\n\tunsigned long dur;\n\tstruct fwd_cb_state fcs;\n\tunsigned long gps;\n\tint idx;\n\tint sd;\n\tint sd4;\n\tbool selfpropcb = false;\n\tunsigned long stopat;\n\tstatic DEFINE_TORTURE_RANDOM(trs);\n\n\tif (!cur_ops->sync)\n\t\treturn; // Cannot do need_resched() forward progress testing without ->sync.\n\tif (cur_ops->call && cur_ops->cb_barrier) {\n\t\tinit_rcu_head_on_stack(&fcs.rh);\n\t\tselfpropcb = true;\n\t}\n\n\t/* Tight loop containing cond_resched(). */\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, true);\n\tcur_ops->sync(); /* Later readers see above write. */\n\tif  (selfpropcb) {\n\t\tWRITE_ONCE(fcs.stop, 0);\n\t\tcur_ops->call(&fcs.rh, rcu_torture_fwd_prog_cb);\n\t}\n\tcver = READ_ONCE(rcu_torture_current_version);\n\tgps = cur_ops->get_gp_seq();\n\tsd = cur_ops->stall_dur() + 1;\n\tsd4 = (sd + fwd_progress_div - 1) / fwd_progress_div;\n\tdur = sd4 + torture_random(&trs) % (sd - sd4);\n\tWRITE_ONCE(rfp->rcu_fwd_startat, jiffies);\n\tstopat = rfp->rcu_fwd_startat + dur;\n\twhile (time_before(jiffies, stopat) &&\n\t       !shutdown_time_arrived() &&\n\t       !READ_ONCE(rcu_fwd_emergency_stop) && !torture_must_stop()) {\n\t\tidx = cur_ops->readlock();\n\t\tudelay(10);\n\t\tcur_ops->readunlock(idx);\n\t\tif (!fwd_progress_need_resched || need_resched())\n\t\t\tcond_resched();\n\t}\n\t(*tested_tries)++;\n\tif (!time_before(jiffies, stopat) &&\n\t    !shutdown_time_arrived() &&\n\t    !READ_ONCE(rcu_fwd_emergency_stop) && !torture_must_stop()) {\n\t\t(*tested)++;\n\t\tcver = READ_ONCE(rcu_torture_current_version) - cver;\n\t\tgps = rcutorture_seq_diff(cur_ops->get_gp_seq(), gps);\n\t\tWARN_ON(!cver && gps < 2);\n\t\tpr_alert(\"%s: %d Duration %ld cver %ld gps %ld\\n\", __func__,\n\t\t\t rfp->rcu_fwd_id, dur, cver, gps);\n\t}\n\tif (selfpropcb) {\n\t\tWRITE_ONCE(fcs.stop, 1);\n\t\tcur_ops->sync(); /* Wait for running CB to complete. */\n\t\tcur_ops->cb_barrier(); /* Wait for queued callbacks. */\n\t}\n\n\tif (selfpropcb) {\n\t\tWARN_ON(READ_ONCE(fcs.stop) != 2);\n\t\tdestroy_rcu_head_on_stack(&fcs.rh);\n\t}\n\tschedule_timeout_uninterruptible(HZ / 10); /* Let kthreads recover. */\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, false);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long rcu_torture_current_version;",
            "static bool rcu_fwd_cb_nodelay;",
            "static struct rcu_torture_ops *cur_ops;",
            "static bool rcu_fwd_emergency_stop;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long rcu_torture_current_version;\nstatic bool rcu_fwd_cb_nodelay;\nstatic struct rcu_torture_ops *cur_ops;\nstatic bool rcu_fwd_emergency_stop;\n\nstatic void rcu_torture_fwd_prog_nr(struct rcu_fwd *rfp,\n\t\t\t\t    int *tested, int *tested_tries)\n{\n\tunsigned long cver;\n\tunsigned long dur;\n\tstruct fwd_cb_state fcs;\n\tunsigned long gps;\n\tint idx;\n\tint sd;\n\tint sd4;\n\tbool selfpropcb = false;\n\tunsigned long stopat;\n\tstatic DEFINE_TORTURE_RANDOM(trs);\n\n\tif (!cur_ops->sync)\n\t\treturn; // Cannot do need_resched() forward progress testing without ->sync.\n\tif (cur_ops->call && cur_ops->cb_barrier) {\n\t\tinit_rcu_head_on_stack(&fcs.rh);\n\t\tselfpropcb = true;\n\t}\n\n\t/* Tight loop containing cond_resched(). */\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, true);\n\tcur_ops->sync(); /* Later readers see above write. */\n\tif  (selfpropcb) {\n\t\tWRITE_ONCE(fcs.stop, 0);\n\t\tcur_ops->call(&fcs.rh, rcu_torture_fwd_prog_cb);\n\t}\n\tcver = READ_ONCE(rcu_torture_current_version);\n\tgps = cur_ops->get_gp_seq();\n\tsd = cur_ops->stall_dur() + 1;\n\tsd4 = (sd + fwd_progress_div - 1) / fwd_progress_div;\n\tdur = sd4 + torture_random(&trs) % (sd - sd4);\n\tWRITE_ONCE(rfp->rcu_fwd_startat, jiffies);\n\tstopat = rfp->rcu_fwd_startat + dur;\n\twhile (time_before(jiffies, stopat) &&\n\t       !shutdown_time_arrived() &&\n\t       !READ_ONCE(rcu_fwd_emergency_stop) && !torture_must_stop()) {\n\t\tidx = cur_ops->readlock();\n\t\tudelay(10);\n\t\tcur_ops->readunlock(idx);\n\t\tif (!fwd_progress_need_resched || need_resched())\n\t\t\tcond_resched();\n\t}\n\t(*tested_tries)++;\n\tif (!time_before(jiffies, stopat) &&\n\t    !shutdown_time_arrived() &&\n\t    !READ_ONCE(rcu_fwd_emergency_stop) && !torture_must_stop()) {\n\t\t(*tested)++;\n\t\tcver = READ_ONCE(rcu_torture_current_version) - cver;\n\t\tgps = rcutorture_seq_diff(cur_ops->get_gp_seq(), gps);\n\t\tWARN_ON(!cver && gps < 2);\n\t\tpr_alert(\"%s: %d Duration %ld cver %ld gps %ld\\n\", __func__,\n\t\t\t rfp->rcu_fwd_id, dur, cver, gps);\n\t}\n\tif (selfpropcb) {\n\t\tWRITE_ONCE(fcs.stop, 1);\n\t\tcur_ops->sync(); /* Wait for running CB to complete. */\n\t\tcur_ops->cb_barrier(); /* Wait for queued callbacks. */\n\t}\n\n\tif (selfpropcb) {\n\t\tWARN_ON(READ_ONCE(fcs.stop) != 2);\n\t\tdestroy_rcu_head_on_stack(&fcs.rh);\n\t}\n\tschedule_timeout_uninterruptible(HZ / 10); /* Let kthreads recover. */\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_num_online_cpus",
          "args": [],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_inkernel_boot_has_ended",
          "args": [],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_inkernel_boot_has_ended",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "206-209",
          "snippet": "bool rcu_inkernel_boot_has_ended(void)\n{\n\treturn rcu_boot_ended;\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_inkernel_boot_has_ended(void)\n{\n\treturn rcu_boot_ended;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TINY_RCU"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->stall_dur",
          "args": [],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_fwd_prog_cr",
          "args": [
            "rfp"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_fwd_prog_cr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2340-2435",
          "snippet": "static void rcu_torture_fwd_prog_cr(struct rcu_fwd *rfp)\n{\n\tunsigned long cver;\n\tunsigned long flags;\n\tunsigned long gps;\n\tint i;\n\tlong n_launders;\n\tlong n_launders_cb_snap;\n\tlong n_launders_sa;\n\tlong n_max_cbs;\n\tlong n_max_gps;\n\tstruct rcu_fwd_cb *rfcp;\n\tstruct rcu_fwd_cb *rfcpn;\n\tunsigned long stopat;\n\tunsigned long stoppedat;\n\n\tif (READ_ONCE(rcu_fwd_emergency_stop))\n\t\treturn; /* Get out of the way quickly, no GP wait! */\n\tif (!cur_ops->call)\n\t\treturn; /* Can't do call_rcu() fwd prog without ->call. */\n\n\t/* Loop continuously posting RCU callbacks. */\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, true);\n\tcur_ops->sync(); /* Later readers see above write. */\n\tWRITE_ONCE(rfp->rcu_fwd_startat, jiffies);\n\tstopat = rfp->rcu_fwd_startat + MAX_FWD_CB_JIFFIES;\n\tn_launders = 0;\n\trfp->n_launders_cb = 0; // Hoist initialization for multi-kthread\n\tn_launders_sa = 0;\n\tn_max_cbs = 0;\n\tn_max_gps = 0;\n\tfor (i = 0; i < ARRAY_SIZE(rfp->n_launders_hist); i++)\n\t\trfp->n_launders_hist[i].n_launders = 0;\n\tcver = READ_ONCE(rcu_torture_current_version);\n\tgps = cur_ops->get_gp_seq();\n\trfp->rcu_launder_gp_seq_start = gps;\n\ttick_dep_set_task(current, TICK_DEP_BIT_RCU);\n\twhile (time_before(jiffies, stopat) &&\n\t       !shutdown_time_arrived() &&\n\t       !READ_ONCE(rcu_fwd_emergency_stop) && !torture_must_stop()) {\n\t\trfcp = READ_ONCE(rfp->rcu_fwd_cb_head);\n\t\trfcpn = NULL;\n\t\tif (rfcp)\n\t\t\trfcpn = READ_ONCE(rfcp->rfc_next);\n\t\tif (rfcpn) {\n\t\t\tif (rfcp->rfc_gps >= MIN_FWD_CB_LAUNDERS &&\n\t\t\t    ++n_max_gps >= MIN_FWD_CBS_LAUNDERED)\n\t\t\t\tbreak;\n\t\t\trfp->rcu_fwd_cb_head = rfcpn;\n\t\t\tn_launders++;\n\t\t\tn_launders_sa++;\n\t\t} else if (!cur_ops->cbflood_max || cur_ops->cbflood_max > n_max_cbs) {\n\t\t\trfcp = kmalloc(sizeof(*rfcp), GFP_KERNEL);\n\t\t\tif (WARN_ON_ONCE(!rfcp)) {\n\t\t\t\tschedule_timeout_interruptible(1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tn_max_cbs++;\n\t\t\tn_launders_sa = 0;\n\t\t\trfcp->rfc_gps = 0;\n\t\t\trfcp->rfc_rfp = rfp;\n\t\t} else {\n\t\t\trfcp = NULL;\n\t\t}\n\t\tif (rfcp)\n\t\t\tcur_ops->call(&rfcp->rh, rcu_torture_fwd_cb_cr);\n\t\trcu_torture_fwd_prog_cond_resched(n_launders + n_max_cbs);\n\t\tif (tick_nohz_full_enabled()) {\n\t\t\tlocal_irq_save(flags);\n\t\t\trcu_momentary_dyntick_idle();\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t}\n\tstoppedat = jiffies;\n\tn_launders_cb_snap = READ_ONCE(rfp->n_launders_cb);\n\tcver = READ_ONCE(rcu_torture_current_version) - cver;\n\tgps = rcutorture_seq_diff(cur_ops->get_gp_seq(), gps);\n\tcur_ops->cb_barrier(); /* Wait for callbacks to be invoked. */\n\t(void)rcu_torture_fwd_prog_cbfree(rfp);\n\n\tif (!torture_must_stop() && !READ_ONCE(rcu_fwd_emergency_stop) &&\n\t    !shutdown_time_arrived()) {\n\t\tWARN_ON(n_max_gps < MIN_FWD_CBS_LAUNDERED);\n\t\tpr_alert(\"%s Duration %lu barrier: %lu pending %ld n_launders: %ld n_launders_sa: %ld n_max_gps: %ld n_max_cbs: %ld cver %ld gps %ld\\n\",\n\t\t\t __func__,\n\t\t\t stoppedat - rfp->rcu_fwd_startat, jiffies - stoppedat,\n\t\t\t n_launders + n_max_cbs - n_launders_cb_snap,\n\t\t\t n_launders, n_launders_sa,\n\t\t\t n_max_gps, n_max_cbs, cver, gps);\n\t\tatomic_long_add(n_max_cbs, &rcu_fwd_max_cbs);\n\t\trcu_torture_fwd_cb_hist(rfp);\n\t}\n\tschedule_timeout_uninterruptible(HZ); /* Let CBs drain. */\n\ttick_dep_clear_task(current, TICK_DEP_BIT_RCU);\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, false);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define MIN_FWD_CBS_LAUNDERED\t100\t/* Number of counted CBs. */",
            "#define MIN_FWD_CB_LAUNDERS\t3\t/* This many CB invocations to count. */",
            "#define MAX_FWD_CB_JIFFIES\t(8 * HZ) /* Maximum CB test duration. */"
          ],
          "globals_used": [
            "static unsigned long rcu_torture_current_version;",
            "static bool rcu_fwd_cb_nodelay;",
            "static struct rcu_torture_ops *cur_ops;",
            "static atomic_long_t rcu_fwd_max_cbs;",
            "static bool rcu_fwd_emergency_stop;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define MIN_FWD_CBS_LAUNDERED\t100\t/* Number of counted CBs. */\n#define MIN_FWD_CB_LAUNDERS\t3\t/* This many CB invocations to count. */\n#define MAX_FWD_CB_JIFFIES\t(8 * HZ) /* Maximum CB test duration. */\n\nstatic unsigned long rcu_torture_current_version;\nstatic bool rcu_fwd_cb_nodelay;\nstatic struct rcu_torture_ops *cur_ops;\nstatic atomic_long_t rcu_fwd_max_cbs;\nstatic bool rcu_fwd_emergency_stop;\n\nstatic void rcu_torture_fwd_prog_cr(struct rcu_fwd *rfp)\n{\n\tunsigned long cver;\n\tunsigned long flags;\n\tunsigned long gps;\n\tint i;\n\tlong n_launders;\n\tlong n_launders_cb_snap;\n\tlong n_launders_sa;\n\tlong n_max_cbs;\n\tlong n_max_gps;\n\tstruct rcu_fwd_cb *rfcp;\n\tstruct rcu_fwd_cb *rfcpn;\n\tunsigned long stopat;\n\tunsigned long stoppedat;\n\n\tif (READ_ONCE(rcu_fwd_emergency_stop))\n\t\treturn; /* Get out of the way quickly, no GP wait! */\n\tif (!cur_ops->call)\n\t\treturn; /* Can't do call_rcu() fwd prog without ->call. */\n\n\t/* Loop continuously posting RCU callbacks. */\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, true);\n\tcur_ops->sync(); /* Later readers see above write. */\n\tWRITE_ONCE(rfp->rcu_fwd_startat, jiffies);\n\tstopat = rfp->rcu_fwd_startat + MAX_FWD_CB_JIFFIES;\n\tn_launders = 0;\n\trfp->n_launders_cb = 0; // Hoist initialization for multi-kthread\n\tn_launders_sa = 0;\n\tn_max_cbs = 0;\n\tn_max_gps = 0;\n\tfor (i = 0; i < ARRAY_SIZE(rfp->n_launders_hist); i++)\n\t\trfp->n_launders_hist[i].n_launders = 0;\n\tcver = READ_ONCE(rcu_torture_current_version);\n\tgps = cur_ops->get_gp_seq();\n\trfp->rcu_launder_gp_seq_start = gps;\n\ttick_dep_set_task(current, TICK_DEP_BIT_RCU);\n\twhile (time_before(jiffies, stopat) &&\n\t       !shutdown_time_arrived() &&\n\t       !READ_ONCE(rcu_fwd_emergency_stop) && !torture_must_stop()) {\n\t\trfcp = READ_ONCE(rfp->rcu_fwd_cb_head);\n\t\trfcpn = NULL;\n\t\tif (rfcp)\n\t\t\trfcpn = READ_ONCE(rfcp->rfc_next);\n\t\tif (rfcpn) {\n\t\t\tif (rfcp->rfc_gps >= MIN_FWD_CB_LAUNDERS &&\n\t\t\t    ++n_max_gps >= MIN_FWD_CBS_LAUNDERED)\n\t\t\t\tbreak;\n\t\t\trfp->rcu_fwd_cb_head = rfcpn;\n\t\t\tn_launders++;\n\t\t\tn_launders_sa++;\n\t\t} else if (!cur_ops->cbflood_max || cur_ops->cbflood_max > n_max_cbs) {\n\t\t\trfcp = kmalloc(sizeof(*rfcp), GFP_KERNEL);\n\t\t\tif (WARN_ON_ONCE(!rfcp)) {\n\t\t\t\tschedule_timeout_interruptible(1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tn_max_cbs++;\n\t\t\tn_launders_sa = 0;\n\t\t\trfcp->rfc_gps = 0;\n\t\t\trfcp->rfc_rfp = rfp;\n\t\t} else {\n\t\t\trfcp = NULL;\n\t\t}\n\t\tif (rfcp)\n\t\t\tcur_ops->call(&rfcp->rh, rcu_torture_fwd_cb_cr);\n\t\trcu_torture_fwd_prog_cond_resched(n_launders + n_max_cbs);\n\t\tif (tick_nohz_full_enabled()) {\n\t\t\tlocal_irq_save(flags);\n\t\t\trcu_momentary_dyntick_idle();\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t}\n\tstoppedat = jiffies;\n\tn_launders_cb_snap = READ_ONCE(rfp->n_launders_cb);\n\tcver = READ_ONCE(rcu_torture_current_version) - cver;\n\tgps = rcutorture_seq_diff(cur_ops->get_gp_seq(), gps);\n\tcur_ops->cb_barrier(); /* Wait for callbacks to be invoked. */\n\t(void)rcu_torture_fwd_prog_cbfree(rfp);\n\n\tif (!torture_must_stop() && !READ_ONCE(rcu_fwd_emergency_stop) &&\n\t    !shutdown_time_arrived()) {\n\t\tWARN_ON(n_max_gps < MIN_FWD_CBS_LAUNDERED);\n\t\tpr_alert(\"%s Duration %lu barrier: %lu pending %ld n_launders: %ld n_launders_sa: %ld n_max_gps: %ld n_max_cbs: %ld cver %ld gps %ld\\n\",\n\t\t\t __func__,\n\t\t\t stoppedat - rfp->rcu_fwd_startat, jiffies - stoppedat,\n\t\t\t n_launders + n_max_cbs - n_launders_cb_snap,\n\t\t\t n_launders, n_launders_sa,\n\t\t\t n_max_gps, n_max_cbs, cver, gps);\n\t\tatomic_long_add(n_max_cbs, &rcu_fwd_max_cbs);\n\t\trcu_torture_fwd_cb_hist(rfp);\n\t}\n\tschedule_timeout_uninterruptible(HZ); /* Let CBs drain. */\n\ttick_dep_clear_task(current, TICK_DEP_BIT_RCU);\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: Starting forward-progress test %d\\n\"",
            "__func__",
            "rfp->rcu_fwd_id"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_fwd_seq"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "1"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_fwd_seq"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_fwd_seq",
            "rcu_fwd_seq + 1"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s n_max_cbs: %ld\\n\"",
            "__func__",
            "max_cbs"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_xchg",
          "args": [
            "&rcu_fwd_max_cbs",
            "0"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_fwd_emergency_stop",
            "false"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_BOOST"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SMP"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_bind_current_to_nocb",
          "args": [],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_bind_current_to_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1349-1353",
          "snippet": "void rcu_bind_current_to_nocb(void)\n{\n\tif (cpumask_available(rcu_nocb_mask) && cpumask_weight(rcu_nocb_mask))\n\t\tWARN_ON(sched_setaffinity(current->pid, rcu_nocb_mask));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "void rcu_bind_current_to_nocb(void)\n{\n\tif (cpumask_available(rcu_nocb_mask) && cpumask_weight(rcu_nocb_mask))\n\t\tWARN_ON(sched_setaffinity(current->pid, rcu_nocb_mask));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_fwd_progress task started\""
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_fwd_seq"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "current"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\nstatic unsigned long rcu_fwd_seq;\nstatic atomic_long_t rcu_fwd_max_cbs;\nstatic bool rcu_fwd_emergency_stop;\n\nstatic int rcu_torture_fwd_prog(void *args)\n{\n\tbool firsttime = true;\n\tlong max_cbs;\n\tint oldnice = task_nice(current);\n\tunsigned long oldseq = READ_ONCE(rcu_fwd_seq);\n\tstruct rcu_fwd *rfp = args;\n\tint tested = 0;\n\tint tested_tries = 0;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_progress task started\");\n\trcu_bind_current_to_nocb();\n\tif (!IS_ENABLED(CONFIG_SMP) || !IS_ENABLED(CONFIG_RCU_BOOST))\n\t\tset_user_nice(current, MAX_NICE);\n\tdo {\n\t\tif (!rfp->rcu_fwd_id) {\n\t\t\tschedule_timeout_interruptible(fwd_progress_holdoff * HZ);\n\t\t\tWRITE_ONCE(rcu_fwd_emergency_stop, false);\n\t\t\tif (!firsttime) {\n\t\t\t\tmax_cbs = atomic_long_xchg(&rcu_fwd_max_cbs, 0);\n\t\t\t\tpr_alert(\"%s n_max_cbs: %ld\\n\", __func__, max_cbs);\n\t\t\t}\n\t\t\tfirsttime = false;\n\t\t\tWRITE_ONCE(rcu_fwd_seq, rcu_fwd_seq + 1);\n\t\t} else {\n\t\t\twhile (READ_ONCE(rcu_fwd_seq) == oldseq)\n\t\t\t\tschedule_timeout_interruptible(1);\n\t\t\toldseq = READ_ONCE(rcu_fwd_seq);\n\t\t}\n\t\tpr_alert(\"%s: Starting forward-progress test %d\\n\", __func__, rfp->rcu_fwd_id);\n\t\tif (rcu_inkernel_boot_has_ended() && torture_num_online_cpus() > rfp->rcu_fwd_id)\n\t\t\trcu_torture_fwd_prog_cr(rfp);\n\t\tif ((cur_ops->stall_dur && cur_ops->stall_dur() > 0) &&\n\t\t    (!IS_ENABLED(CONFIG_TINY_RCU) ||\n\t\t     (rcu_inkernel_boot_has_ended() &&\n\t\t      torture_num_online_cpus() > rfp->rcu_fwd_id)))\n\t\t\trcu_torture_fwd_prog_nr(rfp, &tested, &tested_tries);\n\n\t\t/* Avoid slow periods, better to test when busy. */\n\t\tif (stutter_wait(\"rcu_torture_fwd_prog\"))\n\t\t\tsched_set_normal(current, oldnice);\n\t} while (!torture_must_stop());\n\t/* Short runs might not contain a valid forward-progress attempt. */\n\tif (!rfp->rcu_fwd_id) {\n\t\tWARN_ON(!tested && tested_tries >= 5);\n\t\tpr_alert(\"%s: tested %d tested_tries %d\\n\", __func__, tested, tested_tries);\n\t}\n\ttorture_kthread_stopping(\"rcu_torture_fwd_prog\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcutorture_oom_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2442-2482",
    "snippet": "static int rcutorture_oom_notify(struct notifier_block *self,\n\t\t\t\t unsigned long notused, void *nfreed)\n{\n\tint i;\n\tlong ncbs;\n\tstruct rcu_fwd *rfp;\n\n\tmutex_lock(&rcu_fwd_mutex);\n\trfp = rcu_fwds;\n\tif (!rfp) {\n\t\tmutex_unlock(&rcu_fwd_mutex);\n\t\treturn NOTIFY_OK;\n\t}\n\tWARN(1, \"%s invoked upon OOM during forward-progress testing.\\n\",\n\t     __func__);\n\tfor (i = 0; i < fwd_progress; i++) {\n\t\trcu_torture_fwd_cb_hist(&rfp[i]);\n\t\trcu_fwd_progress_check(1 + (jiffies - READ_ONCE(rfp[i].rcu_fwd_startat)) / 2);\n\t}\n\tWRITE_ONCE(rcu_fwd_emergency_stop, true);\n\tsmp_mb(); /* Emergency stop before free and wait to avoid hangs. */\n\tncbs = 0;\n\tfor (i = 0; i < fwd_progress; i++)\n\t\tncbs += rcu_torture_fwd_prog_cbfree(&rfp[i]);\n\tpr_info(\"%s: Freed %lu RCU callbacks.\\n\", __func__, ncbs);\n\trcu_barrier();\n\tncbs = 0;\n\tfor (i = 0; i < fwd_progress; i++)\n\t\tncbs += rcu_torture_fwd_prog_cbfree(&rfp[i]);\n\tpr_info(\"%s: Freed %lu RCU callbacks.\\n\", __func__, ncbs);\n\trcu_barrier();\n\tncbs = 0;\n\tfor (i = 0; i < fwd_progress; i++)\n\t\tncbs += rcu_torture_fwd_prog_cbfree(&rfp[i]);\n\tpr_info(\"%s: Freed %lu RCU callbacks.\\n\", __func__, ncbs);\n\tsmp_mb(); /* Frees before return to avoid redoing OOM. */\n\t(*(unsigned long *)nfreed)++; /* Forward progress CBs freed! */\n\tpr_info(\"%s returning after OOM processing.\\n\", __func__);\n\tmutex_unlock(&rcu_fwd_mutex);\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(rcu_fwd_mutex);",
      "static struct rcu_fwd *rcu_fwds;",
      "static bool rcu_fwd_emergency_stop;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rcu_fwd_mutex"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s returning after OOM processing.\\n\"",
            "__func__"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Freed %lu RCU callbacks.\\n\"",
            "__func__",
            "ncbs"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_fwd_prog_cbfree",
          "args": [
            "&rfp[i]"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_fwd_prog_cbfree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2240-2267",
          "snippet": "static unsigned long rcu_torture_fwd_prog_cbfree(struct rcu_fwd *rfp)\n{\n\tunsigned long flags;\n\tunsigned long freed = 0;\n\tstruct rcu_fwd_cb *rfcp;\n\n\tfor (;;) {\n\t\tspin_lock_irqsave(&rfp->rcu_fwd_lock, flags);\n\t\trfcp = rfp->rcu_fwd_cb_head;\n\t\tif (!rfcp) {\n\t\t\tspin_unlock_irqrestore(&rfp->rcu_fwd_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\trfp->rcu_fwd_cb_head = rfcp->rfc_next;\n\t\tif (!rfp->rcu_fwd_cb_head)\n\t\t\trfp->rcu_fwd_cb_tail = &rfp->rcu_fwd_cb_head;\n\t\tspin_unlock_irqrestore(&rfp->rcu_fwd_lock, flags);\n\t\tkfree(rfcp);\n\t\tfreed++;\n\t\trcu_torture_fwd_prog_cond_resched(freed);\n\t\tif (tick_nohz_full_enabled()) {\n\t\t\tlocal_irq_save(flags);\n\t\t\trcu_momentary_dyntick_idle();\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t}\n\treturn freed;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long rcu_torture_fwd_prog_cbfree(struct rcu_fwd *rfp)\n{\n\tunsigned long flags;\n\tunsigned long freed = 0;\n\tstruct rcu_fwd_cb *rfcp;\n\n\tfor (;;) {\n\t\tspin_lock_irqsave(&rfp->rcu_fwd_lock, flags);\n\t\trfcp = rfp->rcu_fwd_cb_head;\n\t\tif (!rfcp) {\n\t\t\tspin_unlock_irqrestore(&rfp->rcu_fwd_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\trfp->rcu_fwd_cb_head = rfcp->rfc_next;\n\t\tif (!rfp->rcu_fwd_cb_head)\n\t\t\trfp->rcu_fwd_cb_tail = &rfp->rcu_fwd_cb_head;\n\t\tspin_unlock_irqrestore(&rfp->rcu_fwd_lock, flags);\n\t\tkfree(rfcp);\n\t\tfreed++;\n\t\trcu_torture_fwd_prog_cond_resched(freed);\n\t\tif (tick_nohz_full_enabled()) {\n\t\t\tlocal_irq_save(flags);\n\t\t\trcu_momentary_dyntick_idle();\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t}\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1569-1572",
          "snippet": "void rcu_barrier_tasks_trace(void)\n{\n\trcu_barrier_tasks_generic(&rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid rcu_barrier_tasks_trace(void)\n{\n\trcu_barrier_tasks_generic(&rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Freed %lu RCU callbacks.\\n\"",
            "__func__",
            "ncbs"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Freed %lu RCU callbacks.\\n\"",
            "__func__",
            "ncbs"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_fwd_emergency_stop",
            "true"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_fwd_progress_check",
          "args": [
            "1 + (jiffies - READ_ONCE(rfp[i].rcu_fwd_startat)) / 2"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_fwd_progress_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "525-525",
          "snippet": "static inline void rcu_fwd_progress_check(unsigned long j) { }",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_fwd_progress_check(unsigned long j) { }"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rfp[i].rcu_fwd_startat"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_fwd_cb_hist",
          "args": [
            "&rfp[i]"
          ],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_fwd_cb_hist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2173-2197",
          "snippet": "static void rcu_torture_fwd_cb_hist(struct rcu_fwd *rfp)\n{\n\tunsigned long gps;\n\tunsigned long gps_old;\n\tint i;\n\tint j;\n\n\tfor (i = ARRAY_SIZE(rfp->n_launders_hist) - 1; i > 0; i--)\n\t\tif (rfp->n_launders_hist[i].n_launders > 0)\n\t\t\tbreak;\n\tmutex_lock(&rcu_fwd_mutex); // Serialize histograms.\n\tpr_alert(\"%s: Callback-invocation histogram %d (duration %lu jiffies):\",\n\t\t __func__, rfp->rcu_fwd_id, jiffies - rfp->rcu_fwd_startat);\n\tgps_old = rfp->rcu_launder_gp_seq_start;\n\tfor (j = 0; j <= i; j++) {\n\t\tgps = rfp->n_launders_hist[j].launder_gp_seq;\n\t\tpr_cont(\" %ds/%d: %ld:%ld\",\n\t\t\tj + 1, FWD_CBS_HIST_DIV,\n\t\t\trfp->n_launders_hist[j].n_launders,\n\t\t\trcutorture_seq_diff(gps, gps_old));\n\t\tgps_old = gps;\n\t}\n\tpr_cont(\"\\n\");\n\tmutex_unlock(&rcu_fwd_mutex);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FWD_CBS_HIST_DIV\t10\t/* Histogram buckets/second. */"
          ],
          "globals_used": [
            "static DEFINE_MUTEX(rcu_fwd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FWD_CBS_HIST_DIV\t10\t/* Histogram buckets/second. */\n\nstatic DEFINE_MUTEX(rcu_fwd_mutex);\n\nstatic void rcu_torture_fwd_cb_hist(struct rcu_fwd *rfp)\n{\n\tunsigned long gps;\n\tunsigned long gps_old;\n\tint i;\n\tint j;\n\n\tfor (i = ARRAY_SIZE(rfp->n_launders_hist) - 1; i > 0; i--)\n\t\tif (rfp->n_launders_hist[i].n_launders > 0)\n\t\t\tbreak;\n\tmutex_lock(&rcu_fwd_mutex); // Serialize histograms.\n\tpr_alert(\"%s: Callback-invocation histogram %d (duration %lu jiffies):\",\n\t\t __func__, rfp->rcu_fwd_id, jiffies - rfp->rcu_fwd_startat);\n\tgps_old = rfp->rcu_launder_gp_seq_start;\n\tfor (j = 0; j <= i; j++) {\n\t\tgps = rfp->n_launders_hist[j].launder_gp_seq;\n\t\tpr_cont(\" %ds/%d: %ld:%ld\",\n\t\t\tj + 1, FWD_CBS_HIST_DIV,\n\t\t\trfp->n_launders_hist[j].n_launders,\n\t\t\trcutorture_seq_diff(gps, gps_old));\n\t\tgps_old = gps;\n\t}\n\tpr_cont(\"\\n\");\n\tmutex_unlock(&rcu_fwd_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"%s invoked upon OOM during forward-progress testing.\\n\"",
            "__func__"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rcu_fwd_mutex"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(rcu_fwd_mutex);\nstatic struct rcu_fwd *rcu_fwds;\nstatic bool rcu_fwd_emergency_stop;\n\nstatic int rcutorture_oom_notify(struct notifier_block *self,\n\t\t\t\t unsigned long notused, void *nfreed)\n{\n\tint i;\n\tlong ncbs;\n\tstruct rcu_fwd *rfp;\n\n\tmutex_lock(&rcu_fwd_mutex);\n\trfp = rcu_fwds;\n\tif (!rfp) {\n\t\tmutex_unlock(&rcu_fwd_mutex);\n\t\treturn NOTIFY_OK;\n\t}\n\tWARN(1, \"%s invoked upon OOM during forward-progress testing.\\n\",\n\t     __func__);\n\tfor (i = 0; i < fwd_progress; i++) {\n\t\trcu_torture_fwd_cb_hist(&rfp[i]);\n\t\trcu_fwd_progress_check(1 + (jiffies - READ_ONCE(rfp[i].rcu_fwd_startat)) / 2);\n\t}\n\tWRITE_ONCE(rcu_fwd_emergency_stop, true);\n\tsmp_mb(); /* Emergency stop before free and wait to avoid hangs. */\n\tncbs = 0;\n\tfor (i = 0; i < fwd_progress; i++)\n\t\tncbs += rcu_torture_fwd_prog_cbfree(&rfp[i]);\n\tpr_info(\"%s: Freed %lu RCU callbacks.\\n\", __func__, ncbs);\n\trcu_barrier();\n\tncbs = 0;\n\tfor (i = 0; i < fwd_progress; i++)\n\t\tncbs += rcu_torture_fwd_prog_cbfree(&rfp[i]);\n\tpr_info(\"%s: Freed %lu RCU callbacks.\\n\", __func__, ncbs);\n\trcu_barrier();\n\tncbs = 0;\n\tfor (i = 0; i < fwd_progress; i++)\n\t\tncbs += rcu_torture_fwd_prog_cbfree(&rfp[i]);\n\tpr_info(\"%s: Freed %lu RCU callbacks.\\n\", __func__, ncbs);\n\tsmp_mb(); /* Frees before return to avoid redoing OOM. */\n\t(*(unsigned long *)nfreed)++; /* Forward progress CBs freed! */\n\tpr_info(\"%s returning after OOM processing.\\n\", __func__);\n\tmutex_unlock(&rcu_fwd_mutex);\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "rcu_torture_fwd_prog_cr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2340-2435",
    "snippet": "static void rcu_torture_fwd_prog_cr(struct rcu_fwd *rfp)\n{\n\tunsigned long cver;\n\tunsigned long flags;\n\tunsigned long gps;\n\tint i;\n\tlong n_launders;\n\tlong n_launders_cb_snap;\n\tlong n_launders_sa;\n\tlong n_max_cbs;\n\tlong n_max_gps;\n\tstruct rcu_fwd_cb *rfcp;\n\tstruct rcu_fwd_cb *rfcpn;\n\tunsigned long stopat;\n\tunsigned long stoppedat;\n\n\tif (READ_ONCE(rcu_fwd_emergency_stop))\n\t\treturn; /* Get out of the way quickly, no GP wait! */\n\tif (!cur_ops->call)\n\t\treturn; /* Can't do call_rcu() fwd prog without ->call. */\n\n\t/* Loop continuously posting RCU callbacks. */\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, true);\n\tcur_ops->sync(); /* Later readers see above write. */\n\tWRITE_ONCE(rfp->rcu_fwd_startat, jiffies);\n\tstopat = rfp->rcu_fwd_startat + MAX_FWD_CB_JIFFIES;\n\tn_launders = 0;\n\trfp->n_launders_cb = 0; // Hoist initialization for multi-kthread\n\tn_launders_sa = 0;\n\tn_max_cbs = 0;\n\tn_max_gps = 0;\n\tfor (i = 0; i < ARRAY_SIZE(rfp->n_launders_hist); i++)\n\t\trfp->n_launders_hist[i].n_launders = 0;\n\tcver = READ_ONCE(rcu_torture_current_version);\n\tgps = cur_ops->get_gp_seq();\n\trfp->rcu_launder_gp_seq_start = gps;\n\ttick_dep_set_task(current, TICK_DEP_BIT_RCU);\n\twhile (time_before(jiffies, stopat) &&\n\t       !shutdown_time_arrived() &&\n\t       !READ_ONCE(rcu_fwd_emergency_stop) && !torture_must_stop()) {\n\t\trfcp = READ_ONCE(rfp->rcu_fwd_cb_head);\n\t\trfcpn = NULL;\n\t\tif (rfcp)\n\t\t\trfcpn = READ_ONCE(rfcp->rfc_next);\n\t\tif (rfcpn) {\n\t\t\tif (rfcp->rfc_gps >= MIN_FWD_CB_LAUNDERS &&\n\t\t\t    ++n_max_gps >= MIN_FWD_CBS_LAUNDERED)\n\t\t\t\tbreak;\n\t\t\trfp->rcu_fwd_cb_head = rfcpn;\n\t\t\tn_launders++;\n\t\t\tn_launders_sa++;\n\t\t} else if (!cur_ops->cbflood_max || cur_ops->cbflood_max > n_max_cbs) {\n\t\t\trfcp = kmalloc(sizeof(*rfcp), GFP_KERNEL);\n\t\t\tif (WARN_ON_ONCE(!rfcp)) {\n\t\t\t\tschedule_timeout_interruptible(1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tn_max_cbs++;\n\t\t\tn_launders_sa = 0;\n\t\t\trfcp->rfc_gps = 0;\n\t\t\trfcp->rfc_rfp = rfp;\n\t\t} else {\n\t\t\trfcp = NULL;\n\t\t}\n\t\tif (rfcp)\n\t\t\tcur_ops->call(&rfcp->rh, rcu_torture_fwd_cb_cr);\n\t\trcu_torture_fwd_prog_cond_resched(n_launders + n_max_cbs);\n\t\tif (tick_nohz_full_enabled()) {\n\t\t\tlocal_irq_save(flags);\n\t\t\trcu_momentary_dyntick_idle();\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t}\n\tstoppedat = jiffies;\n\tn_launders_cb_snap = READ_ONCE(rfp->n_launders_cb);\n\tcver = READ_ONCE(rcu_torture_current_version) - cver;\n\tgps = rcutorture_seq_diff(cur_ops->get_gp_seq(), gps);\n\tcur_ops->cb_barrier(); /* Wait for callbacks to be invoked. */\n\t(void)rcu_torture_fwd_prog_cbfree(rfp);\n\n\tif (!torture_must_stop() && !READ_ONCE(rcu_fwd_emergency_stop) &&\n\t    !shutdown_time_arrived()) {\n\t\tWARN_ON(n_max_gps < MIN_FWD_CBS_LAUNDERED);\n\t\tpr_alert(\"%s Duration %lu barrier: %lu pending %ld n_launders: %ld n_launders_sa: %ld n_max_gps: %ld n_max_cbs: %ld cver %ld gps %ld\\n\",\n\t\t\t __func__,\n\t\t\t stoppedat - rfp->rcu_fwd_startat, jiffies - stoppedat,\n\t\t\t n_launders + n_max_cbs - n_launders_cb_snap,\n\t\t\t n_launders, n_launders_sa,\n\t\t\t n_max_gps, n_max_cbs, cver, gps);\n\t\tatomic_long_add(n_max_cbs, &rcu_fwd_max_cbs);\n\t\trcu_torture_fwd_cb_hist(rfp);\n\t}\n\tschedule_timeout_uninterruptible(HZ); /* Let CBs drain. */\n\ttick_dep_clear_task(current, TICK_DEP_BIT_RCU);\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, false);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define MIN_FWD_CBS_LAUNDERED\t100\t/* Number of counted CBs. */",
      "#define MIN_FWD_CB_LAUNDERS\t3\t/* This many CB invocations to count. */",
      "#define MAX_FWD_CB_JIFFIES\t(8 * HZ) /* Maximum CB test duration. */"
    ],
    "globals_used": [
      "static unsigned long rcu_torture_current_version;",
      "static bool rcu_fwd_cb_nodelay;",
      "static struct rcu_torture_ops *cur_ops;",
      "static atomic_long_t rcu_fwd_max_cbs;",
      "static bool rcu_fwd_emergency_stop;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_fwd_cb_nodelay",
            "false"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_dep_clear_task",
          "args": [
            "current",
            "TICK_DEP_BIT_RCU"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "HZ"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_fwd_cb_hist",
          "args": [
            "rfp"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_fwd_cb_hist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2173-2197",
          "snippet": "static void rcu_torture_fwd_cb_hist(struct rcu_fwd *rfp)\n{\n\tunsigned long gps;\n\tunsigned long gps_old;\n\tint i;\n\tint j;\n\n\tfor (i = ARRAY_SIZE(rfp->n_launders_hist) - 1; i > 0; i--)\n\t\tif (rfp->n_launders_hist[i].n_launders > 0)\n\t\t\tbreak;\n\tmutex_lock(&rcu_fwd_mutex); // Serialize histograms.\n\tpr_alert(\"%s: Callback-invocation histogram %d (duration %lu jiffies):\",\n\t\t __func__, rfp->rcu_fwd_id, jiffies - rfp->rcu_fwd_startat);\n\tgps_old = rfp->rcu_launder_gp_seq_start;\n\tfor (j = 0; j <= i; j++) {\n\t\tgps = rfp->n_launders_hist[j].launder_gp_seq;\n\t\tpr_cont(\" %ds/%d: %ld:%ld\",\n\t\t\tj + 1, FWD_CBS_HIST_DIV,\n\t\t\trfp->n_launders_hist[j].n_launders,\n\t\t\trcutorture_seq_diff(gps, gps_old));\n\t\tgps_old = gps;\n\t}\n\tpr_cont(\"\\n\");\n\tmutex_unlock(&rcu_fwd_mutex);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FWD_CBS_HIST_DIV\t10\t/* Histogram buckets/second. */"
          ],
          "globals_used": [
            "static DEFINE_MUTEX(rcu_fwd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FWD_CBS_HIST_DIV\t10\t/* Histogram buckets/second. */\n\nstatic DEFINE_MUTEX(rcu_fwd_mutex);\n\nstatic void rcu_torture_fwd_cb_hist(struct rcu_fwd *rfp)\n{\n\tunsigned long gps;\n\tunsigned long gps_old;\n\tint i;\n\tint j;\n\n\tfor (i = ARRAY_SIZE(rfp->n_launders_hist) - 1; i > 0; i--)\n\t\tif (rfp->n_launders_hist[i].n_launders > 0)\n\t\t\tbreak;\n\tmutex_lock(&rcu_fwd_mutex); // Serialize histograms.\n\tpr_alert(\"%s: Callback-invocation histogram %d (duration %lu jiffies):\",\n\t\t __func__, rfp->rcu_fwd_id, jiffies - rfp->rcu_fwd_startat);\n\tgps_old = rfp->rcu_launder_gp_seq_start;\n\tfor (j = 0; j <= i; j++) {\n\t\tgps = rfp->n_launders_hist[j].launder_gp_seq;\n\t\tpr_cont(\" %ds/%d: %ld:%ld\",\n\t\t\tj + 1, FWD_CBS_HIST_DIV,\n\t\t\trfp->n_launders_hist[j].n_launders,\n\t\t\trcutorture_seq_diff(gps, gps_old));\n\t\tgps_old = gps;\n\t}\n\tpr_cont(\"\\n\");\n\tmutex_unlock(&rcu_fwd_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "n_max_cbs",
            "&rcu_fwd_max_cbs"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s Duration %lu barrier: %lu pending %ld n_launders: %ld n_launders_sa: %ld n_max_gps: %ld n_max_cbs: %ld cver %ld gps %ld\\n\"",
            "__func__",
            "stoppedat - rfp->rcu_fwd_startat",
            "jiffies - stoppedat",
            "n_launders + n_max_cbs - n_launders_cb_snap",
            "n_launders",
            "n_launders_sa",
            "n_max_gps",
            "n_max_cbs",
            "cver",
            "gps"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "n_max_gps < MIN_FWD_CBS_LAUNDERED"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown_time_arrived",
          "args": [],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "shutdown_time_arrived",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "273-276",
          "snippet": "static bool shutdown_time_arrived(void)\n{\n\treturn shutdown_secs && time_after(jiffies, shutdown_jiffies - 30 * HZ);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long shutdown_jiffies;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long shutdown_jiffies;\n\nstatic bool shutdown_time_arrived(void)\n{\n\treturn shutdown_secs && time_after(jiffies, shutdown_jiffies - 30 * HZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_fwd_emergency_stop"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_fwd_prog_cbfree",
          "args": [
            "rfp"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_fwd_prog_cbfree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2240-2267",
          "snippet": "static unsigned long rcu_torture_fwd_prog_cbfree(struct rcu_fwd *rfp)\n{\n\tunsigned long flags;\n\tunsigned long freed = 0;\n\tstruct rcu_fwd_cb *rfcp;\n\n\tfor (;;) {\n\t\tspin_lock_irqsave(&rfp->rcu_fwd_lock, flags);\n\t\trfcp = rfp->rcu_fwd_cb_head;\n\t\tif (!rfcp) {\n\t\t\tspin_unlock_irqrestore(&rfp->rcu_fwd_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\trfp->rcu_fwd_cb_head = rfcp->rfc_next;\n\t\tif (!rfp->rcu_fwd_cb_head)\n\t\t\trfp->rcu_fwd_cb_tail = &rfp->rcu_fwd_cb_head;\n\t\tspin_unlock_irqrestore(&rfp->rcu_fwd_lock, flags);\n\t\tkfree(rfcp);\n\t\tfreed++;\n\t\trcu_torture_fwd_prog_cond_resched(freed);\n\t\tif (tick_nohz_full_enabled()) {\n\t\t\tlocal_irq_save(flags);\n\t\t\trcu_momentary_dyntick_idle();\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t}\n\treturn freed;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long rcu_torture_fwd_prog_cbfree(struct rcu_fwd *rfp)\n{\n\tunsigned long flags;\n\tunsigned long freed = 0;\n\tstruct rcu_fwd_cb *rfcp;\n\n\tfor (;;) {\n\t\tspin_lock_irqsave(&rfp->rcu_fwd_lock, flags);\n\t\trfcp = rfp->rcu_fwd_cb_head;\n\t\tif (!rfcp) {\n\t\t\tspin_unlock_irqrestore(&rfp->rcu_fwd_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\trfp->rcu_fwd_cb_head = rfcp->rfc_next;\n\t\tif (!rfp->rcu_fwd_cb_head)\n\t\t\trfp->rcu_fwd_cb_tail = &rfp->rcu_fwd_cb_head;\n\t\tspin_unlock_irqrestore(&rfp->rcu_fwd_lock, flags);\n\t\tkfree(rfcp);\n\t\tfreed++;\n\t\trcu_torture_fwd_prog_cond_resched(freed);\n\t\tif (tick_nohz_full_enabled()) {\n\t\t\tlocal_irq_save(flags);\n\t\t\trcu_momentary_dyntick_idle();\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t}\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutorture_seq_diff",
          "args": [
            "cur_ops->get_gp_seq()",
            "gps"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_seq_diff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "894-899",
          "snippet": "static unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_torture_current_version"
          ],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rfp->n_launders_cb"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_momentary_dyntick_idle",
          "args": [],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_momentary_dyntick_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "402-411",
          "snippet": "notrace void rcu_momentary_dyntick_idle(void)\n{\n\tint seq;\n\n\traw_cpu_write(rcu_data.rcu_need_heavy_qs, false);\n\tseq = rcu_dynticks_inc(2);\n\t/* It is illegal to call this from idle state. */\n\tWARN_ON_ONCE(!(seq & 0x1));\n\trcu_preempt_deferred_qs(current);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nnotrace void rcu_momentary_dyntick_idle(void)\n{\n\tint seq;\n\n\traw_cpu_write(rcu_data.rcu_need_heavy_qs, false);\n\tseq = rcu_dynticks_inc(2);\n\t/* It is illegal to call this from idle state. */\n\tWARN_ON_ONCE(!(seq & 0x1));\n\trcu_preempt_deferred_qs(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_enabled",
          "args": [],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_fwd_prog_cond_resched",
          "args": [
            "n_launders + n_max_cbs"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_fwd_prog_cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2224-2234",
          "snippet": "static void rcu_torture_fwd_prog_cond_resched(unsigned long iter)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPTION) && IS_ENABLED(CONFIG_NO_HZ_FULL)) {\n\t\t// Real call_rcu() floods hit userspace, so emulate that.\n\t\tif (need_resched() || (iter & 0xfff))\n\t\t\tschedule();\n\t\treturn;\n\t}\n\t// No userspace emulation: CB invocation throttles call_rcu()\n\tcond_resched();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_fwd_prog_cond_resched(unsigned long iter)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPTION) && IS_ENABLED(CONFIG_NO_HZ_FULL)) {\n\t\t// Real call_rcu() floods hit userspace, so emulate that.\n\t\tif (need_resched() || (iter & 0xfff))\n\t\t\tschedule();\n\t\treturn;\n\t}\n\t// No userspace emulation: CB invocation throttles call_rcu()\n\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->call",
          "args": [
            "&rfcp->rh",
            "rcu_torture_fwd_cb_cr"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "1"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rfcp"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*rfcp)",
            "GFP_KERNEL"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rfcp->rfc_next"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rfp->rcu_fwd_cb_head"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_fwd_emergency_stop"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "stopat"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_dep_set_task",
          "args": [
            "current",
            "TICK_DEP_BIT_RCU"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_torture_current_version"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "rfp->n_launders_hist"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rfp->rcu_fwd_startat",
            "jiffies"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->sync",
          "args": [],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_fwd_cb_nodelay",
            "true"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_fwd_emergency_stop"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define MIN_FWD_CBS_LAUNDERED\t100\t/* Number of counted CBs. */\n#define MIN_FWD_CB_LAUNDERS\t3\t/* This many CB invocations to count. */\n#define MAX_FWD_CB_JIFFIES\t(8 * HZ) /* Maximum CB test duration. */\n\nstatic unsigned long rcu_torture_current_version;\nstatic bool rcu_fwd_cb_nodelay;\nstatic struct rcu_torture_ops *cur_ops;\nstatic atomic_long_t rcu_fwd_max_cbs;\nstatic bool rcu_fwd_emergency_stop;\n\nstatic void rcu_torture_fwd_prog_cr(struct rcu_fwd *rfp)\n{\n\tunsigned long cver;\n\tunsigned long flags;\n\tunsigned long gps;\n\tint i;\n\tlong n_launders;\n\tlong n_launders_cb_snap;\n\tlong n_launders_sa;\n\tlong n_max_cbs;\n\tlong n_max_gps;\n\tstruct rcu_fwd_cb *rfcp;\n\tstruct rcu_fwd_cb *rfcpn;\n\tunsigned long stopat;\n\tunsigned long stoppedat;\n\n\tif (READ_ONCE(rcu_fwd_emergency_stop))\n\t\treturn; /* Get out of the way quickly, no GP wait! */\n\tif (!cur_ops->call)\n\t\treturn; /* Can't do call_rcu() fwd prog without ->call. */\n\n\t/* Loop continuously posting RCU callbacks. */\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, true);\n\tcur_ops->sync(); /* Later readers see above write. */\n\tWRITE_ONCE(rfp->rcu_fwd_startat, jiffies);\n\tstopat = rfp->rcu_fwd_startat + MAX_FWD_CB_JIFFIES;\n\tn_launders = 0;\n\trfp->n_launders_cb = 0; // Hoist initialization for multi-kthread\n\tn_launders_sa = 0;\n\tn_max_cbs = 0;\n\tn_max_gps = 0;\n\tfor (i = 0; i < ARRAY_SIZE(rfp->n_launders_hist); i++)\n\t\trfp->n_launders_hist[i].n_launders = 0;\n\tcver = READ_ONCE(rcu_torture_current_version);\n\tgps = cur_ops->get_gp_seq();\n\trfp->rcu_launder_gp_seq_start = gps;\n\ttick_dep_set_task(current, TICK_DEP_BIT_RCU);\n\twhile (time_before(jiffies, stopat) &&\n\t       !shutdown_time_arrived() &&\n\t       !READ_ONCE(rcu_fwd_emergency_stop) && !torture_must_stop()) {\n\t\trfcp = READ_ONCE(rfp->rcu_fwd_cb_head);\n\t\trfcpn = NULL;\n\t\tif (rfcp)\n\t\t\trfcpn = READ_ONCE(rfcp->rfc_next);\n\t\tif (rfcpn) {\n\t\t\tif (rfcp->rfc_gps >= MIN_FWD_CB_LAUNDERS &&\n\t\t\t    ++n_max_gps >= MIN_FWD_CBS_LAUNDERED)\n\t\t\t\tbreak;\n\t\t\trfp->rcu_fwd_cb_head = rfcpn;\n\t\t\tn_launders++;\n\t\t\tn_launders_sa++;\n\t\t} else if (!cur_ops->cbflood_max || cur_ops->cbflood_max > n_max_cbs) {\n\t\t\trfcp = kmalloc(sizeof(*rfcp), GFP_KERNEL);\n\t\t\tif (WARN_ON_ONCE(!rfcp)) {\n\t\t\t\tschedule_timeout_interruptible(1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tn_max_cbs++;\n\t\t\tn_launders_sa = 0;\n\t\t\trfcp->rfc_gps = 0;\n\t\t\trfcp->rfc_rfp = rfp;\n\t\t} else {\n\t\t\trfcp = NULL;\n\t\t}\n\t\tif (rfcp)\n\t\t\tcur_ops->call(&rfcp->rh, rcu_torture_fwd_cb_cr);\n\t\trcu_torture_fwd_prog_cond_resched(n_launders + n_max_cbs);\n\t\tif (tick_nohz_full_enabled()) {\n\t\t\tlocal_irq_save(flags);\n\t\t\trcu_momentary_dyntick_idle();\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t}\n\tstoppedat = jiffies;\n\tn_launders_cb_snap = READ_ONCE(rfp->n_launders_cb);\n\tcver = READ_ONCE(rcu_torture_current_version) - cver;\n\tgps = rcutorture_seq_diff(cur_ops->get_gp_seq(), gps);\n\tcur_ops->cb_barrier(); /* Wait for callbacks to be invoked. */\n\t(void)rcu_torture_fwd_prog_cbfree(rfp);\n\n\tif (!torture_must_stop() && !READ_ONCE(rcu_fwd_emergency_stop) &&\n\t    !shutdown_time_arrived()) {\n\t\tWARN_ON(n_max_gps < MIN_FWD_CBS_LAUNDERED);\n\t\tpr_alert(\"%s Duration %lu barrier: %lu pending %ld n_launders: %ld n_launders_sa: %ld n_max_gps: %ld n_max_cbs: %ld cver %ld gps %ld\\n\",\n\t\t\t __func__,\n\t\t\t stoppedat - rfp->rcu_fwd_startat, jiffies - stoppedat,\n\t\t\t n_launders + n_max_cbs - n_launders_cb_snap,\n\t\t\t n_launders, n_launders_sa,\n\t\t\t n_max_gps, n_max_cbs, cver, gps);\n\t\tatomic_long_add(n_max_cbs, &rcu_fwd_max_cbs);\n\t\trcu_torture_fwd_cb_hist(rfp);\n\t}\n\tschedule_timeout_uninterruptible(HZ); /* Let CBs drain. */\n\ttick_dep_clear_task(current, TICK_DEP_BIT_RCU);\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, false);\n}"
  },
  {
    "function_name": "rcu_torture_fwd_prog_nr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2270-2337",
    "snippet": "static void rcu_torture_fwd_prog_nr(struct rcu_fwd *rfp,\n\t\t\t\t    int *tested, int *tested_tries)\n{\n\tunsigned long cver;\n\tunsigned long dur;\n\tstruct fwd_cb_state fcs;\n\tunsigned long gps;\n\tint idx;\n\tint sd;\n\tint sd4;\n\tbool selfpropcb = false;\n\tunsigned long stopat;\n\tstatic DEFINE_TORTURE_RANDOM(trs);\n\n\tif (!cur_ops->sync)\n\t\treturn; // Cannot do need_resched() forward progress testing without ->sync.\n\tif (cur_ops->call && cur_ops->cb_barrier) {\n\t\tinit_rcu_head_on_stack(&fcs.rh);\n\t\tselfpropcb = true;\n\t}\n\n\t/* Tight loop containing cond_resched(). */\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, true);\n\tcur_ops->sync(); /* Later readers see above write. */\n\tif  (selfpropcb) {\n\t\tWRITE_ONCE(fcs.stop, 0);\n\t\tcur_ops->call(&fcs.rh, rcu_torture_fwd_prog_cb);\n\t}\n\tcver = READ_ONCE(rcu_torture_current_version);\n\tgps = cur_ops->get_gp_seq();\n\tsd = cur_ops->stall_dur() + 1;\n\tsd4 = (sd + fwd_progress_div - 1) / fwd_progress_div;\n\tdur = sd4 + torture_random(&trs) % (sd - sd4);\n\tWRITE_ONCE(rfp->rcu_fwd_startat, jiffies);\n\tstopat = rfp->rcu_fwd_startat + dur;\n\twhile (time_before(jiffies, stopat) &&\n\t       !shutdown_time_arrived() &&\n\t       !READ_ONCE(rcu_fwd_emergency_stop) && !torture_must_stop()) {\n\t\tidx = cur_ops->readlock();\n\t\tudelay(10);\n\t\tcur_ops->readunlock(idx);\n\t\tif (!fwd_progress_need_resched || need_resched())\n\t\t\tcond_resched();\n\t}\n\t(*tested_tries)++;\n\tif (!time_before(jiffies, stopat) &&\n\t    !shutdown_time_arrived() &&\n\t    !READ_ONCE(rcu_fwd_emergency_stop) && !torture_must_stop()) {\n\t\t(*tested)++;\n\t\tcver = READ_ONCE(rcu_torture_current_version) - cver;\n\t\tgps = rcutorture_seq_diff(cur_ops->get_gp_seq(), gps);\n\t\tWARN_ON(!cver && gps < 2);\n\t\tpr_alert(\"%s: %d Duration %ld cver %ld gps %ld\\n\", __func__,\n\t\t\t rfp->rcu_fwd_id, dur, cver, gps);\n\t}\n\tif (selfpropcb) {\n\t\tWRITE_ONCE(fcs.stop, 1);\n\t\tcur_ops->sync(); /* Wait for running CB to complete. */\n\t\tcur_ops->cb_barrier(); /* Wait for queued callbacks. */\n\t}\n\n\tif (selfpropcb) {\n\t\tWARN_ON(READ_ONCE(fcs.stop) != 2);\n\t\tdestroy_rcu_head_on_stack(&fcs.rh);\n\t}\n\tschedule_timeout_uninterruptible(HZ / 10); /* Let kthreads recover. */\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, false);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long rcu_torture_current_version;",
      "static bool rcu_fwd_cb_nodelay;",
      "static struct rcu_torture_ops *cur_ops;",
      "static bool rcu_fwd_emergency_stop;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_fwd_cb_nodelay",
            "false"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "HZ / 10"
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_rcu_head_on_stack",
          "args": [
            "&fcs.rh"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_rcu_head_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "455-458",
          "snippet": "void destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "READ_ONCE(fcs.stop) != 2"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "fcs.stop"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->sync",
          "args": [],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "fcs.stop",
            "1"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: %d Duration %ld cver %ld gps %ld\\n\"",
            "__func__",
            "rfp->rcu_fwd_id",
            "dur",
            "cver",
            "gps"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!cver && gps < 2"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutorture_seq_diff",
          "args": [
            "cur_ops->get_gp_seq()",
            "gps"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_seq_diff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "894-899",
          "snippet": "static unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_torture_current_version"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_fwd_emergency_stop"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown_time_arrived",
          "args": [],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "shutdown_time_arrived",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "273-276",
          "snippet": "static bool shutdown_time_arrived(void)\n{\n\treturn shutdown_secs && time_after(jiffies, shutdown_jiffies - 30 * HZ);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long shutdown_jiffies;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long shutdown_jiffies;\n\nstatic bool shutdown_time_arrived(void)\n{\n\treturn shutdown_secs && time_after(jiffies, shutdown_jiffies - 30 * HZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "stopat"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readunlock",
          "args": [
            "idx"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "10"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readlock",
          "args": [],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_fwd_emergency_stop"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "stopat"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rfp->rcu_fwd_startat",
            "jiffies"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "&trs"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->stall_dur",
          "args": [],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_torture_current_version"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->call",
          "args": [
            "&fcs.rh",
            "rcu_torture_fwd_prog_cb"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "fcs.stop",
            "0"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->sync",
          "args": [],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_fwd_cb_nodelay",
            "true"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rcu_head_on_stack",
          "args": [
            "&fcs.rh"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "init_rcu_head_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "438-441",
          "snippet": "void init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long rcu_torture_current_version;\nstatic bool rcu_fwd_cb_nodelay;\nstatic struct rcu_torture_ops *cur_ops;\nstatic bool rcu_fwd_emergency_stop;\n\nstatic void rcu_torture_fwd_prog_nr(struct rcu_fwd *rfp,\n\t\t\t\t    int *tested, int *tested_tries)\n{\n\tunsigned long cver;\n\tunsigned long dur;\n\tstruct fwd_cb_state fcs;\n\tunsigned long gps;\n\tint idx;\n\tint sd;\n\tint sd4;\n\tbool selfpropcb = false;\n\tunsigned long stopat;\n\tstatic DEFINE_TORTURE_RANDOM(trs);\n\n\tif (!cur_ops->sync)\n\t\treturn; // Cannot do need_resched() forward progress testing without ->sync.\n\tif (cur_ops->call && cur_ops->cb_barrier) {\n\t\tinit_rcu_head_on_stack(&fcs.rh);\n\t\tselfpropcb = true;\n\t}\n\n\t/* Tight loop containing cond_resched(). */\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, true);\n\tcur_ops->sync(); /* Later readers see above write. */\n\tif  (selfpropcb) {\n\t\tWRITE_ONCE(fcs.stop, 0);\n\t\tcur_ops->call(&fcs.rh, rcu_torture_fwd_prog_cb);\n\t}\n\tcver = READ_ONCE(rcu_torture_current_version);\n\tgps = cur_ops->get_gp_seq();\n\tsd = cur_ops->stall_dur() + 1;\n\tsd4 = (sd + fwd_progress_div - 1) / fwd_progress_div;\n\tdur = sd4 + torture_random(&trs) % (sd - sd4);\n\tWRITE_ONCE(rfp->rcu_fwd_startat, jiffies);\n\tstopat = rfp->rcu_fwd_startat + dur;\n\twhile (time_before(jiffies, stopat) &&\n\t       !shutdown_time_arrived() &&\n\t       !READ_ONCE(rcu_fwd_emergency_stop) && !torture_must_stop()) {\n\t\tidx = cur_ops->readlock();\n\t\tudelay(10);\n\t\tcur_ops->readunlock(idx);\n\t\tif (!fwd_progress_need_resched || need_resched())\n\t\t\tcond_resched();\n\t}\n\t(*tested_tries)++;\n\tif (!time_before(jiffies, stopat) &&\n\t    !shutdown_time_arrived() &&\n\t    !READ_ONCE(rcu_fwd_emergency_stop) && !torture_must_stop()) {\n\t\t(*tested)++;\n\t\tcver = READ_ONCE(rcu_torture_current_version) - cver;\n\t\tgps = rcutorture_seq_diff(cur_ops->get_gp_seq(), gps);\n\t\tWARN_ON(!cver && gps < 2);\n\t\tpr_alert(\"%s: %d Duration %ld cver %ld gps %ld\\n\", __func__,\n\t\t\t rfp->rcu_fwd_id, dur, cver, gps);\n\t}\n\tif (selfpropcb) {\n\t\tWRITE_ONCE(fcs.stop, 1);\n\t\tcur_ops->sync(); /* Wait for running CB to complete. */\n\t\tcur_ops->cb_barrier(); /* Wait for queued callbacks. */\n\t}\n\n\tif (selfpropcb) {\n\t\tWARN_ON(READ_ONCE(fcs.stop) != 2);\n\t\tdestroy_rcu_head_on_stack(&fcs.rh);\n\t}\n\tschedule_timeout_uninterruptible(HZ / 10); /* Let kthreads recover. */\n\tWRITE_ONCE(rcu_fwd_cb_nodelay, false);\n}"
  },
  {
    "function_name": "rcu_torture_fwd_prog_cbfree",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2240-2267",
    "snippet": "static unsigned long rcu_torture_fwd_prog_cbfree(struct rcu_fwd *rfp)\n{\n\tunsigned long flags;\n\tunsigned long freed = 0;\n\tstruct rcu_fwd_cb *rfcp;\n\n\tfor (;;) {\n\t\tspin_lock_irqsave(&rfp->rcu_fwd_lock, flags);\n\t\trfcp = rfp->rcu_fwd_cb_head;\n\t\tif (!rfcp) {\n\t\t\tspin_unlock_irqrestore(&rfp->rcu_fwd_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\trfp->rcu_fwd_cb_head = rfcp->rfc_next;\n\t\tif (!rfp->rcu_fwd_cb_head)\n\t\t\trfp->rcu_fwd_cb_tail = &rfp->rcu_fwd_cb_head;\n\t\tspin_unlock_irqrestore(&rfp->rcu_fwd_lock, flags);\n\t\tkfree(rfcp);\n\t\tfreed++;\n\t\trcu_torture_fwd_prog_cond_resched(freed);\n\t\tif (tick_nohz_full_enabled()) {\n\t\t\tlocal_irq_save(flags);\n\t\t\trcu_momentary_dyntick_idle();\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t}\n\treturn freed;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_momentary_dyntick_idle",
          "args": [],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_momentary_dyntick_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "402-411",
          "snippet": "notrace void rcu_momentary_dyntick_idle(void)\n{\n\tint seq;\n\n\traw_cpu_write(rcu_data.rcu_need_heavy_qs, false);\n\tseq = rcu_dynticks_inc(2);\n\t/* It is illegal to call this from idle state. */\n\tWARN_ON_ONCE(!(seq & 0x1));\n\trcu_preempt_deferred_qs(current);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nnotrace void rcu_momentary_dyntick_idle(void)\n{\n\tint seq;\n\n\traw_cpu_write(rcu_data.rcu_need_heavy_qs, false);\n\tseq = rcu_dynticks_inc(2);\n\t/* It is illegal to call this from idle state. */\n\tWARN_ON_ONCE(!(seq & 0x1));\n\trcu_preempt_deferred_qs(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_enabled",
          "args": [],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_fwd_prog_cond_resched",
          "args": [
            "freed"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_fwd_prog_cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "2224-2234",
          "snippet": "static void rcu_torture_fwd_prog_cond_resched(unsigned long iter)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPTION) && IS_ENABLED(CONFIG_NO_HZ_FULL)) {\n\t\t// Real call_rcu() floods hit userspace, so emulate that.\n\t\tif (need_resched() || (iter & 0xfff))\n\t\t\tschedule();\n\t\treturn;\n\t}\n\t// No userspace emulation: CB invocation throttles call_rcu()\n\tcond_resched();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_fwd_prog_cond_resched(unsigned long iter)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPTION) && IS_ENABLED(CONFIG_NO_HZ_FULL)) {\n\t\t// Real call_rcu() floods hit userspace, so emulate that.\n\t\tif (need_resched() || (iter & 0xfff))\n\t\t\tschedule();\n\t\treturn;\n\t}\n\t// No userspace emulation: CB invocation throttles call_rcu()\n\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rfcp"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "736-747",
          "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t shutdown_wq;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_ended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rfp->rcu_fwd_lock",
            "flags"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rfp->rcu_fwd_lock",
            "flags"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long rcu_torture_fwd_prog_cbfree(struct rcu_fwd *rfp)\n{\n\tunsigned long flags;\n\tunsigned long freed = 0;\n\tstruct rcu_fwd_cb *rfcp;\n\n\tfor (;;) {\n\t\tspin_lock_irqsave(&rfp->rcu_fwd_lock, flags);\n\t\trfcp = rfp->rcu_fwd_cb_head;\n\t\tif (!rfcp) {\n\t\t\tspin_unlock_irqrestore(&rfp->rcu_fwd_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\trfp->rcu_fwd_cb_head = rfcp->rfc_next;\n\t\tif (!rfp->rcu_fwd_cb_head)\n\t\t\trfp->rcu_fwd_cb_tail = &rfp->rcu_fwd_cb_head;\n\t\tspin_unlock_irqrestore(&rfp->rcu_fwd_lock, flags);\n\t\tkfree(rfcp);\n\t\tfreed++;\n\t\trcu_torture_fwd_prog_cond_resched(freed);\n\t\tif (tick_nohz_full_enabled()) {\n\t\t\tlocal_irq_save(flags);\n\t\t\trcu_momentary_dyntick_idle();\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\t}\n\treturn freed;\n}"
  },
  {
    "function_name": "rcu_torture_fwd_prog_cond_resched",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2224-2234",
    "snippet": "static void rcu_torture_fwd_prog_cond_resched(unsigned long iter)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPTION) && IS_ENABLED(CONFIG_NO_HZ_FULL)) {\n\t\t// Real call_rcu() floods hit userspace, so emulate that.\n\t\tif (need_resched() || (iter & 0xfff))\n\t\t\tschedule();\n\t\treturn;\n\t}\n\t// No userspace emulation: CB invocation throttles call_rcu()\n\tcond_resched();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_scheduler_starting",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutiny.c",
          "lines": "251-254",
          "snippet": "void __init rcu_scheduler_starting(void)\n{\n\trcu_scheduler_active = RCU_SCHEDULER_RUNNING;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcu_node_tree.h>",
            "#include <linux/srcu.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int rcu_scheduler_active"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/srcu.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint rcu_scheduler_active;\n\nvoid __init rcu_scheduler_starting(void)\n{\n\trcu_scheduler_active = RCU_SCHEDULER_RUNNING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_NO_HZ_FULL"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPTION"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_fwd_prog_cond_resched(unsigned long iter)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPTION) && IS_ENABLED(CONFIG_NO_HZ_FULL)) {\n\t\t// Real call_rcu() floods hit userspace, so emulate that.\n\t\tif (need_resched() || (iter & 0xfff))\n\t\t\tschedule();\n\t\treturn;\n\t}\n\t// No userspace emulation: CB invocation throttles call_rcu()\n\tcond_resched();\n}"
  },
  {
    "function_name": "rcu_torture_fwd_cb_cr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2200-2221",
    "snippet": "static void rcu_torture_fwd_cb_cr(struct rcu_head *rhp)\n{\n\tunsigned long flags;\n\tint i;\n\tstruct rcu_fwd_cb *rfcp = container_of(rhp, struct rcu_fwd_cb, rh);\n\tstruct rcu_fwd_cb **rfcpp;\n\tstruct rcu_fwd *rfp = rfcp->rfc_rfp;\n\n\trfcp->rfc_next = NULL;\n\trfcp->rfc_gps++;\n\tspin_lock_irqsave(&rfp->rcu_fwd_lock, flags);\n\trfcpp = rfp->rcu_fwd_cb_tail;\n\trfp->rcu_fwd_cb_tail = &rfcp->rfc_next;\n\tWRITE_ONCE(*rfcpp, rfcp);\n\tWRITE_ONCE(rfp->n_launders_cb, rfp->n_launders_cb + 1);\n\ti = ((jiffies - rfp->rcu_fwd_startat) / (HZ / FWD_CBS_HIST_DIV));\n\tif (i >= ARRAY_SIZE(rfp->n_launders_hist))\n\t\ti = ARRAY_SIZE(rfp->n_launders_hist) - 1;\n\trfp->n_launders_hist[i].n_launders++;\n\trfp->n_launders_hist[i].launder_gp_seq = cur_ops->get_gp_seq();\n\tspin_unlock_irqrestore(&rfp->rcu_fwd_lock, flags);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define FWD_CBS_HIST_DIV\t10\t/* Histogram buckets/second. */"
    ],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rfp->rcu_fwd_lock",
            "flags"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "rfp->n_launders_hist"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "rfp->n_launders_hist"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rfp->n_launders_cb",
            "rfp->n_launders_cb + 1"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*rfcpp",
            "rfcp"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rfp->rcu_fwd_lock",
            "flags"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rhp",
            "structrcu_fwd_cb",
            "rh"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FWD_CBS_HIST_DIV\t10\t/* Histogram buckets/second. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void rcu_torture_fwd_cb_cr(struct rcu_head *rhp)\n{\n\tunsigned long flags;\n\tint i;\n\tstruct rcu_fwd_cb *rfcp = container_of(rhp, struct rcu_fwd_cb, rh);\n\tstruct rcu_fwd_cb **rfcpp;\n\tstruct rcu_fwd *rfp = rfcp->rfc_rfp;\n\n\trfcp->rfc_next = NULL;\n\trfcp->rfc_gps++;\n\tspin_lock_irqsave(&rfp->rcu_fwd_lock, flags);\n\trfcpp = rfp->rcu_fwd_cb_tail;\n\trfp->rcu_fwd_cb_tail = &rfcp->rfc_next;\n\tWRITE_ONCE(*rfcpp, rfcp);\n\tWRITE_ONCE(rfp->n_launders_cb, rfp->n_launders_cb + 1);\n\ti = ((jiffies - rfp->rcu_fwd_startat) / (HZ / FWD_CBS_HIST_DIV));\n\tif (i >= ARRAY_SIZE(rfp->n_launders_hist))\n\t\ti = ARRAY_SIZE(rfp->n_launders_hist) - 1;\n\trfp->n_launders_hist[i].n_launders++;\n\trfp->n_launders_hist[i].launder_gp_seq = cur_ops->get_gp_seq();\n\tspin_unlock_irqrestore(&rfp->rcu_fwd_lock, flags);\n}"
  },
  {
    "function_name": "rcu_torture_fwd_cb_hist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2173-2197",
    "snippet": "static void rcu_torture_fwd_cb_hist(struct rcu_fwd *rfp)\n{\n\tunsigned long gps;\n\tunsigned long gps_old;\n\tint i;\n\tint j;\n\n\tfor (i = ARRAY_SIZE(rfp->n_launders_hist) - 1; i > 0; i--)\n\t\tif (rfp->n_launders_hist[i].n_launders > 0)\n\t\t\tbreak;\n\tmutex_lock(&rcu_fwd_mutex); // Serialize histograms.\n\tpr_alert(\"%s: Callback-invocation histogram %d (duration %lu jiffies):\",\n\t\t __func__, rfp->rcu_fwd_id, jiffies - rfp->rcu_fwd_startat);\n\tgps_old = rfp->rcu_launder_gp_seq_start;\n\tfor (j = 0; j <= i; j++) {\n\t\tgps = rfp->n_launders_hist[j].launder_gp_seq;\n\t\tpr_cont(\" %ds/%d: %ld:%ld\",\n\t\t\tj + 1, FWD_CBS_HIST_DIV,\n\t\t\trfp->n_launders_hist[j].n_launders,\n\t\t\trcutorture_seq_diff(gps, gps_old));\n\t\tgps_old = gps;\n\t}\n\tpr_cont(\"\\n\");\n\tmutex_unlock(&rcu_fwd_mutex);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define FWD_CBS_HIST_DIV\t10\t/* Histogram buckets/second. */"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(rcu_fwd_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rcu_fwd_mutex"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %ds/%d: %ld:%ld\"",
            "j + 1",
            "FWD_CBS_HIST_DIV",
            "rfp->n_launders_hist[j].n_launders",
            "rcutorture_seq_diff(gps, gps_old)"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutorture_seq_diff",
          "args": [
            "gps",
            "gps_old"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_seq_diff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "894-899",
          "snippet": "static unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: Callback-invocation histogram %d (duration %lu jiffies):\"",
            "__func__",
            "rfp->rcu_fwd_id",
            "jiffies - rfp->rcu_fwd_startat"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rcu_fwd_mutex"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "rfp->n_launders_hist"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FWD_CBS_HIST_DIV\t10\t/* Histogram buckets/second. */\n\nstatic DEFINE_MUTEX(rcu_fwd_mutex);\n\nstatic void rcu_torture_fwd_cb_hist(struct rcu_fwd *rfp)\n{\n\tunsigned long gps;\n\tunsigned long gps_old;\n\tint i;\n\tint j;\n\n\tfor (i = ARRAY_SIZE(rfp->n_launders_hist) - 1; i > 0; i--)\n\t\tif (rfp->n_launders_hist[i].n_launders > 0)\n\t\t\tbreak;\n\tmutex_lock(&rcu_fwd_mutex); // Serialize histograms.\n\tpr_alert(\"%s: Callback-invocation histogram %d (duration %lu jiffies):\",\n\t\t __func__, rfp->rcu_fwd_id, jiffies - rfp->rcu_fwd_startat);\n\tgps_old = rfp->rcu_launder_gp_seq_start;\n\tfor (j = 0; j <= i; j++) {\n\t\tgps = rfp->n_launders_hist[j].launder_gp_seq;\n\t\tpr_cont(\" %ds/%d: %ld:%ld\",\n\t\t\tj + 1, FWD_CBS_HIST_DIV,\n\t\t\trfp->n_launders_hist[j].n_launders,\n\t\t\trcutorture_seq_diff(gps, gps_old));\n\t\tgps_old = gps;\n\t}\n\tpr_cont(\"\\n\");\n\tmutex_unlock(&rcu_fwd_mutex);\n}"
  },
  {
    "function_name": "rcu_torture_fwd_prog_cb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2126-2135",
    "snippet": "static void rcu_torture_fwd_prog_cb(struct rcu_head *rhp)\n{\n\tstruct fwd_cb_state *fcsp = container_of(rhp, struct fwd_cb_state, rh);\n\n\tif (READ_ONCE(fcsp->stop)) {\n\t\tWRITE_ONCE(fcsp->stop, 2);\n\t\treturn;\n\t}\n\tcur_ops->call(&fcsp->rh, rcu_torture_fwd_prog_cb);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_ops->call",
          "args": [
            "&fcsp->rh",
            "rcu_torture_fwd_prog_cb"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "fcsp->stop",
            "2"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "fcsp->stop"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rhp",
            "structfwd_cb_state",
            "rh"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void rcu_torture_fwd_prog_cb(struct rcu_head *rhp)\n{\n\tstruct fwd_cb_state *fcsp = container_of(rhp, struct fwd_cb_state, rh);\n\n\tif (READ_ONCE(fcsp->stop)) {\n\t\tWRITE_ONCE(fcsp->stop, 2);\n\t\treturn;\n\t}\n\tcur_ops->call(&fcsp->rh, rcu_torture_fwd_prog_cb);\n}"
  },
  {
    "function_name": "rcu_torture_stall_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2108-2113",
    "snippet": "static int __init rcu_torture_stall_init(void)\n{\n\tif (stall_cpu <= 0 && stall_gp_kthread <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(rcu_torture_stall, NULL, stall_task);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *stall_task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_stall",
            "NULL",
            "stall_task"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *stall_task;\n\nstatic int __init rcu_torture_stall_init(void)\n{\n\tif (stall_cpu <= 0 && stall_gp_kthread <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(rcu_torture_stall, NULL, stall_task);\n}"
  },
  {
    "function_name": "rcu_torture_stall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2052-2105",
    "snippet": "static int rcu_torture_stall(void *args)\n{\n\tint idx;\n\tunsigned long stop_at;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall task started\");\n\tif (stall_cpu_holdoff > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall begin holdoff\");\n\t\tschedule_timeout_interruptible(stall_cpu_holdoff * HZ);\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall end holdoff\");\n\t}\n\tif (!kthread_should_stop() && stall_gp_kthread > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall begin GP stall\");\n\t\trcu_gp_set_torture_wait(stall_gp_kthread * HZ);\n\t\tfor (idx = 0; idx < stall_gp_kthread + 2; idx++) {\n\t\t\tif (kthread_should_stop())\n\t\t\t\tbreak;\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t}\n\t}\n\tif (!kthread_should_stop() && stall_cpu > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall begin CPU stall\");\n\t\tstop_at = ktime_get_seconds() + stall_cpu;\n\t\t/* RCU CPU stall is expected behavior in following code. */\n\t\tidx = cur_ops->readlock();\n\t\tif (stall_cpu_irqsoff)\n\t\t\tlocal_irq_disable();\n\t\telse if (!stall_cpu_block)\n\t\t\tpreempt_disable();\n\t\tpr_alert(\"%s start on CPU %d.\\n\",\n\t\t\t  __func__, raw_smp_processor_id());\n\t\twhile (ULONG_CMP_LT((unsigned long)ktime_get_seconds(),\n\t\t\t\t    stop_at))\n\t\t\tif (stall_cpu_block) {\n#ifdef CONFIG_PREEMPTION\n\t\t\t\tpreempt_schedule();\n#else\n\t\t\t\tschedule_timeout_uninterruptible(HZ);\n#endif\n\t\t\t} else if (stall_no_softlockup) {\n\t\t\t\ttouch_softlockup_watchdog();\n\t\t\t}\n\t\tif (stall_cpu_irqsoff)\n\t\t\tlocal_irq_enable();\n\t\telse if (!stall_cpu_block)\n\t\t\tpreempt_enable();\n\t\tcur_ops->readunlock(idx);\n\t}\n\tpr_alert(\"%s end.\\n\", __func__);\n\ttorture_shutdown_absorb(\"rcu_torture_stall\");\n\twhile (!kthread_should_stop())\n\t\tschedule_timeout_interruptible(10 * HZ);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "10 * HZ"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_shutdown_absorb",
          "args": [
            "\"rcu_torture_stall\""
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "608-615",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s end.\\n\"",
            "__func__"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readunlock",
          "args": [
            "idx"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog",
          "args": [],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "299-303",
          "snippet": "void touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nvoid touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "HZ"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_schedule",
          "args": [],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "preempt_schedule_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6699-6717",
          "snippet": "void __sched preempt_schedule_irq(void)\n{\n\tenum ctx_state prev_state;\n\n\t/* Catch callers which need to be fixed */\n\tBUG_ON(preempt_count() || !irqs_disabled());\n\n\tprev_state = exception_enter();\n\n\tdo {\n\t\tpreempt_disable();\n\t\tlocal_irq_enable();\n\t\t__schedule(SM_PREEMPT);\n\t\tlocal_irq_disable();\n\t\tsched_preempt_enable_no_resched();\n\t} while (need_resched());\n\n\texception_exit(prev_state);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [
            "#define SM_PREEMPT\t\t0x1"
          ],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\n#define SM_PREEMPT\t\t0x1\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched preempt_schedule_irq(void)\n{\n\tenum ctx_state prev_state;\n\n\t/* Catch callers which need to be fixed */\n\tBUG_ON(preempt_count() || !irqs_disabled());\n\n\tprev_state = exception_enter();\n\n\tdo {\n\t\tpreempt_disable();\n\t\tlocal_irq_enable();\n\t\t__schedule(SM_PREEMPT);\n\t\tlocal_irq_disable();\n\t\tsched_preempt_enable_no_resched();\n\t} while (need_resched());\n\n\texception_exit(prev_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "(unsigned long)ktime_get_seconds()",
            "stop_at"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_seconds",
          "args": [],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "982-988",
          "snippet": "time64_t ktime_get_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tWARN_ON(timekeeping_suspended);\n\treturn tk->ktime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t ktime_get_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tWARN_ON(timekeeping_suspended);\n\treturn tk->ktime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s start on CPU %d.\\n\"",
            "__func__",
            "raw_smp_processor_id()"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readlock",
          "args": [],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_stall begin CPU stall\""
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_set_torture_wait",
          "args": [
            "stall_gp_kthread * HZ"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_set_torture_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "488-488",
          "snippet": "static inline void rcu_gp_set_torture_wait(int duration) { }",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_gp_set_torture_wait(int duration) { }"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_stall begin GP stall\""
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_stall end holdoff\""
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_stall begin holdoff\""
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_stall task started\""
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcu_torture_stall(void *args)\n{\n\tint idx;\n\tunsigned long stop_at;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall task started\");\n\tif (stall_cpu_holdoff > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall begin holdoff\");\n\t\tschedule_timeout_interruptible(stall_cpu_holdoff * HZ);\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall end holdoff\");\n\t}\n\tif (!kthread_should_stop() && stall_gp_kthread > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall begin GP stall\");\n\t\trcu_gp_set_torture_wait(stall_gp_kthread * HZ);\n\t\tfor (idx = 0; idx < stall_gp_kthread + 2; idx++) {\n\t\t\tif (kthread_should_stop())\n\t\t\t\tbreak;\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t}\n\t}\n\tif (!kthread_should_stop() && stall_cpu > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall begin CPU stall\");\n\t\tstop_at = ktime_get_seconds() + stall_cpu;\n\t\t/* RCU CPU stall is expected behavior in following code. */\n\t\tidx = cur_ops->readlock();\n\t\tif (stall_cpu_irqsoff)\n\t\t\tlocal_irq_disable();\n\t\telse if (!stall_cpu_block)\n\t\t\tpreempt_disable();\n\t\tpr_alert(\"%s start on CPU %d.\\n\",\n\t\t\t  __func__, raw_smp_processor_id());\n\t\twhile (ULONG_CMP_LT((unsigned long)ktime_get_seconds(),\n\t\t\t\t    stop_at))\n\t\t\tif (stall_cpu_block) {\n#ifdef CONFIG_PREEMPTION\n\t\t\t\tpreempt_schedule();\n#else\n\t\t\t\tschedule_timeout_uninterruptible(HZ);\n#endif\n\t\t\t} else if (stall_no_softlockup) {\n\t\t\t\ttouch_softlockup_watchdog();\n\t\t\t}\n\t\tif (stall_cpu_irqsoff)\n\t\t\tlocal_irq_enable();\n\t\telse if (!stall_cpu_block)\n\t\t\tpreempt_enable();\n\t\tcur_ops->readunlock(idx);\n\t}\n\tpr_alert(\"%s end.\\n\", __func__);\n\ttorture_shutdown_absorb(\"rcu_torture_stall\");\n\twhile (!kthread_should_stop())\n\t\tschedule_timeout_interruptible(10 * HZ);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcutorture_booster_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2023-2046",
    "snippet": "static int rcutorture_booster_init(unsigned int cpu)\n{\n\tint retval;\n\n\tif (boost_tasks[cpu] != NULL)\n\t\treturn 0;  /* Already created, nothing more to do. */\n\n\t/* Don't allow time recalculation while creating a new task. */\n\tmutex_lock(&boost_mutex);\n\trcu_torture_disable_rt_throttle();\n\tVERBOSE_TOROUT_STRING(\"Creating rcu_torture_boost task\");\n\tboost_tasks[cpu] = kthread_run_on_cpu(rcu_torture_boost, NULL,\n\t\t\t\t\t      cpu, \"rcu_torture_boost_%u\");\n\tif (IS_ERR(boost_tasks[cpu])) {\n\t\tretval = PTR_ERR(boost_tasks[cpu]);\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost task create failed\");\n\t\tn_rcu_torture_boost_ktrerror++;\n\t\tboost_tasks[cpu] = NULL;\n\t\tmutex_unlock(&boost_mutex);\n\t\treturn retval;\n\t}\n\tmutex_unlock(&boost_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *boost_tasks[NR_CPUS];",
      "static long n_rcu_torture_boost_ktrerror;",
      "static DEFINE_MUTEX(boost_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&boost_mutex"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_boost task create failed\""
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "boost_tasks[cpu]"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "boost_tasks[cpu]"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run_on_cpu",
          "args": [
            "rcu_torture_boost",
            "NULL",
            "cpu",
            "\"rcu_torture_boost_%u\""
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"Creating rcu_torture_boost task\""
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_disable_rt_throttle",
          "args": [],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_disable_rt_throttle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "910-923",
          "snippet": "static void rcu_torture_disable_rt_throttle(void)\n{\n\t/*\n\t * Disable RT throttling so that rcutorture's boost threads don't get\n\t * throttled. Only possible if rcutorture is built-in otherwise the\n\t * user should manually do this by setting the sched_rt_period_us and\n\t * sched_rt_runtime sysctls.\n\t */\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime != -1)\n\t\treturn;\n\n\told_rt_runtime = sysctl_sched_rt_runtime;\n\tsysctl_sched_rt_runtime = -1;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int old_rt_runtime = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int old_rt_runtime = -1;\n\nstatic void rcu_torture_disable_rt_throttle(void)\n{\n\t/*\n\t * Disable RT throttling so that rcutorture's boost threads don't get\n\t * throttled. Only possible if rcutorture is built-in otherwise the\n\t * user should manually do this by setting the sched_rt_period_us and\n\t * sched_rt_runtime sysctls.\n\t */\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime != -1)\n\t\treturn;\n\n\told_rt_runtime = sysctl_sched_rt_runtime;\n\tsysctl_sched_rt_runtime = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&boost_mutex"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *boost_tasks[NR_CPUS];\nstatic long n_rcu_torture_boost_ktrerror;\nstatic DEFINE_MUTEX(boost_mutex);\n\nstatic int rcutorture_booster_init(unsigned int cpu)\n{\n\tint retval;\n\n\tif (boost_tasks[cpu] != NULL)\n\t\treturn 0;  /* Already created, nothing more to do. */\n\n\t/* Don't allow time recalculation while creating a new task. */\n\tmutex_lock(&boost_mutex);\n\trcu_torture_disable_rt_throttle();\n\tVERBOSE_TOROUT_STRING(\"Creating rcu_torture_boost task\");\n\tboost_tasks[cpu] = kthread_run_on_cpu(rcu_torture_boost, NULL,\n\t\t\t\t\t      cpu, \"rcu_torture_boost_%u\");\n\tif (IS_ERR(boost_tasks[cpu])) {\n\t\tretval = PTR_ERR(boost_tasks[cpu]);\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost task create failed\");\n\t\tn_rcu_torture_boost_ktrerror++;\n\t\tboost_tasks[cpu] = NULL;\n\t\tmutex_unlock(&boost_mutex);\n\t\treturn retval;\n\t}\n\tmutex_unlock(&boost_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcutorture_booster_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "2006-2021",
    "snippet": "static int rcutorture_booster_cleanup(unsigned int cpu)\n{\n\tstruct task_struct *t;\n\n\tif (boost_tasks[cpu] == NULL)\n\t\treturn 0;\n\tmutex_lock(&boost_mutex);\n\tt = boost_tasks[cpu];\n\tboost_tasks[cpu] = NULL;\n\trcu_torture_enable_rt_throttle();\n\tmutex_unlock(&boost_mutex);\n\n\t/* This must be outside of the mutex, otherwise deadlock! */\n\ttorture_stop_kthread(rcu_torture_boost, t);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *boost_tasks[NR_CPUS];",
      "static DEFINE_MUTEX(boost_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "rcu_torture_boost",
            "t"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "948-955",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&boost_mutex"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_enable_rt_throttle",
          "args": [],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_enable_rt_throttle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "925-932",
          "snippet": "static void rcu_torture_enable_rt_throttle(void)\n{\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime == -1)\n\t\treturn;\n\n\tsysctl_sched_rt_runtime = old_rt_runtime;\n\told_rt_runtime = -1;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int old_rt_runtime = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int old_rt_runtime = -1;\n\nstatic void rcu_torture_enable_rt_throttle(void)\n{\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime == -1)\n\t\treturn;\n\n\tsysctl_sched_rt_runtime = old_rt_runtime;\n\told_rt_runtime = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&boost_mutex"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *boost_tasks[NR_CPUS];\nstatic DEFINE_MUTEX(boost_mutex);\n\nstatic int rcutorture_booster_cleanup(unsigned int cpu)\n{\n\tstruct task_struct *t;\n\n\tif (boost_tasks[cpu] == NULL)\n\t\treturn 0;\n\tmutex_lock(&boost_mutex);\n\tt = boost_tasks[cpu];\n\tboost_tasks[cpu] = NULL;\n\trcu_torture_enable_rt_throttle();\n\tmutex_unlock(&boost_mutex);\n\n\t/* This must be outside of the mutex, otherwise deadlock! */\n\ttorture_stop_kthread(rcu_torture_boost, t);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_print_module_parms",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1977-2004",
    "snippet": "static void\nrcu_torture_print_module_parms(struct rcu_torture_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s: nreaders=%d nfakewriters=%d \"\n\t\t \"stat_interval=%d verbose=%d test_no_idle_hz=%d \"\n\t\t \"shuffle_interval=%d stutter=%d irqreader=%d \"\n\t\t \"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"\n\t\t \"test_boost=%d/%d test_boost_interval=%d \"\n\t\t \"test_boost_duration=%d shutdown_secs=%d \"\n\t\t \"stall_cpu=%d stall_cpu_holdoff=%d stall_cpu_irqsoff=%d \"\n\t\t \"stall_cpu_block=%d \"\n\t\t \"n_barrier_cbs=%d \"\n\t\t \"onoff_interval=%d onoff_holdoff=%d \"\n\t\t \"read_exit_delay=%d read_exit_burst=%d \"\n\t\t \"nocbs_nthreads=%d nocbs_toggle=%d\\n\",\n\t\t torture_type, tag, nrealreaders, nfakewriters,\n\t\t stat_interval, verbose, test_no_idle_hz, shuffle_interval,\n\t\t stutter, irqreader, fqs_duration, fqs_holdoff, fqs_stutter,\n\t\t test_boost, cur_ops->can_boost,\n\t\t test_boost_interval, test_boost_duration, shutdown_secs,\n\t\t stall_cpu, stall_cpu_holdoff, stall_cpu_irqsoff,\n\t\t stall_cpu_block,\n\t\t n_barrier_cbs,\n\t\t onoff_interval, onoff_holdoff,\n\t\t read_exit_delay, read_exit_burst,\n\t\t nocbs_nthreads, nocbs_toggle);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *torture_type = \"rcu\";",
      "static int nrealreaders;",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\" TORTURE_FLAG\n\t\t \"--- %s: nreaders=%d nfakewriters=%d \"\n\t\t \"stat_interval=%d verbose=%d test_no_idle_hz=%d \"\n\t\t \"shuffle_interval=%d stutter=%d irqreader=%d \"\n\t\t \"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"\n\t\t \"test_boost=%d/%d test_boost_interval=%d \"\n\t\t \"test_boost_duration=%d shutdown_secs=%d \"\n\t\t \"stall_cpu=%d stall_cpu_holdoff=%d stall_cpu_irqsoff=%d \"\n\t\t \"stall_cpu_block=%d \"\n\t\t \"n_barrier_cbs=%d \"\n\t\t \"onoff_interval=%d onoff_holdoff=%d \"\n\t\t \"read_exit_delay=%d read_exit_burst=%d \"\n\t\t \"nocbs_nthreads=%d nocbs_toggle=%d\\n\"",
            "torture_type",
            "tag",
            "nrealreaders",
            "nfakewriters",
            "stat_interval",
            "verbose",
            "test_no_idle_hz",
            "shuffle_interval",
            "stutter",
            "irqreader",
            "fqs_duration",
            "fqs_holdoff",
            "fqs_stutter",
            "test_boost",
            "cur_ops->can_boost",
            "test_boost_interval",
            "test_boost_duration",
            "shutdown_secs",
            "stall_cpu",
            "stall_cpu_holdoff",
            "stall_cpu_irqsoff",
            "stall_cpu_block",
            "n_barrier_cbs",
            "onoff_interval",
            "onoff_holdoff",
            "read_exit_delay",
            "read_exit_burst",
            "nocbs_nthreads",
            "nocbs_toggle"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type = \"rcu\";\nstatic int nrealreaders;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void\nrcu_torture_print_module_parms(struct rcu_torture_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s: nreaders=%d nfakewriters=%d \"\n\t\t \"stat_interval=%d verbose=%d test_no_idle_hz=%d \"\n\t\t \"shuffle_interval=%d stutter=%d irqreader=%d \"\n\t\t \"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"\n\t\t \"test_boost=%d/%d test_boost_interval=%d \"\n\t\t \"test_boost_duration=%d shutdown_secs=%d \"\n\t\t \"stall_cpu=%d stall_cpu_holdoff=%d stall_cpu_irqsoff=%d \"\n\t\t \"stall_cpu_block=%d \"\n\t\t \"n_barrier_cbs=%d \"\n\t\t \"onoff_interval=%d onoff_holdoff=%d \"\n\t\t \"read_exit_delay=%d read_exit_burst=%d \"\n\t\t \"nocbs_nthreads=%d nocbs_toggle=%d\\n\",\n\t\t torture_type, tag, nrealreaders, nfakewriters,\n\t\t stat_interval, verbose, test_no_idle_hz, shuffle_interval,\n\t\t stutter, irqreader, fqs_duration, fqs_holdoff, fqs_stutter,\n\t\t test_boost, cur_ops->can_boost,\n\t\t test_boost_interval, test_boost_duration, shutdown_secs,\n\t\t stall_cpu, stall_cpu_holdoff, stall_cpu_irqsoff,\n\t\t stall_cpu_block,\n\t\t n_barrier_cbs,\n\t\t onoff_interval, onoff_holdoff,\n\t\t read_exit_delay, read_exit_burst,\n\t\t nocbs_nthreads, nocbs_toggle);\n}"
  },
  {
    "function_name": "rcu_torture_mem_dump_obj",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1938-1975",
    "snippet": "static void rcu_torture_mem_dump_obj(void)\n{\n\tstruct rcu_head *rhp;\n\tstruct kmem_cache *kcp;\n\tstatic int z;\n\n\tkcp = kmem_cache_create(\"rcuscale\", 136, 8, SLAB_STORE_USER, NULL);\n\trhp = kmem_cache_alloc(kcp, GFP_KERNEL);\n\tpr_alert(\"mem_dump_obj() slab test: rcu_torture_stats = %px, &rhp = %px, rhp = %px, &z = %px\\n\", stats_task, &rhp, rhp, &z);\n\tpr_alert(\"mem_dump_obj(ZERO_SIZE_PTR):\");\n\tmem_dump_obj(ZERO_SIZE_PTR);\n\tpr_alert(\"mem_dump_obj(NULL):\");\n\tmem_dump_obj(NULL);\n\tpr_alert(\"mem_dump_obj(%px):\", &rhp);\n\tmem_dump_obj(&rhp);\n\tpr_alert(\"mem_dump_obj(%px):\", rhp);\n\tmem_dump_obj(rhp);\n\tpr_alert(\"mem_dump_obj(%px):\", &rhp->func);\n\tmem_dump_obj(&rhp->func);\n\tpr_alert(\"mem_dump_obj(%px):\", &z);\n\tmem_dump_obj(&z);\n\tkmem_cache_free(kcp, rhp);\n\tkmem_cache_destroy(kcp);\n\trhp = kmalloc(sizeof(*rhp), GFP_KERNEL);\n\tpr_alert(\"mem_dump_obj() kmalloc test: rcu_torture_stats = %px, &rhp = %px, rhp = %px\\n\", stats_task, &rhp, rhp);\n\tpr_alert(\"mem_dump_obj(kmalloc %px):\", rhp);\n\tmem_dump_obj(rhp);\n\tpr_alert(\"mem_dump_obj(kmalloc %px):\", &rhp->func);\n\tmem_dump_obj(&rhp->func);\n\tkfree(rhp);\n\trhp = vmalloc(4096);\n\tpr_alert(\"mem_dump_obj() vmalloc test: rcu_torture_stats = %px, &rhp = %px, rhp = %px\\n\", stats_task, &rhp, rhp);\n\tpr_alert(\"mem_dump_obj(vmalloc %px):\", rhp);\n\tmem_dump_obj(rhp);\n\tpr_alert(\"mem_dump_obj(vmalloc %px):\", &rhp->func);\n\tmem_dump_obj(&rhp->func);\n\tvfree(rhp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *stats_task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "rhp"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_dump_obj",
          "args": [
            "&rhp->func"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"mem_dump_obj(vmalloc %px):\"",
            "&rhp->func"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_dump_obj",
          "args": [
            "rhp"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"mem_dump_obj(vmalloc %px):\"",
            "rhp"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"mem_dump_obj() vmalloc test: rcu_torture_stats = %px, &rhp = %px, rhp = %px\\n\"",
            "stats_task",
            "&rhp",
            "rhp"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "4096"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "array_map_vmalloc_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "379-382",
          "snippet": "static void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rhp"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "736-747",
          "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t shutdown_wq;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_ended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_dump_obj",
          "args": [
            "&rhp->func"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"mem_dump_obj(kmalloc %px):\"",
            "&rhp->func"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_dump_obj",
          "args": [
            "rhp"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"mem_dump_obj(kmalloc %px):\"",
            "rhp"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"mem_dump_obj() kmalloc test: rcu_torture_stats = %px, &rhp = %px, rhp = %px\\n\"",
            "stats_task",
            "&rhp",
            "rhp"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*rhp)",
            "GFP_KERNEL"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "kcp"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kcp",
            "rhp"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_dump_obj",
          "args": [
            "&z"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"mem_dump_obj(%px):\"",
            "&z"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_dump_obj",
          "args": [
            "&rhp->func"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"mem_dump_obj(%px):\"",
            "&rhp->func"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_dump_obj",
          "args": [
            "rhp"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"mem_dump_obj(%px):\"",
            "rhp"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_dump_obj",
          "args": [
            "&rhp"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"mem_dump_obj(%px):\"",
            "&rhp"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_dump_obj",
          "args": [
            "NULL"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"mem_dump_obj(NULL):\""
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_dump_obj",
          "args": [
            "ZERO_SIZE_PTR"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"mem_dump_obj(ZERO_SIZE_PTR):\""
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"mem_dump_obj() slab test: rcu_torture_stats = %px, &rhp = %px, rhp = %px, &z = %px\\n\"",
            "stats_task",
            "&rhp",
            "rhp",
            "&z"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "kcp",
            "GFP_KERNEL"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"rcuscale\"",
            "136",
            "8",
            "SLAB_STORE_USER",
            "NULL"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *stats_task;\n\nstatic void rcu_torture_mem_dump_obj(void)\n{\n\tstruct rcu_head *rhp;\n\tstruct kmem_cache *kcp;\n\tstatic int z;\n\n\tkcp = kmem_cache_create(\"rcuscale\", 136, 8, SLAB_STORE_USER, NULL);\n\trhp = kmem_cache_alloc(kcp, GFP_KERNEL);\n\tpr_alert(\"mem_dump_obj() slab test: rcu_torture_stats = %px, &rhp = %px, rhp = %px, &z = %px\\n\", stats_task, &rhp, rhp, &z);\n\tpr_alert(\"mem_dump_obj(ZERO_SIZE_PTR):\");\n\tmem_dump_obj(ZERO_SIZE_PTR);\n\tpr_alert(\"mem_dump_obj(NULL):\");\n\tmem_dump_obj(NULL);\n\tpr_alert(\"mem_dump_obj(%px):\", &rhp);\n\tmem_dump_obj(&rhp);\n\tpr_alert(\"mem_dump_obj(%px):\", rhp);\n\tmem_dump_obj(rhp);\n\tpr_alert(\"mem_dump_obj(%px):\", &rhp->func);\n\tmem_dump_obj(&rhp->func);\n\tpr_alert(\"mem_dump_obj(%px):\", &z);\n\tmem_dump_obj(&z);\n\tkmem_cache_free(kcp, rhp);\n\tkmem_cache_destroy(kcp);\n\trhp = kmalloc(sizeof(*rhp), GFP_KERNEL);\n\tpr_alert(\"mem_dump_obj() kmalloc test: rcu_torture_stats = %px, &rhp = %px, rhp = %px\\n\", stats_task, &rhp, rhp);\n\tpr_alert(\"mem_dump_obj(kmalloc %px):\", rhp);\n\tmem_dump_obj(rhp);\n\tpr_alert(\"mem_dump_obj(kmalloc %px):\", &rhp->func);\n\tmem_dump_obj(&rhp->func);\n\tkfree(rhp);\n\trhp = vmalloc(4096);\n\tpr_alert(\"mem_dump_obj() vmalloc test: rcu_torture_stats = %px, &rhp = %px, rhp = %px\\n\", stats_task, &rhp, rhp);\n\tpr_alert(\"mem_dump_obj(vmalloc %px):\", rhp);\n\tmem_dump_obj(rhp);\n\tpr_alert(\"mem_dump_obj(vmalloc %px):\", &rhp->func);\n\tmem_dump_obj(&rhp->func);\n\tvfree(rhp);\n}"
  },
  {
    "function_name": "rcu_torture_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1924-1935",
    "snippet": "static int\nrcu_torture_stats(void *arg)\n{\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_stats task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(stat_interval * HZ);\n\t\trcu_torture_stats_print();\n\t\ttorture_shutdown_absorb(\"rcu_torture_stats\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_torture_stats\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_stats\""
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_shutdown_absorb",
          "args": [
            "\"rcu_torture_stats\""
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "608-615",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_stats_print",
          "args": [],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_stats_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1805-1918",
          "snippet": "static void\nrcu_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong pipesummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tlong batchsummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tstruct rcu_torture *rtcp;\n\tstatic unsigned long rtcv_snap = ULONG_MAX;\n\tstatic bool splatted;\n\tstruct task_struct *wtp;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tpipesummary[i] += READ_ONCE(per_cpu(rcu_torture_count, cpu)[i]);\n\t\t\tbatchsummary[i] += READ_ONCE(per_cpu(rcu_torture_batch, cpu)[i]);\n\t\t}\n\t}\n\tfor (i = RCU_TORTURE_PIPE_LEN - 1; i >= 0; i--) {\n\t\tif (pipesummary[i] != 0)\n\t\t\tbreak;\n\t}\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\trtcp = rcu_access_pointer(rcu_torture_current);\n\tpr_cont(\"rtc: %p %s: %lu tfle: %d rta: %d rtaf: %d rtf: %d \",\n\t\trtcp,\n\t\trtcp && !rcu_stall_is_suppressed_at_boot() ? \"ver\" : \"VER\",\n\t\trcu_torture_current_version,\n\t\tlist_empty(&rcu_torture_freelist),\n\t\tatomic_read(&n_rcu_torture_alloc),\n\t\tatomic_read(&n_rcu_torture_alloc_fail),\n\t\tatomic_read(&n_rcu_torture_free));\n\tpr_cont(\"rtmbe: %d rtmbkf: %d/%d rtbe: %ld rtbke: %ld rtbre: %ld \",\n\t\tatomic_read(&n_rcu_torture_mberror),\n\t\tatomic_read(&n_rcu_torture_mbchk_fail), atomic_read(&n_rcu_torture_mbchk_tries),\n\t\tn_rcu_torture_barrier_error,\n\t\tn_rcu_torture_boost_ktrerror,\n\t\tn_rcu_torture_boost_rterror);\n\tpr_cont(\"rtbf: %ld rtb: %ld nt: %ld \",\n\t\tn_rcu_torture_boost_failure,\n\t\tn_rcu_torture_boosts,\n\t\tatomic_long_read(&n_rcu_torture_timers));\n\ttorture_onoff_stats();\n\tpr_cont(\"barrier: %ld/%ld:%ld \",\n\t\tdata_race(n_barrier_successes),\n\t\tdata_race(n_barrier_attempts),\n\t\tdata_race(n_rcu_torture_barrier_error));\n\tpr_cont(\"read-exits: %ld \", data_race(n_read_exits)); // Statistic.\n\tpr_cont(\"nocb-toggles: %ld:%ld\\n\",\n\t\tatomic_long_read(&n_nocb_offload), atomic_long_read(&n_nocb_deoffload));\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tif (atomic_read(&n_rcu_torture_mberror) ||\n\t    atomic_read(&n_rcu_torture_mbchk_fail) ||\n\t    n_rcu_torture_barrier_error || n_rcu_torture_boost_ktrerror ||\n\t    n_rcu_torture_boost_rterror || n_rcu_torture_boost_failure ||\n\t    i > 1) {\n\t\tpr_cont(\"%s\", \"!!! \");\n\t\tatomic_inc(&n_rcu_torture_error);\n\t\tWARN_ON_ONCE(atomic_read(&n_rcu_torture_mberror));\n\t\tWARN_ON_ONCE(atomic_read(&n_rcu_torture_mbchk_fail));\n\t\tWARN_ON_ONCE(n_rcu_torture_barrier_error);  // rcu_barrier()\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_ktrerror); // no boost kthread\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_rterror); // can't set RT prio\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_failure); // boost failed (TIMER_SOFTIRQ RT prio?)\n\t\tWARN_ON_ONCE(i > 1); // Too-short grace period\n\t}\n\tpr_cont(\"Reader Pipe: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", pipesummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Reader Batch: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", batchsummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Free-Block Circulation: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\tpr_cont(\" %d\", atomic_read(&rcu_torture_wcount[i]));\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (cur_ops->stats)\n\t\tcur_ops->stats();\n\tif (rtcv_snap == rcu_torture_current_version &&\n\t    rcu_access_pointer(rcu_torture_current) &&\n\t    !rcu_stall_is_suppressed()) {\n\t\tint __maybe_unused flags = 0;\n\t\tunsigned long __maybe_unused gp_seq = 0;\n\n\t\trcutorture_get_gp_data(cur_ops->ttype,\n\t\t\t\t       &flags, &gp_seq);\n\t\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp,\n\t\t\t\t\t&flags, &gp_seq);\n\t\twtp = READ_ONCE(writer_task);\n\t\tpr_alert(\"??? Writer stall state %s(%d) g%lu f%#x ->state %#x cpu %d\\n\",\n\t\t\t rcu_torture_writer_state_getname(),\n\t\t\t rcu_torture_writer_state, gp_seq, flags,\n\t\t\t wtp == NULL ? ~0U : wtp->__state,\n\t\t\t wtp == NULL ? -1 : (int)task_cpu(wtp));\n\t\tif (!splatted && wtp) {\n\t\t\tsched_show_task(wtp);\n\t\t\tsplatted = true;\n\t\t}\n\t\tif (cur_ops->gp_kthread_dbg)\n\t\t\tcur_ops->gp_kthread_dbg();\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\trtcv_snap = rcu_torture_current_version;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_TORTURE_PIPE_LEN 10"
          ],
          "globals_used": [
            "static char *torture_type = \"rcu\";",
            "static struct task_struct *writer_task;",
            "static LIST_HEAD(rcu_torture_freelist);",
            "static struct rcu_torture __rcu *rcu_torture_current;",
            "static unsigned long rcu_torture_current_version;",
            "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];",
            "static atomic_t n_rcu_torture_alloc;",
            "static atomic_t n_rcu_torture_alloc_fail;",
            "static atomic_t n_rcu_torture_free;",
            "static atomic_t n_rcu_torture_mberror;",
            "static atomic_t n_rcu_torture_mbchk_fail;",
            "static atomic_t n_rcu_torture_mbchk_tries;",
            "static atomic_t n_rcu_torture_error;",
            "static long n_rcu_torture_barrier_error;",
            "static long n_rcu_torture_boost_ktrerror;",
            "static long n_rcu_torture_boost_rterror;",
            "static long n_rcu_torture_boost_failure;",
            "static long n_rcu_torture_boosts;",
            "static atomic_long_t n_rcu_torture_timers;",
            "static long n_barrier_attempts;",
            "static long n_barrier_successes;",
            "static unsigned long n_read_exits;",
            "static atomic_long_t n_nocb_offload;",
            "static atomic_long_t n_nocb_deoffload;",
            "static int rcu_torture_writer_state;",
            "static struct rcu_torture_ops *cur_ops;",
            "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic char *torture_type = \"rcu\";\nstatic struct task_struct *writer_task;\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic unsigned long rcu_torture_current_version;\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\nstatic atomic_t n_rcu_torture_alloc;\nstatic atomic_t n_rcu_torture_alloc_fail;\nstatic atomic_t n_rcu_torture_free;\nstatic atomic_t n_rcu_torture_mberror;\nstatic atomic_t n_rcu_torture_mbchk_fail;\nstatic atomic_t n_rcu_torture_mbchk_tries;\nstatic atomic_t n_rcu_torture_error;\nstatic long n_rcu_torture_barrier_error;\nstatic long n_rcu_torture_boost_ktrerror;\nstatic long n_rcu_torture_boost_rterror;\nstatic long n_rcu_torture_boost_failure;\nstatic long n_rcu_torture_boosts;\nstatic atomic_long_t n_rcu_torture_timers;\nstatic long n_barrier_attempts;\nstatic long n_barrier_successes;\nstatic unsigned long n_read_exits;\nstatic atomic_long_t n_nocb_offload;\nstatic atomic_long_t n_nocb_deoffload;\nstatic int rcu_torture_writer_state;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void\nrcu_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong pipesummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tlong batchsummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tstruct rcu_torture *rtcp;\n\tstatic unsigned long rtcv_snap = ULONG_MAX;\n\tstatic bool splatted;\n\tstruct task_struct *wtp;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tpipesummary[i] += READ_ONCE(per_cpu(rcu_torture_count, cpu)[i]);\n\t\t\tbatchsummary[i] += READ_ONCE(per_cpu(rcu_torture_batch, cpu)[i]);\n\t\t}\n\t}\n\tfor (i = RCU_TORTURE_PIPE_LEN - 1; i >= 0; i--) {\n\t\tif (pipesummary[i] != 0)\n\t\t\tbreak;\n\t}\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\trtcp = rcu_access_pointer(rcu_torture_current);\n\tpr_cont(\"rtc: %p %s: %lu tfle: %d rta: %d rtaf: %d rtf: %d \",\n\t\trtcp,\n\t\trtcp && !rcu_stall_is_suppressed_at_boot() ? \"ver\" : \"VER\",\n\t\trcu_torture_current_version,\n\t\tlist_empty(&rcu_torture_freelist),\n\t\tatomic_read(&n_rcu_torture_alloc),\n\t\tatomic_read(&n_rcu_torture_alloc_fail),\n\t\tatomic_read(&n_rcu_torture_free));\n\tpr_cont(\"rtmbe: %d rtmbkf: %d/%d rtbe: %ld rtbke: %ld rtbre: %ld \",\n\t\tatomic_read(&n_rcu_torture_mberror),\n\t\tatomic_read(&n_rcu_torture_mbchk_fail), atomic_read(&n_rcu_torture_mbchk_tries),\n\t\tn_rcu_torture_barrier_error,\n\t\tn_rcu_torture_boost_ktrerror,\n\t\tn_rcu_torture_boost_rterror);\n\tpr_cont(\"rtbf: %ld rtb: %ld nt: %ld \",\n\t\tn_rcu_torture_boost_failure,\n\t\tn_rcu_torture_boosts,\n\t\tatomic_long_read(&n_rcu_torture_timers));\n\ttorture_onoff_stats();\n\tpr_cont(\"barrier: %ld/%ld:%ld \",\n\t\tdata_race(n_barrier_successes),\n\t\tdata_race(n_barrier_attempts),\n\t\tdata_race(n_rcu_torture_barrier_error));\n\tpr_cont(\"read-exits: %ld \", data_race(n_read_exits)); // Statistic.\n\tpr_cont(\"nocb-toggles: %ld:%ld\\n\",\n\t\tatomic_long_read(&n_nocb_offload), atomic_long_read(&n_nocb_deoffload));\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tif (atomic_read(&n_rcu_torture_mberror) ||\n\t    atomic_read(&n_rcu_torture_mbchk_fail) ||\n\t    n_rcu_torture_barrier_error || n_rcu_torture_boost_ktrerror ||\n\t    n_rcu_torture_boost_rterror || n_rcu_torture_boost_failure ||\n\t    i > 1) {\n\t\tpr_cont(\"%s\", \"!!! \");\n\t\tatomic_inc(&n_rcu_torture_error);\n\t\tWARN_ON_ONCE(atomic_read(&n_rcu_torture_mberror));\n\t\tWARN_ON_ONCE(atomic_read(&n_rcu_torture_mbchk_fail));\n\t\tWARN_ON_ONCE(n_rcu_torture_barrier_error);  // rcu_barrier()\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_ktrerror); // no boost kthread\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_rterror); // can't set RT prio\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_failure); // boost failed (TIMER_SOFTIRQ RT prio?)\n\t\tWARN_ON_ONCE(i > 1); // Too-short grace period\n\t}\n\tpr_cont(\"Reader Pipe: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", pipesummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Reader Batch: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", batchsummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Free-Block Circulation: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\tpr_cont(\" %d\", atomic_read(&rcu_torture_wcount[i]));\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (cur_ops->stats)\n\t\tcur_ops->stats();\n\tif (rtcv_snap == rcu_torture_current_version &&\n\t    rcu_access_pointer(rcu_torture_current) &&\n\t    !rcu_stall_is_suppressed()) {\n\t\tint __maybe_unused flags = 0;\n\t\tunsigned long __maybe_unused gp_seq = 0;\n\n\t\trcutorture_get_gp_data(cur_ops->ttype,\n\t\t\t\t       &flags, &gp_seq);\n\t\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp,\n\t\t\t\t\t&flags, &gp_seq);\n\t\twtp = READ_ONCE(writer_task);\n\t\tpr_alert(\"??? Writer stall state %s(%d) g%lu f%#x ->state %#x cpu %d\\n\",\n\t\t\t rcu_torture_writer_state_getname(),\n\t\t\t rcu_torture_writer_state, gp_seq, flags,\n\t\t\t wtp == NULL ? ~0U : wtp->__state,\n\t\t\t wtp == NULL ? -1 : (int)task_cpu(wtp));\n\t\tif (!splatted && wtp) {\n\t\t\tsched_show_task(wtp);\n\t\t\tsplatted = true;\n\t\t}\n\t\tif (cur_ops->gp_kthread_dbg)\n\t\t\tcur_ops->gp_kthread_dbg();\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\trtcv_snap = rcu_torture_current_version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "stat_interval * HZ"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_stats task started\""
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int\nrcu_torture_stats(void *arg)\n{\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_stats task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(stat_interval * HZ);\n\t\trcu_torture_stats_print();\n\t\ttorture_shutdown_absorb(\"rcu_torture_stats\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_torture_stats\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_stats_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1805-1918",
    "snippet": "static void\nrcu_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong pipesummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tlong batchsummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tstruct rcu_torture *rtcp;\n\tstatic unsigned long rtcv_snap = ULONG_MAX;\n\tstatic bool splatted;\n\tstruct task_struct *wtp;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tpipesummary[i] += READ_ONCE(per_cpu(rcu_torture_count, cpu)[i]);\n\t\t\tbatchsummary[i] += READ_ONCE(per_cpu(rcu_torture_batch, cpu)[i]);\n\t\t}\n\t}\n\tfor (i = RCU_TORTURE_PIPE_LEN - 1; i >= 0; i--) {\n\t\tif (pipesummary[i] != 0)\n\t\t\tbreak;\n\t}\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\trtcp = rcu_access_pointer(rcu_torture_current);\n\tpr_cont(\"rtc: %p %s: %lu tfle: %d rta: %d rtaf: %d rtf: %d \",\n\t\trtcp,\n\t\trtcp && !rcu_stall_is_suppressed_at_boot() ? \"ver\" : \"VER\",\n\t\trcu_torture_current_version,\n\t\tlist_empty(&rcu_torture_freelist),\n\t\tatomic_read(&n_rcu_torture_alloc),\n\t\tatomic_read(&n_rcu_torture_alloc_fail),\n\t\tatomic_read(&n_rcu_torture_free));\n\tpr_cont(\"rtmbe: %d rtmbkf: %d/%d rtbe: %ld rtbke: %ld rtbre: %ld \",\n\t\tatomic_read(&n_rcu_torture_mberror),\n\t\tatomic_read(&n_rcu_torture_mbchk_fail), atomic_read(&n_rcu_torture_mbchk_tries),\n\t\tn_rcu_torture_barrier_error,\n\t\tn_rcu_torture_boost_ktrerror,\n\t\tn_rcu_torture_boost_rterror);\n\tpr_cont(\"rtbf: %ld rtb: %ld nt: %ld \",\n\t\tn_rcu_torture_boost_failure,\n\t\tn_rcu_torture_boosts,\n\t\tatomic_long_read(&n_rcu_torture_timers));\n\ttorture_onoff_stats();\n\tpr_cont(\"barrier: %ld/%ld:%ld \",\n\t\tdata_race(n_barrier_successes),\n\t\tdata_race(n_barrier_attempts),\n\t\tdata_race(n_rcu_torture_barrier_error));\n\tpr_cont(\"read-exits: %ld \", data_race(n_read_exits)); // Statistic.\n\tpr_cont(\"nocb-toggles: %ld:%ld\\n\",\n\t\tatomic_long_read(&n_nocb_offload), atomic_long_read(&n_nocb_deoffload));\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tif (atomic_read(&n_rcu_torture_mberror) ||\n\t    atomic_read(&n_rcu_torture_mbchk_fail) ||\n\t    n_rcu_torture_barrier_error || n_rcu_torture_boost_ktrerror ||\n\t    n_rcu_torture_boost_rterror || n_rcu_torture_boost_failure ||\n\t    i > 1) {\n\t\tpr_cont(\"%s\", \"!!! \");\n\t\tatomic_inc(&n_rcu_torture_error);\n\t\tWARN_ON_ONCE(atomic_read(&n_rcu_torture_mberror));\n\t\tWARN_ON_ONCE(atomic_read(&n_rcu_torture_mbchk_fail));\n\t\tWARN_ON_ONCE(n_rcu_torture_barrier_error);  // rcu_barrier()\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_ktrerror); // no boost kthread\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_rterror); // can't set RT prio\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_failure); // boost failed (TIMER_SOFTIRQ RT prio?)\n\t\tWARN_ON_ONCE(i > 1); // Too-short grace period\n\t}\n\tpr_cont(\"Reader Pipe: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", pipesummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Reader Batch: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", batchsummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Free-Block Circulation: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\tpr_cont(\" %d\", atomic_read(&rcu_torture_wcount[i]));\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (cur_ops->stats)\n\t\tcur_ops->stats();\n\tif (rtcv_snap == rcu_torture_current_version &&\n\t    rcu_access_pointer(rcu_torture_current) &&\n\t    !rcu_stall_is_suppressed()) {\n\t\tint __maybe_unused flags = 0;\n\t\tunsigned long __maybe_unused gp_seq = 0;\n\n\t\trcutorture_get_gp_data(cur_ops->ttype,\n\t\t\t\t       &flags, &gp_seq);\n\t\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp,\n\t\t\t\t\t&flags, &gp_seq);\n\t\twtp = READ_ONCE(writer_task);\n\t\tpr_alert(\"??? Writer stall state %s(%d) g%lu f%#x ->state %#x cpu %d\\n\",\n\t\t\t rcu_torture_writer_state_getname(),\n\t\t\t rcu_torture_writer_state, gp_seq, flags,\n\t\t\t wtp == NULL ? ~0U : wtp->__state,\n\t\t\t wtp == NULL ? -1 : (int)task_cpu(wtp));\n\t\tif (!splatted && wtp) {\n\t\t\tsched_show_task(wtp);\n\t\t\tsplatted = true;\n\t\t}\n\t\tif (cur_ops->gp_kthread_dbg)\n\t\t\tcur_ops->gp_kthread_dbg();\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\trtcv_snap = rcu_torture_current_version;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_TORTURE_PIPE_LEN 10"
    ],
    "globals_used": [
      "static char *torture_type = \"rcu\";",
      "static struct task_struct *writer_task;",
      "static LIST_HEAD(rcu_torture_freelist);",
      "static struct rcu_torture __rcu *rcu_torture_current;",
      "static unsigned long rcu_torture_current_version;",
      "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];",
      "static atomic_t n_rcu_torture_alloc;",
      "static atomic_t n_rcu_torture_alloc_fail;",
      "static atomic_t n_rcu_torture_free;",
      "static atomic_t n_rcu_torture_mberror;",
      "static atomic_t n_rcu_torture_mbchk_fail;",
      "static atomic_t n_rcu_torture_mbchk_tries;",
      "static atomic_t n_rcu_torture_error;",
      "static long n_rcu_torture_barrier_error;",
      "static long n_rcu_torture_boost_ktrerror;",
      "static long n_rcu_torture_boost_rterror;",
      "static long n_rcu_torture_boost_failure;",
      "static long n_rcu_torture_boosts;",
      "static atomic_long_t n_rcu_torture_timers;",
      "static long n_barrier_attempts;",
      "static long n_barrier_successes;",
      "static unsigned long n_read_exits;",
      "static atomic_long_t n_nocb_offload;",
      "static atomic_long_t n_nocb_deoffload;",
      "static int rcu_torture_writer_state;",
      "static struct rcu_torture_ops *cur_ops;",
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->gp_kthread_dbg",
          "args": [],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_show_task",
          "args": [
            "wtp"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "sched_show_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8544-8572",
          "snippet": "void sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tpr_info(\"task:%-15.15s state:%c\", p->comm, task_state_to_char(p));\n\n\tif (task_is_running(p))\n\t\tpr_cont(\"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpr_cont(\" stack:%5lu pid:%5d ppid:%6d flags:0x%08lx\\n\",\n\t\tfree, task_pid_nr(p), ppid,\n\t\tread_task_thread_flags(p));\n\n\tprint_worker_info(KERN_INFO, p);\n\tprint_stop_info(KERN_INFO, p);\n\tshow_stack(p, NULL, KERN_INFO);\n\tput_task_stack(p);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tpr_info(\"task:%-15.15s state:%c\", p->comm, task_state_to_char(p));\n\n\tif (task_is_running(p))\n\t\tpr_cont(\"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpr_cont(\" stack:%5lu pid:%5d ppid:%6d flags:0x%08lx\\n\",\n\t\tfree, task_pid_nr(p), ppid,\n\t\tread_task_thread_flags(p));\n\n\tprint_worker_info(KERN_INFO, p);\n\tprint_stop_info(KERN_INFO, p);\n\tshow_stack(p, NULL, KERN_INFO);\n\tput_task_stack(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"??? Writer stall state %s(%d) g%lu f%#x ->state %#x cpu %d\\n\"",
            "rcu_torture_writer_state_getname()",
            "rcu_torture_writer_state",
            "gp_seq",
            "flags",
            "wtp == NULL ? ~0U : wtp->__state",
            "wtp == NULL ? -1 : (int)task_cpu(wtp)"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "wtp"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_writer_state_getname",
          "args": [],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_writer_state_getname",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "245-252",
          "snippet": "static const char *rcu_torture_writer_state_getname(void)\n{\n\tunsigned int i = READ_ONCE(rcu_torture_writer_state);\n\n\tif (i >= ARRAY_SIZE(rcu_torture_writer_state_names))\n\t\treturn \"???\";\n\treturn rcu_torture_writer_state_names[i];\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_torture_writer_state;",
            "static const char * const rcu_torture_writer_state_names[] = {\n\t\"RTWS_FIXED_DELAY\",\n\t\"RTWS_DELAY\",\n\t\"RTWS_REPLACE\",\n\t\"RTWS_DEF_FREE\",\n\t\"RTWS_EXP_SYNC\",\n\t\"RTWS_COND_GET\",\n\t\"RTWS_COND_SYNC\",\n\t\"RTWS_POLL_GET\",\n\t\"RTWS_POLL_WAIT\",\n\t\"RTWS_SYNC\",\n\t\"RTWS_STUTTER\",\n\t\"RTWS_STOPPING\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_torture_writer_state;\nstatic const char * const rcu_torture_writer_state_names[] = {\n\t\"RTWS_FIXED_DELAY\",\n\t\"RTWS_DELAY\",\n\t\"RTWS_REPLACE\",\n\t\"RTWS_DEF_FREE\",\n\t\"RTWS_EXP_SYNC\",\n\t\"RTWS_COND_GET\",\n\t\"RTWS_COND_SYNC\",\n\t\"RTWS_POLL_GET\",\n\t\"RTWS_POLL_WAIT\",\n\t\"RTWS_SYNC\",\n\t\"RTWS_STUTTER\",\n\t\"RTWS_STOPPING\",\n};\n\nstatic const char *rcu_torture_writer_state_getname(void)\n{\n\tunsigned int i = READ_ONCE(rcu_torture_writer_state);\n\n\tif (i >= ARRAY_SIZE(rcu_torture_writer_state_names))\n\t\treturn \"???\";\n\treturn rcu_torture_writer_state_names[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "writer_task"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcutorture_get_gp_data",
          "args": [
            "cur_ops->ttype",
            "srcu_ctlp",
            "&flags",
            "&gp_seq"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "srcutorture_get_gp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1329-1337",
          "snippet": "void srcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t     struct srcu_struct *ssp, int *flags,\n\t\t\t     unsigned long *gp_seq)\n{\n\tif (test_type != SRCU_FLAVOR)\n\t\treturn;\n\t*flags = 0;\n\t*gp_seq = rcu_seq_current(&ssp->srcu_gp_seq);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid srcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t     struct srcu_struct *ssp, int *flags,\n\t\t\t     unsigned long *gp_seq)\n{\n\tif (test_type != SRCU_FLAVOR)\n\t\treturn;\n\t*flags = 0;\n\t*gp_seq = rcu_seq_current(&ssp->srcu_gp_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcutorture_get_gp_data",
          "args": [
            "cur_ops->ttype",
            "&flags",
            "&gp_seq"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_get_gp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "472-477",
          "snippet": "static inline void rcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t\t\t  int *flags, unsigned long *gp_seq)\n{\n\t*flags = 0;\n\t*gp_seq = 0;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t\t\t  int *flags, unsigned long *gp_seq)\n{\n\t*flags = 0;\n\t*gp_seq = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_stall_is_suppressed",
          "args": [],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_stall_is_suppressed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "234-237",
          "snippet": "static inline bool rcu_stall_is_suppressed(void)\n{\n\treturn rcu_stall_is_suppressed_at_boot();\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_stall_is_suppressed(void)\n{\n\treturn rcu_stall_is_suppressed_at_boot();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "rcu_torture_current"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->stats",
          "args": [],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %d\"",
            "atomic_read(&rcu_torture_wcount[i])"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rcu_torture_wcount[i]"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s%s \"",
            "torture_type",
            "TORTURE_FLAG"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s%s \"",
            "torture_type",
            "TORTURE_FLAG"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "i > 1"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "n_rcu_torture_boost_failure"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "n_rcu_torture_boost_rterror"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "n_rcu_torture_boost_ktrerror"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "n_rcu_torture_barrier_error"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&n_rcu_torture_mbchk_fail)"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_mbchk_fail"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&n_rcu_torture_mberror)"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_mberror"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_rcu_torture_error"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_mbchk_fail"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_mberror"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s%s \"",
            "torture_type",
            "TORTURE_FLAG"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"nocb-toggles: %ld:%ld\\n\"",
            "atomic_long_read(&n_nocb_offload)",
            "atomic_long_read(&n_nocb_deoffload)"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n_nocb_deoffload"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n_nocb_offload"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "n_read_exits"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"barrier: %ld/%ld:%ld \"",
            "data_race(n_barrier_successes)",
            "data_race(n_barrier_attempts)",
            "data_race(n_rcu_torture_barrier_error)"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_onoff_stats",
          "args": [],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "torture_onoff_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "414-424",
          "snippet": "void torture_onoff_stats(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tpr_cont(\"onoff: %ld/%ld:%ld/%ld %d,%d:%d,%d %lu:%lu (HZ=%d) \",\n\t\tn_online_successes, n_online_attempts,\n\t\tn_offline_successes, n_offline_attempts,\n\t\tmin_online, max_online,\n\t\tmin_offline, max_offline,\n\t\tsum_online, sum_offline, HZ);\n#endif /* #ifdef CONFIG_HOTPLUG_CPU */\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_onoff_stats(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tpr_cont(\"onoff: %ld/%ld:%ld/%ld %d,%d:%d,%d %lu:%lu (HZ=%d) \",\n\t\tn_online_successes, n_online_attempts,\n\t\tn_offline_successes, n_offline_attempts,\n\t\tmin_online, max_online,\n\t\tmin_offline, max_offline,\n\t\tsum_online, sum_offline, HZ);\n#endif /* #ifdef CONFIG_HOTPLUG_CPU */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"rtbf: %ld rtb: %ld nt: %ld \"",
            "n_rcu_torture_boost_failure",
            "n_rcu_torture_boosts",
            "atomic_long_read(&n_rcu_torture_timers)"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n_rcu_torture_timers"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"rtmbe: %d rtmbkf: %d/%d rtbe: %ld rtbke: %ld rtbre: %ld \"",
            "atomic_read(&n_rcu_torture_mberror)",
            "atomic_read(&n_rcu_torture_mbchk_fail)",
            "atomic_read(&n_rcu_torture_mbchk_tries)",
            "n_rcu_torture_barrier_error",
            "n_rcu_torture_boost_ktrerror",
            "n_rcu_torture_boost_rterror"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_mbchk_tries"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_mbchk_fail"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_mberror"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"rtc: %p %s: %lu tfle: %d rta: %d rtaf: %d rtf: %d \"",
            "rtcp",
            "rtcp && !rcu_stall_is_suppressed_at_boot() ? \"ver\" : \"VER\"",
            "rcu_torture_current_version",
            "list_empty(&rcu_torture_freelist)",
            "atomic_read(&n_rcu_torture_alloc)",
            "atomic_read(&n_rcu_torture_alloc_fail)",
            "atomic_read(&n_rcu_torture_free)"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_free"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_alloc_fail"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_alloc"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rcu_torture_freelist"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_stall_is_suppressed_at_boot",
          "args": [],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_stall_is_suppressed_at_boot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "203-206",
          "snippet": "static inline bool rcu_stall_is_suppressed_at_boot(void)\n{\n\treturn rcu_cpu_stall_suppress_at_boot && !rcu_inkernel_boot_has_ended();\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_stall_is_suppressed_at_boot(void)\n{\n\treturn rcu_cpu_stall_suppress_at_boot && !rcu_inkernel_boot_has_ended();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "rcu_torture_current"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s%s \"",
            "torture_type",
            "TORTURE_FLAG"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "per_cpu(rcu_torture_batch, cpu)[i]"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "rcu_torture_batch",
            "cpu"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "per_cpu(rcu_torture_count, cpu)[i]"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic char *torture_type = \"rcu\";\nstatic struct task_struct *writer_task;\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic unsigned long rcu_torture_current_version;\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\nstatic atomic_t n_rcu_torture_alloc;\nstatic atomic_t n_rcu_torture_alloc_fail;\nstatic atomic_t n_rcu_torture_free;\nstatic atomic_t n_rcu_torture_mberror;\nstatic atomic_t n_rcu_torture_mbchk_fail;\nstatic atomic_t n_rcu_torture_mbchk_tries;\nstatic atomic_t n_rcu_torture_error;\nstatic long n_rcu_torture_barrier_error;\nstatic long n_rcu_torture_boost_ktrerror;\nstatic long n_rcu_torture_boost_rterror;\nstatic long n_rcu_torture_boost_failure;\nstatic long n_rcu_torture_boosts;\nstatic atomic_long_t n_rcu_torture_timers;\nstatic long n_barrier_attempts;\nstatic long n_barrier_successes;\nstatic unsigned long n_read_exits;\nstatic atomic_long_t n_nocb_offload;\nstatic atomic_long_t n_nocb_deoffload;\nstatic int rcu_torture_writer_state;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void\nrcu_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong pipesummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tlong batchsummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tstruct rcu_torture *rtcp;\n\tstatic unsigned long rtcv_snap = ULONG_MAX;\n\tstatic bool splatted;\n\tstruct task_struct *wtp;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tpipesummary[i] += READ_ONCE(per_cpu(rcu_torture_count, cpu)[i]);\n\t\t\tbatchsummary[i] += READ_ONCE(per_cpu(rcu_torture_batch, cpu)[i]);\n\t\t}\n\t}\n\tfor (i = RCU_TORTURE_PIPE_LEN - 1; i >= 0; i--) {\n\t\tif (pipesummary[i] != 0)\n\t\t\tbreak;\n\t}\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\trtcp = rcu_access_pointer(rcu_torture_current);\n\tpr_cont(\"rtc: %p %s: %lu tfle: %d rta: %d rtaf: %d rtf: %d \",\n\t\trtcp,\n\t\trtcp && !rcu_stall_is_suppressed_at_boot() ? \"ver\" : \"VER\",\n\t\trcu_torture_current_version,\n\t\tlist_empty(&rcu_torture_freelist),\n\t\tatomic_read(&n_rcu_torture_alloc),\n\t\tatomic_read(&n_rcu_torture_alloc_fail),\n\t\tatomic_read(&n_rcu_torture_free));\n\tpr_cont(\"rtmbe: %d rtmbkf: %d/%d rtbe: %ld rtbke: %ld rtbre: %ld \",\n\t\tatomic_read(&n_rcu_torture_mberror),\n\t\tatomic_read(&n_rcu_torture_mbchk_fail), atomic_read(&n_rcu_torture_mbchk_tries),\n\t\tn_rcu_torture_barrier_error,\n\t\tn_rcu_torture_boost_ktrerror,\n\t\tn_rcu_torture_boost_rterror);\n\tpr_cont(\"rtbf: %ld rtb: %ld nt: %ld \",\n\t\tn_rcu_torture_boost_failure,\n\t\tn_rcu_torture_boosts,\n\t\tatomic_long_read(&n_rcu_torture_timers));\n\ttorture_onoff_stats();\n\tpr_cont(\"barrier: %ld/%ld:%ld \",\n\t\tdata_race(n_barrier_successes),\n\t\tdata_race(n_barrier_attempts),\n\t\tdata_race(n_rcu_torture_barrier_error));\n\tpr_cont(\"read-exits: %ld \", data_race(n_read_exits)); // Statistic.\n\tpr_cont(\"nocb-toggles: %ld:%ld\\n\",\n\t\tatomic_long_read(&n_nocb_offload), atomic_long_read(&n_nocb_deoffload));\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tif (atomic_read(&n_rcu_torture_mberror) ||\n\t    atomic_read(&n_rcu_torture_mbchk_fail) ||\n\t    n_rcu_torture_barrier_error || n_rcu_torture_boost_ktrerror ||\n\t    n_rcu_torture_boost_rterror || n_rcu_torture_boost_failure ||\n\t    i > 1) {\n\t\tpr_cont(\"%s\", \"!!! \");\n\t\tatomic_inc(&n_rcu_torture_error);\n\t\tWARN_ON_ONCE(atomic_read(&n_rcu_torture_mberror));\n\t\tWARN_ON_ONCE(atomic_read(&n_rcu_torture_mbchk_fail));\n\t\tWARN_ON_ONCE(n_rcu_torture_barrier_error);  // rcu_barrier()\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_ktrerror); // no boost kthread\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_rterror); // can't set RT prio\n\t\tWARN_ON_ONCE(n_rcu_torture_boost_failure); // boost failed (TIMER_SOFTIRQ RT prio?)\n\t\tWARN_ON_ONCE(i > 1); // Too-short grace period\n\t}\n\tpr_cont(\"Reader Pipe: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", pipesummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Reader Batch: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", batchsummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Free-Block Circulation: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\tpr_cont(\" %d\", atomic_read(&rcu_torture_wcount[i]));\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (cur_ops->stats)\n\t\tcur_ops->stats();\n\tif (rtcv_snap == rcu_torture_current_version &&\n\t    rcu_access_pointer(rcu_torture_current) &&\n\t    !rcu_stall_is_suppressed()) {\n\t\tint __maybe_unused flags = 0;\n\t\tunsigned long __maybe_unused gp_seq = 0;\n\n\t\trcutorture_get_gp_data(cur_ops->ttype,\n\t\t\t\t       &flags, &gp_seq);\n\t\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp,\n\t\t\t\t\t&flags, &gp_seq);\n\t\twtp = READ_ONCE(writer_task);\n\t\tpr_alert(\"??? Writer stall state %s(%d) g%lu f%#x ->state %#x cpu %d\\n\",\n\t\t\t rcu_torture_writer_state_getname(),\n\t\t\t rcu_torture_writer_state, gp_seq, flags,\n\t\t\t wtp == NULL ? ~0U : wtp->__state,\n\t\t\t wtp == NULL ? -1 : (int)task_cpu(wtp));\n\t\tif (!splatted && wtp) {\n\t\t\tsched_show_task(wtp);\n\t\t\tsplatted = true;\n\t\t}\n\t\tif (cur_ops->gp_kthread_dbg)\n\t\t\tcur_ops->gp_kthread_dbg();\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\trtcv_snap = rcu_torture_current_version;\n}"
  },
  {
    "function_name": "rcu_nocb_toggle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1754-1795",
    "snippet": "static int rcu_nocb_toggle(void *arg)\n{\n\tint cpu;\n\tint maxcpu = -1;\n\tint oldnice = task_nice(current);\n\tlong r;\n\tDEFINE_TORTURE_RANDOM(rand);\n\tktime_t toggle_delay;\n\tunsigned long toggle_fuzz;\n\tktime_t toggle_interval = ms_to_ktime(nocbs_toggle);\n\n\tVERBOSE_TOROUT_STRING(\"rcu_nocb_toggle task started\");\n\twhile (!rcu_inkernel_boot_has_ended())\n\t\tschedule_timeout_interruptible(HZ / 10);\n\tfor_each_online_cpu(cpu)\n\t\tmaxcpu = cpu;\n\tWARN_ON(maxcpu < 0);\n\tif (toggle_interval > ULONG_MAX)\n\t\ttoggle_fuzz = ULONG_MAX >> 3;\n\telse\n\t\ttoggle_fuzz = toggle_interval >> 3;\n\tif (toggle_fuzz <= 0)\n\t\ttoggle_fuzz = NSEC_PER_USEC;\n\tdo {\n\t\tr = torture_random(&rand);\n\t\tcpu = (r >> 4) % (maxcpu + 1);\n\t\tif (r & 0x1) {\n\t\t\trcu_nocb_cpu_offload(cpu);\n\t\t\tatomic_long_inc(&n_nocb_offload);\n\t\t} else {\n\t\t\trcu_nocb_cpu_deoffload(cpu);\n\t\t\tatomic_long_inc(&n_nocb_deoffload);\n\t\t}\n\t\ttoggle_delay = torture_random(&rand) % toggle_fuzz + toggle_interval;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_hrtimeout(&toggle_delay, HRTIMER_MODE_REL);\n\t\tif (stutter_wait(\"rcu_nocb_toggle\"))\n\t\t\tsched_set_normal(current, oldnice);\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_nocb_toggle\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_long_t n_nocb_offload;",
      "static atomic_long_t n_nocb_deoffload;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_nocb_toggle\""
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_set_normal",
          "args": [
            "current",
            "oldnice"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "sched_set_normal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7606-7613",
          "snippet": "void sched_set_normal(struct task_struct *p, int nice)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t\t.sched_nice = nice,\n\t};\n\tWARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_set_normal(struct task_struct *p, int nice)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t\t.sched_nice = nice,\n\t};\n\tWARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_nocb_toggle\""
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "722-749",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_hrtimeout",
          "args": [
            "&toggle_delay",
            "HRTIMER_MODE_REL"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_hrtimeout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2381-2385",
          "snippet": "int __sched schedule_hrtimeout(ktime_t *expires,\n\t\t\t       const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range(expires, 0, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint __sched schedule_hrtimeout(ktime_t *expires,\n\t\t\t       const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range(expires, 0, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "&rand"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&n_nocb_deoffload"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_cpu_deoffload",
          "args": [
            "cpu"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_cpu_deoffload",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1052-1073",
          "snippet": "int rcu_nocb_cpu_deoffload(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tint ret = 0;\n\n\tmutex_lock(&rcu_state.barrier_mutex);\n\tcpus_read_lock();\n\tif (rcu_rdp_is_offloaded(rdp)) {\n\t\tif (cpu_online(cpu)) {\n\t\t\tret = work_on_cpu(cpu, rcu_nocb_rdp_deoffload, rdp);\n\t\t\tif (!ret)\n\t\t\t\tcpumask_clear_cpu(cpu, rcu_nocb_mask);\n\t\t} else {\n\t\t\tpr_info(\"NOCB: Can't CB-deoffload an offline CPU\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&rcu_state.barrier_mutex);\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "int rcu_nocb_cpu_deoffload(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tint ret = 0;\n\n\tmutex_lock(&rcu_state.barrier_mutex);\n\tcpus_read_lock();\n\tif (rcu_rdp_is_offloaded(rdp)) {\n\t\tif (cpu_online(cpu)) {\n\t\t\tret = work_on_cpu(cpu, rcu_nocb_rdp_deoffload, rdp);\n\t\t\tif (!ret)\n\t\t\t\tcpumask_clear_cpu(cpu, rcu_nocb_mask);\n\t\t} else {\n\t\t\tpr_info(\"NOCB: Can't CB-deoffload an offline CPU\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&rcu_state.barrier_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&n_nocb_offload"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_cpu_offload",
          "args": [
            "cpu"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_cpu_offload",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1141-1162",
          "snippet": "int rcu_nocb_cpu_offload(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tint ret = 0;\n\n\tmutex_lock(&rcu_state.barrier_mutex);\n\tcpus_read_lock();\n\tif (!rcu_rdp_is_offloaded(rdp)) {\n\t\tif (cpu_online(cpu)) {\n\t\t\tret = work_on_cpu(cpu, rcu_nocb_rdp_offload, rdp);\n\t\t\tif (!ret)\n\t\t\t\tcpumask_set_cpu(cpu, rcu_nocb_mask);\n\t\t} else {\n\t\t\tpr_info(\"NOCB: Can't CB-offload an offline CPU\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&rcu_state.barrier_mutex);\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "int rcu_nocb_cpu_offload(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tint ret = 0;\n\n\tmutex_lock(&rcu_state.barrier_mutex);\n\tcpus_read_lock();\n\tif (!rcu_rdp_is_offloaded(rdp)) {\n\t\tif (cpu_online(cpu)) {\n\t\t\tret = work_on_cpu(cpu, rcu_nocb_rdp_offload, rdp);\n\t\t\tif (!ret)\n\t\t\t\tcpumask_set_cpu(cpu, rcu_nocb_mask);\n\t\t} else {\n\t\t\tpr_info(\"NOCB: Can't CB-offload an offline CPU\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&rcu_state.barrier_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "maxcpu < 0"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "HZ / 10"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_inkernel_boot_has_ended",
          "args": [],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_inkernel_boot_has_ended",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "206-209",
          "snippet": "bool rcu_inkernel_boot_has_ended(void)\n{\n\treturn rcu_boot_ended;\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_inkernel_boot_has_ended(void)\n{\n\treturn rcu_boot_ended;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_nocb_toggle task started\""
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ms_to_ktime",
          "args": [
            "nocbs_toggle"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_TORTURE_RANDOM",
          "args": [
            "rand"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "current"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_long_t n_nocb_offload;\nstatic atomic_long_t n_nocb_deoffload;\n\nstatic int rcu_nocb_toggle(void *arg)\n{\n\tint cpu;\n\tint maxcpu = -1;\n\tint oldnice = task_nice(current);\n\tlong r;\n\tDEFINE_TORTURE_RANDOM(rand);\n\tktime_t toggle_delay;\n\tunsigned long toggle_fuzz;\n\tktime_t toggle_interval = ms_to_ktime(nocbs_toggle);\n\n\tVERBOSE_TOROUT_STRING(\"rcu_nocb_toggle task started\");\n\twhile (!rcu_inkernel_boot_has_ended())\n\t\tschedule_timeout_interruptible(HZ / 10);\n\tfor_each_online_cpu(cpu)\n\t\tmaxcpu = cpu;\n\tWARN_ON(maxcpu < 0);\n\tif (toggle_interval > ULONG_MAX)\n\t\ttoggle_fuzz = ULONG_MAX >> 3;\n\telse\n\t\ttoggle_fuzz = toggle_interval >> 3;\n\tif (toggle_fuzz <= 0)\n\t\ttoggle_fuzz = NSEC_PER_USEC;\n\tdo {\n\t\tr = torture_random(&rand);\n\t\tcpu = (r >> 4) % (maxcpu + 1);\n\t\tif (r & 0x1) {\n\t\t\trcu_nocb_cpu_offload(cpu);\n\t\t\tatomic_long_inc(&n_nocb_offload);\n\t\t} else {\n\t\t\trcu_nocb_cpu_deoffload(cpu);\n\t\t\tatomic_long_inc(&n_nocb_deoffload);\n\t\t}\n\t\ttoggle_delay = torture_random(&rand) % toggle_fuzz + toggle_interval;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_hrtimeout(&toggle_delay, HRTIMER_MODE_REL);\n\t\tif (stutter_wait(\"rcu_nocb_toggle\"))\n\t\t\tsched_set_normal(current, oldnice);\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_nocb_toggle\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_reader",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1712-1748",
    "snippet": "static int\nrcu_torture_reader(void *arg)\n{\n\tunsigned long lastsleep = jiffies;\n\tlong myid = (long)arg;\n\tint mynumonline = myid;\n\tDEFINE_TORTURE_RANDOM(rand);\n\tstruct timer_list t;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_reader task started\");\n\tset_user_nice(current, MAX_NICE);\n\tif (irqreader && cur_ops->irq_capable)\n\t\ttimer_setup_on_stack(&t, rcu_torture_timer, 0);\n\ttick_dep_set_task(current, TICK_DEP_BIT_RCU);\n\tdo {\n\t\tif (irqreader && cur_ops->irq_capable) {\n\t\t\tif (!timer_pending(&t))\n\t\t\t\tmod_timer(&t, jiffies + 1);\n\t\t}\n\t\tif (!rcu_torture_one_read(&rand, myid) && !torture_must_stop())\n\t\t\tschedule_timeout_interruptible(HZ);\n\t\tif (time_after(jiffies, lastsleep) && !torture_must_stop()) {\n\t\t\ttorture_hrtimeout_us(500, 1000, &rand);\n\t\t\tlastsleep = jiffies + 10;\n\t\t}\n\t\twhile (torture_num_online_cpus() < mynumonline && !torture_must_stop())\n\t\t\tschedule_timeout_interruptible(HZ / 5);\n\t\tstutter_wait(\"rcu_torture_reader\");\n\t} while (!torture_must_stop());\n\tif (irqreader && cur_ops->irq_capable) {\n\t\tdel_timer_sync(&t);\n\t\tdestroy_timer_on_stack(&t);\n\t}\n\ttick_dep_clear_task(current, TICK_DEP_BIT_RCU);\n\ttorture_kthread_stopping(\"rcu_torture_reader\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_reader\""
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_dep_clear_task",
          "args": [
            "current",
            "TICK_DEP_BIT_RCU"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_timer_on_stack",
          "args": [
            "&t"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_timer_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "757-760",
          "snippet": "void destroy_timer_on_stack(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid destroy_timer_on_stack(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&t"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1352-1391",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_torture_reader\""
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "722-749",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "HZ / 5"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_num_online_cpus",
          "args": [],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_hrtimeout_us",
          "args": [
            "500",
            "1000",
            "&rand"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "torture_hrtimeout_us",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "101-106",
          "snippet": "int torture_hrtimeout_us(u32 baset_us, u32 fuzzt_ns, struct torture_random_state *trsp)\n{\n\tktime_t baset_ns = baset_us * NSEC_PER_USEC;\n\n\treturn torture_hrtimeout_ns(baset_ns, fuzzt_ns, trsp);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_hrtimeout_us(u32 baset_us, u32 fuzzt_ns, struct torture_random_state *trsp)\n{\n\tktime_t baset_ns = baset_us * NSEC_PER_USEC;\n\n\treturn torture_hrtimeout_ns(baset_ns, fuzzt_ns, trsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "lastsleep"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_one_read",
          "args": [
            "&rand",
            "myid"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_one_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1607-1682",
          "snippet": "static bool rcu_torture_one_read(struct torture_random_state *trsp, long myid)\n{\n\tunsigned long cookie;\n\tint i;\n\tunsigned long started;\n\tunsigned long completed;\n\tint newstate;\n\tstruct rcu_torture *p;\n\tint pipe_count;\n\tint readstate = 0;\n\tstruct rt_read_seg rtseg[RCUTORTURE_RDR_MAX_SEGS] = { { 0 } };\n\tstruct rt_read_seg *rtrsp = &rtseg[0];\n\tstruct rt_read_seg *rtrsp1;\n\tunsigned long long ts;\n\n\tWARN_ON_ONCE(!rcu_is_watching());\n\tnewstate = rcutorture_extend_mask(readstate, trsp);\n\trcutorture_one_extend(&readstate, newstate, trsp, rtrsp++);\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tcookie = cur_ops->get_gp_state();\n\tstarted = cur_ops->get_gp_seq();\n\tts = rcu_trace_clock_local();\n\tp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t  !cur_ops->readlock_held || cur_ops->readlock_held());\n\tif (p == NULL) {\n\t\t/* Wait for rcu_torture_writer to get underway */\n\t\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\t\treturn false;\n\t}\n\tif (p->rtort_mbtest == 0)\n\t\tatomic_inc(&n_rcu_torture_mberror);\n\trcu_torture_reader_do_mbchk(myid, p, trsp);\n\trtrsp = rcutorture_loop_extend(&readstate, trsp, rtrsp);\n\tpreempt_disable();\n\tpipe_count = READ_ONCE(p->rtort_pipe_count);\n\tif (pipe_count > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tpipe_count = RCU_TORTURE_PIPE_LEN;\n\t}\n\tcompleted = cur_ops->get_gp_seq();\n\tif (pipe_count > 1) {\n\t\tdo_trace_rcu_torture_read(cur_ops->name, &p->rtort_rcu,\n\t\t\t\t\t  ts, started, completed);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\t__this_cpu_inc(rcu_torture_count[pipe_count]);\n\tcompleted = rcutorture_seq_diff(completed, started);\n\tif (completed > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tcompleted = RCU_TORTURE_PIPE_LEN;\n\t}\n\t__this_cpu_inc(rcu_torture_batch[completed]);\n\tpreempt_enable();\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tWARN_ONCE(cur_ops->poll_gp_state(cookie),\n\t\t\t  \"%s: Cookie check 2 failed %s(%d) %lu->%lu\\n\",\n\t\t\t  __func__,\n\t\t\t  rcu_torture_writer_state_getname(),\n\t\t\t  rcu_torture_writer_state,\n\t\t\t  cookie, cur_ops->get_gp_state());\n\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\tWARN_ON_ONCE(readstate);\n\t// This next splat is expected behavior if leakpointer, especially\n\t// for CONFIG_RCU_STRICT_GRACE_PERIOD=y kernels.\n\tWARN_ON_ONCE(leakpointer && READ_ONCE(p->rtort_pipe_count) > 1);\n\n\t/* If error or close call, record the sequence of reader protections. */\n\tif ((pipe_count > 1 || completed > 1) && !xchg(&err_segs_recorded, 1)) {\n\t\ti = 0;\n\t\tfor (rtrsp1 = &rtseg[0]; rtrsp1 < rtrsp; rtrsp1++)\n\t\t\terr_segs[i++] = *rtrsp1;\n\t\trt_read_nsegs = i;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_TORTURE_PIPE_LEN 10",
            "#define RCUTORTURE_RDR_MAX_SEGS (RCUTORTURE_RDR_MAX_LOOPS + 3)"
          ],
          "globals_used": [
            "static struct rcu_torture __rcu *rcu_torture_current;",
            "static atomic_t n_rcu_torture_mberror;",
            "static int rcu_torture_writer_state;",
            "static int err_segs_recorded;",
            "static struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];",
            "static int rt_read_nsegs;",
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n#define RCUTORTURE_RDR_MAX_SEGS (RCUTORTURE_RDR_MAX_LOOPS + 3)\n\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic atomic_t n_rcu_torture_mberror;\nstatic int rcu_torture_writer_state;\nstatic int err_segs_recorded;\nstatic struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];\nstatic int rt_read_nsegs;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic bool rcu_torture_one_read(struct torture_random_state *trsp, long myid)\n{\n\tunsigned long cookie;\n\tint i;\n\tunsigned long started;\n\tunsigned long completed;\n\tint newstate;\n\tstruct rcu_torture *p;\n\tint pipe_count;\n\tint readstate = 0;\n\tstruct rt_read_seg rtseg[RCUTORTURE_RDR_MAX_SEGS] = { { 0 } };\n\tstruct rt_read_seg *rtrsp = &rtseg[0];\n\tstruct rt_read_seg *rtrsp1;\n\tunsigned long long ts;\n\n\tWARN_ON_ONCE(!rcu_is_watching());\n\tnewstate = rcutorture_extend_mask(readstate, trsp);\n\trcutorture_one_extend(&readstate, newstate, trsp, rtrsp++);\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tcookie = cur_ops->get_gp_state();\n\tstarted = cur_ops->get_gp_seq();\n\tts = rcu_trace_clock_local();\n\tp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t  !cur_ops->readlock_held || cur_ops->readlock_held());\n\tif (p == NULL) {\n\t\t/* Wait for rcu_torture_writer to get underway */\n\t\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\t\treturn false;\n\t}\n\tif (p->rtort_mbtest == 0)\n\t\tatomic_inc(&n_rcu_torture_mberror);\n\trcu_torture_reader_do_mbchk(myid, p, trsp);\n\trtrsp = rcutorture_loop_extend(&readstate, trsp, rtrsp);\n\tpreempt_disable();\n\tpipe_count = READ_ONCE(p->rtort_pipe_count);\n\tif (pipe_count > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tpipe_count = RCU_TORTURE_PIPE_LEN;\n\t}\n\tcompleted = cur_ops->get_gp_seq();\n\tif (pipe_count > 1) {\n\t\tdo_trace_rcu_torture_read(cur_ops->name, &p->rtort_rcu,\n\t\t\t\t\t  ts, started, completed);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\t__this_cpu_inc(rcu_torture_count[pipe_count]);\n\tcompleted = rcutorture_seq_diff(completed, started);\n\tif (completed > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tcompleted = RCU_TORTURE_PIPE_LEN;\n\t}\n\t__this_cpu_inc(rcu_torture_batch[completed]);\n\tpreempt_enable();\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tWARN_ONCE(cur_ops->poll_gp_state(cookie),\n\t\t\t  \"%s: Cookie check 2 failed %s(%d) %lu->%lu\\n\",\n\t\t\t  __func__,\n\t\t\t  rcu_torture_writer_state_getname(),\n\t\t\t  rcu_torture_writer_state,\n\t\t\t  cookie, cur_ops->get_gp_state());\n\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\tWARN_ON_ONCE(readstate);\n\t// This next splat is expected behavior if leakpointer, especially\n\t// for CONFIG_RCU_STRICT_GRACE_PERIOD=y kernels.\n\tWARN_ON_ONCE(leakpointer && READ_ONCE(p->rtort_pipe_count) > 1);\n\n\t/* If error or close call, record the sequence of reader protections. */\n\tif ((pipe_count > 1 || completed > 1) && !xchg(&err_segs_recorded, 1)) {\n\t\ti = 0;\n\t\tfor (rtrsp1 = &rtseg[0]; rtrsp1 < rtrsp; rtrsp1++)\n\t\t\terr_segs[i++] = *rtrsp1;\n\t\trt_read_nsegs = i;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&t",
            "jiffies + 1"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1106-1109",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "&t"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_dep_set_task",
          "args": [
            "current",
            "TICK_DEP_BIT_RCU"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup_on_stack",
          "args": [
            "&t",
            "rcu_torture_timer",
            "0"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_reader task started\""
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_TORTURE_RANDOM",
          "args": [
            "rand"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int\nrcu_torture_reader(void *arg)\n{\n\tunsigned long lastsleep = jiffies;\n\tlong myid = (long)arg;\n\tint mynumonline = myid;\n\tDEFINE_TORTURE_RANDOM(rand);\n\tstruct timer_list t;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_reader task started\");\n\tset_user_nice(current, MAX_NICE);\n\tif (irqreader && cur_ops->irq_capable)\n\t\ttimer_setup_on_stack(&t, rcu_torture_timer, 0);\n\ttick_dep_set_task(current, TICK_DEP_BIT_RCU);\n\tdo {\n\t\tif (irqreader && cur_ops->irq_capable) {\n\t\t\tif (!timer_pending(&t))\n\t\t\t\tmod_timer(&t, jiffies + 1);\n\t\t}\n\t\tif (!rcu_torture_one_read(&rand, myid) && !torture_must_stop())\n\t\t\tschedule_timeout_interruptible(HZ);\n\t\tif (time_after(jiffies, lastsleep) && !torture_must_stop()) {\n\t\t\ttorture_hrtimeout_us(500, 1000, &rand);\n\t\t\tlastsleep = jiffies + 10;\n\t\t}\n\t\twhile (torture_num_online_cpus() < mynumonline && !torture_must_stop())\n\t\t\tschedule_timeout_interruptible(HZ / 5);\n\t\tstutter_wait(\"rcu_torture_reader\");\n\t} while (!torture_must_stop());\n\tif (irqreader && cur_ops->irq_capable) {\n\t\tdel_timer_sync(&t);\n\t\tdestroy_timer_on_stack(&t);\n\t}\n\ttick_dep_clear_task(current, TICK_DEP_BIT_RCU);\n\ttorture_kthread_stopping(\"rcu_torture_reader\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1692-1704",
    "snippet": "static void rcu_torture_timer(struct timer_list *unused)\n{\n\tatomic_long_inc(&n_rcu_torture_timers);\n\t(void)rcu_torture_one_read(this_cpu_ptr(&rcu_torture_timer_rand), -1);\n\n\t/* Test call_rcu() invocation from interrupt handler. */\n\tif (cur_ops->call) {\n\t\tstruct rcu_head *rhp = kmalloc(sizeof(*rhp), GFP_NOWAIT);\n\n\t\tif (rhp)\n\t\t\tcur_ops->call(rhp, rcu_torture_timer_cb);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_long_t n_rcu_torture_timers;",
      "static struct rcu_torture_ops *cur_ops;",
      "static DEFINE_TORTURE_RANDOM_PERCPU(rcu_torture_timer_rand);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_ops->call",
          "args": [
            "rhp",
            "rcu_torture_timer_cb"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*rhp)",
            "GFP_NOWAIT"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_one_read",
          "args": [
            "this_cpu_ptr(&rcu_torture_timer_rand)",
            "-1"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_one_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1607-1682",
          "snippet": "static bool rcu_torture_one_read(struct torture_random_state *trsp, long myid)\n{\n\tunsigned long cookie;\n\tint i;\n\tunsigned long started;\n\tunsigned long completed;\n\tint newstate;\n\tstruct rcu_torture *p;\n\tint pipe_count;\n\tint readstate = 0;\n\tstruct rt_read_seg rtseg[RCUTORTURE_RDR_MAX_SEGS] = { { 0 } };\n\tstruct rt_read_seg *rtrsp = &rtseg[0];\n\tstruct rt_read_seg *rtrsp1;\n\tunsigned long long ts;\n\n\tWARN_ON_ONCE(!rcu_is_watching());\n\tnewstate = rcutorture_extend_mask(readstate, trsp);\n\trcutorture_one_extend(&readstate, newstate, trsp, rtrsp++);\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tcookie = cur_ops->get_gp_state();\n\tstarted = cur_ops->get_gp_seq();\n\tts = rcu_trace_clock_local();\n\tp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t  !cur_ops->readlock_held || cur_ops->readlock_held());\n\tif (p == NULL) {\n\t\t/* Wait for rcu_torture_writer to get underway */\n\t\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\t\treturn false;\n\t}\n\tif (p->rtort_mbtest == 0)\n\t\tatomic_inc(&n_rcu_torture_mberror);\n\trcu_torture_reader_do_mbchk(myid, p, trsp);\n\trtrsp = rcutorture_loop_extend(&readstate, trsp, rtrsp);\n\tpreempt_disable();\n\tpipe_count = READ_ONCE(p->rtort_pipe_count);\n\tif (pipe_count > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tpipe_count = RCU_TORTURE_PIPE_LEN;\n\t}\n\tcompleted = cur_ops->get_gp_seq();\n\tif (pipe_count > 1) {\n\t\tdo_trace_rcu_torture_read(cur_ops->name, &p->rtort_rcu,\n\t\t\t\t\t  ts, started, completed);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\t__this_cpu_inc(rcu_torture_count[pipe_count]);\n\tcompleted = rcutorture_seq_diff(completed, started);\n\tif (completed > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tcompleted = RCU_TORTURE_PIPE_LEN;\n\t}\n\t__this_cpu_inc(rcu_torture_batch[completed]);\n\tpreempt_enable();\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tWARN_ONCE(cur_ops->poll_gp_state(cookie),\n\t\t\t  \"%s: Cookie check 2 failed %s(%d) %lu->%lu\\n\",\n\t\t\t  __func__,\n\t\t\t  rcu_torture_writer_state_getname(),\n\t\t\t  rcu_torture_writer_state,\n\t\t\t  cookie, cur_ops->get_gp_state());\n\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\tWARN_ON_ONCE(readstate);\n\t// This next splat is expected behavior if leakpointer, especially\n\t// for CONFIG_RCU_STRICT_GRACE_PERIOD=y kernels.\n\tWARN_ON_ONCE(leakpointer && READ_ONCE(p->rtort_pipe_count) > 1);\n\n\t/* If error or close call, record the sequence of reader protections. */\n\tif ((pipe_count > 1 || completed > 1) && !xchg(&err_segs_recorded, 1)) {\n\t\ti = 0;\n\t\tfor (rtrsp1 = &rtseg[0]; rtrsp1 < rtrsp; rtrsp1++)\n\t\t\terr_segs[i++] = *rtrsp1;\n\t\trt_read_nsegs = i;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_TORTURE_PIPE_LEN 10",
            "#define RCUTORTURE_RDR_MAX_SEGS (RCUTORTURE_RDR_MAX_LOOPS + 3)"
          ],
          "globals_used": [
            "static struct rcu_torture __rcu *rcu_torture_current;",
            "static atomic_t n_rcu_torture_mberror;",
            "static int rcu_torture_writer_state;",
            "static int err_segs_recorded;",
            "static struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];",
            "static int rt_read_nsegs;",
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n#define RCUTORTURE_RDR_MAX_SEGS (RCUTORTURE_RDR_MAX_LOOPS + 3)\n\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic atomic_t n_rcu_torture_mberror;\nstatic int rcu_torture_writer_state;\nstatic int err_segs_recorded;\nstatic struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];\nstatic int rt_read_nsegs;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic bool rcu_torture_one_read(struct torture_random_state *trsp, long myid)\n{\n\tunsigned long cookie;\n\tint i;\n\tunsigned long started;\n\tunsigned long completed;\n\tint newstate;\n\tstruct rcu_torture *p;\n\tint pipe_count;\n\tint readstate = 0;\n\tstruct rt_read_seg rtseg[RCUTORTURE_RDR_MAX_SEGS] = { { 0 } };\n\tstruct rt_read_seg *rtrsp = &rtseg[0];\n\tstruct rt_read_seg *rtrsp1;\n\tunsigned long long ts;\n\n\tWARN_ON_ONCE(!rcu_is_watching());\n\tnewstate = rcutorture_extend_mask(readstate, trsp);\n\trcutorture_one_extend(&readstate, newstate, trsp, rtrsp++);\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tcookie = cur_ops->get_gp_state();\n\tstarted = cur_ops->get_gp_seq();\n\tts = rcu_trace_clock_local();\n\tp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t  !cur_ops->readlock_held || cur_ops->readlock_held());\n\tif (p == NULL) {\n\t\t/* Wait for rcu_torture_writer to get underway */\n\t\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\t\treturn false;\n\t}\n\tif (p->rtort_mbtest == 0)\n\t\tatomic_inc(&n_rcu_torture_mberror);\n\trcu_torture_reader_do_mbchk(myid, p, trsp);\n\trtrsp = rcutorture_loop_extend(&readstate, trsp, rtrsp);\n\tpreempt_disable();\n\tpipe_count = READ_ONCE(p->rtort_pipe_count);\n\tif (pipe_count > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tpipe_count = RCU_TORTURE_PIPE_LEN;\n\t}\n\tcompleted = cur_ops->get_gp_seq();\n\tif (pipe_count > 1) {\n\t\tdo_trace_rcu_torture_read(cur_ops->name, &p->rtort_rcu,\n\t\t\t\t\t  ts, started, completed);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\t__this_cpu_inc(rcu_torture_count[pipe_count]);\n\tcompleted = rcutorture_seq_diff(completed, started);\n\tif (completed > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tcompleted = RCU_TORTURE_PIPE_LEN;\n\t}\n\t__this_cpu_inc(rcu_torture_batch[completed]);\n\tpreempt_enable();\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tWARN_ONCE(cur_ops->poll_gp_state(cookie),\n\t\t\t  \"%s: Cookie check 2 failed %s(%d) %lu->%lu\\n\",\n\t\t\t  __func__,\n\t\t\t  rcu_torture_writer_state_getname(),\n\t\t\t  rcu_torture_writer_state,\n\t\t\t  cookie, cur_ops->get_gp_state());\n\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\tWARN_ON_ONCE(readstate);\n\t// This next splat is expected behavior if leakpointer, especially\n\t// for CONFIG_RCU_STRICT_GRACE_PERIOD=y kernels.\n\tWARN_ON_ONCE(leakpointer && READ_ONCE(p->rtort_pipe_count) > 1);\n\n\t/* If error or close call, record the sequence of reader protections. */\n\tif ((pipe_count > 1 || completed > 1) && !xchg(&err_segs_recorded, 1)) {\n\t\ti = 0;\n\t\tfor (rtrsp1 = &rtseg[0]; rtrsp1 < rtrsp; rtrsp1++)\n\t\t\terr_segs[i++] = *rtrsp1;\n\t\trt_read_nsegs = i;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_torture_timer_rand"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&n_rcu_torture_timers"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_long_t n_rcu_torture_timers;\nstatic struct rcu_torture_ops *cur_ops;\nstatic DEFINE_TORTURE_RANDOM_PERCPU(rcu_torture_timer_rand);\n\nstatic void rcu_torture_timer(struct timer_list *unused)\n{\n\tatomic_long_inc(&n_rcu_torture_timers);\n\t(void)rcu_torture_one_read(this_cpu_ptr(&rcu_torture_timer_rand), -1);\n\n\t/* Test call_rcu() invocation from interrupt handler. */\n\tif (cur_ops->call) {\n\t\tstruct rcu_head *rhp = kmalloc(sizeof(*rhp), GFP_NOWAIT);\n\n\t\tif (rhp)\n\t\t\tcur_ops->call(rhp, rcu_torture_timer_cb);\n\t}\n}"
  },
  {
    "function_name": "rcu_torture_one_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1607-1682",
    "snippet": "static bool rcu_torture_one_read(struct torture_random_state *trsp, long myid)\n{\n\tunsigned long cookie;\n\tint i;\n\tunsigned long started;\n\tunsigned long completed;\n\tint newstate;\n\tstruct rcu_torture *p;\n\tint pipe_count;\n\tint readstate = 0;\n\tstruct rt_read_seg rtseg[RCUTORTURE_RDR_MAX_SEGS] = { { 0 } };\n\tstruct rt_read_seg *rtrsp = &rtseg[0];\n\tstruct rt_read_seg *rtrsp1;\n\tunsigned long long ts;\n\n\tWARN_ON_ONCE(!rcu_is_watching());\n\tnewstate = rcutorture_extend_mask(readstate, trsp);\n\trcutorture_one_extend(&readstate, newstate, trsp, rtrsp++);\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tcookie = cur_ops->get_gp_state();\n\tstarted = cur_ops->get_gp_seq();\n\tts = rcu_trace_clock_local();\n\tp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t  !cur_ops->readlock_held || cur_ops->readlock_held());\n\tif (p == NULL) {\n\t\t/* Wait for rcu_torture_writer to get underway */\n\t\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\t\treturn false;\n\t}\n\tif (p->rtort_mbtest == 0)\n\t\tatomic_inc(&n_rcu_torture_mberror);\n\trcu_torture_reader_do_mbchk(myid, p, trsp);\n\trtrsp = rcutorture_loop_extend(&readstate, trsp, rtrsp);\n\tpreempt_disable();\n\tpipe_count = READ_ONCE(p->rtort_pipe_count);\n\tif (pipe_count > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tpipe_count = RCU_TORTURE_PIPE_LEN;\n\t}\n\tcompleted = cur_ops->get_gp_seq();\n\tif (pipe_count > 1) {\n\t\tdo_trace_rcu_torture_read(cur_ops->name, &p->rtort_rcu,\n\t\t\t\t\t  ts, started, completed);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\t__this_cpu_inc(rcu_torture_count[pipe_count]);\n\tcompleted = rcutorture_seq_diff(completed, started);\n\tif (completed > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tcompleted = RCU_TORTURE_PIPE_LEN;\n\t}\n\t__this_cpu_inc(rcu_torture_batch[completed]);\n\tpreempt_enable();\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tWARN_ONCE(cur_ops->poll_gp_state(cookie),\n\t\t\t  \"%s: Cookie check 2 failed %s(%d) %lu->%lu\\n\",\n\t\t\t  __func__,\n\t\t\t  rcu_torture_writer_state_getname(),\n\t\t\t  rcu_torture_writer_state,\n\t\t\t  cookie, cur_ops->get_gp_state());\n\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\tWARN_ON_ONCE(readstate);\n\t// This next splat is expected behavior if leakpointer, especially\n\t// for CONFIG_RCU_STRICT_GRACE_PERIOD=y kernels.\n\tWARN_ON_ONCE(leakpointer && READ_ONCE(p->rtort_pipe_count) > 1);\n\n\t/* If error or close call, record the sequence of reader protections. */\n\tif ((pipe_count > 1 || completed > 1) && !xchg(&err_segs_recorded, 1)) {\n\t\ti = 0;\n\t\tfor (rtrsp1 = &rtseg[0]; rtrsp1 < rtrsp; rtrsp1++)\n\t\t\terr_segs[i++] = *rtrsp1;\n\t\trt_read_nsegs = i;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_TORTURE_PIPE_LEN 10",
      "#define RCUTORTURE_RDR_MAX_SEGS (RCUTORTURE_RDR_MAX_LOOPS + 3)"
    ],
    "globals_used": [
      "static struct rcu_torture __rcu *rcu_torture_current;",
      "static atomic_t n_rcu_torture_mberror;",
      "static int rcu_torture_writer_state;",
      "static int err_segs_recorded;",
      "static struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];",
      "static int rt_read_nsegs;",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&err_segs_recorded",
            "1"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "leakpointer && READ_ONCE(p->rtort_pipe_count) > 1"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "p->rtort_pipe_count"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "readstate"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutorture_one_extend",
          "args": [
            "&readstate",
            "0",
            "trsp",
            "rtrsp"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_one_extend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1431-1516",
          "snippet": "static void rcutorture_one_extend(int *readstate, int newstate,\n\t\t\t\t  struct torture_random_state *trsp,\n\t\t\t\t  struct rt_read_seg *rtrsp)\n{\n\tunsigned long flags;\n\tint idxnew1 = -1;\n\tint idxnew2 = -1;\n\tint idxold1 = *readstate;\n\tint idxold2 = idxold1;\n\tint statesnew = ~*readstate & newstate;\n\tint statesold = *readstate & ~newstate;\n\n\tWARN_ON_ONCE(idxold2 < 0);\n\tWARN_ON_ONCE((idxold2 >> RCUTORTURE_RDR_SHIFT_2) > 1);\n\trtrsp->rt_readstate = newstate;\n\n\t/* First, put new protection in place to avoid critical-section gap. */\n\tif (statesnew & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_disable();\n\tif (statesnew & RCUTORTURE_RDR_RBH)\n\t\trcu_read_lock_bh();\n\tif (statesnew & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_disable();\n\tif (statesnew & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_disable();\n\tif (statesnew & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_lock_sched();\n\tif (statesnew & RCUTORTURE_RDR_RCU_1)\n\t\tidxnew1 = (cur_ops->readlock() & 0x1) << RCUTORTURE_RDR_SHIFT_1;\n\tif (statesnew & RCUTORTURE_RDR_RCU_2)\n\t\tidxnew2 = (cur_ops->readlock() & 0x1) << RCUTORTURE_RDR_SHIFT_2;\n\n\t/*\n\t * Next, remove old protection, in decreasing order of strength\n\t * to avoid unlock paths that aren't safe in the stronger\n\t * context. Namely: BH can not be enabled with disabled interrupts.\n\t * Additionally PREEMPT_RT requires that BH is enabled in preemptible\n\t * context.\n\t */\n\tif (statesold & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_enable();\n\tif (statesold & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_enable();\n\tif (statesold & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_unlock_sched();\n\tif (statesold & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_enable();\n\tif (statesold & RCUTORTURE_RDR_RBH)\n\t\trcu_read_unlock_bh();\n\tif (statesold & RCUTORTURE_RDR_RCU_2) {\n\t\tcur_ops->readunlock((idxold2 >> RCUTORTURE_RDR_SHIFT_2) & 0x1);\n\t\tWARN_ON_ONCE(idxnew2 != -1);\n\t\tidxold2 = 0;\n\t}\n\tif (statesold & RCUTORTURE_RDR_RCU_1) {\n\t\tbool lockit;\n\n\t\tlockit = !cur_ops->no_pi_lock && !statesnew && !(torture_random(trsp) & 0xffff);\n\t\tif (lockit)\n\t\t\traw_spin_lock_irqsave(&current->pi_lock, flags);\n\t\tcur_ops->readunlock((idxold1 >> RCUTORTURE_RDR_SHIFT_1) & 0x1);\n\t\tWARN_ON_ONCE(idxnew1 != -1);\n\t\tidxold1 = 0;\n\t\tif (lockit)\n\t\t\traw_spin_unlock_irqrestore(&current->pi_lock, flags);\n\t}\n\n\t/* Delay if neither beginning nor end and there was a change. */\n\tif ((statesnew || statesold) && *readstate && newstate)\n\t\tcur_ops->read_delay(trsp, rtrsp);\n\n\t/* Update the reader state. */\n\tif (idxnew1 == -1)\n\t\tidxnew1 = idxold1 & RCUTORTURE_RDR_MASK_1;\n\tWARN_ON_ONCE(idxnew1 < 0);\n\tif (WARN_ON_ONCE((idxnew1 >> RCUTORTURE_RDR_SHIFT_1) > 1))\n\t\tpr_info(\"Unexpected idxnew1 value of %#x\\n\", idxnew1);\n\tif (idxnew2 == -1)\n\t\tidxnew2 = idxold2 & RCUTORTURE_RDR_MASK_2;\n\tWARN_ON_ONCE(idxnew2 < 0);\n\tWARN_ON_ONCE((idxnew2 >> RCUTORTURE_RDR_SHIFT_2) > 1);\n\t*readstate = idxnew1 | idxnew2 | newstate;\n\tWARN_ON_ONCE(*readstate < 0);\n\tif (WARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT_2) > 1))\n\t\tpr_info(\"Unexpected idxnew2 value of %#x\\n\", idxnew2);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */",
            "#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */",
            "#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */",
            "#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */",
            "#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */",
            "#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */",
            "#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */",
            "#define RCUTORTURE_RDR_MASK_2\t (1 << RCUTORTURE_RDR_SHIFT_2)",
            "#define RCUTORTURE_RDR_SHIFT_2\t 9\t/* Put SRCU index in upper bits. */",
            "#define RCUTORTURE_RDR_MASK_1\t (1 << RCUTORTURE_RDR_SHIFT_1)",
            "#define RCUTORTURE_RDR_SHIFT_1\t 8\t/* Put SRCU index in upper bits. */"
          ],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */\n#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */\n#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */\n#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */\n#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */\n#define RCUTORTURE_RDR_MASK_2\t (1 << RCUTORTURE_RDR_SHIFT_2)\n#define RCUTORTURE_RDR_SHIFT_2\t 9\t/* Put SRCU index in upper bits. */\n#define RCUTORTURE_RDR_MASK_1\t (1 << RCUTORTURE_RDR_SHIFT_1)\n#define RCUTORTURE_RDR_SHIFT_1\t 8\t/* Put SRCU index in upper bits. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void rcutorture_one_extend(int *readstate, int newstate,\n\t\t\t\t  struct torture_random_state *trsp,\n\t\t\t\t  struct rt_read_seg *rtrsp)\n{\n\tunsigned long flags;\n\tint idxnew1 = -1;\n\tint idxnew2 = -1;\n\tint idxold1 = *readstate;\n\tint idxold2 = idxold1;\n\tint statesnew = ~*readstate & newstate;\n\tint statesold = *readstate & ~newstate;\n\n\tWARN_ON_ONCE(idxold2 < 0);\n\tWARN_ON_ONCE((idxold2 >> RCUTORTURE_RDR_SHIFT_2) > 1);\n\trtrsp->rt_readstate = newstate;\n\n\t/* First, put new protection in place to avoid critical-section gap. */\n\tif (statesnew & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_disable();\n\tif (statesnew & RCUTORTURE_RDR_RBH)\n\t\trcu_read_lock_bh();\n\tif (statesnew & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_disable();\n\tif (statesnew & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_disable();\n\tif (statesnew & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_lock_sched();\n\tif (statesnew & RCUTORTURE_RDR_RCU_1)\n\t\tidxnew1 = (cur_ops->readlock() & 0x1) << RCUTORTURE_RDR_SHIFT_1;\n\tif (statesnew & RCUTORTURE_RDR_RCU_2)\n\t\tidxnew2 = (cur_ops->readlock() & 0x1) << RCUTORTURE_RDR_SHIFT_2;\n\n\t/*\n\t * Next, remove old protection, in decreasing order of strength\n\t * to avoid unlock paths that aren't safe in the stronger\n\t * context. Namely: BH can not be enabled with disabled interrupts.\n\t * Additionally PREEMPT_RT requires that BH is enabled in preemptible\n\t * context.\n\t */\n\tif (statesold & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_enable();\n\tif (statesold & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_enable();\n\tif (statesold & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_unlock_sched();\n\tif (statesold & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_enable();\n\tif (statesold & RCUTORTURE_RDR_RBH)\n\t\trcu_read_unlock_bh();\n\tif (statesold & RCUTORTURE_RDR_RCU_2) {\n\t\tcur_ops->readunlock((idxold2 >> RCUTORTURE_RDR_SHIFT_2) & 0x1);\n\t\tWARN_ON_ONCE(idxnew2 != -1);\n\t\tidxold2 = 0;\n\t}\n\tif (statesold & RCUTORTURE_RDR_RCU_1) {\n\t\tbool lockit;\n\n\t\tlockit = !cur_ops->no_pi_lock && !statesnew && !(torture_random(trsp) & 0xffff);\n\t\tif (lockit)\n\t\t\traw_spin_lock_irqsave(&current->pi_lock, flags);\n\t\tcur_ops->readunlock((idxold1 >> RCUTORTURE_RDR_SHIFT_1) & 0x1);\n\t\tWARN_ON_ONCE(idxnew1 != -1);\n\t\tidxold1 = 0;\n\t\tif (lockit)\n\t\t\traw_spin_unlock_irqrestore(&current->pi_lock, flags);\n\t}\n\n\t/* Delay if neither beginning nor end and there was a change. */\n\tif ((statesnew || statesold) && *readstate && newstate)\n\t\tcur_ops->read_delay(trsp, rtrsp);\n\n\t/* Update the reader state. */\n\tif (idxnew1 == -1)\n\t\tidxnew1 = idxold1 & RCUTORTURE_RDR_MASK_1;\n\tWARN_ON_ONCE(idxnew1 < 0);\n\tif (WARN_ON_ONCE((idxnew1 >> RCUTORTURE_RDR_SHIFT_1) > 1))\n\t\tpr_info(\"Unexpected idxnew1 value of %#x\\n\", idxnew1);\n\tif (idxnew2 == -1)\n\t\tidxnew2 = idxold2 & RCUTORTURE_RDR_MASK_2;\n\tWARN_ON_ONCE(idxnew2 < 0);\n\tWARN_ON_ONCE((idxnew2 >> RCUTORTURE_RDR_SHIFT_2) > 1);\n\t*readstate = idxnew1 | idxnew2 | newstate;\n\tWARN_ON_ONCE(*readstate < 0);\n\tif (WARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT_2) > 1))\n\t\tpr_info(\"Unexpected idxnew2 value of %#x\\n\", idxnew2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "cur_ops->poll_gp_state(cookie)",
            "\"%s: Cookie check 2 failed %s(%d) %lu->%lu\\n\"",
            "__func__",
            "rcu_torture_writer_state_getname()",
            "rcu_torture_writer_state",
            "cookie",
            "cur_ops->get_gp_state()"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_state",
          "args": [],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_writer_state_getname",
          "args": [],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_writer_state_getname",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "245-252",
          "snippet": "static const char *rcu_torture_writer_state_getname(void)\n{\n\tunsigned int i = READ_ONCE(rcu_torture_writer_state);\n\n\tif (i >= ARRAY_SIZE(rcu_torture_writer_state_names))\n\t\treturn \"???\";\n\treturn rcu_torture_writer_state_names[i];\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_torture_writer_state;",
            "static const char * const rcu_torture_writer_state_names[] = {\n\t\"RTWS_FIXED_DELAY\",\n\t\"RTWS_DELAY\",\n\t\"RTWS_REPLACE\",\n\t\"RTWS_DEF_FREE\",\n\t\"RTWS_EXP_SYNC\",\n\t\"RTWS_COND_GET\",\n\t\"RTWS_COND_SYNC\",\n\t\"RTWS_POLL_GET\",\n\t\"RTWS_POLL_WAIT\",\n\t\"RTWS_SYNC\",\n\t\"RTWS_STUTTER\",\n\t\"RTWS_STOPPING\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_torture_writer_state;\nstatic const char * const rcu_torture_writer_state_names[] = {\n\t\"RTWS_FIXED_DELAY\",\n\t\"RTWS_DELAY\",\n\t\"RTWS_REPLACE\",\n\t\"RTWS_DEF_FREE\",\n\t\"RTWS_EXP_SYNC\",\n\t\"RTWS_COND_GET\",\n\t\"RTWS_COND_SYNC\",\n\t\"RTWS_POLL_GET\",\n\t\"RTWS_POLL_WAIT\",\n\t\"RTWS_SYNC\",\n\t\"RTWS_STUTTER\",\n\t\"RTWS_STOPPING\",\n};\n\nstatic const char *rcu_torture_writer_state_getname(void)\n{\n\tunsigned int i = READ_ONCE(rcu_torture_writer_state);\n\n\tif (i >= ARRAY_SIZE(rcu_torture_writer_state_names))\n\t\treturn \"???\";\n\treturn rcu_torture_writer_state_names[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->poll_gp_state",
          "args": [
            "cookie"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "rcu_torture_batch[completed]"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutorture_seq_diff",
          "args": [
            "completed",
            "started"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_seq_diff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "894-899",
          "snippet": "static unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "rcu_torture_count[pipe_count]"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_trace_rcu_torture_read",
          "args": [
            "cur_ops->name",
            "&p->rtort_rcu",
            "ts",
            "started",
            "completed"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "do_trace_rcu_torture_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "469-474",
          "snippet": "void do_trace_rcu_torture_read(const char *rcutorturename, struct rcu_head *rhp,\n\t\t\t       unsigned long secs,\n\t\t\t       unsigned long c_old, unsigned long c)\n{\n\ttrace_rcu_torture_read(rcutorturename, rhp, secs, c_old, c);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid do_trace_rcu_torture_read(const char *rcutorturename, struct rcu_head *rhp,\n\t\t\t       unsigned long secs,\n\t\t\t       unsigned long c_old, unsigned long c)\n{\n\ttrace_rcu_torture_read(rcutorturename, rhp, secs, c_old, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "p->rtort_pipe_count"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcutorture_loop_extend",
          "args": [
            "&readstate",
            "trsp",
            "rtrsp"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_loop_extend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1581-1600",
          "snippet": "static struct rt_read_seg *\nrcutorture_loop_extend(int *readstate, struct torture_random_state *trsp,\n\t\t       struct rt_read_seg *rtrsp)\n{\n\tint i;\n\tint j;\n\tint mask = rcutorture_extend_mask_max();\n\n\tWARN_ON_ONCE(!*readstate); /* -Existing- RCU read-side critsect! */\n\tif (!((mask - 1) & mask))\n\t\treturn rtrsp;  /* Current RCU reader not extendable. */\n\t/* Bias towards larger numbers of loops. */\n\ti = (torture_random(trsp) >> 3);\n\ti = ((i | (i >> 3)) & RCUTORTURE_RDR_MAX_LOOPS) + 1;\n\tfor (j = 0; j < i; j++) {\n\t\tmask = rcutorture_extend_mask(*readstate, trsp);\n\t\trcutorture_one_extend(readstate, mask, trsp, &rtrsp[j]);\n\t}\n\treturn &rtrsp[j];\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCUTORTURE_RDR_MAX_LOOPS 0x7\t/* Maximum reader extensions. */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_MAX_LOOPS 0x7\t/* Maximum reader extensions. */\n\nstatic struct rt_read_seg *\nrcutorture_loop_extend(int *readstate, struct torture_random_state *trsp,\n\t\t       struct rt_read_seg *rtrsp)\n{\n\tint i;\n\tint j;\n\tint mask = rcutorture_extend_mask_max();\n\n\tWARN_ON_ONCE(!*readstate); /* -Existing- RCU read-side critsect! */\n\tif (!((mask - 1) & mask))\n\t\treturn rtrsp;  /* Current RCU reader not extendable. */\n\t/* Bias towards larger numbers of loops. */\n\ti = (torture_random(trsp) >> 3);\n\ti = ((i | (i >> 3)) & RCUTORTURE_RDR_MAX_LOOPS) + 1;\n\tfor (j = 0; j < i; j++) {\n\t\tmask = rcutorture_extend_mask(*readstate, trsp);\n\t\trcutorture_one_extend(readstate, mask, trsp, &rtrsp[j]);\n\t}\n\treturn &rtrsp[j];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_reader_do_mbchk",
          "args": [
            "myid",
            "p",
            "trsp"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_reader_do_mbchk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1367-1420",
          "snippet": "static void rcu_torture_reader_do_mbchk(long myid, struct rcu_torture *rtp,\n\t\t\t\t\tstruct torture_random_state *trsp)\n{\n\tunsigned long loops;\n\tint noc = torture_num_online_cpus();\n\tint rdrchked;\n\tint rdrchker;\n\tstruct rcu_torture_reader_check *rtrcp; // Me.\n\tstruct rcu_torture_reader_check *rtrcp_assigner; // Assigned us to do checking.\n\tstruct rcu_torture_reader_check *rtrcp_chked; // Reader being checked.\n\tstruct rcu_torture_reader_check *rtrcp_chker; // Reader doing checking when not me.\n\n\tif (myid < 0)\n\t\treturn; // Don't try this from timer handlers.\n\n\t// Increment my counter.\n\trtrcp = &rcu_torture_reader_mbchk[myid];\n\tWRITE_ONCE(rtrcp->rtc_myloops, rtrcp->rtc_myloops + 1);\n\n\t// Attempt to assign someone else some checking work.\n\trdrchked = torture_random(trsp) % nrealreaders;\n\trtrcp_chked = &rcu_torture_reader_mbchk[rdrchked];\n\trdrchker = torture_random(trsp) % nrealreaders;\n\trtrcp_chker = &rcu_torture_reader_mbchk[rdrchker];\n\tif (rdrchked != myid && rdrchked != rdrchker && noc >= rdrchked && noc >= rdrchker &&\n\t    smp_load_acquire(&rtrcp->rtc_chkrdr) < 0 && // Pairs with smp_store_release below.\n\t    !READ_ONCE(rtp->rtort_chkp) &&\n\t    !smp_load_acquire(&rtrcp_chker->rtc_assigner)) { // Pairs with smp_store_release below.\n\t\trtrcp->rtc_chkloops = READ_ONCE(rtrcp_chked->rtc_myloops);\n\t\tWARN_ON_ONCE(rtrcp->rtc_chkrdr >= 0);\n\t\trtrcp->rtc_chkrdr = rdrchked;\n\t\tWARN_ON_ONCE(rtrcp->rtc_ready); // This gets set after the grace period ends.\n\t\tif (cmpxchg_relaxed(&rtrcp_chker->rtc_assigner, NULL, rtrcp) ||\n\t\t    cmpxchg_relaxed(&rtp->rtort_chkp, NULL, rtrcp))\n\t\t\t(void)cmpxchg_relaxed(&rtrcp_chker->rtc_assigner, rtrcp, NULL); // Back out.\n\t}\n\n\t// If assigned some completed work, do it!\n\trtrcp_assigner = READ_ONCE(rtrcp->rtc_assigner);\n\tif (!rtrcp_assigner || !smp_load_acquire(&rtrcp_assigner->rtc_ready))\n\t\treturn; // No work or work not yet ready.\n\trdrchked = rtrcp_assigner->rtc_chkrdr;\n\tif (WARN_ON_ONCE(rdrchked < 0))\n\t\treturn;\n\trtrcp_chked = &rcu_torture_reader_mbchk[rdrchked];\n\tloops = READ_ONCE(rtrcp_chked->rtc_myloops);\n\tatomic_inc(&n_rcu_torture_mbchk_tries);\n\tif (ULONG_CMP_LT(loops, rtrcp_assigner->rtc_chkloops))\n\t\tatomic_inc(&n_rcu_torture_mbchk_fail);\n\trtrcp_assigner->rtc_chkloops = loops + ULONG_MAX / 2;\n\trtrcp_assigner->rtc_ready = 0;\n\tsmp_store_release(&rtrcp->rtc_assigner, NULL); // Someone else can assign us work.\n\tsmp_store_release(&rtrcp_assigner->rtc_chkrdr, -1); // Assigner can again assign.\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nrealreaders;",
            "static struct rcu_torture_reader_check *rcu_torture_reader_mbchk;",
            "static atomic_t n_rcu_torture_mbchk_fail;",
            "static atomic_t n_rcu_torture_mbchk_tries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int nrealreaders;\nstatic struct rcu_torture_reader_check *rcu_torture_reader_mbchk;\nstatic atomic_t n_rcu_torture_mbchk_fail;\nstatic atomic_t n_rcu_torture_mbchk_tries;\n\nstatic void rcu_torture_reader_do_mbchk(long myid, struct rcu_torture *rtp,\n\t\t\t\t\tstruct torture_random_state *trsp)\n{\n\tunsigned long loops;\n\tint noc = torture_num_online_cpus();\n\tint rdrchked;\n\tint rdrchker;\n\tstruct rcu_torture_reader_check *rtrcp; // Me.\n\tstruct rcu_torture_reader_check *rtrcp_assigner; // Assigned us to do checking.\n\tstruct rcu_torture_reader_check *rtrcp_chked; // Reader being checked.\n\tstruct rcu_torture_reader_check *rtrcp_chker; // Reader doing checking when not me.\n\n\tif (myid < 0)\n\t\treturn; // Don't try this from timer handlers.\n\n\t// Increment my counter.\n\trtrcp = &rcu_torture_reader_mbchk[myid];\n\tWRITE_ONCE(rtrcp->rtc_myloops, rtrcp->rtc_myloops + 1);\n\n\t// Attempt to assign someone else some checking work.\n\trdrchked = torture_random(trsp) % nrealreaders;\n\trtrcp_chked = &rcu_torture_reader_mbchk[rdrchked];\n\trdrchker = torture_random(trsp) % nrealreaders;\n\trtrcp_chker = &rcu_torture_reader_mbchk[rdrchker];\n\tif (rdrchked != myid && rdrchked != rdrchker && noc >= rdrchked && noc >= rdrchker &&\n\t    smp_load_acquire(&rtrcp->rtc_chkrdr) < 0 && // Pairs with smp_store_release below.\n\t    !READ_ONCE(rtp->rtort_chkp) &&\n\t    !smp_load_acquire(&rtrcp_chker->rtc_assigner)) { // Pairs with smp_store_release below.\n\t\trtrcp->rtc_chkloops = READ_ONCE(rtrcp_chked->rtc_myloops);\n\t\tWARN_ON_ONCE(rtrcp->rtc_chkrdr >= 0);\n\t\trtrcp->rtc_chkrdr = rdrchked;\n\t\tWARN_ON_ONCE(rtrcp->rtc_ready); // This gets set after the grace period ends.\n\t\tif (cmpxchg_relaxed(&rtrcp_chker->rtc_assigner, NULL, rtrcp) ||\n\t\t    cmpxchg_relaxed(&rtp->rtort_chkp, NULL, rtrcp))\n\t\t\t(void)cmpxchg_relaxed(&rtrcp_chker->rtc_assigner, rtrcp, NULL); // Back out.\n\t}\n\n\t// If assigned some completed work, do it!\n\trtrcp_assigner = READ_ONCE(rtrcp->rtc_assigner);\n\tif (!rtrcp_assigner || !smp_load_acquire(&rtrcp_assigner->rtc_ready))\n\t\treturn; // No work or work not yet ready.\n\trdrchked = rtrcp_assigner->rtc_chkrdr;\n\tif (WARN_ON_ONCE(rdrchked < 0))\n\t\treturn;\n\trtrcp_chked = &rcu_torture_reader_mbchk[rdrchked];\n\tloops = READ_ONCE(rtrcp_chked->rtc_myloops);\n\tatomic_inc(&n_rcu_torture_mbchk_tries);\n\tif (ULONG_CMP_LT(loops, rtrcp_assigner->rtc_chkloops))\n\t\tatomic_inc(&n_rcu_torture_mbchk_fail);\n\trtrcp_assigner->rtc_chkloops = loops + ULONG_MAX / 2;\n\trtrcp_assigner->rtc_ready = 0;\n\tsmp_store_release(&rtrcp->rtc_assigner, NULL); // Someone else can assign us work.\n\tsmp_store_release(&rtrcp_assigner->rtc_chkrdr, -1); // Assigner can again assign.\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_rcu_torture_mberror"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "rcu_torture_current",
            "!cur_ops->readlock_held || cur_ops->readlock_held()"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readlock_held",
          "args": [],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_trace_clock_local",
          "args": [],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_trace_clock_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "263-266",
          "snippet": "static u64 notrace rcu_trace_clock_local(void)\n{\n\treturn 0ULL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic u64 notrace rcu_trace_clock_local(void)\n{\n\treturn 0ULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_state",
          "args": [],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutorture_extend_mask",
          "args": [
            "readstate",
            "trsp"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_extend_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1530-1575",
          "snippet": "static int\nrcutorture_extend_mask(int oldmask, struct torture_random_state *trsp)\n{\n\tint mask = rcutorture_extend_mask_max();\n\tunsigned long randmask1 = torture_random(trsp) >> 8;\n\tunsigned long randmask2 = randmask1 >> 3;\n\tunsigned long preempts = RCUTORTURE_RDR_PREEMPT | RCUTORTURE_RDR_SCHED;\n\tunsigned long preempts_irq = preempts | RCUTORTURE_RDR_IRQ;\n\tunsigned long bhs = RCUTORTURE_RDR_BH | RCUTORTURE_RDR_RBH;\n\n\tWARN_ON_ONCE(mask >> RCUTORTURE_RDR_SHIFT_1);\n\t/* Mostly only one bit (need preemption!), sometimes lots of bits. */\n\tif (!(randmask1 & 0x7))\n\t\tmask = mask & randmask2;\n\telse\n\t\tmask = mask & (1 << (randmask2 % RCUTORTURE_RDR_NBITS));\n\n\t// Can't have nested RCU reader without outer RCU reader.\n\tif (!(mask & RCUTORTURE_RDR_RCU_1) && (mask & RCUTORTURE_RDR_RCU_2)) {\n\t\tif (oldmask & RCUTORTURE_RDR_RCU_1)\n\t\t\tmask &= ~RCUTORTURE_RDR_RCU_2;\n\t\telse\n\t\t\tmask |= RCUTORTURE_RDR_RCU_1;\n\t}\n\n\t/*\n\t * Can't enable bh w/irq disabled.\n\t */\n\tif (mask & RCUTORTURE_RDR_IRQ)\n\t\tmask |= oldmask & bhs;\n\n\t/*\n\t * Ideally these sequences would be detected in debug builds\n\t * (regardless of RT), but until then don't stop testing\n\t * them on non-RT.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\t/* Can't modify BH in atomic context */\n\t\tif (oldmask & preempts_irq)\n\t\t\tmask &= ~bhs;\n\t\tif ((oldmask | mask) & preempts_irq)\n\t\t\tmask |= oldmask & bhs;\n\t}\n\n\treturn mask ?: RCUTORTURE_RDR_RCU_1;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCUTORTURE_RDR_NBITS\t 7\t/* Number of bits defined above. */",
            "#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */",
            "#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */",
            "#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */",
            "#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */",
            "#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */",
            "#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */",
            "#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */",
            "#define RCUTORTURE_RDR_SHIFT_1\t 8\t/* Put SRCU index in upper bits. */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_NBITS\t 7\t/* Number of bits defined above. */\n#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */\n#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */\n#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */\n#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */\n#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */\n#define RCUTORTURE_RDR_SHIFT_1\t 8\t/* Put SRCU index in upper bits. */\n\nstatic int\nrcutorture_extend_mask(int oldmask, struct torture_random_state *trsp)\n{\n\tint mask = rcutorture_extend_mask_max();\n\tunsigned long randmask1 = torture_random(trsp) >> 8;\n\tunsigned long randmask2 = randmask1 >> 3;\n\tunsigned long preempts = RCUTORTURE_RDR_PREEMPT | RCUTORTURE_RDR_SCHED;\n\tunsigned long preempts_irq = preempts | RCUTORTURE_RDR_IRQ;\n\tunsigned long bhs = RCUTORTURE_RDR_BH | RCUTORTURE_RDR_RBH;\n\n\tWARN_ON_ONCE(mask >> RCUTORTURE_RDR_SHIFT_1);\n\t/* Mostly only one bit (need preemption!), sometimes lots of bits. */\n\tif (!(randmask1 & 0x7))\n\t\tmask = mask & randmask2;\n\telse\n\t\tmask = mask & (1 << (randmask2 % RCUTORTURE_RDR_NBITS));\n\n\t// Can't have nested RCU reader without outer RCU reader.\n\tif (!(mask & RCUTORTURE_RDR_RCU_1) && (mask & RCUTORTURE_RDR_RCU_2)) {\n\t\tif (oldmask & RCUTORTURE_RDR_RCU_1)\n\t\t\tmask &= ~RCUTORTURE_RDR_RCU_2;\n\t\telse\n\t\t\tmask |= RCUTORTURE_RDR_RCU_1;\n\t}\n\n\t/*\n\t * Can't enable bh w/irq disabled.\n\t */\n\tif (mask & RCUTORTURE_RDR_IRQ)\n\t\tmask |= oldmask & bhs;\n\n\t/*\n\t * Ideally these sequences would be detected in debug builds\n\t * (regardless of RT), but until then don't stop testing\n\t * them on non-RT.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\t/* Can't modify BH in atomic context */\n\t\tif (oldmask & preempts_irq)\n\t\t\tmask &= ~bhs;\n\t\tif ((oldmask | mask) & preempts_irq)\n\t\t\tmask |= oldmask & bhs;\n\t}\n\n\treturn mask ?: RCUTORTURE_RDR_RCU_1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_is_watching()"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1123-1131",
          "snippet": "notrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nnotrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n#define RCUTORTURE_RDR_MAX_SEGS (RCUTORTURE_RDR_MAX_LOOPS + 3)\n\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic atomic_t n_rcu_torture_mberror;\nstatic int rcu_torture_writer_state;\nstatic int err_segs_recorded;\nstatic struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];\nstatic int rt_read_nsegs;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic bool rcu_torture_one_read(struct torture_random_state *trsp, long myid)\n{\n\tunsigned long cookie;\n\tint i;\n\tunsigned long started;\n\tunsigned long completed;\n\tint newstate;\n\tstruct rcu_torture *p;\n\tint pipe_count;\n\tint readstate = 0;\n\tstruct rt_read_seg rtseg[RCUTORTURE_RDR_MAX_SEGS] = { { 0 } };\n\tstruct rt_read_seg *rtrsp = &rtseg[0];\n\tstruct rt_read_seg *rtrsp1;\n\tunsigned long long ts;\n\n\tWARN_ON_ONCE(!rcu_is_watching());\n\tnewstate = rcutorture_extend_mask(readstate, trsp);\n\trcutorture_one_extend(&readstate, newstate, trsp, rtrsp++);\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tcookie = cur_ops->get_gp_state();\n\tstarted = cur_ops->get_gp_seq();\n\tts = rcu_trace_clock_local();\n\tp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t  !cur_ops->readlock_held || cur_ops->readlock_held());\n\tif (p == NULL) {\n\t\t/* Wait for rcu_torture_writer to get underway */\n\t\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\t\treturn false;\n\t}\n\tif (p->rtort_mbtest == 0)\n\t\tatomic_inc(&n_rcu_torture_mberror);\n\trcu_torture_reader_do_mbchk(myid, p, trsp);\n\trtrsp = rcutorture_loop_extend(&readstate, trsp, rtrsp);\n\tpreempt_disable();\n\tpipe_count = READ_ONCE(p->rtort_pipe_count);\n\tif (pipe_count > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tpipe_count = RCU_TORTURE_PIPE_LEN;\n\t}\n\tcompleted = cur_ops->get_gp_seq();\n\tif (pipe_count > 1) {\n\t\tdo_trace_rcu_torture_read(cur_ops->name, &p->rtort_rcu,\n\t\t\t\t\t  ts, started, completed);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\t__this_cpu_inc(rcu_torture_count[pipe_count]);\n\tcompleted = rcutorture_seq_diff(completed, started);\n\tif (completed > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tcompleted = RCU_TORTURE_PIPE_LEN;\n\t}\n\t__this_cpu_inc(rcu_torture_batch[completed]);\n\tpreempt_enable();\n\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state)\n\t\tWARN_ONCE(cur_ops->poll_gp_state(cookie),\n\t\t\t  \"%s: Cookie check 2 failed %s(%d) %lu->%lu\\n\",\n\t\t\t  __func__,\n\t\t\t  rcu_torture_writer_state_getname(),\n\t\t\t  rcu_torture_writer_state,\n\t\t\t  cookie, cur_ops->get_gp_state());\n\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\tWARN_ON_ONCE(readstate);\n\t// This next splat is expected behavior if leakpointer, especially\n\t// for CONFIG_RCU_STRICT_GRACE_PERIOD=y kernels.\n\tWARN_ON_ONCE(leakpointer && READ_ONCE(p->rtort_pipe_count) > 1);\n\n\t/* If error or close call, record the sequence of reader protections. */\n\tif ((pipe_count > 1 || completed > 1) && !xchg(&err_segs_recorded, 1)) {\n\t\ti = 0;\n\t\tfor (rtrsp1 = &rtseg[0]; rtrsp1 < rtrsp; rtrsp1++)\n\t\t\terr_segs[i++] = *rtrsp1;\n\t\trt_read_nsegs = i;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "rcutorture_loop_extend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1581-1600",
    "snippet": "static struct rt_read_seg *\nrcutorture_loop_extend(int *readstate, struct torture_random_state *trsp,\n\t\t       struct rt_read_seg *rtrsp)\n{\n\tint i;\n\tint j;\n\tint mask = rcutorture_extend_mask_max();\n\n\tWARN_ON_ONCE(!*readstate); /* -Existing- RCU read-side critsect! */\n\tif (!((mask - 1) & mask))\n\t\treturn rtrsp;  /* Current RCU reader not extendable. */\n\t/* Bias towards larger numbers of loops. */\n\ti = (torture_random(trsp) >> 3);\n\ti = ((i | (i >> 3)) & RCUTORTURE_RDR_MAX_LOOPS) + 1;\n\tfor (j = 0; j < i; j++) {\n\t\tmask = rcutorture_extend_mask(*readstate, trsp);\n\t\trcutorture_one_extend(readstate, mask, trsp, &rtrsp[j]);\n\t}\n\treturn &rtrsp[j];\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCUTORTURE_RDR_MAX_LOOPS 0x7\t/* Maximum reader extensions. */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcutorture_one_extend",
          "args": [
            "readstate",
            "mask",
            "trsp",
            "&rtrsp[j]"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_one_extend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1431-1516",
          "snippet": "static void rcutorture_one_extend(int *readstate, int newstate,\n\t\t\t\t  struct torture_random_state *trsp,\n\t\t\t\t  struct rt_read_seg *rtrsp)\n{\n\tunsigned long flags;\n\tint idxnew1 = -1;\n\tint idxnew2 = -1;\n\tint idxold1 = *readstate;\n\tint idxold2 = idxold1;\n\tint statesnew = ~*readstate & newstate;\n\tint statesold = *readstate & ~newstate;\n\n\tWARN_ON_ONCE(idxold2 < 0);\n\tWARN_ON_ONCE((idxold2 >> RCUTORTURE_RDR_SHIFT_2) > 1);\n\trtrsp->rt_readstate = newstate;\n\n\t/* First, put new protection in place to avoid critical-section gap. */\n\tif (statesnew & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_disable();\n\tif (statesnew & RCUTORTURE_RDR_RBH)\n\t\trcu_read_lock_bh();\n\tif (statesnew & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_disable();\n\tif (statesnew & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_disable();\n\tif (statesnew & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_lock_sched();\n\tif (statesnew & RCUTORTURE_RDR_RCU_1)\n\t\tidxnew1 = (cur_ops->readlock() & 0x1) << RCUTORTURE_RDR_SHIFT_1;\n\tif (statesnew & RCUTORTURE_RDR_RCU_2)\n\t\tidxnew2 = (cur_ops->readlock() & 0x1) << RCUTORTURE_RDR_SHIFT_2;\n\n\t/*\n\t * Next, remove old protection, in decreasing order of strength\n\t * to avoid unlock paths that aren't safe in the stronger\n\t * context. Namely: BH can not be enabled with disabled interrupts.\n\t * Additionally PREEMPT_RT requires that BH is enabled in preemptible\n\t * context.\n\t */\n\tif (statesold & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_enable();\n\tif (statesold & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_enable();\n\tif (statesold & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_unlock_sched();\n\tif (statesold & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_enable();\n\tif (statesold & RCUTORTURE_RDR_RBH)\n\t\trcu_read_unlock_bh();\n\tif (statesold & RCUTORTURE_RDR_RCU_2) {\n\t\tcur_ops->readunlock((idxold2 >> RCUTORTURE_RDR_SHIFT_2) & 0x1);\n\t\tWARN_ON_ONCE(idxnew2 != -1);\n\t\tidxold2 = 0;\n\t}\n\tif (statesold & RCUTORTURE_RDR_RCU_1) {\n\t\tbool lockit;\n\n\t\tlockit = !cur_ops->no_pi_lock && !statesnew && !(torture_random(trsp) & 0xffff);\n\t\tif (lockit)\n\t\t\traw_spin_lock_irqsave(&current->pi_lock, flags);\n\t\tcur_ops->readunlock((idxold1 >> RCUTORTURE_RDR_SHIFT_1) & 0x1);\n\t\tWARN_ON_ONCE(idxnew1 != -1);\n\t\tidxold1 = 0;\n\t\tif (lockit)\n\t\t\traw_spin_unlock_irqrestore(&current->pi_lock, flags);\n\t}\n\n\t/* Delay if neither beginning nor end and there was a change. */\n\tif ((statesnew || statesold) && *readstate && newstate)\n\t\tcur_ops->read_delay(trsp, rtrsp);\n\n\t/* Update the reader state. */\n\tif (idxnew1 == -1)\n\t\tidxnew1 = idxold1 & RCUTORTURE_RDR_MASK_1;\n\tWARN_ON_ONCE(idxnew1 < 0);\n\tif (WARN_ON_ONCE((idxnew1 >> RCUTORTURE_RDR_SHIFT_1) > 1))\n\t\tpr_info(\"Unexpected idxnew1 value of %#x\\n\", idxnew1);\n\tif (idxnew2 == -1)\n\t\tidxnew2 = idxold2 & RCUTORTURE_RDR_MASK_2;\n\tWARN_ON_ONCE(idxnew2 < 0);\n\tWARN_ON_ONCE((idxnew2 >> RCUTORTURE_RDR_SHIFT_2) > 1);\n\t*readstate = idxnew1 | idxnew2 | newstate;\n\tWARN_ON_ONCE(*readstate < 0);\n\tif (WARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT_2) > 1))\n\t\tpr_info(\"Unexpected idxnew2 value of %#x\\n\", idxnew2);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */",
            "#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */",
            "#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */",
            "#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */",
            "#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */",
            "#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */",
            "#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */",
            "#define RCUTORTURE_RDR_MASK_2\t (1 << RCUTORTURE_RDR_SHIFT_2)",
            "#define RCUTORTURE_RDR_SHIFT_2\t 9\t/* Put SRCU index in upper bits. */",
            "#define RCUTORTURE_RDR_MASK_1\t (1 << RCUTORTURE_RDR_SHIFT_1)",
            "#define RCUTORTURE_RDR_SHIFT_1\t 8\t/* Put SRCU index in upper bits. */"
          ],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */\n#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */\n#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */\n#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */\n#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */\n#define RCUTORTURE_RDR_MASK_2\t (1 << RCUTORTURE_RDR_SHIFT_2)\n#define RCUTORTURE_RDR_SHIFT_2\t 9\t/* Put SRCU index in upper bits. */\n#define RCUTORTURE_RDR_MASK_1\t (1 << RCUTORTURE_RDR_SHIFT_1)\n#define RCUTORTURE_RDR_SHIFT_1\t 8\t/* Put SRCU index in upper bits. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void rcutorture_one_extend(int *readstate, int newstate,\n\t\t\t\t  struct torture_random_state *trsp,\n\t\t\t\t  struct rt_read_seg *rtrsp)\n{\n\tunsigned long flags;\n\tint idxnew1 = -1;\n\tint idxnew2 = -1;\n\tint idxold1 = *readstate;\n\tint idxold2 = idxold1;\n\tint statesnew = ~*readstate & newstate;\n\tint statesold = *readstate & ~newstate;\n\n\tWARN_ON_ONCE(idxold2 < 0);\n\tWARN_ON_ONCE((idxold2 >> RCUTORTURE_RDR_SHIFT_2) > 1);\n\trtrsp->rt_readstate = newstate;\n\n\t/* First, put new protection in place to avoid critical-section gap. */\n\tif (statesnew & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_disable();\n\tif (statesnew & RCUTORTURE_RDR_RBH)\n\t\trcu_read_lock_bh();\n\tif (statesnew & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_disable();\n\tif (statesnew & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_disable();\n\tif (statesnew & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_lock_sched();\n\tif (statesnew & RCUTORTURE_RDR_RCU_1)\n\t\tidxnew1 = (cur_ops->readlock() & 0x1) << RCUTORTURE_RDR_SHIFT_1;\n\tif (statesnew & RCUTORTURE_RDR_RCU_2)\n\t\tidxnew2 = (cur_ops->readlock() & 0x1) << RCUTORTURE_RDR_SHIFT_2;\n\n\t/*\n\t * Next, remove old protection, in decreasing order of strength\n\t * to avoid unlock paths that aren't safe in the stronger\n\t * context. Namely: BH can not be enabled with disabled interrupts.\n\t * Additionally PREEMPT_RT requires that BH is enabled in preemptible\n\t * context.\n\t */\n\tif (statesold & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_enable();\n\tif (statesold & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_enable();\n\tif (statesold & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_unlock_sched();\n\tif (statesold & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_enable();\n\tif (statesold & RCUTORTURE_RDR_RBH)\n\t\trcu_read_unlock_bh();\n\tif (statesold & RCUTORTURE_RDR_RCU_2) {\n\t\tcur_ops->readunlock((idxold2 >> RCUTORTURE_RDR_SHIFT_2) & 0x1);\n\t\tWARN_ON_ONCE(idxnew2 != -1);\n\t\tidxold2 = 0;\n\t}\n\tif (statesold & RCUTORTURE_RDR_RCU_1) {\n\t\tbool lockit;\n\n\t\tlockit = !cur_ops->no_pi_lock && !statesnew && !(torture_random(trsp) & 0xffff);\n\t\tif (lockit)\n\t\t\traw_spin_lock_irqsave(&current->pi_lock, flags);\n\t\tcur_ops->readunlock((idxold1 >> RCUTORTURE_RDR_SHIFT_1) & 0x1);\n\t\tWARN_ON_ONCE(idxnew1 != -1);\n\t\tidxold1 = 0;\n\t\tif (lockit)\n\t\t\traw_spin_unlock_irqrestore(&current->pi_lock, flags);\n\t}\n\n\t/* Delay if neither beginning nor end and there was a change. */\n\tif ((statesnew || statesold) && *readstate && newstate)\n\t\tcur_ops->read_delay(trsp, rtrsp);\n\n\t/* Update the reader state. */\n\tif (idxnew1 == -1)\n\t\tidxnew1 = idxold1 & RCUTORTURE_RDR_MASK_1;\n\tWARN_ON_ONCE(idxnew1 < 0);\n\tif (WARN_ON_ONCE((idxnew1 >> RCUTORTURE_RDR_SHIFT_1) > 1))\n\t\tpr_info(\"Unexpected idxnew1 value of %#x\\n\", idxnew1);\n\tif (idxnew2 == -1)\n\t\tidxnew2 = idxold2 & RCUTORTURE_RDR_MASK_2;\n\tWARN_ON_ONCE(idxnew2 < 0);\n\tWARN_ON_ONCE((idxnew2 >> RCUTORTURE_RDR_SHIFT_2) > 1);\n\t*readstate = idxnew1 | idxnew2 | newstate;\n\tWARN_ON_ONCE(*readstate < 0);\n\tif (WARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT_2) > 1))\n\t\tpr_info(\"Unexpected idxnew2 value of %#x\\n\", idxnew2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcutorture_extend_mask",
          "args": [
            "*readstate",
            "trsp"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_extend_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1530-1575",
          "snippet": "static int\nrcutorture_extend_mask(int oldmask, struct torture_random_state *trsp)\n{\n\tint mask = rcutorture_extend_mask_max();\n\tunsigned long randmask1 = torture_random(trsp) >> 8;\n\tunsigned long randmask2 = randmask1 >> 3;\n\tunsigned long preempts = RCUTORTURE_RDR_PREEMPT | RCUTORTURE_RDR_SCHED;\n\tunsigned long preempts_irq = preempts | RCUTORTURE_RDR_IRQ;\n\tunsigned long bhs = RCUTORTURE_RDR_BH | RCUTORTURE_RDR_RBH;\n\n\tWARN_ON_ONCE(mask >> RCUTORTURE_RDR_SHIFT_1);\n\t/* Mostly only one bit (need preemption!), sometimes lots of bits. */\n\tif (!(randmask1 & 0x7))\n\t\tmask = mask & randmask2;\n\telse\n\t\tmask = mask & (1 << (randmask2 % RCUTORTURE_RDR_NBITS));\n\n\t// Can't have nested RCU reader without outer RCU reader.\n\tif (!(mask & RCUTORTURE_RDR_RCU_1) && (mask & RCUTORTURE_RDR_RCU_2)) {\n\t\tif (oldmask & RCUTORTURE_RDR_RCU_1)\n\t\t\tmask &= ~RCUTORTURE_RDR_RCU_2;\n\t\telse\n\t\t\tmask |= RCUTORTURE_RDR_RCU_1;\n\t}\n\n\t/*\n\t * Can't enable bh w/irq disabled.\n\t */\n\tif (mask & RCUTORTURE_RDR_IRQ)\n\t\tmask |= oldmask & bhs;\n\n\t/*\n\t * Ideally these sequences would be detected in debug builds\n\t * (regardless of RT), but until then don't stop testing\n\t * them on non-RT.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\t/* Can't modify BH in atomic context */\n\t\tif (oldmask & preempts_irq)\n\t\t\tmask &= ~bhs;\n\t\tif ((oldmask | mask) & preempts_irq)\n\t\t\tmask |= oldmask & bhs;\n\t}\n\n\treturn mask ?: RCUTORTURE_RDR_RCU_1;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCUTORTURE_RDR_NBITS\t 7\t/* Number of bits defined above. */",
            "#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */",
            "#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */",
            "#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */",
            "#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */",
            "#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */",
            "#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */",
            "#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */",
            "#define RCUTORTURE_RDR_SHIFT_1\t 8\t/* Put SRCU index in upper bits. */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_NBITS\t 7\t/* Number of bits defined above. */\n#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */\n#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */\n#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */\n#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */\n#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */\n#define RCUTORTURE_RDR_SHIFT_1\t 8\t/* Put SRCU index in upper bits. */\n\nstatic int\nrcutorture_extend_mask(int oldmask, struct torture_random_state *trsp)\n{\n\tint mask = rcutorture_extend_mask_max();\n\tunsigned long randmask1 = torture_random(trsp) >> 8;\n\tunsigned long randmask2 = randmask1 >> 3;\n\tunsigned long preempts = RCUTORTURE_RDR_PREEMPT | RCUTORTURE_RDR_SCHED;\n\tunsigned long preempts_irq = preempts | RCUTORTURE_RDR_IRQ;\n\tunsigned long bhs = RCUTORTURE_RDR_BH | RCUTORTURE_RDR_RBH;\n\n\tWARN_ON_ONCE(mask >> RCUTORTURE_RDR_SHIFT_1);\n\t/* Mostly only one bit (need preemption!), sometimes lots of bits. */\n\tif (!(randmask1 & 0x7))\n\t\tmask = mask & randmask2;\n\telse\n\t\tmask = mask & (1 << (randmask2 % RCUTORTURE_RDR_NBITS));\n\n\t// Can't have nested RCU reader without outer RCU reader.\n\tif (!(mask & RCUTORTURE_RDR_RCU_1) && (mask & RCUTORTURE_RDR_RCU_2)) {\n\t\tif (oldmask & RCUTORTURE_RDR_RCU_1)\n\t\t\tmask &= ~RCUTORTURE_RDR_RCU_2;\n\t\telse\n\t\t\tmask |= RCUTORTURE_RDR_RCU_1;\n\t}\n\n\t/*\n\t * Can't enable bh w/irq disabled.\n\t */\n\tif (mask & RCUTORTURE_RDR_IRQ)\n\t\tmask |= oldmask & bhs;\n\n\t/*\n\t * Ideally these sequences would be detected in debug builds\n\t * (regardless of RT), but until then don't stop testing\n\t * them on non-RT.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\t/* Can't modify BH in atomic context */\n\t\tif (oldmask & preempts_irq)\n\t\t\tmask &= ~bhs;\n\t\tif ((oldmask | mask) & preempts_irq)\n\t\t\tmask |= oldmask & bhs;\n\t}\n\n\treturn mask ?: RCUTORTURE_RDR_RCU_1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!*readstate"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutorture_extend_mask_max",
          "args": [],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_extend_mask_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1519-1527",
          "snippet": "static int rcutorture_extend_mask_max(void)\n{\n\tint mask;\n\n\tWARN_ON_ONCE(extendables & ~RCUTORTURE_MAX_EXTEND);\n\tmask = extendables & RCUTORTURE_MAX_EXTEND & cur_ops->extendables;\n\tmask = mask | RCUTORTURE_RDR_RCU_1 | RCUTORTURE_RDR_RCU_2;\n\treturn mask;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCUTORTURE_MAX_EXTEND\t \\\n\t(RCUTORTURE_RDR_BH | RCUTORTURE_RDR_IRQ | RCUTORTURE_RDR_PREEMPT | \\\n\t RCUTORTURE_RDR_RBH | RCUTORTURE_RDR_SCHED)",
            "#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */",
            "#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */"
          ],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_MAX_EXTEND\t \\\n\t(RCUTORTURE_RDR_BH | RCUTORTURE_RDR_IRQ | RCUTORTURE_RDR_PREEMPT | \\\n\t RCUTORTURE_RDR_RBH | RCUTORTURE_RDR_SCHED)\n#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcutorture_extend_mask_max(void)\n{\n\tint mask;\n\n\tWARN_ON_ONCE(extendables & ~RCUTORTURE_MAX_EXTEND);\n\tmask = extendables & RCUTORTURE_MAX_EXTEND & cur_ops->extendables;\n\tmask = mask | RCUTORTURE_RDR_RCU_1 | RCUTORTURE_RDR_RCU_2;\n\treturn mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_MAX_LOOPS 0x7\t/* Maximum reader extensions. */\n\nstatic struct rt_read_seg *\nrcutorture_loop_extend(int *readstate, struct torture_random_state *trsp,\n\t\t       struct rt_read_seg *rtrsp)\n{\n\tint i;\n\tint j;\n\tint mask = rcutorture_extend_mask_max();\n\n\tWARN_ON_ONCE(!*readstate); /* -Existing- RCU read-side critsect! */\n\tif (!((mask - 1) & mask))\n\t\treturn rtrsp;  /* Current RCU reader not extendable. */\n\t/* Bias towards larger numbers of loops. */\n\ti = (torture_random(trsp) >> 3);\n\ti = ((i | (i >> 3)) & RCUTORTURE_RDR_MAX_LOOPS) + 1;\n\tfor (j = 0; j < i; j++) {\n\t\tmask = rcutorture_extend_mask(*readstate, trsp);\n\t\trcutorture_one_extend(readstate, mask, trsp, &rtrsp[j]);\n\t}\n\treturn &rtrsp[j];\n}"
  },
  {
    "function_name": "rcutorture_extend_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1530-1575",
    "snippet": "static int\nrcutorture_extend_mask(int oldmask, struct torture_random_state *trsp)\n{\n\tint mask = rcutorture_extend_mask_max();\n\tunsigned long randmask1 = torture_random(trsp) >> 8;\n\tunsigned long randmask2 = randmask1 >> 3;\n\tunsigned long preempts = RCUTORTURE_RDR_PREEMPT | RCUTORTURE_RDR_SCHED;\n\tunsigned long preempts_irq = preempts | RCUTORTURE_RDR_IRQ;\n\tunsigned long bhs = RCUTORTURE_RDR_BH | RCUTORTURE_RDR_RBH;\n\n\tWARN_ON_ONCE(mask >> RCUTORTURE_RDR_SHIFT_1);\n\t/* Mostly only one bit (need preemption!), sometimes lots of bits. */\n\tif (!(randmask1 & 0x7))\n\t\tmask = mask & randmask2;\n\telse\n\t\tmask = mask & (1 << (randmask2 % RCUTORTURE_RDR_NBITS));\n\n\t// Can't have nested RCU reader without outer RCU reader.\n\tif (!(mask & RCUTORTURE_RDR_RCU_1) && (mask & RCUTORTURE_RDR_RCU_2)) {\n\t\tif (oldmask & RCUTORTURE_RDR_RCU_1)\n\t\t\tmask &= ~RCUTORTURE_RDR_RCU_2;\n\t\telse\n\t\t\tmask |= RCUTORTURE_RDR_RCU_1;\n\t}\n\n\t/*\n\t * Can't enable bh w/irq disabled.\n\t */\n\tif (mask & RCUTORTURE_RDR_IRQ)\n\t\tmask |= oldmask & bhs;\n\n\t/*\n\t * Ideally these sequences would be detected in debug builds\n\t * (regardless of RT), but until then don't stop testing\n\t * them on non-RT.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\t/* Can't modify BH in atomic context */\n\t\tif (oldmask & preempts_irq)\n\t\t\tmask &= ~bhs;\n\t\tif ((oldmask | mask) & preempts_irq)\n\t\t\tmask |= oldmask & bhs;\n\t}\n\n\treturn mask ?: RCUTORTURE_RDR_RCU_1;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCUTORTURE_RDR_NBITS\t 7\t/* Number of bits defined above. */",
      "#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */",
      "#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */",
      "#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */",
      "#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */",
      "#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */",
      "#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */",
      "#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */",
      "#define RCUTORTURE_RDR_SHIFT_1\t 8\t/* Put SRCU index in upper bits. */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "mask >> RCUTORTURE_RDR_SHIFT_1"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcutorture_extend_mask_max",
          "args": [],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_extend_mask_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "1519-1527",
          "snippet": "static int rcutorture_extend_mask_max(void)\n{\n\tint mask;\n\n\tWARN_ON_ONCE(extendables & ~RCUTORTURE_MAX_EXTEND);\n\tmask = extendables & RCUTORTURE_MAX_EXTEND & cur_ops->extendables;\n\tmask = mask | RCUTORTURE_RDR_RCU_1 | RCUTORTURE_RDR_RCU_2;\n\treturn mask;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCUTORTURE_MAX_EXTEND\t \\\n\t(RCUTORTURE_RDR_BH | RCUTORTURE_RDR_IRQ | RCUTORTURE_RDR_PREEMPT | \\\n\t RCUTORTURE_RDR_RBH | RCUTORTURE_RDR_SCHED)",
            "#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */",
            "#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */"
          ],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_MAX_EXTEND\t \\\n\t(RCUTORTURE_RDR_BH | RCUTORTURE_RDR_IRQ | RCUTORTURE_RDR_PREEMPT | \\\n\t RCUTORTURE_RDR_RBH | RCUTORTURE_RDR_SCHED)\n#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcutorture_extend_mask_max(void)\n{\n\tint mask;\n\n\tWARN_ON_ONCE(extendables & ~RCUTORTURE_MAX_EXTEND);\n\tmask = extendables & RCUTORTURE_MAX_EXTEND & cur_ops->extendables;\n\tmask = mask | RCUTORTURE_RDR_RCU_1 | RCUTORTURE_RDR_RCU_2;\n\treturn mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_NBITS\t 7\t/* Number of bits defined above. */\n#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */\n#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */\n#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */\n#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */\n#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */\n#define RCUTORTURE_RDR_SHIFT_1\t 8\t/* Put SRCU index in upper bits. */\n\nstatic int\nrcutorture_extend_mask(int oldmask, struct torture_random_state *trsp)\n{\n\tint mask = rcutorture_extend_mask_max();\n\tunsigned long randmask1 = torture_random(trsp) >> 8;\n\tunsigned long randmask2 = randmask1 >> 3;\n\tunsigned long preempts = RCUTORTURE_RDR_PREEMPT | RCUTORTURE_RDR_SCHED;\n\tunsigned long preempts_irq = preempts | RCUTORTURE_RDR_IRQ;\n\tunsigned long bhs = RCUTORTURE_RDR_BH | RCUTORTURE_RDR_RBH;\n\n\tWARN_ON_ONCE(mask >> RCUTORTURE_RDR_SHIFT_1);\n\t/* Mostly only one bit (need preemption!), sometimes lots of bits. */\n\tif (!(randmask1 & 0x7))\n\t\tmask = mask & randmask2;\n\telse\n\t\tmask = mask & (1 << (randmask2 % RCUTORTURE_RDR_NBITS));\n\n\t// Can't have nested RCU reader without outer RCU reader.\n\tif (!(mask & RCUTORTURE_RDR_RCU_1) && (mask & RCUTORTURE_RDR_RCU_2)) {\n\t\tif (oldmask & RCUTORTURE_RDR_RCU_1)\n\t\t\tmask &= ~RCUTORTURE_RDR_RCU_2;\n\t\telse\n\t\t\tmask |= RCUTORTURE_RDR_RCU_1;\n\t}\n\n\t/*\n\t * Can't enable bh w/irq disabled.\n\t */\n\tif (mask & RCUTORTURE_RDR_IRQ)\n\t\tmask |= oldmask & bhs;\n\n\t/*\n\t * Ideally these sequences would be detected in debug builds\n\t * (regardless of RT), but until then don't stop testing\n\t * them on non-RT.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\t/* Can't modify BH in atomic context */\n\t\tif (oldmask & preempts_irq)\n\t\t\tmask &= ~bhs;\n\t\tif ((oldmask | mask) & preempts_irq)\n\t\t\tmask |= oldmask & bhs;\n\t}\n\n\treturn mask ?: RCUTORTURE_RDR_RCU_1;\n}"
  },
  {
    "function_name": "rcutorture_extend_mask_max",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1519-1527",
    "snippet": "static int rcutorture_extend_mask_max(void)\n{\n\tint mask;\n\n\tWARN_ON_ONCE(extendables & ~RCUTORTURE_MAX_EXTEND);\n\tmask = extendables & RCUTORTURE_MAX_EXTEND & cur_ops->extendables;\n\tmask = mask | RCUTORTURE_RDR_RCU_1 | RCUTORTURE_RDR_RCU_2;\n\treturn mask;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCUTORTURE_MAX_EXTEND\t \\\n\t(RCUTORTURE_RDR_BH | RCUTORTURE_RDR_IRQ | RCUTORTURE_RDR_PREEMPT | \\\n\t RCUTORTURE_RDR_RBH | RCUTORTURE_RDR_SCHED)",
      "#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */",
      "#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */"
    ],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "extendables & ~RCUTORTURE_MAX_EXTEND"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_MAX_EXTEND\t \\\n\t(RCUTORTURE_RDR_BH | RCUTORTURE_RDR_IRQ | RCUTORTURE_RDR_PREEMPT | \\\n\t RCUTORTURE_RDR_RBH | RCUTORTURE_RDR_SCHED)\n#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcutorture_extend_mask_max(void)\n{\n\tint mask;\n\n\tWARN_ON_ONCE(extendables & ~RCUTORTURE_MAX_EXTEND);\n\tmask = extendables & RCUTORTURE_MAX_EXTEND & cur_ops->extendables;\n\tmask = mask | RCUTORTURE_RDR_RCU_1 | RCUTORTURE_RDR_RCU_2;\n\treturn mask;\n}"
  },
  {
    "function_name": "rcutorture_one_extend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1431-1516",
    "snippet": "static void rcutorture_one_extend(int *readstate, int newstate,\n\t\t\t\t  struct torture_random_state *trsp,\n\t\t\t\t  struct rt_read_seg *rtrsp)\n{\n\tunsigned long flags;\n\tint idxnew1 = -1;\n\tint idxnew2 = -1;\n\tint idxold1 = *readstate;\n\tint idxold2 = idxold1;\n\tint statesnew = ~*readstate & newstate;\n\tint statesold = *readstate & ~newstate;\n\n\tWARN_ON_ONCE(idxold2 < 0);\n\tWARN_ON_ONCE((idxold2 >> RCUTORTURE_RDR_SHIFT_2) > 1);\n\trtrsp->rt_readstate = newstate;\n\n\t/* First, put new protection in place to avoid critical-section gap. */\n\tif (statesnew & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_disable();\n\tif (statesnew & RCUTORTURE_RDR_RBH)\n\t\trcu_read_lock_bh();\n\tif (statesnew & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_disable();\n\tif (statesnew & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_disable();\n\tif (statesnew & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_lock_sched();\n\tif (statesnew & RCUTORTURE_RDR_RCU_1)\n\t\tidxnew1 = (cur_ops->readlock() & 0x1) << RCUTORTURE_RDR_SHIFT_1;\n\tif (statesnew & RCUTORTURE_RDR_RCU_2)\n\t\tidxnew2 = (cur_ops->readlock() & 0x1) << RCUTORTURE_RDR_SHIFT_2;\n\n\t/*\n\t * Next, remove old protection, in decreasing order of strength\n\t * to avoid unlock paths that aren't safe in the stronger\n\t * context. Namely: BH can not be enabled with disabled interrupts.\n\t * Additionally PREEMPT_RT requires that BH is enabled in preemptible\n\t * context.\n\t */\n\tif (statesold & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_enable();\n\tif (statesold & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_enable();\n\tif (statesold & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_unlock_sched();\n\tif (statesold & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_enable();\n\tif (statesold & RCUTORTURE_RDR_RBH)\n\t\trcu_read_unlock_bh();\n\tif (statesold & RCUTORTURE_RDR_RCU_2) {\n\t\tcur_ops->readunlock((idxold2 >> RCUTORTURE_RDR_SHIFT_2) & 0x1);\n\t\tWARN_ON_ONCE(idxnew2 != -1);\n\t\tidxold2 = 0;\n\t}\n\tif (statesold & RCUTORTURE_RDR_RCU_1) {\n\t\tbool lockit;\n\n\t\tlockit = !cur_ops->no_pi_lock && !statesnew && !(torture_random(trsp) & 0xffff);\n\t\tif (lockit)\n\t\t\traw_spin_lock_irqsave(&current->pi_lock, flags);\n\t\tcur_ops->readunlock((idxold1 >> RCUTORTURE_RDR_SHIFT_1) & 0x1);\n\t\tWARN_ON_ONCE(idxnew1 != -1);\n\t\tidxold1 = 0;\n\t\tif (lockit)\n\t\t\traw_spin_unlock_irqrestore(&current->pi_lock, flags);\n\t}\n\n\t/* Delay if neither beginning nor end and there was a change. */\n\tif ((statesnew || statesold) && *readstate && newstate)\n\t\tcur_ops->read_delay(trsp, rtrsp);\n\n\t/* Update the reader state. */\n\tif (idxnew1 == -1)\n\t\tidxnew1 = idxold1 & RCUTORTURE_RDR_MASK_1;\n\tWARN_ON_ONCE(idxnew1 < 0);\n\tif (WARN_ON_ONCE((idxnew1 >> RCUTORTURE_RDR_SHIFT_1) > 1))\n\t\tpr_info(\"Unexpected idxnew1 value of %#x\\n\", idxnew1);\n\tif (idxnew2 == -1)\n\t\tidxnew2 = idxold2 & RCUTORTURE_RDR_MASK_2;\n\tWARN_ON_ONCE(idxnew2 < 0);\n\tWARN_ON_ONCE((idxnew2 >> RCUTORTURE_RDR_SHIFT_2) > 1);\n\t*readstate = idxnew1 | idxnew2 | newstate;\n\tWARN_ON_ONCE(*readstate < 0);\n\tif (WARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT_2) > 1))\n\t\tpr_info(\"Unexpected idxnew2 value of %#x\\n\", idxnew2);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */",
      "#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */",
      "#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */",
      "#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */",
      "#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */",
      "#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */",
      "#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */",
      "#define RCUTORTURE_RDR_MASK_2\t (1 << RCUTORTURE_RDR_SHIFT_2)",
      "#define RCUTORTURE_RDR_SHIFT_2\t 9\t/* Put SRCU index in upper bits. */",
      "#define RCUTORTURE_RDR_MASK_1\t (1 << RCUTORTURE_RDR_SHIFT_1)",
      "#define RCUTORTURE_RDR_SHIFT_1\t 8\t/* Put SRCU index in upper bits. */"
    ],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Unexpected idxnew2 value of %#x\\n\"",
            "idxnew2"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(*readstate >> RCUTORTURE_RDR_SHIFT_2) > 1"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "*readstate < 0"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(idxnew2 >> RCUTORTURE_RDR_SHIFT_2) > 1"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "idxnew2 < 0"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Unexpected idxnew1 value of %#x\\n\"",
            "idxnew1"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(idxnew1 >> RCUTORTURE_RDR_SHIFT_1) > 1"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "idxnew1 < 0"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->read_delay",
          "args": [
            "trsp",
            "rtrsp"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&current->pi_lock",
            "flags"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "idxnew1 != -1"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readunlock",
          "args": [
            "(idxold1 >> RCUTORTURE_RDR_SHIFT_1) & 0x1"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&current->pi_lock",
            "flags"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "idxnew2 != -1"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readunlock",
          "args": [
            "(idxold2 >> RCUTORTURE_RDR_SHIFT_2) & 0x1"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_bh",
          "args": [],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "353-357",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readlock",
          "args": [],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readlock",
          "args": [],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_bh",
          "args": [],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "330-337",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(idxold2 >> RCUTORTURE_RDR_SHIFT_2) > 1"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "idxold2 < 0"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_RCU_2\t 0x40\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_RCU_1\t 0x20\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */\n#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */\n#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */\n#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */\n#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */\n#define RCUTORTURE_RDR_MASK_2\t (1 << RCUTORTURE_RDR_SHIFT_2)\n#define RCUTORTURE_RDR_SHIFT_2\t 9\t/* Put SRCU index in upper bits. */\n#define RCUTORTURE_RDR_MASK_1\t (1 << RCUTORTURE_RDR_SHIFT_1)\n#define RCUTORTURE_RDR_SHIFT_1\t 8\t/* Put SRCU index in upper bits. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void rcutorture_one_extend(int *readstate, int newstate,\n\t\t\t\t  struct torture_random_state *trsp,\n\t\t\t\t  struct rt_read_seg *rtrsp)\n{\n\tunsigned long flags;\n\tint idxnew1 = -1;\n\tint idxnew2 = -1;\n\tint idxold1 = *readstate;\n\tint idxold2 = idxold1;\n\tint statesnew = ~*readstate & newstate;\n\tint statesold = *readstate & ~newstate;\n\n\tWARN_ON_ONCE(idxold2 < 0);\n\tWARN_ON_ONCE((idxold2 >> RCUTORTURE_RDR_SHIFT_2) > 1);\n\trtrsp->rt_readstate = newstate;\n\n\t/* First, put new protection in place to avoid critical-section gap. */\n\tif (statesnew & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_disable();\n\tif (statesnew & RCUTORTURE_RDR_RBH)\n\t\trcu_read_lock_bh();\n\tif (statesnew & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_disable();\n\tif (statesnew & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_disable();\n\tif (statesnew & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_lock_sched();\n\tif (statesnew & RCUTORTURE_RDR_RCU_1)\n\t\tidxnew1 = (cur_ops->readlock() & 0x1) << RCUTORTURE_RDR_SHIFT_1;\n\tif (statesnew & RCUTORTURE_RDR_RCU_2)\n\t\tidxnew2 = (cur_ops->readlock() & 0x1) << RCUTORTURE_RDR_SHIFT_2;\n\n\t/*\n\t * Next, remove old protection, in decreasing order of strength\n\t * to avoid unlock paths that aren't safe in the stronger\n\t * context. Namely: BH can not be enabled with disabled interrupts.\n\t * Additionally PREEMPT_RT requires that BH is enabled in preemptible\n\t * context.\n\t */\n\tif (statesold & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_enable();\n\tif (statesold & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_enable();\n\tif (statesold & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_unlock_sched();\n\tif (statesold & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_enable();\n\tif (statesold & RCUTORTURE_RDR_RBH)\n\t\trcu_read_unlock_bh();\n\tif (statesold & RCUTORTURE_RDR_RCU_2) {\n\t\tcur_ops->readunlock((idxold2 >> RCUTORTURE_RDR_SHIFT_2) & 0x1);\n\t\tWARN_ON_ONCE(idxnew2 != -1);\n\t\tidxold2 = 0;\n\t}\n\tif (statesold & RCUTORTURE_RDR_RCU_1) {\n\t\tbool lockit;\n\n\t\tlockit = !cur_ops->no_pi_lock && !statesnew && !(torture_random(trsp) & 0xffff);\n\t\tif (lockit)\n\t\t\traw_spin_lock_irqsave(&current->pi_lock, flags);\n\t\tcur_ops->readunlock((idxold1 >> RCUTORTURE_RDR_SHIFT_1) & 0x1);\n\t\tWARN_ON_ONCE(idxnew1 != -1);\n\t\tidxold1 = 0;\n\t\tif (lockit)\n\t\t\traw_spin_unlock_irqrestore(&current->pi_lock, flags);\n\t}\n\n\t/* Delay if neither beginning nor end and there was a change. */\n\tif ((statesnew || statesold) && *readstate && newstate)\n\t\tcur_ops->read_delay(trsp, rtrsp);\n\n\t/* Update the reader state. */\n\tif (idxnew1 == -1)\n\t\tidxnew1 = idxold1 & RCUTORTURE_RDR_MASK_1;\n\tWARN_ON_ONCE(idxnew1 < 0);\n\tif (WARN_ON_ONCE((idxnew1 >> RCUTORTURE_RDR_SHIFT_1) > 1))\n\t\tpr_info(\"Unexpected idxnew1 value of %#x\\n\", idxnew1);\n\tif (idxnew2 == -1)\n\t\tidxnew2 = idxold2 & RCUTORTURE_RDR_MASK_2;\n\tWARN_ON_ONCE(idxnew2 < 0);\n\tWARN_ON_ONCE((idxnew2 >> RCUTORTURE_RDR_SHIFT_2) > 1);\n\t*readstate = idxnew1 | idxnew2 | newstate;\n\tWARN_ON_ONCE(*readstate < 0);\n\tif (WARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT_2) > 1))\n\t\tpr_info(\"Unexpected idxnew2 value of %#x\\n\", idxnew2);\n}"
  },
  {
    "function_name": "rcu_torture_reader_do_mbchk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1367-1420",
    "snippet": "static void rcu_torture_reader_do_mbchk(long myid, struct rcu_torture *rtp,\n\t\t\t\t\tstruct torture_random_state *trsp)\n{\n\tunsigned long loops;\n\tint noc = torture_num_online_cpus();\n\tint rdrchked;\n\tint rdrchker;\n\tstruct rcu_torture_reader_check *rtrcp; // Me.\n\tstruct rcu_torture_reader_check *rtrcp_assigner; // Assigned us to do checking.\n\tstruct rcu_torture_reader_check *rtrcp_chked; // Reader being checked.\n\tstruct rcu_torture_reader_check *rtrcp_chker; // Reader doing checking when not me.\n\n\tif (myid < 0)\n\t\treturn; // Don't try this from timer handlers.\n\n\t// Increment my counter.\n\trtrcp = &rcu_torture_reader_mbchk[myid];\n\tWRITE_ONCE(rtrcp->rtc_myloops, rtrcp->rtc_myloops + 1);\n\n\t// Attempt to assign someone else some checking work.\n\trdrchked = torture_random(trsp) % nrealreaders;\n\trtrcp_chked = &rcu_torture_reader_mbchk[rdrchked];\n\trdrchker = torture_random(trsp) % nrealreaders;\n\trtrcp_chker = &rcu_torture_reader_mbchk[rdrchker];\n\tif (rdrchked != myid && rdrchked != rdrchker && noc >= rdrchked && noc >= rdrchker &&\n\t    smp_load_acquire(&rtrcp->rtc_chkrdr) < 0 && // Pairs with smp_store_release below.\n\t    !READ_ONCE(rtp->rtort_chkp) &&\n\t    !smp_load_acquire(&rtrcp_chker->rtc_assigner)) { // Pairs with smp_store_release below.\n\t\trtrcp->rtc_chkloops = READ_ONCE(rtrcp_chked->rtc_myloops);\n\t\tWARN_ON_ONCE(rtrcp->rtc_chkrdr >= 0);\n\t\trtrcp->rtc_chkrdr = rdrchked;\n\t\tWARN_ON_ONCE(rtrcp->rtc_ready); // This gets set after the grace period ends.\n\t\tif (cmpxchg_relaxed(&rtrcp_chker->rtc_assigner, NULL, rtrcp) ||\n\t\t    cmpxchg_relaxed(&rtp->rtort_chkp, NULL, rtrcp))\n\t\t\t(void)cmpxchg_relaxed(&rtrcp_chker->rtc_assigner, rtrcp, NULL); // Back out.\n\t}\n\n\t// If assigned some completed work, do it!\n\trtrcp_assigner = READ_ONCE(rtrcp->rtc_assigner);\n\tif (!rtrcp_assigner || !smp_load_acquire(&rtrcp_assigner->rtc_ready))\n\t\treturn; // No work or work not yet ready.\n\trdrchked = rtrcp_assigner->rtc_chkrdr;\n\tif (WARN_ON_ONCE(rdrchked < 0))\n\t\treturn;\n\trtrcp_chked = &rcu_torture_reader_mbchk[rdrchked];\n\tloops = READ_ONCE(rtrcp_chked->rtc_myloops);\n\tatomic_inc(&n_rcu_torture_mbchk_tries);\n\tif (ULONG_CMP_LT(loops, rtrcp_assigner->rtc_chkloops))\n\t\tatomic_inc(&n_rcu_torture_mbchk_fail);\n\trtrcp_assigner->rtc_chkloops = loops + ULONG_MAX / 2;\n\trtrcp_assigner->rtc_ready = 0;\n\tsmp_store_release(&rtrcp->rtc_assigner, NULL); // Someone else can assign us work.\n\tsmp_store_release(&rtrcp_assigner->rtc_chkrdr, -1); // Assigner can again assign.\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nrealreaders;",
      "static struct rcu_torture_reader_check *rcu_torture_reader_mbchk;",
      "static atomic_t n_rcu_torture_mbchk_fail;",
      "static atomic_t n_rcu_torture_mbchk_tries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&rtrcp_assigner->rtc_chkrdr",
            "-1"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&rtrcp->rtc_assigner",
            "NULL"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_rcu_torture_mbchk_fail"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "loops",
            "rtrcp_assigner->rtc_chkloops"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_rcu_torture_mbchk_tries"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rtrcp_chked->rtc_myloops"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdrchked < 0"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rtrcp_assigner->rtc_ready"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rtrcp->rtc_assigner"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg_relaxed",
          "args": [
            "&rtrcp_chker->rtc_assigner",
            "rtrcp",
            "NULL"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg_relaxed",
          "args": [
            "&rtp->rtort_chkp",
            "NULL",
            "rtrcp"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg_relaxed",
          "args": [
            "&rtrcp_chker->rtc_assigner",
            "NULL",
            "rtrcp"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rtrcp->rtc_ready"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rtrcp->rtc_chkrdr >= 0"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rtrcp_chked->rtc_myloops"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rtrcp_chker->rtc_assigner"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rtp->rtort_chkp"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rtrcp->rtc_chkrdr"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rtrcp->rtc_myloops",
            "rtrcp->rtc_myloops + 1"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_num_online_cpus",
          "args": [],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int nrealreaders;\nstatic struct rcu_torture_reader_check *rcu_torture_reader_mbchk;\nstatic atomic_t n_rcu_torture_mbchk_fail;\nstatic atomic_t n_rcu_torture_mbchk_tries;\n\nstatic void rcu_torture_reader_do_mbchk(long myid, struct rcu_torture *rtp,\n\t\t\t\t\tstruct torture_random_state *trsp)\n{\n\tunsigned long loops;\n\tint noc = torture_num_online_cpus();\n\tint rdrchked;\n\tint rdrchker;\n\tstruct rcu_torture_reader_check *rtrcp; // Me.\n\tstruct rcu_torture_reader_check *rtrcp_assigner; // Assigned us to do checking.\n\tstruct rcu_torture_reader_check *rtrcp_chked; // Reader being checked.\n\tstruct rcu_torture_reader_check *rtrcp_chker; // Reader doing checking when not me.\n\n\tif (myid < 0)\n\t\treturn; // Don't try this from timer handlers.\n\n\t// Increment my counter.\n\trtrcp = &rcu_torture_reader_mbchk[myid];\n\tWRITE_ONCE(rtrcp->rtc_myloops, rtrcp->rtc_myloops + 1);\n\n\t// Attempt to assign someone else some checking work.\n\trdrchked = torture_random(trsp) % nrealreaders;\n\trtrcp_chked = &rcu_torture_reader_mbchk[rdrchked];\n\trdrchker = torture_random(trsp) % nrealreaders;\n\trtrcp_chker = &rcu_torture_reader_mbchk[rdrchker];\n\tif (rdrchked != myid && rdrchked != rdrchker && noc >= rdrchked && noc >= rdrchker &&\n\t    smp_load_acquire(&rtrcp->rtc_chkrdr) < 0 && // Pairs with smp_store_release below.\n\t    !READ_ONCE(rtp->rtort_chkp) &&\n\t    !smp_load_acquire(&rtrcp_chker->rtc_assigner)) { // Pairs with smp_store_release below.\n\t\trtrcp->rtc_chkloops = READ_ONCE(rtrcp_chked->rtc_myloops);\n\t\tWARN_ON_ONCE(rtrcp->rtc_chkrdr >= 0);\n\t\trtrcp->rtc_chkrdr = rdrchked;\n\t\tWARN_ON_ONCE(rtrcp->rtc_ready); // This gets set after the grace period ends.\n\t\tif (cmpxchg_relaxed(&rtrcp_chker->rtc_assigner, NULL, rtrcp) ||\n\t\t    cmpxchg_relaxed(&rtp->rtort_chkp, NULL, rtrcp))\n\t\t\t(void)cmpxchg_relaxed(&rtrcp_chker->rtc_assigner, rtrcp, NULL); // Back out.\n\t}\n\n\t// If assigned some completed work, do it!\n\trtrcp_assigner = READ_ONCE(rtrcp->rtc_assigner);\n\tif (!rtrcp_assigner || !smp_load_acquire(&rtrcp_assigner->rtc_ready))\n\t\treturn; // No work or work not yet ready.\n\trdrchked = rtrcp_assigner->rtc_chkrdr;\n\tif (WARN_ON_ONCE(rdrchked < 0))\n\t\treturn;\n\trtrcp_chked = &rcu_torture_reader_mbchk[rdrchked];\n\tloops = READ_ONCE(rtrcp_chked->rtc_myloops);\n\tatomic_inc(&n_rcu_torture_mbchk_tries);\n\tif (ULONG_CMP_LT(loops, rtrcp_assigner->rtc_chkloops))\n\t\tatomic_inc(&n_rcu_torture_mbchk_fail);\n\trtrcp_assigner->rtc_chkloops = loops + ULONG_MAX / 2;\n\trtrcp_assigner->rtc_ready = 0;\n\tsmp_store_release(&rtrcp->rtc_assigner, NULL); // Someone else can assign us work.\n\tsmp_store_release(&rtrcp_assigner->rtc_chkrdr, -1); // Assigner can again assign.\n}"
  },
  {
    "function_name": "rcu_torture_timer_cb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1361-1364",
    "snippet": "static void rcu_torture_timer_cb(struct rcu_head *rhp)\n{\n\tkfree(rhp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rhp"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "736-747",
          "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t shutdown_wq;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_ended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_timer_cb(struct rcu_head *rhp)\n{\n\tkfree(rhp);\n}"
  },
  {
    "function_name": "rcu_torture_fakewriter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1313-1359",
    "snippet": "static int\nrcu_torture_fakewriter(void *arg)\n{\n\tunsigned long gp_snap;\n\tDEFINE_TORTURE_RANDOM(rand);\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_fakewriter task started\");\n\tset_user_nice(current, MAX_NICE);\n\n\tdo {\n\t\ttorture_hrtimeout_jiffies(torture_random(&rand) % 10, &rand);\n\t\tif (cur_ops->cb_barrier != NULL &&\n\t\t    torture_random(&rand) % (nfakewriters * 8) == 0) {\n\t\t\tcur_ops->cb_barrier();\n\t\t} else {\n\t\t\tswitch (synctype[torture_random(&rand) % nsynctypes]) {\n\t\t\tcase RTWS_DEF_FREE:\n\t\t\t\tbreak;\n\t\t\tcase RTWS_EXP_SYNC:\n\t\t\t\tcur_ops->exp_sync();\n\t\t\t\tbreak;\n\t\t\tcase RTWS_COND_GET:\n\t\t\t\tgp_snap = cur_ops->get_gp_state();\n\t\t\t\ttorture_hrtimeout_jiffies(torture_random(&rand) % 16, &rand);\n\t\t\t\tcur_ops->cond_sync(gp_snap);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_POLL_GET:\n\t\t\t\tgp_snap = cur_ops->start_gp_poll();\n\t\t\t\twhile (!cur_ops->poll_gp_state(gp_snap)) {\n\t\t\t\t\ttorture_hrtimeout_jiffies(torture_random(&rand) % 16,\n\t\t\t\t\t\t\t\t  &rand);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RTWS_SYNC:\n\t\t\t\tcur_ops->sync();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstutter_wait(\"rcu_torture_fakewriter\");\n\t} while (!torture_must_stop());\n\n\ttorture_kthread_stopping(\"rcu_torture_fakewriter\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RTWS_SYNC\t\t9",
      "#define RTWS_POLL_GET\t\t7",
      "#define RTWS_COND_GET\t\t5",
      "#define RTWS_EXP_SYNC\t\t4",
      "#define RTWS_DEF_FREE\t\t3"
    ],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;",
      "static int synctype[] = { RTWS_DEF_FREE, RTWS_EXP_SYNC, RTWS_COND_GET, RTWS_POLL_GET, RTWS_SYNC };",
      "static int nsynctypes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_fakewriter\""
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_torture_fakewriter\""
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "722-749",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->sync",
          "args": [],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_hrtimeout_jiffies",
          "args": [
            "torture_random(&rand) % 16",
            "&rand"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "torture_hrtimeout_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "131-136",
          "snippet": "int torture_hrtimeout_jiffies(u32 baset_j, struct torture_random_state *trsp)\n{\n\tktime_t baset_ns = jiffies_to_nsecs(baset_j);\n\n\treturn torture_hrtimeout_ns(baset_ns, jiffies_to_nsecs(1), trsp);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_hrtimeout_jiffies(u32 baset_j, struct torture_random_state *trsp)\n{\n\tktime_t baset_ns = jiffies_to_nsecs(baset_j);\n\n\treturn torture_hrtimeout_ns(baset_ns, jiffies_to_nsecs(1), trsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "&rand"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->poll_gp_state",
          "args": [
            "gp_snap"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->start_gp_poll",
          "args": [],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->cond_sync",
          "args": [
            "gp_snap"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_state",
          "args": [],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->exp_sync",
          "args": [],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_fakewriter task started\""
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_TORTURE_RANDOM",
          "args": [
            "rand"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RTWS_SYNC\t\t9\n#define RTWS_POLL_GET\t\t7\n#define RTWS_COND_GET\t\t5\n#define RTWS_EXP_SYNC\t\t4\n#define RTWS_DEF_FREE\t\t3\n\nstatic struct rcu_torture_ops *cur_ops;\nstatic int synctype[] = { RTWS_DEF_FREE, RTWS_EXP_SYNC, RTWS_COND_GET, RTWS_POLL_GET, RTWS_SYNC };\nstatic int nsynctypes;\n\nstatic int\nrcu_torture_fakewriter(void *arg)\n{\n\tunsigned long gp_snap;\n\tDEFINE_TORTURE_RANDOM(rand);\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_fakewriter task started\");\n\tset_user_nice(current, MAX_NICE);\n\n\tdo {\n\t\ttorture_hrtimeout_jiffies(torture_random(&rand) % 10, &rand);\n\t\tif (cur_ops->cb_barrier != NULL &&\n\t\t    torture_random(&rand) % (nfakewriters * 8) == 0) {\n\t\t\tcur_ops->cb_barrier();\n\t\t} else {\n\t\t\tswitch (synctype[torture_random(&rand) % nsynctypes]) {\n\t\t\tcase RTWS_DEF_FREE:\n\t\t\t\tbreak;\n\t\t\tcase RTWS_EXP_SYNC:\n\t\t\t\tcur_ops->exp_sync();\n\t\t\t\tbreak;\n\t\t\tcase RTWS_COND_GET:\n\t\t\t\tgp_snap = cur_ops->get_gp_state();\n\t\t\t\ttorture_hrtimeout_jiffies(torture_random(&rand) % 16, &rand);\n\t\t\t\tcur_ops->cond_sync(gp_snap);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_POLL_GET:\n\t\t\t\tgp_snap = cur_ops->start_gp_poll();\n\t\t\t\twhile (!cur_ops->poll_gp_state(gp_snap)) {\n\t\t\t\t\ttorture_hrtimeout_jiffies(torture_random(&rand) % 16,\n\t\t\t\t\t\t\t\t  &rand);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RTWS_SYNC:\n\t\t\t\tcur_ops->sync();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstutter_wait(\"rcu_torture_fakewriter\");\n\t} while (!torture_must_stop());\n\n\ttorture_kthread_stopping(\"rcu_torture_fakewriter\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_writer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1156-1307",
    "snippet": "static int\nrcu_torture_writer(void *arg)\n{\n\tbool boot_ended;\n\tbool can_expedite = !rcu_gp_is_expedited() && !rcu_gp_is_normal();\n\tunsigned long cookie;\n\tint expediting = 0;\n\tunsigned long gp_snap;\n\tint i;\n\tint idx;\n\tint oldnice = task_nice(current);\n\tstruct rcu_torture *rp;\n\tstruct rcu_torture *old_rp;\n\tstatic DEFINE_TORTURE_RANDOM(rand);\n\tbool stutter_waited;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_writer task started\");\n\tif (!can_expedite)\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" GP expediting controlled from boot/sysfs for %s.\\n\",\n\t\t\t torture_type, cur_ops->name);\n\tif (WARN_ONCE(nsynctypes == 0,\n\t\t      \"rcu_torture_writer: No update-side primitives.\\n\")) {\n\t\t/*\n\t\t * No updates primitives, so don't try updating.\n\t\t * The resulting test won't be testing much, hence the\n\t\t * above WARN_ONCE().\n\t\t */\n\t\trcu_torture_writer_state = RTWS_STOPPING;\n\t\ttorture_kthread_stopping(\"rcu_torture_writer\");\n\t}\n\n\tdo {\n\t\trcu_torture_writer_state = RTWS_FIXED_DELAY;\n\t\ttorture_hrtimeout_us(500, 1000, &rand);\n\t\trp = rcu_torture_alloc();\n\t\tif (rp == NULL)\n\t\t\tcontinue;\n\t\trp->rtort_pipe_count = 0;\n\t\trcu_torture_writer_state = RTWS_DELAY;\n\t\tudelay(torture_random(&rand) & 0x3ff);\n\t\trcu_torture_writer_state = RTWS_REPLACE;\n\t\told_rp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t\t       current == writer_task);\n\t\trp->rtort_mbtest = 1;\n\t\trcu_assign_pointer(rcu_torture_current, rp);\n\t\tsmp_wmb(); /* Mods to old_rp must follow rcu_assign_pointer() */\n\t\tif (old_rp) {\n\t\t\ti = old_rp->rtort_pipe_count;\n\t\t\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\t\t\ti = RCU_TORTURE_PIPE_LEN;\n\t\t\tatomic_inc(&rcu_torture_wcount[i]);\n\t\t\tWRITE_ONCE(old_rp->rtort_pipe_count,\n\t\t\t\t   old_rp->rtort_pipe_count + 1);\n\t\t\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state) {\n\t\t\t\tidx = cur_ops->readlock();\n\t\t\t\tcookie = cur_ops->get_gp_state();\n\t\t\t\tWARN_ONCE(rcu_torture_writer_state != RTWS_DEF_FREE &&\n\t\t\t\t\t  cur_ops->poll_gp_state(cookie),\n\t\t\t\t\t  \"%s: Cookie check 1 failed %s(%d) %lu->%lu\\n\",\n\t\t\t\t\t  __func__,\n\t\t\t\t\t  rcu_torture_writer_state_getname(),\n\t\t\t\t\t  rcu_torture_writer_state,\n\t\t\t\t\t  cookie, cur_ops->get_gp_state());\n\t\t\t\tcur_ops->readunlock(idx);\n\t\t\t}\n\t\t\tswitch (synctype[torture_random(&rand) % nsynctypes]) {\n\t\t\tcase RTWS_DEF_FREE:\n\t\t\t\trcu_torture_writer_state = RTWS_DEF_FREE;\n\t\t\t\tcur_ops->deferred_free(old_rp);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_EXP_SYNC:\n\t\t\t\trcu_torture_writer_state = RTWS_EXP_SYNC;\n\t\t\t\tcur_ops->exp_sync();\n\t\t\t\trcu_torture_pipe_update(old_rp);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_COND_GET:\n\t\t\t\trcu_torture_writer_state = RTWS_COND_GET;\n\t\t\t\tgp_snap = cur_ops->get_gp_state();\n\t\t\t\ttorture_hrtimeout_jiffies(torture_random(&rand) % 16, &rand);\n\t\t\t\trcu_torture_writer_state = RTWS_COND_SYNC;\n\t\t\t\tcur_ops->cond_sync(gp_snap);\n\t\t\t\trcu_torture_pipe_update(old_rp);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_POLL_GET:\n\t\t\t\trcu_torture_writer_state = RTWS_POLL_GET;\n\t\t\t\tgp_snap = cur_ops->start_gp_poll();\n\t\t\t\trcu_torture_writer_state = RTWS_POLL_WAIT;\n\t\t\t\twhile (!cur_ops->poll_gp_state(gp_snap))\n\t\t\t\t\ttorture_hrtimeout_jiffies(torture_random(&rand) % 16,\n\t\t\t\t\t\t\t\t  &rand);\n\t\t\t\trcu_torture_pipe_update(old_rp);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_SYNC:\n\t\t\t\trcu_torture_writer_state = RTWS_SYNC;\n\t\t\t\tcur_ops->sync();\n\t\t\t\trcu_torture_pipe_update(old_rp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tWRITE_ONCE(rcu_torture_current_version,\n\t\t\t   rcu_torture_current_version + 1);\n\t\t/* Cycle through nesting levels of rcu_expedite_gp() calls. */\n\t\tif (can_expedite &&\n\t\t    !(torture_random(&rand) & 0xff & (!!expediting - 1))) {\n\t\t\tWARN_ON_ONCE(expediting == 0 && rcu_gp_is_expedited());\n\t\t\tif (expediting >= 0)\n\t\t\t\trcu_expedite_gp();\n\t\t\telse\n\t\t\t\trcu_unexpedite_gp();\n\t\t\tif (++expediting > 3)\n\t\t\t\texpediting = -expediting;\n\t\t} else if (!can_expedite) { /* Disabled during boot, recheck. */\n\t\t\tcan_expedite = !rcu_gp_is_expedited() &&\n\t\t\t\t       !rcu_gp_is_normal();\n\t\t}\n\t\trcu_torture_writer_state = RTWS_STUTTER;\n\t\tboot_ended = rcu_inkernel_boot_has_ended();\n\t\tstutter_waited = stutter_wait(\"rcu_torture_writer\");\n\t\tif (stutter_waited &&\n\t\t    !READ_ONCE(rcu_fwd_cb_nodelay) &&\n\t\t    !cur_ops->slow_gps &&\n\t\t    !torture_must_stop() &&\n\t\t    boot_ended)\n\t\t\tfor (i = 0; i < ARRAY_SIZE(rcu_tortures); i++)\n\t\t\t\tif (list_empty(&rcu_tortures[i].rtort_free) &&\n\t\t\t\t    rcu_access_pointer(rcu_torture_current) !=\n\t\t\t\t    &rcu_tortures[i]) {\n\t\t\t\t\trcu_ftrace_dump(DUMP_ALL);\n\t\t\t\t\tWARN(1, \"%s: rtort_pipe_count: %d\\n\", __func__, rcu_tortures[i].rtort_pipe_count);\n\t\t\t\t}\n\t\tif (stutter_waited)\n\t\t\tsched_set_normal(current, oldnice);\n\t} while (!torture_must_stop());\n\trcu_torture_current = NULL;  // Let stats task know that we are done.\n\t/* Reset expediting back to unexpedited. */\n\tif (expediting > 0)\n\t\texpediting = -expediting;\n\twhile (can_expedite && expediting++ < 0)\n\t\trcu_unexpedite_gp();\n\tWARN_ON_ONCE(can_expedite && rcu_gp_is_expedited());\n\tif (!can_expedite)\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" Dynamic grace-period expediting was disabled.\\n\",\n\t\t\t torture_type);\n\trcu_torture_writer_state = RTWS_STOPPING;\n\ttorture_kthread_stopping(\"rcu_torture_writer\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RTWS_STOPPING\t\t11",
      "#define RTWS_STUTTER\t\t10",
      "#define RTWS_SYNC\t\t9",
      "#define RTWS_POLL_WAIT\t\t8",
      "#define RTWS_POLL_GET\t\t7",
      "#define RTWS_COND_SYNC\t\t6",
      "#define RTWS_COND_GET\t\t5",
      "#define RTWS_EXP_SYNC\t\t4",
      "#define RTWS_DEF_FREE\t\t3",
      "#define RTWS_REPLACE\t\t2",
      "#define RTWS_DELAY\t\t1",
      "#define RTWS_FIXED_DELAY\t0",
      "#define RCU_TORTURE_PIPE_LEN 10"
    ],
    "globals_used": [
      "static char *torture_type = \"rcu\";",
      "static struct task_struct *writer_task;",
      "static struct rcu_torture __rcu *rcu_torture_current;",
      "static unsigned long rcu_torture_current_version;",
      "static struct rcu_torture rcu_tortures[10 * RCU_TORTURE_PIPE_LEN];",
      "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];",
      "static int rcu_torture_writer_state;",
      "static bool rcu_fwd_cb_nodelay;",
      "static struct rcu_torture_ops *cur_ops;",
      "static int synctype[] = { RTWS_DEF_FREE, RTWS_EXP_SYNC, RTWS_COND_GET, RTWS_POLL_GET, RTWS_SYNC };",
      "static int nsynctypes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_writer\""
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\" TORTURE_FLAG\n\t\t\t \" Dynamic grace-period expediting was disabled.\\n\"",
            "torture_type"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "can_expedite && rcu_gp_is_expedited()"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_expedited",
          "args": [],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "156-159",
          "snippet": "bool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_unexpedite_gp",
          "args": [],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_unexpedite_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "184-187",
          "snippet": "void rcu_unexpedite_gp(void)\n{\n\tatomic_dec(&rcu_expedited_nesting);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_unexpedite_gp(void)\n{\n\tatomic_dec(&rcu_expedited_nesting);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_set_normal",
          "args": [
            "current",
            "oldnice"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "sched_set_normal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7606-7613",
          "snippet": "void sched_set_normal(struct task_struct *p, int nice)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t\t.sched_nice = nice,\n\t};\n\tWARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_set_normal(struct task_struct *p, int nice)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t\t.sched_nice = nice,\n\t};\n\tWARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"%s: rtort_pipe_count: %d\\n\"",
            "__func__",
            "rcu_tortures[i].rtort_pipe_count"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "rcu_torture_current"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rcu_tortures[i].rtort_free"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "rcu_tortures"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_fwd_cb_nodelay"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_torture_writer\""
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "722-749",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_inkernel_boot_has_ended",
          "args": [],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_inkernel_boot_has_ended",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "206-209",
          "snippet": "bool rcu_inkernel_boot_has_ended(void)\n{\n\treturn rcu_boot_ended;\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_inkernel_boot_has_ended(void)\n{\n\treturn rcu_boot_ended;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_normal",
          "args": [],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_normal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "140-144",
          "snippet": "bool rcu_gp_is_normal(void)\n{\n\treturn READ_ONCE(rcu_normal) &&\n\t       rcu_scheduler_active != RCU_SCHEDULER_INIT;\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_normal(void)\n{\n\treturn READ_ONCE(rcu_normal) &&\n\t       rcu_scheduler_active != RCU_SCHEDULER_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_expedite_gp",
          "args": [],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_expedite_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "169-172",
          "snippet": "void rcu_expedite_gp(void)\n{\n\tatomic_inc(&rcu_expedited_nesting);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_expedite_gp(void)\n{\n\tatomic_inc(&rcu_expedited_nesting);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "expediting == 0 && rcu_gp_is_expedited()"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "&rand"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_torture_current_version",
            "rcu_torture_current_version + 1"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_pipe_update",
          "args": [
            "old_rp"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_pipe_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "447-461",
          "snippet": "static void\nrcu_torture_pipe_update(struct rcu_torture *old_rp)\n{\n\tstruct rcu_torture *rp;\n\tstruct rcu_torture *rp1;\n\n\tif (old_rp)\n\t\tlist_add(&old_rp->rtort_free, &rcu_torture_removed);\n\tlist_for_each_entry_safe(rp, rp1, &rcu_torture_removed, rtort_free) {\n\t\tif (rcu_torture_pipe_update_one(rp)) {\n\t\t\tlist_del(&rp->rtort_free);\n\t\t\trcu_torture_free(rp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head rcu_torture_removed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct list_head rcu_torture_removed;\n\nstatic void\nrcu_torture_pipe_update(struct rcu_torture *old_rp)\n{\n\tstruct rcu_torture *rp;\n\tstruct rcu_torture *rp1;\n\n\tif (old_rp)\n\t\tlist_add(&old_rp->rtort_free, &rcu_torture_removed);\n\tlist_for_each_entry_safe(rp, rp1, &rcu_torture_removed, rtort_free) {\n\t\tif (rcu_torture_pipe_update_one(rp)) {\n\t\t\tlist_del(&rp->rtort_free);\n\t\t\trcu_torture_free(rp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->sync",
          "args": [],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_hrtimeout_jiffies",
          "args": [
            "torture_random(&rand) % 16",
            "&rand"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "torture_hrtimeout_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "131-136",
          "snippet": "int torture_hrtimeout_jiffies(u32 baset_j, struct torture_random_state *trsp)\n{\n\tktime_t baset_ns = jiffies_to_nsecs(baset_j);\n\n\treturn torture_hrtimeout_ns(baset_ns, jiffies_to_nsecs(1), trsp);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_hrtimeout_jiffies(u32 baset_j, struct torture_random_state *trsp)\n{\n\tktime_t baset_ns = jiffies_to_nsecs(baset_j);\n\n\treturn torture_hrtimeout_ns(baset_ns, jiffies_to_nsecs(1), trsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->poll_gp_state",
          "args": [
            "gp_snap"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->start_gp_poll",
          "args": [],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->cond_sync",
          "args": [
            "gp_snap"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_state",
          "args": [],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->exp_sync",
          "args": [],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->deferred_free",
          "args": [
            "old_rp"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readunlock",
          "args": [
            "idx"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "rcu_torture_writer_state != RTWS_DEF_FREE &&\n\t\t\t\t\t  cur_ops->poll_gp_state(cookie)",
            "\"%s: Cookie check 1 failed %s(%d) %lu->%lu\\n\"",
            "__func__",
            "rcu_torture_writer_state_getname()",
            "rcu_torture_writer_state",
            "cookie",
            "cur_ops->get_gp_state()"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_state",
          "args": [],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_writer_state_getname",
          "args": [],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_writer_state_getname",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "245-252",
          "snippet": "static const char *rcu_torture_writer_state_getname(void)\n{\n\tunsigned int i = READ_ONCE(rcu_torture_writer_state);\n\n\tif (i >= ARRAY_SIZE(rcu_torture_writer_state_names))\n\t\treturn \"???\";\n\treturn rcu_torture_writer_state_names[i];\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_torture_writer_state;",
            "static const char * const rcu_torture_writer_state_names[] = {\n\t\"RTWS_FIXED_DELAY\",\n\t\"RTWS_DELAY\",\n\t\"RTWS_REPLACE\",\n\t\"RTWS_DEF_FREE\",\n\t\"RTWS_EXP_SYNC\",\n\t\"RTWS_COND_GET\",\n\t\"RTWS_COND_SYNC\",\n\t\"RTWS_POLL_GET\",\n\t\"RTWS_POLL_WAIT\",\n\t\"RTWS_SYNC\",\n\t\"RTWS_STUTTER\",\n\t\"RTWS_STOPPING\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_torture_writer_state;\nstatic const char * const rcu_torture_writer_state_names[] = {\n\t\"RTWS_FIXED_DELAY\",\n\t\"RTWS_DELAY\",\n\t\"RTWS_REPLACE\",\n\t\"RTWS_DEF_FREE\",\n\t\"RTWS_EXP_SYNC\",\n\t\"RTWS_COND_GET\",\n\t\"RTWS_COND_SYNC\",\n\t\"RTWS_POLL_GET\",\n\t\"RTWS_POLL_WAIT\",\n\t\"RTWS_SYNC\",\n\t\"RTWS_STUTTER\",\n\t\"RTWS_STOPPING\",\n};\n\nstatic const char *rcu_torture_writer_state_getname(void)\n{\n\tunsigned int i = READ_ONCE(rcu_torture_writer_state);\n\n\tif (i >= ARRAY_SIZE(rcu_torture_writer_state_names))\n\t\treturn \"???\";\n\treturn rcu_torture_writer_state_names[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->poll_gp_state",
          "args": [
            "cookie"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_state",
          "args": [],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readlock",
          "args": [],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "old_rp->rtort_pipe_count",
            "old_rp->rtort_pipe_count + 1"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rcu_torture_wcount[i]"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "rcu_torture_current",
            "rp"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "rcu_torture_current",
            "current == writer_task"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "torture_random(&rand) & 0x3ff"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_alloc",
          "args": [],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "292-308",
          "snippet": "static struct rcu_torture *\nrcu_torture_alloc(void)\n{\n\tstruct list_head *p;\n\n\tspin_lock_bh(&rcu_torture_lock);\n\tif (list_empty(&rcu_torture_freelist)) {\n\t\tatomic_inc(&n_rcu_torture_alloc_fail);\n\t\tspin_unlock_bh(&rcu_torture_lock);\n\t\treturn NULL;\n\t}\n\tatomic_inc(&n_rcu_torture_alloc);\n\tp = rcu_torture_freelist.next;\n\tlist_del_init(p);\n\tspin_unlock_bh(&rcu_torture_lock);\n\treturn container_of(p, struct rcu_torture, rtort_free);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(rcu_torture_freelist);",
            "static DEFINE_SPINLOCK(rcu_torture_lock);",
            "static atomic_t n_rcu_torture_alloc;",
            "static atomic_t n_rcu_torture_alloc_fail;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic DEFINE_SPINLOCK(rcu_torture_lock);\nstatic atomic_t n_rcu_torture_alloc;\nstatic atomic_t n_rcu_torture_alloc_fail;\n\nstatic struct rcu_torture *\nrcu_torture_alloc(void)\n{\n\tstruct list_head *p;\n\n\tspin_lock_bh(&rcu_torture_lock);\n\tif (list_empty(&rcu_torture_freelist)) {\n\t\tatomic_inc(&n_rcu_torture_alloc_fail);\n\t\tspin_unlock_bh(&rcu_torture_lock);\n\t\treturn NULL;\n\t}\n\tatomic_inc(&n_rcu_torture_alloc);\n\tp = rcu_torture_freelist.next;\n\tlist_del_init(p);\n\tspin_unlock_bh(&rcu_torture_lock);\n\treturn container_of(p, struct rcu_torture, rtort_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_hrtimeout_us",
          "args": [
            "500",
            "1000",
            "&rand"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "torture_hrtimeout_us",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "101-106",
          "snippet": "int torture_hrtimeout_us(u32 baset_us, u32 fuzzt_ns, struct torture_random_state *trsp)\n{\n\tktime_t baset_ns = baset_us * NSEC_PER_USEC;\n\n\treturn torture_hrtimeout_ns(baset_ns, fuzzt_ns, trsp);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_hrtimeout_us(u32 baset_us, u32 fuzzt_ns, struct torture_random_state *trsp)\n{\n\tktime_t baset_ns = baset_us * NSEC_PER_USEC;\n\n\treturn torture_hrtimeout_ns(baset_ns, fuzzt_ns, trsp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "nsynctypes == 0",
            "\"rcu_torture_writer: No update-side primitives.\\n\""
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\" TORTURE_FLAG\n\t\t\t \" GP expediting controlled from boot/sysfs for %s.\\n\"",
            "torture_type",
            "cur_ops->name"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_writer task started\""
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "current"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RTWS_STOPPING\t\t11\n#define RTWS_STUTTER\t\t10\n#define RTWS_SYNC\t\t9\n#define RTWS_POLL_WAIT\t\t8\n#define RTWS_POLL_GET\t\t7\n#define RTWS_COND_SYNC\t\t6\n#define RTWS_COND_GET\t\t5\n#define RTWS_EXP_SYNC\t\t4\n#define RTWS_DEF_FREE\t\t3\n#define RTWS_REPLACE\t\t2\n#define RTWS_DELAY\t\t1\n#define RTWS_FIXED_DELAY\t0\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic char *torture_type = \"rcu\";\nstatic struct task_struct *writer_task;\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic unsigned long rcu_torture_current_version;\nstatic struct rcu_torture rcu_tortures[10 * RCU_TORTURE_PIPE_LEN];\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\nstatic int rcu_torture_writer_state;\nstatic bool rcu_fwd_cb_nodelay;\nstatic struct rcu_torture_ops *cur_ops;\nstatic int synctype[] = { RTWS_DEF_FREE, RTWS_EXP_SYNC, RTWS_COND_GET, RTWS_POLL_GET, RTWS_SYNC };\nstatic int nsynctypes;\n\nstatic int\nrcu_torture_writer(void *arg)\n{\n\tbool boot_ended;\n\tbool can_expedite = !rcu_gp_is_expedited() && !rcu_gp_is_normal();\n\tunsigned long cookie;\n\tint expediting = 0;\n\tunsigned long gp_snap;\n\tint i;\n\tint idx;\n\tint oldnice = task_nice(current);\n\tstruct rcu_torture *rp;\n\tstruct rcu_torture *old_rp;\n\tstatic DEFINE_TORTURE_RANDOM(rand);\n\tbool stutter_waited;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_writer task started\");\n\tif (!can_expedite)\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" GP expediting controlled from boot/sysfs for %s.\\n\",\n\t\t\t torture_type, cur_ops->name);\n\tif (WARN_ONCE(nsynctypes == 0,\n\t\t      \"rcu_torture_writer: No update-side primitives.\\n\")) {\n\t\t/*\n\t\t * No updates primitives, so don't try updating.\n\t\t * The resulting test won't be testing much, hence the\n\t\t * above WARN_ONCE().\n\t\t */\n\t\trcu_torture_writer_state = RTWS_STOPPING;\n\t\ttorture_kthread_stopping(\"rcu_torture_writer\");\n\t}\n\n\tdo {\n\t\trcu_torture_writer_state = RTWS_FIXED_DELAY;\n\t\ttorture_hrtimeout_us(500, 1000, &rand);\n\t\trp = rcu_torture_alloc();\n\t\tif (rp == NULL)\n\t\t\tcontinue;\n\t\trp->rtort_pipe_count = 0;\n\t\trcu_torture_writer_state = RTWS_DELAY;\n\t\tudelay(torture_random(&rand) & 0x3ff);\n\t\trcu_torture_writer_state = RTWS_REPLACE;\n\t\told_rp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t\t       current == writer_task);\n\t\trp->rtort_mbtest = 1;\n\t\trcu_assign_pointer(rcu_torture_current, rp);\n\t\tsmp_wmb(); /* Mods to old_rp must follow rcu_assign_pointer() */\n\t\tif (old_rp) {\n\t\t\ti = old_rp->rtort_pipe_count;\n\t\t\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\t\t\ti = RCU_TORTURE_PIPE_LEN;\n\t\t\tatomic_inc(&rcu_torture_wcount[i]);\n\t\t\tWRITE_ONCE(old_rp->rtort_pipe_count,\n\t\t\t\t   old_rp->rtort_pipe_count + 1);\n\t\t\tif (cur_ops->get_gp_state && cur_ops->poll_gp_state) {\n\t\t\t\tidx = cur_ops->readlock();\n\t\t\t\tcookie = cur_ops->get_gp_state();\n\t\t\t\tWARN_ONCE(rcu_torture_writer_state != RTWS_DEF_FREE &&\n\t\t\t\t\t  cur_ops->poll_gp_state(cookie),\n\t\t\t\t\t  \"%s: Cookie check 1 failed %s(%d) %lu->%lu\\n\",\n\t\t\t\t\t  __func__,\n\t\t\t\t\t  rcu_torture_writer_state_getname(),\n\t\t\t\t\t  rcu_torture_writer_state,\n\t\t\t\t\t  cookie, cur_ops->get_gp_state());\n\t\t\t\tcur_ops->readunlock(idx);\n\t\t\t}\n\t\t\tswitch (synctype[torture_random(&rand) % nsynctypes]) {\n\t\t\tcase RTWS_DEF_FREE:\n\t\t\t\trcu_torture_writer_state = RTWS_DEF_FREE;\n\t\t\t\tcur_ops->deferred_free(old_rp);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_EXP_SYNC:\n\t\t\t\trcu_torture_writer_state = RTWS_EXP_SYNC;\n\t\t\t\tcur_ops->exp_sync();\n\t\t\t\trcu_torture_pipe_update(old_rp);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_COND_GET:\n\t\t\t\trcu_torture_writer_state = RTWS_COND_GET;\n\t\t\t\tgp_snap = cur_ops->get_gp_state();\n\t\t\t\ttorture_hrtimeout_jiffies(torture_random(&rand) % 16, &rand);\n\t\t\t\trcu_torture_writer_state = RTWS_COND_SYNC;\n\t\t\t\tcur_ops->cond_sync(gp_snap);\n\t\t\t\trcu_torture_pipe_update(old_rp);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_POLL_GET:\n\t\t\t\trcu_torture_writer_state = RTWS_POLL_GET;\n\t\t\t\tgp_snap = cur_ops->start_gp_poll();\n\t\t\t\trcu_torture_writer_state = RTWS_POLL_WAIT;\n\t\t\t\twhile (!cur_ops->poll_gp_state(gp_snap))\n\t\t\t\t\ttorture_hrtimeout_jiffies(torture_random(&rand) % 16,\n\t\t\t\t\t\t\t\t  &rand);\n\t\t\t\trcu_torture_pipe_update(old_rp);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_SYNC:\n\t\t\t\trcu_torture_writer_state = RTWS_SYNC;\n\t\t\t\tcur_ops->sync();\n\t\t\t\trcu_torture_pipe_update(old_rp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tWRITE_ONCE(rcu_torture_current_version,\n\t\t\t   rcu_torture_current_version + 1);\n\t\t/* Cycle through nesting levels of rcu_expedite_gp() calls. */\n\t\tif (can_expedite &&\n\t\t    !(torture_random(&rand) & 0xff & (!!expediting - 1))) {\n\t\t\tWARN_ON_ONCE(expediting == 0 && rcu_gp_is_expedited());\n\t\t\tif (expediting >= 0)\n\t\t\t\trcu_expedite_gp();\n\t\t\telse\n\t\t\t\trcu_unexpedite_gp();\n\t\t\tif (++expediting > 3)\n\t\t\t\texpediting = -expediting;\n\t\t} else if (!can_expedite) { /* Disabled during boot, recheck. */\n\t\t\tcan_expedite = !rcu_gp_is_expedited() &&\n\t\t\t\t       !rcu_gp_is_normal();\n\t\t}\n\t\trcu_torture_writer_state = RTWS_STUTTER;\n\t\tboot_ended = rcu_inkernel_boot_has_ended();\n\t\tstutter_waited = stutter_wait(\"rcu_torture_writer\");\n\t\tif (stutter_waited &&\n\t\t    !READ_ONCE(rcu_fwd_cb_nodelay) &&\n\t\t    !cur_ops->slow_gps &&\n\t\t    !torture_must_stop() &&\n\t\t    boot_ended)\n\t\t\tfor (i = 0; i < ARRAY_SIZE(rcu_tortures); i++)\n\t\t\t\tif (list_empty(&rcu_tortures[i].rtort_free) &&\n\t\t\t\t    rcu_access_pointer(rcu_torture_current) !=\n\t\t\t\t    &rcu_tortures[i]) {\n\t\t\t\t\trcu_ftrace_dump(DUMP_ALL);\n\t\t\t\t\tWARN(1, \"%s: rtort_pipe_count: %d\\n\", __func__, rcu_tortures[i].rtort_pipe_count);\n\t\t\t\t}\n\t\tif (stutter_waited)\n\t\t\tsched_set_normal(current, oldnice);\n\t} while (!torture_must_stop());\n\trcu_torture_current = NULL;  // Let stats task know that we are done.\n\t/* Reset expediting back to unexpedited. */\n\tif (expediting > 0)\n\t\texpediting = -expediting;\n\twhile (can_expedite && expediting++ < 0)\n\t\trcu_unexpedite_gp();\n\tWARN_ON_ONCE(can_expedite && rcu_gp_is_expedited());\n\tif (!can_expedite)\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" Dynamic grace-period expediting was disabled.\\n\",\n\t\t\t torture_type);\n\trcu_torture_writer_state = RTWS_STOPPING;\n\ttorture_kthread_stopping(\"rcu_torture_writer\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_write_types",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1111-1149",
    "snippet": "static void rcu_torture_write_types(void)\n{\n\tbool gp_cond1 = gp_cond, gp_exp1 = gp_exp, gp_normal1 = gp_normal;\n\tbool gp_poll1 = gp_poll, gp_sync1 = gp_sync;\n\n\t/* Initialize synctype[] array.  If none set, take default. */\n\tif (!gp_cond1 && !gp_exp1 && !gp_normal1 && !gp_poll1 && !gp_sync1)\n\t\tgp_cond1 = gp_exp1 = gp_normal1 = gp_poll1 = gp_sync1 = true;\n\tif (gp_cond1 && cur_ops->get_gp_state && cur_ops->cond_sync) {\n\t\tsynctype[nsynctypes++] = RTWS_COND_GET;\n\t\tpr_info(\"%s: Testing conditional GPs.\\n\", __func__);\n\t} else if (gp_cond && (!cur_ops->get_gp_state || !cur_ops->cond_sync)) {\n\t\tpr_alert(\"%s: gp_cond without primitives.\\n\", __func__);\n\t}\n\tif (gp_exp1 && cur_ops->exp_sync) {\n\t\tsynctype[nsynctypes++] = RTWS_EXP_SYNC;\n\t\tpr_info(\"%s: Testing expedited GPs.\\n\", __func__);\n\t} else if (gp_exp && !cur_ops->exp_sync) {\n\t\tpr_alert(\"%s: gp_exp without primitives.\\n\", __func__);\n\t}\n\tif (gp_normal1 && cur_ops->deferred_free) {\n\t\tsynctype[nsynctypes++] = RTWS_DEF_FREE;\n\t\tpr_info(\"%s: Testing asynchronous GPs.\\n\", __func__);\n\t} else if (gp_normal && !cur_ops->deferred_free) {\n\t\tpr_alert(\"%s: gp_normal without primitives.\\n\", __func__);\n\t}\n\tif (gp_poll1 && cur_ops->start_gp_poll && cur_ops->poll_gp_state) {\n\t\tsynctype[nsynctypes++] = RTWS_POLL_GET;\n\t\tpr_info(\"%s: Testing polling GPs.\\n\", __func__);\n\t} else if (gp_poll && (!cur_ops->start_gp_poll || !cur_ops->poll_gp_state)) {\n\t\tpr_alert(\"%s: gp_poll without primitives.\\n\", __func__);\n\t}\n\tif (gp_sync1 && cur_ops->sync) {\n\t\tsynctype[nsynctypes++] = RTWS_SYNC;\n\t\tpr_info(\"%s: Testing normal GPs.\\n\", __func__);\n\t} else if (gp_sync && !cur_ops->sync) {\n\t\tpr_alert(\"%s: gp_sync without primitives.\\n\", __func__);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RTWS_SYNC\t\t9",
      "#define RTWS_POLL_GET\t\t7",
      "#define RTWS_COND_GET\t\t5",
      "#define RTWS_EXP_SYNC\t\t4",
      "#define RTWS_DEF_FREE\t\t3"
    ],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;",
      "static int synctype[] = { RTWS_DEF_FREE, RTWS_EXP_SYNC, RTWS_COND_GET, RTWS_POLL_GET, RTWS_SYNC };",
      "static int nsynctypes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: gp_sync without primitives.\\n\"",
            "__func__"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Testing normal GPs.\\n\"",
            "__func__"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: gp_poll without primitives.\\n\"",
            "__func__"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Testing polling GPs.\\n\"",
            "__func__"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: gp_normal without primitives.\\n\"",
            "__func__"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Testing asynchronous GPs.\\n\"",
            "__func__"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: gp_exp without primitives.\\n\"",
            "__func__"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Testing expedited GPs.\\n\"",
            "__func__"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: gp_cond without primitives.\\n\"",
            "__func__"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Testing conditional GPs.\\n\"",
            "__func__"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RTWS_SYNC\t\t9\n#define RTWS_POLL_GET\t\t7\n#define RTWS_COND_GET\t\t5\n#define RTWS_EXP_SYNC\t\t4\n#define RTWS_DEF_FREE\t\t3\n\nstatic struct rcu_torture_ops *cur_ops;\nstatic int synctype[] = { RTWS_DEF_FREE, RTWS_EXP_SYNC, RTWS_COND_GET, RTWS_POLL_GET, RTWS_SYNC };\nstatic int nsynctypes;\n\nstatic void rcu_torture_write_types(void)\n{\n\tbool gp_cond1 = gp_cond, gp_exp1 = gp_exp, gp_normal1 = gp_normal;\n\tbool gp_poll1 = gp_poll, gp_sync1 = gp_sync;\n\n\t/* Initialize synctype[] array.  If none set, take default. */\n\tif (!gp_cond1 && !gp_exp1 && !gp_normal1 && !gp_poll1 && !gp_sync1)\n\t\tgp_cond1 = gp_exp1 = gp_normal1 = gp_poll1 = gp_sync1 = true;\n\tif (gp_cond1 && cur_ops->get_gp_state && cur_ops->cond_sync) {\n\t\tsynctype[nsynctypes++] = RTWS_COND_GET;\n\t\tpr_info(\"%s: Testing conditional GPs.\\n\", __func__);\n\t} else if (gp_cond && (!cur_ops->get_gp_state || !cur_ops->cond_sync)) {\n\t\tpr_alert(\"%s: gp_cond without primitives.\\n\", __func__);\n\t}\n\tif (gp_exp1 && cur_ops->exp_sync) {\n\t\tsynctype[nsynctypes++] = RTWS_EXP_SYNC;\n\t\tpr_info(\"%s: Testing expedited GPs.\\n\", __func__);\n\t} else if (gp_exp && !cur_ops->exp_sync) {\n\t\tpr_alert(\"%s: gp_exp without primitives.\\n\", __func__);\n\t}\n\tif (gp_normal1 && cur_ops->deferred_free) {\n\t\tsynctype[nsynctypes++] = RTWS_DEF_FREE;\n\t\tpr_info(\"%s: Testing asynchronous GPs.\\n\", __func__);\n\t} else if (gp_normal && !cur_ops->deferred_free) {\n\t\tpr_alert(\"%s: gp_normal without primitives.\\n\", __func__);\n\t}\n\tif (gp_poll1 && cur_ops->start_gp_poll && cur_ops->poll_gp_state) {\n\t\tsynctype[nsynctypes++] = RTWS_POLL_GET;\n\t\tpr_info(\"%s: Testing polling GPs.\\n\", __func__);\n\t} else if (gp_poll && (!cur_ops->start_gp_poll || !cur_ops->poll_gp_state)) {\n\t\tpr_alert(\"%s: gp_poll without primitives.\\n\", __func__);\n\t}\n\tif (gp_sync1 && cur_ops->sync) {\n\t\tsynctype[nsynctypes++] = RTWS_SYNC;\n\t\tpr_info(\"%s: Testing normal GPs.\\n\", __func__);\n\t} else if (gp_sync && !cur_ops->sync) {\n\t\tpr_alert(\"%s: gp_sync without primitives.\\n\", __func__);\n\t}\n}"
  },
  {
    "function_name": "rcu_torture_fqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "1075-1101",
    "snippet": "static int\nrcu_torture_fqs(void *arg)\n{\n\tunsigned long fqs_resume_time;\n\tint fqs_burst_remaining;\n\tint oldnice = task_nice(current);\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_fqs task started\");\n\tdo {\n\t\tfqs_resume_time = jiffies + fqs_stutter * HZ;\n\t\twhile (time_before(jiffies, fqs_resume_time) &&\n\t\t       !kthread_should_stop()) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t}\n\t\tfqs_burst_remaining = fqs_duration;\n\t\twhile (fqs_burst_remaining > 0 &&\n\t\t       !kthread_should_stop()) {\n\t\t\tcur_ops->fqs();\n\t\t\tudelay(fqs_holdoff);\n\t\t\tfqs_burst_remaining -= fqs_holdoff;\n\t\t}\n\t\tif (stutter_wait(\"rcu_torture_fqs\"))\n\t\t\tsched_set_normal(current, oldnice);\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_torture_fqs\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_fqs\""
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_set_normal",
          "args": [
            "current",
            "oldnice"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "sched_set_normal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7606-7613",
          "snippet": "void sched_set_normal(struct task_struct *p, int nice)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t\t.sched_nice = nice,\n\t};\n\tWARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_set_normal(struct task_struct *p, int nice)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t\t.sched_nice = nice,\n\t};\n\tWARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_torture_fqs\""
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "722-749",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "fqs_holdoff"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->fqs",
          "args": [],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "1"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "fqs_resume_time"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_fqs task started\""
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "current"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int\nrcu_torture_fqs(void *arg)\n{\n\tunsigned long fqs_resume_time;\n\tint fqs_burst_remaining;\n\tint oldnice = task_nice(current);\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_fqs task started\");\n\tdo {\n\t\tfqs_resume_time = jiffies + fqs_stutter * HZ;\n\t\twhile (time_before(jiffies, fqs_resume_time) &&\n\t\t       !kthread_should_stop()) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t}\n\t\tfqs_burst_remaining = fqs_duration;\n\t\twhile (fqs_burst_remaining > 0 &&\n\t\t       !kthread_should_stop()) {\n\t\t\tcur_ops->fqs();\n\t\t\tudelay(fqs_holdoff);\n\t\t\tfqs_burst_remaining -= fqs_holdoff;\n\t\t}\n\t\tif (stutter_wait(\"rcu_torture_fqs\"))\n\t\t\tsched_set_normal(current, oldnice);\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_torture_fqs\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_boost",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "979-1068",
    "snippet": "static int rcu_torture_boost(void *arg)\n{\n\tunsigned long endtime;\n\tunsigned long gp_state;\n\tunsigned long gp_state_time;\n\tunsigned long oldstarttime;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost started\");\n\n\t/* Set real-time priority. */\n\tsched_set_fifo_low(current);\n\n\t/* Each pass through the following loop does one boost-test cycle. */\n\tdo {\n\t\tbool failed = false; // Test failed already in this test interval\n\t\tbool gp_initiated = false;\n\n\t\tif (kthread_should_stop())\n\t\t\tgoto checkwait;\n\n\t\t/* Wait for the next test interval. */\n\t\toldstarttime = boost_starttime;\n\t\twhile (time_before(jiffies, oldstarttime)) {\n\t\t\tschedule_timeout_interruptible(oldstarttime - jiffies);\n\t\t\tif (stutter_wait(\"rcu_torture_boost\"))\n\t\t\t\tsched_set_fifo_low(current);\n\t\t\tif (torture_must_stop())\n\t\t\t\tgoto checkwait;\n\t\t}\n\n\t\t// Do one boost-test interval.\n\t\tendtime = oldstarttime + test_boost_duration * HZ;\n\t\twhile (time_before(jiffies, endtime)) {\n\t\t\t// Has current GP gone too long?\n\t\t\tif (gp_initiated && !failed && !cur_ops->poll_gp_state(gp_state))\n\t\t\t\tfailed = rcu_torture_boost_failed(gp_state, &gp_state_time);\n\t\t\t// If we don't have a grace period in flight, start one.\n\t\t\tif (!gp_initiated || cur_ops->poll_gp_state(gp_state)) {\n\t\t\t\tgp_state = cur_ops->start_gp_poll();\n\t\t\t\tgp_initiated = true;\n\t\t\t\tgp_state_time = jiffies;\n\t\t\t}\n\t\t\tif (stutter_wait(\"rcu_torture_boost\")) {\n\t\t\t\tsched_set_fifo_low(current);\n\t\t\t\t// If the grace period already ended,\n\t\t\t\t// we don't know when that happened, so\n\t\t\t\t// start over.\n\t\t\t\tif (cur_ops->poll_gp_state(gp_state))\n\t\t\t\t\tgp_initiated = false;\n\t\t\t}\n\t\t\tif (torture_must_stop())\n\t\t\t\tgoto checkwait;\n\t\t}\n\n\t\t// In case the grace period extended beyond the end of the loop.\n\t\tif (gp_initiated && !failed && !cur_ops->poll_gp_state(gp_state))\n\t\t\trcu_torture_boost_failed(gp_state, &gp_state_time);\n\n\t\t/*\n\t\t * Set the start time of the next test interval.\n\t\t * Yes, this is vulnerable to long delays, but such\n\t\t * delays simply cause a false negative for the next\n\t\t * interval.  Besides, we are running at RT priority,\n\t\t * so delays should be relatively rare.\n\t\t */\n\t\twhile (oldstarttime == boost_starttime && !kthread_should_stop()) {\n\t\t\tif (mutex_trylock(&boost_mutex)) {\n\t\t\t\tif (oldstarttime == boost_starttime) {\n\t\t\t\t\tboost_starttime = jiffies + test_boost_interval * HZ;\n\t\t\t\t\tn_rcu_torture_boosts++;\n\t\t\t\t}\n\t\t\t\tmutex_unlock(&boost_mutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\n\t\t/* Go do the stutter. */\ncheckwait:\tif (stutter_wait(\"rcu_torture_boost\"))\n\t\t\tsched_set_fifo_low(current);\n\t} while (!torture_must_stop());\n\n\t/* Clean up and exit. */\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(\"rcu_torture_boost\");\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\ttorture_kthread_stopping(\"rcu_torture_boost\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long n_rcu_torture_boosts;",
      "static unsigned long boost_starttime;",
      "static DEFINE_MUTEX(boost_mutex);",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_boost\""
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_shutdown_absorb",
          "args": [
            "\"rcu_torture_boost\""
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "608-615",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_set_fifo_low",
          "args": [
            "current"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "sched_set_fifo_low",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7599-7603",
          "snippet": "void sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_torture_boost\""
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "722-749",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&boost_mutex"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&boost_mutex"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1278-1284",
          "snippet": "static __always_inline int __rt_mutex_trylock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))\n\t\treturn 1;\n\n\treturn rt_mutex_slowtrylock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline int __rt_mutex_trylock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))\n\t\treturn 1;\n\n\treturn rt_mutex_slowtrylock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_boost_failed",
          "args": [
            "gp_state",
            "&gp_state_time"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_boost_failed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "934-977",
          "snippet": "static bool rcu_torture_boost_failed(unsigned long gp_state, unsigned long *start)\n{\n\tint cpu;\n\tstatic int dbg_done;\n\tunsigned long end = jiffies;\n\tbool gp_done;\n\tunsigned long j;\n\tstatic unsigned long last_persist;\n\tunsigned long lp;\n\tunsigned long mininterval = test_boost_duration * HZ - HZ / 2;\n\n\tif (end - *start > mininterval) {\n\t\t// Recheck after checking time to avoid false positives.\n\t\tsmp_mb(); // Time check before grace-period check.\n\t\tif (cur_ops->poll_gp_state(gp_state))\n\t\t\treturn false; // passed, though perhaps just barely\n\t\tif (cur_ops->check_boost_failed && !cur_ops->check_boost_failed(gp_state, &cpu)) {\n\t\t\t// At most one persisted message per boost test.\n\t\t\tj = jiffies;\n\t\t\tlp = READ_ONCE(last_persist);\n\t\t\tif (time_after(j, lp + mininterval) && cmpxchg(&last_persist, lp, j) == lp)\n\t\t\t\tpr_info(\"Boost inversion persisted: No QS from CPU %d\\n\", cpu);\n\t\t\treturn false; // passed on a technicality\n\t\t}\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost boosting failed\");\n\t\tn_rcu_torture_boost_failure++;\n\t\tif (!xchg(&dbg_done, 1) && cur_ops->gp_kthread_dbg) {\n\t\t\tpr_info(\"Boost inversion thread ->rt_priority %u gp_state %lu jiffies %lu\\n\",\n\t\t\t\tcurrent->rt_priority, gp_state, end - *start);\n\t\t\tcur_ops->gp_kthread_dbg();\n\t\t\t// Recheck after print to flag grace period ending during splat.\n\t\t\tgp_done = cur_ops->poll_gp_state(gp_state);\n\t\t\tpr_info(\"Boost inversion: GP %lu %s.\\n\", gp_state,\n\t\t\t\tgp_done ? \"ended already\" : \"still pending\");\n\n\t\t}\n\n\t\treturn true; // failed\n\t} else if (cur_ops->check_boost_failed && !cur_ops->check_boost_failed(gp_state, NULL)) {\n\t\t*start = jiffies;\n\t}\n\n\treturn false; // passed\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long n_rcu_torture_boost_failure;",
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic long n_rcu_torture_boost_failure;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic bool rcu_torture_boost_failed(unsigned long gp_state, unsigned long *start)\n{\n\tint cpu;\n\tstatic int dbg_done;\n\tunsigned long end = jiffies;\n\tbool gp_done;\n\tunsigned long j;\n\tstatic unsigned long last_persist;\n\tunsigned long lp;\n\tunsigned long mininterval = test_boost_duration * HZ - HZ / 2;\n\n\tif (end - *start > mininterval) {\n\t\t// Recheck after checking time to avoid false positives.\n\t\tsmp_mb(); // Time check before grace-period check.\n\t\tif (cur_ops->poll_gp_state(gp_state))\n\t\t\treturn false; // passed, though perhaps just barely\n\t\tif (cur_ops->check_boost_failed && !cur_ops->check_boost_failed(gp_state, &cpu)) {\n\t\t\t// At most one persisted message per boost test.\n\t\t\tj = jiffies;\n\t\t\tlp = READ_ONCE(last_persist);\n\t\t\tif (time_after(j, lp + mininterval) && cmpxchg(&last_persist, lp, j) == lp)\n\t\t\t\tpr_info(\"Boost inversion persisted: No QS from CPU %d\\n\", cpu);\n\t\t\treturn false; // passed on a technicality\n\t\t}\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost boosting failed\");\n\t\tn_rcu_torture_boost_failure++;\n\t\tif (!xchg(&dbg_done, 1) && cur_ops->gp_kthread_dbg) {\n\t\t\tpr_info(\"Boost inversion thread ->rt_priority %u gp_state %lu jiffies %lu\\n\",\n\t\t\t\tcurrent->rt_priority, gp_state, end - *start);\n\t\t\tcur_ops->gp_kthread_dbg();\n\t\t\t// Recheck after print to flag grace period ending during splat.\n\t\t\tgp_done = cur_ops->poll_gp_state(gp_state);\n\t\t\tpr_info(\"Boost inversion: GP %lu %s.\\n\", gp_state,\n\t\t\t\tgp_done ? \"ended already\" : \"still pending\");\n\n\t\t}\n\n\t\treturn true; // failed\n\t} else if (cur_ops->check_boost_failed && !cur_ops->check_boost_failed(gp_state, NULL)) {\n\t\t*start = jiffies;\n\t}\n\n\treturn false; // passed\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->poll_gp_state",
          "args": [
            "gp_state"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->poll_gp_state",
          "args": [
            "gp_state"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->start_gp_poll",
          "args": [],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->poll_gp_state",
          "args": [
            "gp_state"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->poll_gp_state",
          "args": [
            "gp_state"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "endtime"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "oldstarttime - jiffies"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "oldstarttime"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_boost started\""
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic long n_rcu_torture_boosts;\nstatic unsigned long boost_starttime;\nstatic DEFINE_MUTEX(boost_mutex);\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcu_torture_boost(void *arg)\n{\n\tunsigned long endtime;\n\tunsigned long gp_state;\n\tunsigned long gp_state_time;\n\tunsigned long oldstarttime;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost started\");\n\n\t/* Set real-time priority. */\n\tsched_set_fifo_low(current);\n\n\t/* Each pass through the following loop does one boost-test cycle. */\n\tdo {\n\t\tbool failed = false; // Test failed already in this test interval\n\t\tbool gp_initiated = false;\n\n\t\tif (kthread_should_stop())\n\t\t\tgoto checkwait;\n\n\t\t/* Wait for the next test interval. */\n\t\toldstarttime = boost_starttime;\n\t\twhile (time_before(jiffies, oldstarttime)) {\n\t\t\tschedule_timeout_interruptible(oldstarttime - jiffies);\n\t\t\tif (stutter_wait(\"rcu_torture_boost\"))\n\t\t\t\tsched_set_fifo_low(current);\n\t\t\tif (torture_must_stop())\n\t\t\t\tgoto checkwait;\n\t\t}\n\n\t\t// Do one boost-test interval.\n\t\tendtime = oldstarttime + test_boost_duration * HZ;\n\t\twhile (time_before(jiffies, endtime)) {\n\t\t\t// Has current GP gone too long?\n\t\t\tif (gp_initiated && !failed && !cur_ops->poll_gp_state(gp_state))\n\t\t\t\tfailed = rcu_torture_boost_failed(gp_state, &gp_state_time);\n\t\t\t// If we don't have a grace period in flight, start one.\n\t\t\tif (!gp_initiated || cur_ops->poll_gp_state(gp_state)) {\n\t\t\t\tgp_state = cur_ops->start_gp_poll();\n\t\t\t\tgp_initiated = true;\n\t\t\t\tgp_state_time = jiffies;\n\t\t\t}\n\t\t\tif (stutter_wait(\"rcu_torture_boost\")) {\n\t\t\t\tsched_set_fifo_low(current);\n\t\t\t\t// If the grace period already ended,\n\t\t\t\t// we don't know when that happened, so\n\t\t\t\t// start over.\n\t\t\t\tif (cur_ops->poll_gp_state(gp_state))\n\t\t\t\t\tgp_initiated = false;\n\t\t\t}\n\t\t\tif (torture_must_stop())\n\t\t\t\tgoto checkwait;\n\t\t}\n\n\t\t// In case the grace period extended beyond the end of the loop.\n\t\tif (gp_initiated && !failed && !cur_ops->poll_gp_state(gp_state))\n\t\t\trcu_torture_boost_failed(gp_state, &gp_state_time);\n\n\t\t/*\n\t\t * Set the start time of the next test interval.\n\t\t * Yes, this is vulnerable to long delays, but such\n\t\t * delays simply cause a false negative for the next\n\t\t * interval.  Besides, we are running at RT priority,\n\t\t * so delays should be relatively rare.\n\t\t */\n\t\twhile (oldstarttime == boost_starttime && !kthread_should_stop()) {\n\t\t\tif (mutex_trylock(&boost_mutex)) {\n\t\t\t\tif (oldstarttime == boost_starttime) {\n\t\t\t\t\tboost_starttime = jiffies + test_boost_interval * HZ;\n\t\t\t\t\tn_rcu_torture_boosts++;\n\t\t\t\t}\n\t\t\t\tmutex_unlock(&boost_mutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\n\t\t/* Go do the stutter. */\ncheckwait:\tif (stutter_wait(\"rcu_torture_boost\"))\n\t\t\tsched_set_fifo_low(current);\n\t} while (!torture_must_stop());\n\n\t/* Clean up and exit. */\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(\"rcu_torture_boost\");\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\ttorture_kthread_stopping(\"rcu_torture_boost\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_boost_failed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "934-977",
    "snippet": "static bool rcu_torture_boost_failed(unsigned long gp_state, unsigned long *start)\n{\n\tint cpu;\n\tstatic int dbg_done;\n\tunsigned long end = jiffies;\n\tbool gp_done;\n\tunsigned long j;\n\tstatic unsigned long last_persist;\n\tunsigned long lp;\n\tunsigned long mininterval = test_boost_duration * HZ - HZ / 2;\n\n\tif (end - *start > mininterval) {\n\t\t// Recheck after checking time to avoid false positives.\n\t\tsmp_mb(); // Time check before grace-period check.\n\t\tif (cur_ops->poll_gp_state(gp_state))\n\t\t\treturn false; // passed, though perhaps just barely\n\t\tif (cur_ops->check_boost_failed && !cur_ops->check_boost_failed(gp_state, &cpu)) {\n\t\t\t// At most one persisted message per boost test.\n\t\t\tj = jiffies;\n\t\t\tlp = READ_ONCE(last_persist);\n\t\t\tif (time_after(j, lp + mininterval) && cmpxchg(&last_persist, lp, j) == lp)\n\t\t\t\tpr_info(\"Boost inversion persisted: No QS from CPU %d\\n\", cpu);\n\t\t\treturn false; // passed on a technicality\n\t\t}\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost boosting failed\");\n\t\tn_rcu_torture_boost_failure++;\n\t\tif (!xchg(&dbg_done, 1) && cur_ops->gp_kthread_dbg) {\n\t\t\tpr_info(\"Boost inversion thread ->rt_priority %u gp_state %lu jiffies %lu\\n\",\n\t\t\t\tcurrent->rt_priority, gp_state, end - *start);\n\t\t\tcur_ops->gp_kthread_dbg();\n\t\t\t// Recheck after print to flag grace period ending during splat.\n\t\t\tgp_done = cur_ops->poll_gp_state(gp_state);\n\t\t\tpr_info(\"Boost inversion: GP %lu %s.\\n\", gp_state,\n\t\t\t\tgp_done ? \"ended already\" : \"still pending\");\n\n\t\t}\n\n\t\treturn true; // failed\n\t} else if (cur_ops->check_boost_failed && !cur_ops->check_boost_failed(gp_state, NULL)) {\n\t\t*start = jiffies;\n\t}\n\n\treturn false; // passed\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long n_rcu_torture_boost_failure;",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_ops->check_boost_failed",
          "args": [
            "gp_state",
            "NULL"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Boost inversion: GP %lu %s.\\n\"",
            "gp_state",
            "gp_done ? \"ended already\" : \"still pending\""
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->poll_gp_state",
          "args": [
            "gp_state"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->gp_kthread_dbg",
          "args": [],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Boost inversion thread ->rt_priority %u gp_state %lu jiffies %lu\\n\"",
            "current->rt_priority",
            "gp_state",
            "end - *start"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&dbg_done",
            "1"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_boost boosting failed\""
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Boost inversion persisted: No QS from CPU %d\\n\"",
            "cpu"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&last_persist",
            "lp",
            "j"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "j",
            "lp + mininterval"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "last_persist"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->check_boost_failed",
          "args": [
            "gp_state",
            "&cpu"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->poll_gp_state",
          "args": [
            "gp_state"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic long n_rcu_torture_boost_failure;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic bool rcu_torture_boost_failed(unsigned long gp_state, unsigned long *start)\n{\n\tint cpu;\n\tstatic int dbg_done;\n\tunsigned long end = jiffies;\n\tbool gp_done;\n\tunsigned long j;\n\tstatic unsigned long last_persist;\n\tunsigned long lp;\n\tunsigned long mininterval = test_boost_duration * HZ - HZ / 2;\n\n\tif (end - *start > mininterval) {\n\t\t// Recheck after checking time to avoid false positives.\n\t\tsmp_mb(); // Time check before grace-period check.\n\t\tif (cur_ops->poll_gp_state(gp_state))\n\t\t\treturn false; // passed, though perhaps just barely\n\t\tif (cur_ops->check_boost_failed && !cur_ops->check_boost_failed(gp_state, &cpu)) {\n\t\t\t// At most one persisted message per boost test.\n\t\t\tj = jiffies;\n\t\t\tlp = READ_ONCE(last_persist);\n\t\t\tif (time_after(j, lp + mininterval) && cmpxchg(&last_persist, lp, j) == lp)\n\t\t\t\tpr_info(\"Boost inversion persisted: No QS from CPU %d\\n\", cpu);\n\t\t\treturn false; // passed on a technicality\n\t\t}\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost boosting failed\");\n\t\tn_rcu_torture_boost_failure++;\n\t\tif (!xchg(&dbg_done, 1) && cur_ops->gp_kthread_dbg) {\n\t\t\tpr_info(\"Boost inversion thread ->rt_priority %u gp_state %lu jiffies %lu\\n\",\n\t\t\t\tcurrent->rt_priority, gp_state, end - *start);\n\t\t\tcur_ops->gp_kthread_dbg();\n\t\t\t// Recheck after print to flag grace period ending during splat.\n\t\t\tgp_done = cur_ops->poll_gp_state(gp_state);\n\t\t\tpr_info(\"Boost inversion: GP %lu %s.\\n\", gp_state,\n\t\t\t\tgp_done ? \"ended already\" : \"still pending\");\n\n\t\t}\n\n\t\treturn true; // failed\n\t} else if (cur_ops->check_boost_failed && !cur_ops->check_boost_failed(gp_state, NULL)) {\n\t\t*start = jiffies;\n\t}\n\n\treturn false; // passed\n}"
  },
  {
    "function_name": "rcu_torture_enable_rt_throttle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "925-932",
    "snippet": "static void rcu_torture_enable_rt_throttle(void)\n{\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime == -1)\n\t\treturn;\n\n\tsysctl_sched_rt_runtime = old_rt_runtime;\n\told_rt_runtime = -1;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int old_rt_runtime = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_BUILTIN",
          "args": [
            "CONFIG_RCU_TORTURE_TEST"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int old_rt_runtime = -1;\n\nstatic void rcu_torture_enable_rt_throttle(void)\n{\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime == -1)\n\t\treturn;\n\n\tsysctl_sched_rt_runtime = old_rt_runtime;\n\told_rt_runtime = -1;\n}"
  },
  {
    "function_name": "rcu_torture_disable_rt_throttle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "910-923",
    "snippet": "static void rcu_torture_disable_rt_throttle(void)\n{\n\t/*\n\t * Disable RT throttling so that rcutorture's boost threads don't get\n\t * throttled. Only possible if rcutorture is built-in otherwise the\n\t * user should manually do this by setting the sched_rt_period_us and\n\t * sched_rt_runtime sysctls.\n\t */\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime != -1)\n\t\treturn;\n\n\told_rt_runtime = sysctl_sched_rt_runtime;\n\tsysctl_sched_rt_runtime = -1;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int old_rt_runtime = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_BUILTIN",
          "args": [
            "CONFIG_RCU_TORTURE_TEST"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int old_rt_runtime = -1;\n\nstatic void rcu_torture_disable_rt_throttle(void)\n{\n\t/*\n\t * Disable RT throttling so that rcutorture's boost threads don't get\n\t * throttled. Only possible if rcutorture is built-in otherwise the\n\t * user should manually do this by setting the sched_rt_period_us and\n\t * sched_rt_runtime sysctls.\n\t */\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime != -1)\n\t\treturn;\n\n\told_rt_runtime = sysctl_sched_rt_runtime;\n\tsysctl_sched_rt_runtime = -1;\n}"
  },
  {
    "function_name": "rcutorture_seq_diff",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "894-899",
    "snippet": "static unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_ops->gp_diff",
          "args": [
            "new",
            "old"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}"
  },
  {
    "function_name": "rcu_tasks_tracing_torture_deferred_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "867-870",
    "snippet": "static void rcu_tasks_tracing_torture_deferred_free(struct rcu_torture *p)\n{\n\tcall_rcu_tasks_trace(&p->rtort_rcu, rcu_torture_cb);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_tasks_trace",
          "args": [
            "&p->rtort_rcu",
            "rcu_torture_cb"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_tasks_tracing_torture_deferred_free(struct rcu_torture *p)\n{\n\tcall_rcu_tasks_trace(&p->rtort_rcu, rcu_torture_cb);\n}"
  },
  {
    "function_name": "tasks_tracing_torture_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "862-865",
    "snippet": "static void tasks_tracing_torture_read_unlock(int idx)\n{\n\trcu_read_unlock_trace();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_trace",
          "args": [],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_tracing_torture_read_unlock(int idx)\n{\n\trcu_read_unlock_trace();\n}"
  },
  {
    "function_name": "tasks_tracing_torture_read_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "856-860",
    "snippet": "static int tasks_tracing_torture_read_lock(void)\n{\n\trcu_read_lock_trace();\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_lock_trace",
          "args": [],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int tasks_tracing_torture_read_lock(void)\n{\n\trcu_read_lock_trace();\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_tasks_rude_torture_deferred_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "827-830",
    "snippet": "static void rcu_tasks_rude_torture_deferred_free(struct rcu_torture *p)\n{\n\tcall_rcu_tasks_rude(&p->rtort_rcu, rcu_torture_cb);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_tasks_rude",
          "args": [
            "&p->rtort_rcu",
            "rcu_torture_cb"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_rude",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "975-978",
          "snippet": "void call_rcu_tasks_rude(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_rude);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_rude(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_rude);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_tasks_rude_torture_deferred_free(struct rcu_torture *p)\n{\n\tcall_rcu_tasks_rude(&p->rtort_rcu, rcu_torture_cb);\n}"
  },
  {
    "function_name": "rcu_torture_read_unlock_trivial",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "802-805",
    "snippet": "static void rcu_torture_read_unlock_trivial(int idx) __releases(RCU)\n{\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "RCU"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_read_unlock_trivial(int idx) __releases(RCU)\n{\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "rcu_torture_read_lock_trivial",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "796-800",
    "snippet": "static int rcu_torture_read_lock_trivial(void) __acquires(RCU)\n{\n\tpreempt_disable();\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "RCU"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_torture_read_lock_trivial(void) __acquires(RCU)\n{\n\tpreempt_disable();\n\treturn 0;\n}"
  },
  {
    "function_name": "synchronize_rcu_trivial",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "786-794",
    "snippet": "static void synchronize_rcu_trivial(void)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\trcutorture_sched_setaffinity(current->pid, cpumask_of(cpu));\n\t\tWARN_ON_ONCE(raw_smp_processor_id() != cpu);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "raw_smp_processor_id() != cpu"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutorture_sched_setaffinity",
          "args": [
            "current->pid",
            "cpumask_of(cpu)"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_sched_setaffinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "483-490",
          "snippet": "long rcutorture_sched_setaffinity(pid_t pid, const struct cpumask *in_mask)\n{\n\tint ret;\n\n\tret = sched_setaffinity(pid, in_mask);\n\tWARN_ONCE(ret, \"%s: sched_setaffinity() returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nlong rcutorture_sched_setaffinity(pid_t pid, const struct cpumask *in_mask)\n{\n\tint ret;\n\n\tret = sched_setaffinity(pid, in_mask);\n\tWARN_ONCE(ret, \"%s: sched_setaffinity() returned %d\\n\", __func__, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void synchronize_rcu_trivial(void)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\trcutorture_sched_setaffinity(current->pid, cpumask_of(cpu));\n\t\tWARN_ON_ONCE(raw_smp_processor_id() != cpu);\n\t}\n}"
  },
  {
    "function_name": "synchronize_rcu_mult_test",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "756-759",
    "snippet": "static void synchronize_rcu_mult_test(void)\n{\n\tsynchronize_rcu_mult(call_rcu_tasks, call_rcu);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_rcu_mult",
          "args": [
            "call_rcu_tasks",
            "call_rcu"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void synchronize_rcu_mult_test(void)\n{\n\tsynchronize_rcu_mult(call_rcu_tasks, call_rcu);\n}"
  },
  {
    "function_name": "rcu_tasks_torture_deferred_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "751-754",
    "snippet": "static void rcu_tasks_torture_deferred_free(struct rcu_torture *p)\n{\n\tcall_rcu_tasks(&p->rtort_rcu, rcu_torture_cb);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_tasks",
          "args": [
            "&p->rtort_rcu",
            "rcu_torture_cb"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_tasks_torture_deferred_free(struct rcu_torture *p)\n{\n\tcall_rcu_tasks(&p->rtort_rcu, rcu_torture_cb);\n}"
  },
  {
    "function_name": "tasks_torture_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "747-749",
    "snippet": "static void tasks_torture_read_unlock(int idx)\n{\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_torture_read_unlock(int idx)\n{\n}"
  },
  {
    "function_name": "tasks_torture_read_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "742-745",
    "snippet": "static int tasks_torture_read_lock(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int tasks_torture_read_lock(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "srcu_torture_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "689-693",
    "snippet": "static void srcu_torture_cleanup(void)\n{\n\tcleanup_srcu_struct(&srcu_ctld);\n\tsrcu_ctlp = &srcu_ctl; /* In case of a later rcutorture run. */\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct srcu_ctld;",
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_srcu_struct",
          "args": [
            "&srcu_ctld"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_srcu_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "367-392",
          "snippet": "void cleanup_srcu_struct(struct srcu_struct *ssp)\n{\n\tint cpu;\n\n\tif (WARN_ON(!srcu_get_delay(ssp)))\n\t\treturn; /* Just leak it! */\n\tif (WARN_ON(srcu_readers_active(ssp)))\n\t\treturn; /* Just leak it! */\n\tflush_delayed_work(&ssp->work);\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *sdp = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tdel_timer_sync(&sdp->delay_work);\n\t\tflush_work(&sdp->work);\n\t\tif (WARN_ON(rcu_segcblist_n_cbs(&sdp->srcu_cblist)))\n\t\t\treturn; /* Forgot srcu_barrier(), so just leak it! */\n\t}\n\tif (WARN_ON(rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) != SRCU_STATE_IDLE) ||\n\t    WARN_ON(srcu_readers_active(ssp))) {\n\t\tpr_info(\"%s: Active srcu_struct %p state: %d\\n\",\n\t\t\t__func__, ssp, rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)));\n\t\treturn; /* Caller forgot to stop doing call_srcu()? */\n\t}\n\tfree_percpu(ssp->sda);\n\tssp->sda = NULL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nvoid cleanup_srcu_struct(struct srcu_struct *ssp)\n{\n\tint cpu;\n\n\tif (WARN_ON(!srcu_get_delay(ssp)))\n\t\treturn; /* Just leak it! */\n\tif (WARN_ON(srcu_readers_active(ssp)))\n\t\treturn; /* Just leak it! */\n\tflush_delayed_work(&ssp->work);\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *sdp = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tdel_timer_sync(&sdp->delay_work);\n\t\tflush_work(&sdp->work);\n\t\tif (WARN_ON(rcu_segcblist_n_cbs(&sdp->srcu_cblist)))\n\t\t\treturn; /* Forgot srcu_barrier(), so just leak it! */\n\t}\n\tif (WARN_ON(rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) != SRCU_STATE_IDLE) ||\n\t    WARN_ON(srcu_readers_active(ssp))) {\n\t\tpr_info(\"%s: Active srcu_struct %p state: %d\\n\",\n\t\t\t__func__, ssp, rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)));\n\t\treturn; /* Caller forgot to stop doing call_srcu()? */\n\t}\n\tfree_percpu(ssp->sda);\n\tssp->sda = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct srcu_ctld;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_cleanup(void)\n{\n\tcleanup_srcu_struct(&srcu_ctld);\n\tsrcu_ctlp = &srcu_ctl; /* In case of a later rcutorture run. */\n}"
  },
  {
    "function_name": "srcu_torture_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "682-687",
    "snippet": "static void srcu_torture_init(void)\n{\n\trcu_sync_torture_init();\n\tWARN_ON(init_srcu_struct(&srcu_ctld));\n\tsrcu_ctlp = &srcu_ctld;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct srcu_ctld;",
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "init_srcu_struct(&srcu_ctld)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_srcu_struct",
          "args": [
            "&srcu_ctld"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "check_init_srcu_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "224-238",
          "snippet": "static void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_sync_torture_init",
          "args": [],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_sync_torture_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "489-492",
          "snippet": "static void rcu_sync_torture_init(void)\n{\n\tINIT_LIST_HEAD(&rcu_torture_removed);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head rcu_torture_removed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct list_head rcu_torture_removed;\n\nstatic void rcu_sync_torture_init(void)\n{\n\tINIT_LIST_HEAD(&rcu_torture_removed);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct srcu_ctld;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_init(void)\n{\n\trcu_sync_torture_init();\n\tWARN_ON(init_srcu_struct(&srcu_ctld));\n\tsrcu_ctlp = &srcu_ctld;\n}"
  },
  {
    "function_name": "srcu_torture_synchronize_expedited",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "655-658",
    "snippet": "static void srcu_torture_synchronize_expedited(void)\n{\n\tsynchronize_srcu_expedited(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_srcu_expedited",
          "args": [
            "srcu_ctlp"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_srcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "953-956",
          "snippet": "void synchronize_srcu_expedited(struct srcu_struct *ssp)\n{\n\t__synchronize_srcu(ssp, rcu_gp_is_normal());\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid synchronize_srcu_expedited(struct srcu_struct *ssp)\n{\n\t__synchronize_srcu(ssp, rcu_gp_is_normal());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_synchronize_expedited(void)\n{\n\tsynchronize_srcu_expedited(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_torture_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "650-653",
    "snippet": "static void srcu_torture_stats(void)\n{\n\tsrcu_torture_stats_print(srcu_ctlp, torture_type, TORTURE_FLAG);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *torture_type = \"rcu\";",
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_torture_stats_print",
          "args": [
            "srcu_ctlp",
            "torture_type",
            "TORTURE_FLAG"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_torture_stats_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1340-1377",
          "snippet": "void srcu_torture_stats_print(struct srcu_struct *ssp, char *tt, char *tf)\n{\n\tint cpu;\n\tint idx;\n\tunsigned long s0 = 0, s1 = 0;\n\n\tidx = ssp->srcu_idx & 0x1;\n\tpr_alert(\"%s%s Tree SRCU g%ld per-CPU(idx=%d):\",\n\t\t tt, tf, rcu_seq_current(&ssp->srcu_gp_seq), idx);\n\tfor_each_possible_cpu(cpu) {\n\t\tunsigned long l0, l1;\n\t\tunsigned long u0, u1;\n\t\tlong c0, c1;\n\t\tstruct srcu_data *sdp;\n\n\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\tu0 = data_race(sdp->srcu_unlock_count[!idx]);\n\t\tu1 = data_race(sdp->srcu_unlock_count[idx]);\n\n\t\t/*\n\t\t * Make sure that a lock is always counted if the corresponding\n\t\t * unlock is counted.\n\t\t */\n\t\tsmp_rmb();\n\n\t\tl0 = data_race(sdp->srcu_lock_count[!idx]);\n\t\tl1 = data_race(sdp->srcu_lock_count[idx]);\n\n\t\tc0 = l0 - u0;\n\t\tc1 = l1 - u1;\n\t\tpr_cont(\" %d(%ld,%ld %c)\",\n\t\t\tcpu, c0, c1,\n\t\t\t\"C.\"[rcu_segcblist_empty(&sdp->srcu_cblist)]);\n\t\ts0 += c0;\n\t\ts1 += c1;\n\t}\n\tpr_cont(\" T(%ld,%ld)\\n\", s0, s1);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid srcu_torture_stats_print(struct srcu_struct *ssp, char *tt, char *tf)\n{\n\tint cpu;\n\tint idx;\n\tunsigned long s0 = 0, s1 = 0;\n\n\tidx = ssp->srcu_idx & 0x1;\n\tpr_alert(\"%s%s Tree SRCU g%ld per-CPU(idx=%d):\",\n\t\t tt, tf, rcu_seq_current(&ssp->srcu_gp_seq), idx);\n\tfor_each_possible_cpu(cpu) {\n\t\tunsigned long l0, l1;\n\t\tunsigned long u0, u1;\n\t\tlong c0, c1;\n\t\tstruct srcu_data *sdp;\n\n\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\tu0 = data_race(sdp->srcu_unlock_count[!idx]);\n\t\tu1 = data_race(sdp->srcu_unlock_count[idx]);\n\n\t\t/*\n\t\t * Make sure that a lock is always counted if the corresponding\n\t\t * unlock is counted.\n\t\t */\n\t\tsmp_rmb();\n\n\t\tl0 = data_race(sdp->srcu_lock_count[!idx]);\n\t\tl1 = data_race(sdp->srcu_lock_count[idx]);\n\n\t\tc0 = l0 - u0;\n\t\tc1 = l1 - u1;\n\t\tpr_cont(\" %d(%ld,%ld %c)\",\n\t\t\tcpu, c0, c1,\n\t\t\t\"C.\"[rcu_segcblist_empty(&sdp->srcu_cblist)]);\n\t\ts0 += c0;\n\t\ts1 += c1;\n\t}\n\tpr_cont(\" T(%ld,%ld)\\n\", s0, s1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type = \"rcu\";\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_stats(void)\n{\n\tsrcu_torture_stats_print(srcu_ctlp, torture_type, TORTURE_FLAG);\n}"
  },
  {
    "function_name": "srcu_torture_barrier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "645-648",
    "snippet": "static void srcu_torture_barrier(void)\n{\n\tsrcu_barrier(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_barrier",
          "args": [
            "srcu_ctlp"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_barrier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1104-1152",
          "snippet": "void srcu_barrier(struct srcu_struct *ssp)\n{\n\tint cpu;\n\tstruct srcu_data *sdp;\n\tunsigned long s = rcu_seq_snap(&ssp->srcu_barrier_seq);\n\n\tcheck_init_srcu_struct(ssp);\n\tmutex_lock(&ssp->srcu_barrier_mutex);\n\tif (rcu_seq_done(&ssp->srcu_barrier_seq, s)) {\n\t\tsmp_mb(); /* Force ordering following return. */\n\t\tmutex_unlock(&ssp->srcu_barrier_mutex);\n\t\treturn; /* Someone else did our work for us. */\n\t}\n\trcu_seq_start(&ssp->srcu_barrier_seq);\n\tinit_completion(&ssp->srcu_barrier_completion);\n\n\t/* Initial count prevents reaching zero until all CBs are posted. */\n\tatomic_set(&ssp->srcu_barrier_cpu_cnt, 1);\n\n\t/*\n\t * Each pass through this loop enqueues a callback, but only\n\t * on CPUs already having callbacks enqueued.  Note that if\n\t * a CPU already has callbacks enqueue, it must have already\n\t * registered the need for a future grace period, so all we\n\t * need do is enqueue a callback that will use the same\n\t * grace period as the last callback already in the queue.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\tspin_lock_irq_rcu_node(sdp);\n\t\tatomic_inc(&ssp->srcu_barrier_cpu_cnt);\n\t\tsdp->srcu_barrier_head.func = srcu_barrier_cb;\n\t\tdebug_rcu_head_queue(&sdp->srcu_barrier_head);\n\t\tif (!rcu_segcblist_entrain(&sdp->srcu_cblist,\n\t\t\t\t\t   &sdp->srcu_barrier_head)) {\n\t\t\tdebug_rcu_head_unqueue(&sdp->srcu_barrier_head);\n\t\t\tatomic_dec(&ssp->srcu_barrier_cpu_cnt);\n\t\t}\n\t\tspin_unlock_irq_rcu_node(sdp);\n\t}\n\n\t/* Remove the initial count, at which point reaching zero can happen. */\n\tif (atomic_dec_and_test(&ssp->srcu_barrier_cpu_cnt))\n\t\tcomplete(&ssp->srcu_barrier_completion);\n\twait_for_completion(&ssp->srcu_barrier_completion);\n\n\trcu_seq_end(&ssp->srcu_barrier_seq);\n\tmutex_unlock(&ssp->srcu_barrier_mutex);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nvoid srcu_barrier(struct srcu_struct *ssp)\n{\n\tint cpu;\n\tstruct srcu_data *sdp;\n\tunsigned long s = rcu_seq_snap(&ssp->srcu_barrier_seq);\n\n\tcheck_init_srcu_struct(ssp);\n\tmutex_lock(&ssp->srcu_barrier_mutex);\n\tif (rcu_seq_done(&ssp->srcu_barrier_seq, s)) {\n\t\tsmp_mb(); /* Force ordering following return. */\n\t\tmutex_unlock(&ssp->srcu_barrier_mutex);\n\t\treturn; /* Someone else did our work for us. */\n\t}\n\trcu_seq_start(&ssp->srcu_barrier_seq);\n\tinit_completion(&ssp->srcu_barrier_completion);\n\n\t/* Initial count prevents reaching zero until all CBs are posted. */\n\tatomic_set(&ssp->srcu_barrier_cpu_cnt, 1);\n\n\t/*\n\t * Each pass through this loop enqueues a callback, but only\n\t * on CPUs already having callbacks enqueued.  Note that if\n\t * a CPU already has callbacks enqueue, it must have already\n\t * registered the need for a future grace period, so all we\n\t * need do is enqueue a callback that will use the same\n\t * grace period as the last callback already in the queue.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\tspin_lock_irq_rcu_node(sdp);\n\t\tatomic_inc(&ssp->srcu_barrier_cpu_cnt);\n\t\tsdp->srcu_barrier_head.func = srcu_barrier_cb;\n\t\tdebug_rcu_head_queue(&sdp->srcu_barrier_head);\n\t\tif (!rcu_segcblist_entrain(&sdp->srcu_cblist,\n\t\t\t\t\t   &sdp->srcu_barrier_head)) {\n\t\t\tdebug_rcu_head_unqueue(&sdp->srcu_barrier_head);\n\t\t\tatomic_dec(&ssp->srcu_barrier_cpu_cnt);\n\t\t}\n\t\tspin_unlock_irq_rcu_node(sdp);\n\t}\n\n\t/* Remove the initial count, at which point reaching zero can happen. */\n\tif (atomic_dec_and_test(&ssp->srcu_barrier_cpu_cnt))\n\t\tcomplete(&ssp->srcu_barrier_completion);\n\twait_for_completion(&ssp->srcu_barrier_completion);\n\n\trcu_seq_end(&ssp->srcu_barrier_seq);\n\tmutex_unlock(&ssp->srcu_barrier_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_barrier(void)\n{\n\tsrcu_barrier(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_torture_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "639-643",
    "snippet": "static void srcu_torture_call(struct rcu_head *head,\n\t\t\t      rcu_callback_t func)\n{\n\tcall_srcu(srcu_ctlp, head, func);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_srcu",
          "args": [
            "srcu_ctlp",
            "head",
            "func"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "call_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "903-907",
          "snippet": "void call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(ssp, rhp, func, true);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(ssp, rhp, func, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_call(struct rcu_head *head,\n\t\t\t      rcu_callback_t func)\n{\n\tcall_srcu(srcu_ctlp, head, func);\n}"
  },
  {
    "function_name": "srcu_torture_poll_gp_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "634-637",
    "snippet": "static bool srcu_torture_poll_gp_state(unsigned long oldstate)\n{\n\treturn poll_state_synchronize_srcu(srcu_ctlp, oldstate);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "poll_state_synchronize_srcu",
          "args": [
            "srcu_ctlp",
            "oldstate"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "poll_state_synchronize_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1075-1083",
          "snippet": "bool poll_state_synchronize_srcu(struct srcu_struct *ssp, unsigned long cookie)\n{\n\tif (!rcu_seq_done(&ssp->srcu_gp_seq, cookie))\n\t\treturn false;\n\t// Ensure that the end of the SRCU grace period happens before\n\t// any subsequent code that the caller might execute.\n\tsmp_mb(); // ^^^\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nbool poll_state_synchronize_srcu(struct srcu_struct *ssp, unsigned long cookie)\n{\n\tif (!rcu_seq_done(&ssp->srcu_gp_seq, cookie))\n\t\treturn false;\n\t// Ensure that the end of the SRCU grace period happens before\n\t// any subsequent code that the caller might execute.\n\tsmp_mb(); // ^^^\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic bool srcu_torture_poll_gp_state(unsigned long oldstate)\n{\n\treturn poll_state_synchronize_srcu(srcu_ctlp, oldstate);\n}"
  },
  {
    "function_name": "srcu_torture_start_gp_poll",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "629-632",
    "snippet": "static unsigned long srcu_torture_start_gp_poll(void)\n{\n\treturn start_poll_synchronize_srcu(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_poll_synchronize_srcu",
          "args": [
            "srcu_ctlp"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "start_poll_synchronize_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1044-1047",
          "snippet": "unsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\treturn srcu_gp_start_if_needed(ssp, NULL, true);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\treturn srcu_gp_start_if_needed(ssp, NULL, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic unsigned long srcu_torture_start_gp_poll(void)\n{\n\treturn start_poll_synchronize_srcu(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_torture_get_gp_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "624-627",
    "snippet": "static unsigned long srcu_torture_get_gp_state(void)\n{\n\treturn get_state_synchronize_srcu(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_state_synchronize_srcu",
          "args": [
            "srcu_ctlp"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "get_state_synchronize_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1025-1031",
          "snippet": "unsigned long get_state_synchronize_srcu(struct srcu_struct *ssp)\n{\n\t// Any prior manipulation of SRCU-protected data must happen\n\t// before the load from ->srcu_gp_seq.\n\tsmp_mb();\n\treturn rcu_seq_snap(&ssp->srcu_gp_seq);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long get_state_synchronize_srcu(struct srcu_struct *ssp)\n{\n\t// Any prior manipulation of SRCU-protected data must happen\n\t// before the load from ->srcu_gp_seq.\n\tsmp_mb();\n\treturn rcu_seq_snap(&ssp->srcu_gp_seq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic unsigned long srcu_torture_get_gp_state(void)\n{\n\treturn get_state_synchronize_srcu(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_torture_synchronize",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "619-622",
    "snippet": "static void srcu_torture_synchronize(void)\n{\n\tsynchronize_srcu(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_srcu",
          "args": [
            "srcu_ctlp"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "start_poll_synchronize_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1044-1047",
          "snippet": "unsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\treturn srcu_gp_start_if_needed(ssp, NULL, true);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\treturn srcu_gp_start_if_needed(ssp, NULL, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_synchronize(void)\n{\n\tsynchronize_srcu(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_torture_deferred_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "614-617",
    "snippet": "static void srcu_torture_deferred_free(struct rcu_torture *rp)\n{\n\tcall_srcu(srcu_ctlp, &rp->rtort_rcu, rcu_torture_cb);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_srcu",
          "args": [
            "srcu_ctlp",
            "&rp->rtort_rcu",
            "rcu_torture_cb"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "call_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "903-907",
          "snippet": "void call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(ssp, rhp, func, true);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(ssp, rhp, func, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_deferred_free(struct rcu_torture *rp)\n{\n\tcall_srcu(srcu_ctlp, &rp->rtort_rcu, rcu_torture_cb);\n}"
  },
  {
    "function_name": "srcu_torture_completed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "609-612",
    "snippet": "static unsigned long srcu_torture_completed(void)\n{\n\treturn srcu_batches_completed(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_batches_completed",
          "args": [
            "srcu_ctlp"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_batches_completed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1162-1165",
          "snippet": "unsigned long srcu_batches_completed(struct srcu_struct *ssp)\n{\n\treturn READ_ONCE(ssp->srcu_idx);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long srcu_batches_completed(struct srcu_struct *ssp)\n{\n\treturn READ_ONCE(ssp->srcu_idx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic unsigned long srcu_torture_completed(void)\n{\n\treturn srcu_batches_completed(srcu_ctlp);\n}"
  },
  {
    "function_name": "torture_srcu_read_lock_held",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "604-607",
    "snippet": "static int torture_srcu_read_lock_held(void)\n{\n\treturn srcu_read_lock_held(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_lock_held",
          "args": [
            "srcu_ctlp"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic int torture_srcu_read_lock_held(void)\n{\n\treturn srcu_read_lock_held(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_torture_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "599-602",
    "snippet": "static void srcu_torture_read_unlock(int idx) __releases(srcu_ctlp)\n{\n\tsrcu_read_unlock(srcu_ctlp, idx);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "srcu_ctlp",
            "idx"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "416-420",
          "snippet": "void __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(ssp->sda->srcu_unlock_count[idx]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(ssp->sda->srcu_unlock_count[idx]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "srcu_ctlp"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_read_unlock(int idx) __releases(srcu_ctlp)\n{\n\tsrcu_read_unlock(srcu_ctlp, idx);\n}"
  },
  {
    "function_name": "srcu_read_delay",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "580-597",
    "snippet": "static void\nsrcu_read_delay(struct torture_random_state *rrsp, struct rt_read_seg *rtrsp)\n{\n\tlong delay;\n\tconst long uspertick = 1000000 / HZ;\n\tconst long longdelay = 10;\n\n\t/* We want there to be long-running readers, but not all the time. */\n\n\tdelay = torture_random(rrsp) %\n\t\t(nrealreaders * 2 * longdelay * uspertick);\n\tif (!delay && in_task()) {\n\t\tschedule_timeout_interruptible(longdelay);\n\t\trtrsp->rt_delay_jiffies = longdelay;\n\t} else {\n\t\trcu_read_delay(rrsp, rtrsp);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nrealreaders;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_delay",
          "args": [
            "rrsp",
            "rtrsp"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_read_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "580-597",
          "snippet": "static void\nsrcu_read_delay(struct torture_random_state *rrsp, struct rt_read_seg *rtrsp)\n{\n\tlong delay;\n\tconst long uspertick = 1000000 / HZ;\n\tconst long longdelay = 10;\n\n\t/* We want there to be long-running readers, but not all the time. */\n\n\tdelay = torture_random(rrsp) %\n\t\t(nrealreaders * 2 * longdelay * uspertick);\n\tif (!delay && in_task()) {\n\t\tschedule_timeout_interruptible(longdelay);\n\t\trtrsp->rt_delay_jiffies = longdelay;\n\t} else {\n\t\trcu_read_delay(rrsp, rtrsp);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "longdelay"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "rrsp"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int nrealreaders;\n\nstatic void\nsrcu_read_delay(struct torture_random_state *rrsp, struct rt_read_seg *rtrsp)\n{\n\tlong delay;\n\tconst long uspertick = 1000000 / HZ;\n\tconst long longdelay = 10;\n\n\t/* We want there to be long-running readers, but not all the time. */\n\n\tdelay = torture_random(rrsp) %\n\t\t(nrealreaders * 2 * longdelay * uspertick);\n\tif (!delay && in_task()) {\n\t\tschedule_timeout_interruptible(longdelay);\n\t\trtrsp->rt_delay_jiffies = longdelay;\n\t} else {\n\t\trcu_read_delay(rrsp, rtrsp);\n\t}\n}"
  },
  {
    "function_name": "srcu_torture_read_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "575-578",
    "snippet": "static int srcu_torture_read_lock(void) __acquires(srcu_ctlp)\n{\n\treturn srcu_read_lock(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "srcu_ctlp"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "400-408",
          "snippet": "int __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "srcu_ctlp"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic int srcu_torture_read_lock(void) __acquires(srcu_ctlp)\n{\n\treturn srcu_read_lock(srcu_ctlp);\n}"
  },
  {
    "function_name": "call_rcu_busted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "541-546",
    "snippet": "static void\ncall_rcu_busted(struct rcu_head *head, rcu_callback_t func)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\tfunc(head);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "func",
          "args": [
            "head"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_sync_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/sync.c",
          "lines": "73-104",
          "snippet": "static void rcu_sync_func(struct rcu_head *rhp)\n{\n\tstruct rcu_sync *rsp = container_of(rhp, struct rcu_sync, cb_head);\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);\n\n\tspin_lock_irqsave(&rsp->rss_lock, flags);\n\tif (rsp->gp_count) {\n\t\t/*\n\t\t * We're at least a GP after the GP_IDLE->GP_ENTER transition.\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_PASSED);\n\t\twake_up_locked(&rsp->gp_wait);\n\t} else if (rsp->gp_state == GP_REPLAY) {\n\t\t/*\n\t\t * A new rcu_sync_exit() has happened; requeue the callback to\n\t\t * catch a later GP.\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\t\trcu_sync_call(rsp);\n\t} else {\n\t\t/*\n\t\t * We're at least a GP after the last rcu_sync_exit(); everybody\n\t\t * will now have observed the write side critical section.\n\t\t * Let 'em rip!\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_IDLE);\n\t}\n\tspin_unlock_irqrestore(&rsp->rss_lock, flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/rcu_sync.h>"
          ],
          "macros_used": [
            "#define\trss_lock\tgp_wait.lock"
          ],
          "globals_used": [
            "static void rcu_sync_func(struct rcu_head *rhp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\n#define\trss_lock\tgp_wait.lock\n\nstatic void rcu_sync_func(struct rcu_head *rhp);\n\nstatic void rcu_sync_func(struct rcu_head *rhp)\n{\n\tstruct rcu_sync *rsp = container_of(rhp, struct rcu_sync, cb_head);\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);\n\n\tspin_lock_irqsave(&rsp->rss_lock, flags);\n\tif (rsp->gp_count) {\n\t\t/*\n\t\t * We're at least a GP after the GP_IDLE->GP_ENTER transition.\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_PASSED);\n\t\twake_up_locked(&rsp->gp_wait);\n\t} else if (rsp->gp_state == GP_REPLAY) {\n\t\t/*\n\t\t * A new rcu_sync_exit() has happened; requeue the callback to\n\t\t * catch a later GP.\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\t\trcu_sync_call(rsp);\n\t} else {\n\t\t/*\n\t\t * We're at least a GP after the last rcu_sync_exit(); everybody\n\t\t * will now have observed the write side critical section.\n\t\t * Let 'em rip!\n\t\t */\n\t\tWRITE_ONCE(rsp->gp_state, GP_IDLE);\n\t}\n\tspin_unlock_irqrestore(&rsp->rss_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void\ncall_rcu_busted(struct rcu_head *head, rcu_callback_t func)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\tfunc(head);\n}"
  },
  {
    "function_name": "synchronize_rcu_busted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "536-539",
    "snippet": "static void synchronize_rcu_busted(void)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void synchronize_rcu_busted(void)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n}"
  },
  {
    "function_name": "rcu_busted_torture_deferred_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "530-534",
    "snippet": "static void rcu_busted_torture_deferred_free(struct rcu_torture *p)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\trcu_torture_cb(&p->rtort_rcu);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_torture_cb",
          "args": [
            "&p->rtort_rcu"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_cb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "463-477",
          "snippet": "static void\nrcu_torture_cb(struct rcu_head *p)\n{\n\tstruct rcu_torture *rp = container_of(p, struct rcu_torture, rtort_rcu);\n\n\tif (torture_must_stop_irq()) {\n\t\t/* Test is ending, just drop callbacks on the floor. */\n\t\t/* The next initialization will pick up the pieces. */\n\t\treturn;\n\t}\n\tif (rcu_torture_pipe_update_one(rp))\n\t\trcu_torture_free(rp);\n\telse\n\t\tcur_ops->deferred_free(rp);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void\nrcu_torture_cb(struct rcu_head *p)\n{\n\tstruct rcu_torture *rp = container_of(p, struct rcu_torture, rtort_rcu);\n\n\tif (torture_must_stop_irq()) {\n\t\t/* Test is ending, just drop callbacks on the floor. */\n\t\t/* The next initialization will pick up the pieces. */\n\t\treturn;\n\t}\n\tif (rcu_torture_pipe_update_one(rp))\n\t\trcu_torture_free(rp);\n\telse\n\t\tcur_ops->deferred_free(rp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_busted_torture_deferred_free(struct rcu_torture *p)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\trcu_torture_cb(&p->rtort_rcu);\n}"
  },
  {
    "function_name": "rcu_sync_torture_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "489-492",
    "snippet": "static void rcu_sync_torture_init(void)\n{\n\tINIT_LIST_HEAD(&rcu_torture_removed);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head rcu_torture_removed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rcu_torture_removed"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct list_head rcu_torture_removed;\n\nstatic void rcu_sync_torture_init(void)\n{\n\tINIT_LIST_HEAD(&rcu_torture_removed);\n}"
  },
  {
    "function_name": "rcu_torture_deferred_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "484-487",
    "snippet": "static void rcu_torture_deferred_free(struct rcu_torture *p)\n{\n\tcall_rcu(&p->rtort_rcu, rcu_torture_cb);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&p->rtort_rcu",
            "rcu_torture_cb"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_busted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "541-546",
          "snippet": "static void\ncall_rcu_busted(struct rcu_head *head, rcu_callback_t func)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\tfunc(head);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void\ncall_rcu_busted(struct rcu_head *head, rcu_callback_t func)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\tfunc(head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_deferred_free(struct rcu_torture *p)\n{\n\tcall_rcu(&p->rtort_rcu, rcu_torture_cb);\n}"
  },
  {
    "function_name": "rcu_no_completed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "479-482",
    "snippet": "static unsigned long rcu_no_completed(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long rcu_no_completed(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_cb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "463-477",
    "snippet": "static void\nrcu_torture_cb(struct rcu_head *p)\n{\n\tstruct rcu_torture *rp = container_of(p, struct rcu_torture, rtort_rcu);\n\n\tif (torture_must_stop_irq()) {\n\t\t/* Test is ending, just drop callbacks on the floor. */\n\t\t/* The next initialization will pick up the pieces. */\n\t\treturn;\n\t}\n\tif (rcu_torture_pipe_update_one(rp))\n\t\trcu_torture_free(rp);\n\telse\n\t\tcur_ops->deferred_free(rp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_ops->deferred_free",
          "args": [
            "rp"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_free",
          "args": [
            "rp"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "313-320",
          "snippet": "static void\nrcu_torture_free(struct rcu_torture *p)\n{\n\tatomic_inc(&n_rcu_torture_free);\n\tspin_lock_bh(&rcu_torture_lock);\n\tlist_add_tail(&p->rtort_free, &rcu_torture_freelist);\n\tspin_unlock_bh(&rcu_torture_lock);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(rcu_torture_freelist);",
            "static DEFINE_SPINLOCK(rcu_torture_lock);",
            "static atomic_t n_rcu_torture_free;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic DEFINE_SPINLOCK(rcu_torture_lock);\nstatic atomic_t n_rcu_torture_free;\n\nstatic void\nrcu_torture_free(struct rcu_torture *p)\n{\n\tatomic_inc(&n_rcu_torture_free);\n\tspin_lock_bh(&rcu_torture_lock);\n\tlist_add_tail(&p->rtort_free, &rcu_torture_freelist);\n\tspin_unlock_bh(&rcu_torture_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_pipe_update_one",
          "args": [
            "rp"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_pipe_update_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "421-441",
          "snippet": "static bool\nrcu_torture_pipe_update_one(struct rcu_torture *rp)\n{\n\tint i;\n\tstruct rcu_torture_reader_check *rtrcp = READ_ONCE(rp->rtort_chkp);\n\n\tif (rtrcp) {\n\t\tWRITE_ONCE(rp->rtort_chkp, NULL);\n\t\tsmp_store_release(&rtrcp->rtc_ready, 1); // Pair with smp_load_acquire().\n\t}\n\ti = READ_ONCE(rp->rtort_pipe_count);\n\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\ti = RCU_TORTURE_PIPE_LEN;\n\tatomic_inc(&rcu_torture_wcount[i]);\n\tWRITE_ONCE(rp->rtort_pipe_count, i + 1);\n\tif (rp->rtort_pipe_count >= RCU_TORTURE_PIPE_LEN) {\n\t\trp->rtort_mbtest = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_TORTURE_PIPE_LEN 10"
          ],
          "globals_used": [
            "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\n\nstatic bool\nrcu_torture_pipe_update_one(struct rcu_torture *rp)\n{\n\tint i;\n\tstruct rcu_torture_reader_check *rtrcp = READ_ONCE(rp->rtort_chkp);\n\n\tif (rtrcp) {\n\t\tWRITE_ONCE(rp->rtort_chkp, NULL);\n\t\tsmp_store_release(&rtrcp->rtc_ready, 1); // Pair with smp_load_acquire().\n\t}\n\ti = READ_ONCE(rp->rtort_pipe_count);\n\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\ti = RCU_TORTURE_PIPE_LEN;\n\tatomic_inc(&rcu_torture_wcount[i]);\n\tWRITE_ONCE(rp->rtort_pipe_count, i + 1);\n\tif (rp->rtort_pipe_count >= RCU_TORTURE_PIPE_LEN) {\n\t\trp->rtort_mbtest = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop_irq",
          "args": [],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structrcu_torture",
            "rtort_rcu"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void\nrcu_torture_cb(struct rcu_head *p)\n{\n\tstruct rcu_torture *rp = container_of(p, struct rcu_torture, rtort_rcu);\n\n\tif (torture_must_stop_irq()) {\n\t\t/* Test is ending, just drop callbacks on the floor. */\n\t\t/* The next initialization will pick up the pieces. */\n\t\treturn;\n\t}\n\tif (rcu_torture_pipe_update_one(rp))\n\t\trcu_torture_free(rp);\n\telse\n\t\tcur_ops->deferred_free(rp);\n}"
  },
  {
    "function_name": "rcu_torture_pipe_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "447-461",
    "snippet": "static void\nrcu_torture_pipe_update(struct rcu_torture *old_rp)\n{\n\tstruct rcu_torture *rp;\n\tstruct rcu_torture *rp1;\n\n\tif (old_rp)\n\t\tlist_add(&old_rp->rtort_free, &rcu_torture_removed);\n\tlist_for_each_entry_safe(rp, rp1, &rcu_torture_removed, rtort_free) {\n\t\tif (rcu_torture_pipe_update_one(rp)) {\n\t\t\tlist_del(&rp->rtort_free);\n\t\t\trcu_torture_free(rp);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head rcu_torture_removed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_torture_free",
          "args": [
            "rp"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "313-320",
          "snippet": "static void\nrcu_torture_free(struct rcu_torture *p)\n{\n\tatomic_inc(&n_rcu_torture_free);\n\tspin_lock_bh(&rcu_torture_lock);\n\tlist_add_tail(&p->rtort_free, &rcu_torture_freelist);\n\tspin_unlock_bh(&rcu_torture_lock);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(rcu_torture_freelist);",
            "static DEFINE_SPINLOCK(rcu_torture_lock);",
            "static atomic_t n_rcu_torture_free;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic DEFINE_SPINLOCK(rcu_torture_lock);\nstatic atomic_t n_rcu_torture_free;\n\nstatic void\nrcu_torture_free(struct rcu_torture *p)\n{\n\tatomic_inc(&n_rcu_torture_free);\n\tspin_lock_bh(&rcu_torture_lock);\n\tlist_add_tail(&p->rtort_free, &rcu_torture_freelist);\n\tspin_unlock_bh(&rcu_torture_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rp->rtort_free"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_pipe_update_one",
          "args": [
            "rp"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_pipe_update_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "421-441",
          "snippet": "static bool\nrcu_torture_pipe_update_one(struct rcu_torture *rp)\n{\n\tint i;\n\tstruct rcu_torture_reader_check *rtrcp = READ_ONCE(rp->rtort_chkp);\n\n\tif (rtrcp) {\n\t\tWRITE_ONCE(rp->rtort_chkp, NULL);\n\t\tsmp_store_release(&rtrcp->rtc_ready, 1); // Pair with smp_load_acquire().\n\t}\n\ti = READ_ONCE(rp->rtort_pipe_count);\n\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\ti = RCU_TORTURE_PIPE_LEN;\n\tatomic_inc(&rcu_torture_wcount[i]);\n\tWRITE_ONCE(rp->rtort_pipe_count, i + 1);\n\tif (rp->rtort_pipe_count >= RCU_TORTURE_PIPE_LEN) {\n\t\trp->rtort_mbtest = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_TORTURE_PIPE_LEN 10"
          ],
          "globals_used": [
            "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\n\nstatic bool\nrcu_torture_pipe_update_one(struct rcu_torture *rp)\n{\n\tint i;\n\tstruct rcu_torture_reader_check *rtrcp = READ_ONCE(rp->rtort_chkp);\n\n\tif (rtrcp) {\n\t\tWRITE_ONCE(rp->rtort_chkp, NULL);\n\t\tsmp_store_release(&rtrcp->rtc_ready, 1); // Pair with smp_load_acquire().\n\t}\n\ti = READ_ONCE(rp->rtort_pipe_count);\n\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\ti = RCU_TORTURE_PIPE_LEN;\n\tatomic_inc(&rcu_torture_wcount[i]);\n\tWRITE_ONCE(rp->rtort_pipe_count, i + 1);\n\tif (rp->rtort_pipe_count >= RCU_TORTURE_PIPE_LEN) {\n\t\trp->rtort_mbtest = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "rp",
            "rp1",
            "&rcu_torture_removed",
            "rtort_free"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&old_rp->rtort_free",
            "&rcu_torture_removed"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_add_len",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "210-221",
          "snippet": "void rcu_segcblist_add_len(struct rcu_segcblist *rsclp, long v)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\tsmp_mb__before_atomic(); // Read header comment above.\n\tatomic_long_add(v, &rsclp->len);\n\tsmp_mb__after_atomic();  // Read header comment above.\n#else\n\tsmp_mb(); // Read header comment above.\n\tWRITE_ONCE(rsclp->len, rsclp->len + v);\n\tsmp_mb(); // Read header comment above.\n#endif\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_add_len(struct rcu_segcblist *rsclp, long v)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\tsmp_mb__before_atomic(); // Read header comment above.\n\tatomic_long_add(v, &rsclp->len);\n\tsmp_mb__after_atomic();  // Read header comment above.\n#else\n\tsmp_mb(); // Read header comment above.\n\tWRITE_ONCE(rsclp->len, rsclp->len + v);\n\tsmp_mb(); // Read header comment above.\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct list_head rcu_torture_removed;\n\nstatic void\nrcu_torture_pipe_update(struct rcu_torture *old_rp)\n{\n\tstruct rcu_torture *rp;\n\tstruct rcu_torture *rp1;\n\n\tif (old_rp)\n\t\tlist_add(&old_rp->rtort_free, &rcu_torture_removed);\n\tlist_for_each_entry_safe(rp, rp1, &rcu_torture_removed, rtort_free) {\n\t\tif (rcu_torture_pipe_update_one(rp)) {\n\t\t\tlist_del(&rp->rtort_free);\n\t\t\trcu_torture_free(rp);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rcu_torture_pipe_update_one",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "421-441",
    "snippet": "static bool\nrcu_torture_pipe_update_one(struct rcu_torture *rp)\n{\n\tint i;\n\tstruct rcu_torture_reader_check *rtrcp = READ_ONCE(rp->rtort_chkp);\n\n\tif (rtrcp) {\n\t\tWRITE_ONCE(rp->rtort_chkp, NULL);\n\t\tsmp_store_release(&rtrcp->rtc_ready, 1); // Pair with smp_load_acquire().\n\t}\n\ti = READ_ONCE(rp->rtort_pipe_count);\n\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\ti = RCU_TORTURE_PIPE_LEN;\n\tatomic_inc(&rcu_torture_wcount[i]);\n\tWRITE_ONCE(rp->rtort_pipe_count, i + 1);\n\tif (rp->rtort_pipe_count >= RCU_TORTURE_PIPE_LEN) {\n\t\trp->rtort_mbtest = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_TORTURE_PIPE_LEN 10"
    ],
    "globals_used": [
      "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rp->rtort_pipe_count",
            "i + 1"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rcu_torture_wcount[i]"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rp->rtort_pipe_count"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&rtrcp->rtc_ready",
            "1"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rp->rtort_chkp",
            "NULL"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rp->rtort_chkp"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\n\nstatic bool\nrcu_torture_pipe_update_one(struct rcu_torture *rp)\n{\n\tint i;\n\tstruct rcu_torture_reader_check *rtrcp = READ_ONCE(rp->rtort_chkp);\n\n\tif (rtrcp) {\n\t\tWRITE_ONCE(rp->rtort_chkp, NULL);\n\t\tsmp_store_release(&rtrcp->rtc_ready, 1); // Pair with smp_load_acquire().\n\t}\n\ti = READ_ONCE(rp->rtort_pipe_count);\n\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\ti = RCU_TORTURE_PIPE_LEN;\n\tatomic_inc(&rcu_torture_wcount[i]);\n\tWRITE_ONCE(rp->rtort_pipe_count, i + 1);\n\tif (rp->rtort_pipe_count >= RCU_TORTURE_PIPE_LEN) {\n\t\trp->rtort_mbtest = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_torture_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "413-416",
    "snippet": "static void rcu_torture_read_unlock(int idx) __releases(RCU)\n{\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "RCU"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_read_unlock(int idx) __releases(RCU)\n{\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "rcu_read_delay",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "377-411",
    "snippet": "static void\nrcu_read_delay(struct torture_random_state *rrsp, struct rt_read_seg *rtrsp)\n{\n\tunsigned long started;\n\tunsigned long completed;\n\tconst unsigned long shortdelay_us = 200;\n\tunsigned long longdelay_ms = 300;\n\tunsigned long long ts;\n\n\t/* We want a short delay sometimes to make a reader delay the grace\n\t * period, and we want a long delay occasionally to trigger\n\t * force_quiescent_state. */\n\n\tif (!READ_ONCE(rcu_fwd_cb_nodelay) &&\n\t    !(torture_random(rrsp) % (nrealreaders * 2000 * longdelay_ms))) {\n\t\tstarted = cur_ops->get_gp_seq();\n\t\tts = rcu_trace_clock_local();\n\t\tif (preempt_count() & (SOFTIRQ_MASK | HARDIRQ_MASK))\n\t\t\tlongdelay_ms = 5; /* Avoid triggering BH limits. */\n\t\tmdelay(longdelay_ms);\n\t\trtrsp->rt_delay_ms = longdelay_ms;\n\t\tcompleted = cur_ops->get_gp_seq();\n\t\tdo_trace_rcu_torture_read(cur_ops->name, NULL, ts,\n\t\t\t\t\t  started, completed);\n\t}\n\tif (!(torture_random(rrsp) % (nrealreaders * 2 * shortdelay_us))) {\n\t\tudelay(shortdelay_us);\n\t\trtrsp->rt_delay_us = shortdelay_us;\n\t}\n\tif (!preempt_count() &&\n\t    !(torture_random(rrsp) % (nrealreaders * 500))) {\n\t\ttorture_preempt_schedule();  /* QS only if preemptible. */\n\t\trtrsp->rt_preempted = true;\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nrealreaders;",
      "static bool rcu_fwd_cb_nodelay;",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_preempt_schedule",
          "args": [],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "rrsp"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "shortdelay_us"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_trace_rcu_torture_read",
          "args": [
            "cur_ops->name",
            "NULL",
            "ts",
            "started",
            "completed"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "do_trace_rcu_torture_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "469-474",
          "snippet": "void do_trace_rcu_torture_read(const char *rcutorturename, struct rcu_head *rhp,\n\t\t\t       unsigned long secs,\n\t\t\t       unsigned long c_old, unsigned long c)\n{\n\ttrace_rcu_torture_read(rcutorturename, rhp, secs, c_old, c);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid do_trace_rcu_torture_read(const char *rcutorturename, struct rcu_head *rhp,\n\t\t\t       unsigned long secs,\n\t\t\t       unsigned long c_old, unsigned long c)\n{\n\ttrace_rcu_torture_read(rcutorturename, rhp, secs, c_old, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_trace_clock_local",
          "args": [],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_trace_clock_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "263-266",
          "snippet": "static u64 notrace rcu_trace_clock_local(void)\n{\n\treturn 0ULL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic u64 notrace rcu_trace_clock_local(void)\n{\n\treturn 0ULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_fwd_cb_nodelay"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int nrealreaders;\nstatic bool rcu_fwd_cb_nodelay;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void\nrcu_read_delay(struct torture_random_state *rrsp, struct rt_read_seg *rtrsp)\n{\n\tunsigned long started;\n\tunsigned long completed;\n\tconst unsigned long shortdelay_us = 200;\n\tunsigned long longdelay_ms = 300;\n\tunsigned long long ts;\n\n\t/* We want a short delay sometimes to make a reader delay the grace\n\t * period, and we want a long delay occasionally to trigger\n\t * force_quiescent_state. */\n\n\tif (!READ_ONCE(rcu_fwd_cb_nodelay) &&\n\t    !(torture_random(rrsp) % (nrealreaders * 2000 * longdelay_ms))) {\n\t\tstarted = cur_ops->get_gp_seq();\n\t\tts = rcu_trace_clock_local();\n\t\tif (preempt_count() & (SOFTIRQ_MASK | HARDIRQ_MASK))\n\t\t\tlongdelay_ms = 5; /* Avoid triggering BH limits. */\n\t\tmdelay(longdelay_ms);\n\t\trtrsp->rt_delay_ms = longdelay_ms;\n\t\tcompleted = cur_ops->get_gp_seq();\n\t\tdo_trace_rcu_torture_read(cur_ops->name, NULL, ts,\n\t\t\t\t\t  started, completed);\n\t}\n\tif (!(torture_random(rrsp) % (nrealreaders * 2 * shortdelay_us))) {\n\t\tudelay(shortdelay_us);\n\t\trtrsp->rt_delay_us = shortdelay_us;\n\t}\n\tif (!preempt_count() &&\n\t    !(torture_random(rrsp) % (nrealreaders * 500))) {\n\t\ttorture_preempt_schedule();  /* QS only if preemptible. */\n\t\trtrsp->rt_preempted = true;\n\t}\n}"
  },
  {
    "function_name": "rcu_torture_read_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "371-375",
    "snippet": "static int rcu_torture_read_lock(void) __acquires(RCU)\n{\n\trcu_read_lock();\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "torture_srcu_read_lock_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "604-607",
          "snippet": "static int torture_srcu_read_lock_held(void)\n{\n\treturn srcu_read_lock_held(srcu_ctlp);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/tick.h>",
            "#include <linux/oom.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic int torture_srcu_read_lock_held(void)\n{\n\treturn srcu_read_lock_held(srcu_ctlp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "RCU"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_torture_read_lock(void) __acquires(RCU)\n{\n\trcu_read_lock();\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_readlock_not_held",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "366-369",
    "snippet": "static int torture_readlock_not_held(void)\n{\n\treturn rcu_read_lock_bh_held() || rcu_read_lock_sched_held();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_lock_sched_held",
          "args": [],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_bh_held",
          "args": [],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "330-337",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int torture_readlock_not_held(void)\n{\n\treturn rcu_read_lock_bh_held() || rcu_read_lock_sched_held();\n}"
  },
  {
    "function_name": "rcu_torture_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "313-320",
    "snippet": "static void\nrcu_torture_free(struct rcu_torture *p)\n{\n\tatomic_inc(&n_rcu_torture_free);\n\tspin_lock_bh(&rcu_torture_lock);\n\tlist_add_tail(&p->rtort_free, &rcu_torture_freelist);\n\tspin_unlock_bh(&rcu_torture_lock);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(rcu_torture_freelist);",
      "static DEFINE_SPINLOCK(rcu_torture_lock);",
      "static atomic_t n_rcu_torture_free;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&rcu_torture_lock"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&p->rtort_free",
            "&rcu_torture_freelist"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&rcu_torture_lock"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_rcu_torture_free"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic DEFINE_SPINLOCK(rcu_torture_lock);\nstatic atomic_t n_rcu_torture_free;\n\nstatic void\nrcu_torture_free(struct rcu_torture *p)\n{\n\tatomic_inc(&n_rcu_torture_free);\n\tspin_lock_bh(&rcu_torture_lock);\n\tlist_add_tail(&p->rtort_free, &rcu_torture_freelist);\n\tspin_unlock_bh(&rcu_torture_lock);\n}"
  },
  {
    "function_name": "rcu_torture_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "292-308",
    "snippet": "static struct rcu_torture *\nrcu_torture_alloc(void)\n{\n\tstruct list_head *p;\n\n\tspin_lock_bh(&rcu_torture_lock);\n\tif (list_empty(&rcu_torture_freelist)) {\n\t\tatomic_inc(&n_rcu_torture_alloc_fail);\n\t\tspin_unlock_bh(&rcu_torture_lock);\n\t\treturn NULL;\n\t}\n\tatomic_inc(&n_rcu_torture_alloc);\n\tp = rcu_torture_freelist.next;\n\tlist_del_init(p);\n\tspin_unlock_bh(&rcu_torture_lock);\n\treturn container_of(p, struct rcu_torture, rtort_free);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(rcu_torture_freelist);",
      "static DEFINE_SPINLOCK(rcu_torture_lock);",
      "static atomic_t n_rcu_torture_alloc;",
      "static atomic_t n_rcu_torture_alloc_fail;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structrcu_torture",
            "rtort_free"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&rcu_torture_lock"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "p"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_rcu_torture_alloc"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_rcu_torture_alloc_fail"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rcu_torture_freelist"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&rcu_torture_lock"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic DEFINE_SPINLOCK(rcu_torture_lock);\nstatic atomic_t n_rcu_torture_alloc;\nstatic atomic_t n_rcu_torture_alloc_fail;\n\nstatic struct rcu_torture *\nrcu_torture_alloc(void)\n{\n\tstruct list_head *p;\n\n\tspin_lock_bh(&rcu_torture_lock);\n\tif (list_empty(&rcu_torture_freelist)) {\n\t\tatomic_inc(&n_rcu_torture_alloc_fail);\n\t\tspin_unlock_bh(&rcu_torture_lock);\n\t\treturn NULL;\n\t}\n\tatomic_inc(&n_rcu_torture_alloc);\n\tp = rcu_torture_freelist.next;\n\tlist_del_init(p);\n\tspin_unlock_bh(&rcu_torture_lock);\n\treturn container_of(p, struct rcu_torture, rtort_free);\n}"
  },
  {
    "function_name": "shutdown_time_arrived",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "273-276",
    "snippet": "static bool shutdown_time_arrived(void)\n{\n\treturn shutdown_secs && time_after(jiffies, shutdown_jiffies - 30 * HZ);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long shutdown_jiffies;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "shutdown_jiffies - 30 * HZ"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long shutdown_jiffies;\n\nstatic bool shutdown_time_arrived(void)\n{\n\treturn shutdown_secs && time_after(jiffies, shutdown_jiffies - 30 * HZ);\n}"
  },
  {
    "function_name": "rcu_trace_clock_local",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "263-266",
    "snippet": "static u64 notrace rcu_trace_clock_local(void)\n{\n\treturn 0ULL;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic u64 notrace rcu_trace_clock_local(void)\n{\n\treturn 0ULL;\n}"
  },
  {
    "function_name": "rcu_trace_clock_local",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "255-261",
    "snippet": "static u64 notrace rcu_trace_clock_local(void)\n{\n\tu64 ts = trace_clock_local();\n\n\t(void)do_div(ts, NSEC_PER_USEC);\n\treturn ts;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ts",
            "NSEC_PER_USEC"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_clock_local",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_trace_clock_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
          "lines": "263-266",
          "snippet": "static u64 notrace rcu_trace_clock_local(void)\n{\n\treturn 0ULL;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic u64 notrace rcu_trace_clock_local(void)\n{\n\tu64 ts = trace_clock_local();\n\n\t(void)do_div(ts, NSEC_PER_USEC);\n\treturn ts;\n}"
  },
  {
    "function_name": "rcu_torture_writer_state_getname",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcutorture.c",
    "lines": "245-252",
    "snippet": "static const char *rcu_torture_writer_state_getname(void)\n{\n\tunsigned int i = READ_ONCE(rcu_torture_writer_state);\n\n\tif (i >= ARRAY_SIZE(rcu_torture_writer_state_names))\n\t\treturn \"???\";\n\treturn rcu_torture_writer_state_names[i];\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/tick.h>",
      "#include <linux/oom.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_torture_writer_state;",
      "static const char * const rcu_torture_writer_state_names[] = {\n\t\"RTWS_FIXED_DELAY\",\n\t\"RTWS_DELAY\",\n\t\"RTWS_REPLACE\",\n\t\"RTWS_DEF_FREE\",\n\t\"RTWS_EXP_SYNC\",\n\t\"RTWS_COND_GET\",\n\t\"RTWS_COND_SYNC\",\n\t\"RTWS_POLL_GET\",\n\t\"RTWS_POLL_WAIT\",\n\t\"RTWS_SYNC\",\n\t\"RTWS_STUTTER\",\n\t\"RTWS_STOPPING\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "rcu_torture_writer_state_names"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_torture_writer_state"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/nmi.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/tick.h>\n#include <linux/oom.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_torture_writer_state;\nstatic const char * const rcu_torture_writer_state_names[] = {\n\t\"RTWS_FIXED_DELAY\",\n\t\"RTWS_DELAY\",\n\t\"RTWS_REPLACE\",\n\t\"RTWS_DEF_FREE\",\n\t\"RTWS_EXP_SYNC\",\n\t\"RTWS_COND_GET\",\n\t\"RTWS_COND_SYNC\",\n\t\"RTWS_POLL_GET\",\n\t\"RTWS_POLL_WAIT\",\n\t\"RTWS_SYNC\",\n\t\"RTWS_STUTTER\",\n\t\"RTWS_STOPPING\",\n};\n\nstatic const char *rcu_torture_writer_state_getname(void)\n{\n\tunsigned int i = READ_ONCE(rcu_torture_writer_state);\n\n\tif (i >= ARRAY_SIZE(rcu_torture_writer_state_names))\n\t\treturn \"???\";\n\treturn rcu_torture_writer_state_names[i];\n}"
  }
]