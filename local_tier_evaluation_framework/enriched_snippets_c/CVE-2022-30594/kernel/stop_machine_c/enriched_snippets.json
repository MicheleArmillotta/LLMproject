[
  {
    "function_name": "stop_machine_from_inactive_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "658-687",
    "snippet": "int stop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void *data,\n\t\t\t\t  const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = { .fn = fn, .data = data,\n\t\t\t\t\t    .active_cpus = cpus };\n\tstruct cpu_stop_done done;\n\tint ret;\n\n\t/* Local CPU must be inactive and CPU hotplug in progress. */\n\tBUG_ON(cpu_active(raw_smp_processor_id()));\n\tmsdata.num_threads = num_active_cpus() + 1;\t/* +1 for local */\n\n\t/* No proper task established and can't sleep - busy wait for lock. */\n\twhile (!mutex_trylock(&stop_cpus_mutex))\n\t\tcpu_relax();\n\n\t/* Schedule work on other CPUs and execute directly for local CPU */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\tcpu_stop_init_done(&done, num_active_cpus());\n\tqueue_stop_cpus_work(cpu_active_mask, multi_cpu_stop, &msdata,\n\t\t\t     &done);\n\tret = multi_cpu_stop(&msdata);\n\n\t/* Busy wait for completion. */\n\twhile (!completion_done(&done.completion))\n\t\tcpu_relax();\n\n\tmutex_unlock(&stop_cpus_mutex);\n\treturn ret ?: done.ret;\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(stop_cpus_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stop_cpus_mutex"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completion_done",
          "args": [
            "&done.completion"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "completion_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "315-330",
          "snippet": "bool completion_done(struct completion *x)\n{\n\tunsigned long flags;\n\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\t/*\n\t * If ->done, we need to wait for complete() to release ->wait.lock\n\t * otherwise we can end up freeing the completion before complete()\n\t * is done referencing it.\n\t */\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn true;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool completion_done(struct completion *x)\n{\n\tunsigned long flags;\n\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\t/*\n\t * If ->done, we need to wait for complete() to release ->wait.lock\n\t * otherwise we can end up freeing the completion before complete()\n\t * is done referencing it.\n\t */\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "multi_cpu_stop",
          "args": [
            "&msdata"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "multi_cpu_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "203-259",
          "snippet": "static int multi_cpu_stop(void *data)\n{\n\tstruct multi_stop_data *msdata = data;\n\tenum multi_stop_state newstate, curstate = MULTI_STOP_NONE;\n\tint cpu = smp_processor_id(), err = 0;\n\tconst struct cpumask *cpumask;\n\tunsigned long flags;\n\tbool is_active;\n\n\t/*\n\t * When called from stop_machine_from_inactive_cpu(), irq might\n\t * already be disabled.  Save the state and restore it on exit.\n\t */\n\tlocal_save_flags(flags);\n\n\tif (!msdata->active_cpus) {\n\t\tcpumask = cpu_online_mask;\n\t\tis_active = cpu == cpumask_first(cpumask);\n\t} else {\n\t\tcpumask = msdata->active_cpus;\n\t\tis_active = cpumask_test_cpu(cpu, cpumask);\n\t}\n\n\t/* Simple state machine */\n\tdo {\n\t\t/* Chill out and ensure we re-read multi_stop_state. */\n\t\tstop_machine_yield(cpumask);\n\t\tnewstate = READ_ONCE(msdata->state);\n\t\tif (newstate != curstate) {\n\t\t\tcurstate = newstate;\n\t\t\tswitch (curstate) {\n\t\t\tcase MULTI_STOP_DISABLE_IRQ:\n\t\t\t\tlocal_irq_disable();\n\t\t\t\thard_irq_disable();\n\t\t\t\tbreak;\n\t\t\tcase MULTI_STOP_RUN:\n\t\t\t\tif (is_active)\n\t\t\t\t\terr = msdata->fn(msdata->data);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tack_state(msdata);\n\t\t} else if (curstate > MULTI_STOP_PREPARE) {\n\t\t\t/*\n\t\t\t * At this stage all other CPUs we depend on must spin\n\t\t\t * in the same loop. Any reason for hard-lockup should\n\t\t\t * be detected and reported on their side.\n\t\t\t */\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t\trcu_momentary_dyntick_idle();\n\t} while (curstate != MULTI_STOP_EXIT);\n\n\tlocal_irq_restore(flags);\n\treturn err;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic int multi_cpu_stop(void *data)\n{\n\tstruct multi_stop_data *msdata = data;\n\tenum multi_stop_state newstate, curstate = MULTI_STOP_NONE;\n\tint cpu = smp_processor_id(), err = 0;\n\tconst struct cpumask *cpumask;\n\tunsigned long flags;\n\tbool is_active;\n\n\t/*\n\t * When called from stop_machine_from_inactive_cpu(), irq might\n\t * already be disabled.  Save the state and restore it on exit.\n\t */\n\tlocal_save_flags(flags);\n\n\tif (!msdata->active_cpus) {\n\t\tcpumask = cpu_online_mask;\n\t\tis_active = cpu == cpumask_first(cpumask);\n\t} else {\n\t\tcpumask = msdata->active_cpus;\n\t\tis_active = cpumask_test_cpu(cpu, cpumask);\n\t}\n\n\t/* Simple state machine */\n\tdo {\n\t\t/* Chill out and ensure we re-read multi_stop_state. */\n\t\tstop_machine_yield(cpumask);\n\t\tnewstate = READ_ONCE(msdata->state);\n\t\tif (newstate != curstate) {\n\t\t\tcurstate = newstate;\n\t\t\tswitch (curstate) {\n\t\t\tcase MULTI_STOP_DISABLE_IRQ:\n\t\t\t\tlocal_irq_disable();\n\t\t\t\thard_irq_disable();\n\t\t\t\tbreak;\n\t\t\tcase MULTI_STOP_RUN:\n\t\t\t\tif (is_active)\n\t\t\t\t\terr = msdata->fn(msdata->data);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tack_state(msdata);\n\t\t} else if (curstate > MULTI_STOP_PREPARE) {\n\t\t\t/*\n\t\t\t * At this stage all other CPUs we depend on must spin\n\t\t\t * in the same loop. Any reason for hard-lockup should\n\t\t\t * be detected and reported on their side.\n\t\t\t */\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t\trcu_momentary_dyntick_idle();\n\t} while (curstate != MULTI_STOP_EXIT);\n\n\tlocal_irq_restore(flags);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_stop_cpus_work",
          "args": [
            "cpu_active_mask",
            "multi_cpu_stop",
            "&msdata",
            "&done"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "queue_stop_cpus_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "391-421",
          "snippet": "static bool queue_stop_cpus_work(const struct cpumask *cpumask,\n\t\t\t\t cpu_stop_fn_t fn, void *arg,\n\t\t\t\t struct cpu_stop_done *done)\n{\n\tstruct cpu_stop_work *work;\n\tunsigned int cpu;\n\tbool queued = false;\n\n\t/*\n\t * Disable preemption while queueing to avoid getting\n\t * preempted by a stopper which might wait for other stoppers\n\t * to enter @fn which can lead to deadlock.\n\t */\n\tpreempt_disable();\n\tstop_cpus_in_progress = true;\n\tbarrier();\n\tfor_each_cpu(cpu, cpumask) {\n\t\twork = &per_cpu(cpu_stopper.stop_work, cpu);\n\t\twork->fn = fn;\n\t\twork->arg = arg;\n\t\twork->done = done;\n\t\twork->caller = _RET_IP_;\n\t\tif (cpu_stop_queue_work(cpu, work))\n\t\t\tqueued = true;\n\t}\n\tbarrier();\n\tstop_cpus_in_progress = false;\n\tpreempt_enable();\n\n\treturn queued;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);",
            "static bool stop_cpus_in_progress;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\nstatic bool stop_cpus_in_progress;\n\nstatic bool queue_stop_cpus_work(const struct cpumask *cpumask,\n\t\t\t\t cpu_stop_fn_t fn, void *arg,\n\t\t\t\t struct cpu_stop_done *done)\n{\n\tstruct cpu_stop_work *work;\n\tunsigned int cpu;\n\tbool queued = false;\n\n\t/*\n\t * Disable preemption while queueing to avoid getting\n\t * preempted by a stopper which might wait for other stoppers\n\t * to enter @fn which can lead to deadlock.\n\t */\n\tpreempt_disable();\n\tstop_cpus_in_progress = true;\n\tbarrier();\n\tfor_each_cpu(cpu, cpumask) {\n\t\twork = &per_cpu(cpu_stopper.stop_work, cpu);\n\t\twork->fn = fn;\n\t\twork->arg = arg;\n\t\twork->done = done;\n\t\twork->caller = _RET_IP_;\n\t\tif (cpu_stop_queue_work(cpu, work))\n\t\t\tqueued = true;\n\t}\n\tbarrier();\n\tstop_cpus_in_progress = false;\n\tpreempt_enable();\n\n\treturn queued;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_stop_init_done",
          "args": [
            "&done",
            "num_active_cpus()"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_init_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "70-75",
          "snippet": "static void cpu_stop_init_done(struct cpu_stop_done *done, unsigned int nr_todo)\n{\n\tmemset(done, 0, sizeof(*done));\n\tatomic_set(&done->nr_todo, nr_todo);\n\tinit_completion(&done->completion);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void cpu_stop_init_done(struct cpu_stop_done *done, unsigned int nr_todo)\n{\n\tmemset(done, 0, sizeof(*done));\n\tatomic_set(&done->nr_todo, nr_todo);\n\tinit_completion(&done->completion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_active_cpus",
          "args": [],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_state",
          "args": [
            "&msdata",
            "MULTI_STOP_PREPARE"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "set_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "181-188",
          "snippet": "static void set_state(struct multi_stop_data *msdata,\n\t\t      enum multi_stop_state newstate)\n{\n\t/* Reset ack counter. */\n\tatomic_set(&msdata->thread_ack, msdata->num_threads);\n\tsmp_wmb();\n\tWRITE_ONCE(msdata->state, newstate);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void set_state(struct multi_stop_data *msdata,\n\t\t      enum multi_stop_state newstate)\n{\n\t/* Reset ack counter. */\n\tatomic_set(&msdata->thread_ack, msdata->num_threads);\n\tsmp_wmb();\n\tWRITE_ONCE(msdata->state, newstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&stop_cpus_mutex"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1278-1284",
          "snippet": "static __always_inline int __rt_mutex_trylock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))\n\t\treturn 1;\n\n\treturn rt_mutex_slowtrylock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline int __rt_mutex_trylock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))\n\t\treturn 1;\n\n\treturn rt_mutex_slowtrylock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_active_cpus",
          "args": [],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpu_active(raw_smp_processor_id())"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_active",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_MUTEX(stop_cpus_mutex);\n\nint stop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void *data,\n\t\t\t\t  const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = { .fn = fn, .data = data,\n\t\t\t\t\t    .active_cpus = cpus };\n\tstruct cpu_stop_done done;\n\tint ret;\n\n\t/* Local CPU must be inactive and CPU hotplug in progress. */\n\tBUG_ON(cpu_active(raw_smp_processor_id()));\n\tmsdata.num_threads = num_active_cpus() + 1;\t/* +1 for local */\n\n\t/* No proper task established and can't sleep - busy wait for lock. */\n\twhile (!mutex_trylock(&stop_cpus_mutex))\n\t\tcpu_relax();\n\n\t/* Schedule work on other CPUs and execute directly for local CPU */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\tcpu_stop_init_done(&done, num_active_cpus());\n\tqueue_stop_cpus_work(cpu_active_mask, multi_cpu_stop, &msdata,\n\t\t\t     &done);\n\tret = multi_cpu_stop(&msdata);\n\n\t/* Busy wait for completion. */\n\twhile (!completion_done(&done.completion))\n\t\tcpu_relax();\n\n\tmutex_unlock(&stop_cpus_mutex);\n\treturn ret ?: done.ret;\n}"
  },
  {
    "function_name": "stop_machine",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "624-633",
    "snippet": "int stop_machine(cpu_stop_fn_t fn, void *data, const struct cpumask *cpus)\n{\n\tint ret;\n\n\t/* No CPUs can come up or down during this. */\n\tcpus_read_lock();\n\tret = stop_machine_cpuslocked(fn, data, cpus);\n\tcpus_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_machine_cpuslocked",
          "args": [
            "fn",
            "data",
            "cpus"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "stop_machine_cpuslocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "588-622",
          "snippet": "int stop_machine_cpuslocked(cpu_stop_fn_t fn, void *data,\n\t\t\t    const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = {\n\t\t.fn = fn,\n\t\t.data = data,\n\t\t.num_threads = num_online_cpus(),\n\t\t.active_cpus = cpus,\n\t};\n\n\tlockdep_assert_cpus_held();\n\n\tif (!stop_machine_initialized) {\n\t\t/*\n\t\t * Handle the case where stop_machine() is called\n\t\t * early in boot before stop_machine() has been\n\t\t * initialized.\n\t\t */\n\t\tunsigned long flags;\n\t\tint ret;\n\n\t\tWARN_ON_ONCE(msdata.num_threads != 1);\n\n\t\tlocal_irq_save(flags);\n\t\thard_irq_disable();\n\t\tret = (*fn)(data);\n\t\tlocal_irq_restore(flags);\n\n\t\treturn ret;\n\t}\n\n\t/* Set the initial state and stop all online cpus. */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\treturn stop_cpus(cpu_online_mask, multi_cpu_stop, &msdata);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool stop_machine_initialized = false;",
            "extern void sched_set_stop_task(int cpu, struct task_struct *stop);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic bool stop_machine_initialized = false;\nextern void sched_set_stop_task(int cpu, struct task_struct *stop);\n\nint stop_machine_cpuslocked(cpu_stop_fn_t fn, void *data,\n\t\t\t    const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = {\n\t\t.fn = fn,\n\t\t.data = data,\n\t\t.num_threads = num_online_cpus(),\n\t\t.active_cpus = cpus,\n\t};\n\n\tlockdep_assert_cpus_held();\n\n\tif (!stop_machine_initialized) {\n\t\t/*\n\t\t * Handle the case where stop_machine() is called\n\t\t * early in boot before stop_machine() has been\n\t\t * initialized.\n\t\t */\n\t\tunsigned long flags;\n\t\tint ret;\n\n\t\tWARN_ON_ONCE(msdata.num_threads != 1);\n\n\t\tlocal_irq_save(flags);\n\t\thard_irq_disable();\n\t\tret = (*fn)(data);\n\t\tlocal_irq_restore(flags);\n\n\t\treturn ret;\n\t}\n\n\t/* Set the initial state and stop all online cpus. */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\treturn stop_cpus(cpu_online_mask, multi_cpu_stop, &msdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nint stop_machine(cpu_stop_fn_t fn, void *data, const struct cpumask *cpus)\n{\n\tint ret;\n\n\t/* No CPUs can come up or down during this. */\n\tcpus_read_lock();\n\tret = stop_machine_cpuslocked(fn, data, cpus);\n\tcpus_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "stop_machine_cpuslocked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "588-622",
    "snippet": "int stop_machine_cpuslocked(cpu_stop_fn_t fn, void *data,\n\t\t\t    const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = {\n\t\t.fn = fn,\n\t\t.data = data,\n\t\t.num_threads = num_online_cpus(),\n\t\t.active_cpus = cpus,\n\t};\n\n\tlockdep_assert_cpus_held();\n\n\tif (!stop_machine_initialized) {\n\t\t/*\n\t\t * Handle the case where stop_machine() is called\n\t\t * early in boot before stop_machine() has been\n\t\t * initialized.\n\t\t */\n\t\tunsigned long flags;\n\t\tint ret;\n\n\t\tWARN_ON_ONCE(msdata.num_threads != 1);\n\n\t\tlocal_irq_save(flags);\n\t\thard_irq_disable();\n\t\tret = (*fn)(data);\n\t\tlocal_irq_restore(flags);\n\n\t\treturn ret;\n\t}\n\n\t/* Set the initial state and stop all online cpus. */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\treturn stop_cpus(cpu_online_mask, multi_cpu_stop, &msdata);\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool stop_machine_initialized = false;",
      "extern void sched_set_stop_task(int cpu, struct task_struct *stop);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_cpus",
          "args": [
            "cpu_online_mask",
            "multi_cpu_stop",
            "&msdata"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "stop_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "463-472",
          "snippet": "static int stop_cpus(const struct cpumask *cpumask, cpu_stop_fn_t fn, void *arg)\n{\n\tint ret;\n\n\t/* static works are used, process one request at a time */\n\tmutex_lock(&stop_cpus_mutex);\n\tret = __stop_cpus(cpumask, fn, arg);\n\tmutex_unlock(&stop_cpus_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(stop_cpus_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_MUTEX(stop_cpus_mutex);\n\nstatic int stop_cpus(const struct cpumask *cpumask, cpu_stop_fn_t fn, void *arg)\n{\n\tint ret;\n\n\t/* static works are used, process one request at a time */\n\tmutex_lock(&stop_cpus_mutex);\n\tret = __stop_cpus(cpumask, fn, arg);\n\tmutex_unlock(&stop_cpus_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_state",
          "args": [
            "&msdata",
            "MULTI_STOP_PREPARE"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "set_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "181-188",
          "snippet": "static void set_state(struct multi_stop_data *msdata,\n\t\t      enum multi_stop_state newstate)\n{\n\t/* Reset ack counter. */\n\tatomic_set(&msdata->thread_ack, msdata->num_threads);\n\tsmp_wmb();\n\tWRITE_ONCE(msdata->state, newstate);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void set_state(struct multi_stop_data *msdata,\n\t\t      enum multi_stop_state newstate)\n{\n\t/* Reset ack counter. */\n\tatomic_set(&msdata->thread_ack, msdata->num_threads);\n\tsmp_wmb();\n\tWRITE_ONCE(msdata->state, newstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "data"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "msdata.num_threads != 1"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "335-347",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic bool stop_machine_initialized = false;\nextern void sched_set_stop_task(int cpu, struct task_struct *stop);\n\nint stop_machine_cpuslocked(cpu_stop_fn_t fn, void *data,\n\t\t\t    const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = {\n\t\t.fn = fn,\n\t\t.data = data,\n\t\t.num_threads = num_online_cpus(),\n\t\t.active_cpus = cpus,\n\t};\n\n\tlockdep_assert_cpus_held();\n\n\tif (!stop_machine_initialized) {\n\t\t/*\n\t\t * Handle the case where stop_machine() is called\n\t\t * early in boot before stop_machine() has been\n\t\t * initialized.\n\t\t */\n\t\tunsigned long flags;\n\t\tint ret;\n\n\t\tWARN_ON_ONCE(msdata.num_threads != 1);\n\n\t\tlocal_irq_save(flags);\n\t\thard_irq_disable();\n\t\tret = (*fn)(data);\n\t\tlocal_irq_restore(flags);\n\n\t\treturn ret;\n\t}\n\n\t/* Set the initial state and stop all online cpus. */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\treturn stop_cpus(cpu_online_mask, multi_cpu_stop, &msdata);\n}"
  },
  {
    "function_name": "cpu_stop_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "570-585",
    "snippet": "static int __init cpu_stop_init(void)\n{\n\tunsigned int cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\n\t\traw_spin_lock_init(&stopper->lock);\n\t\tINIT_LIST_HEAD(&stopper->works);\n\t}\n\n\tBUG_ON(smpboot_register_percpu_thread(&cpu_stop_threads));\n\tstop_machine_unpark(raw_smp_processor_id());\n\tstop_machine_initialized = true;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);",
      "static bool stop_machine_initialized = false;",
      "static struct smp_hotplug_thread cpu_stop_threads = {\n\t.store\t\t\t= &cpu_stopper.thread,\n\t.thread_should_run\t= cpu_stop_should_run,\n\t.thread_fn\t\t= cpu_stopper_thread,\n\t.thread_comm\t\t= \"migration/%u\",\n\t.create\t\t\t= cpu_stop_create,\n\t.park\t\t\t= cpu_stop_park,\n\t.selfparking\t\t= true,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_machine_unpark",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "stop_machine_unpark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "552-558",
          "snippet": "void stop_machine_unpark(int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\n\tstopper->enabled = true;\n\tkthread_unpark(stopper->thread);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nvoid stop_machine_unpark(int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\n\tstopper->enabled = true;\n\tkthread_unpark(stopper->thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "smpboot_register_percpu_thread(&cpu_stop_threads)"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smpboot_register_percpu_thread",
          "args": [
            "&cpu_stop_threads"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "smpboot_register_percpu_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smpboot.c",
          "lines": "289-309",
          "snippet": "int smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tcpus_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(hotplug_threads);",
            "static DEFINE_MUTEX(smpboot_threads_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic LIST_HEAD(hotplug_threads);\nstatic DEFINE_MUTEX(smpboot_threads_lock);\n\nint smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tcpus_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&stopper->works"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&stopper->lock"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_stopper",
            "cpu"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\nstatic bool stop_machine_initialized = false;\nstatic struct smp_hotplug_thread cpu_stop_threads = {\n\t.store\t\t\t= &cpu_stopper.thread,\n\t.thread_should_run\t= cpu_stop_should_run,\n\t.thread_fn\t\t= cpu_stopper_thread,\n\t.thread_comm\t\t= \"migration/%u\",\n\t.create\t\t\t= cpu_stop_create,\n\t.park\t\t\t= cpu_stop_park,\n\t.selfparking\t\t= true,\n};\n\nstatic int __init cpu_stop_init(void)\n{\n\tunsigned int cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\n\t\traw_spin_lock_init(&stopper->lock);\n\t\tINIT_LIST_HEAD(&stopper->works);\n\t}\n\n\tBUG_ON(smpboot_register_percpu_thread(&cpu_stop_threads));\n\tstop_machine_unpark(raw_smp_processor_id());\n\tstop_machine_initialized = true;\n\treturn 0;\n}"
  },
  {
    "function_name": "stop_machine_unpark",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "552-558",
    "snippet": "void stop_machine_unpark(int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\n\tstopper->enabled = true;\n\tkthread_unpark(stopper->thread);\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_unpark",
          "args": [
            "stopper->thread"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_unpark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "622-638",
          "snippet": "void kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_unpark(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\t/*\n\t * Newly created kthread was parked when the CPU was offline.\n\t * The binding was lost and we need to set it again.\n\t */\n\tif (test_bit(KTHREAD_IS_PER_CPU, &kthread->flags))\n\t\t__kthread_bind(k, kthread->cpu, TASK_PARKED);\n\n\tclear_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\t/*\n\t * __kthread_parkme() will either see !SHOULD_PARK or get the wakeup.\n\t */\n\twake_up_state(k, TASK_PARKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_stopper",
            "cpu"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nvoid stop_machine_unpark(int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\n\tstopper->enabled = true;\n\tkthread_unpark(stopper->thread);\n}"
  },
  {
    "function_name": "cpu_stop_park",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "545-550",
    "snippet": "static void cpu_stop_park(unsigned int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\n\tWARN_ON(!list_empty(&stopper->works));\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&stopper->works)"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&stopper->works"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_stopper",
            "cpu"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic void cpu_stop_park(unsigned int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\n\tWARN_ON(!list_empty(&stopper->works));\n}"
  },
  {
    "function_name": "cpu_stop_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "540-543",
    "snippet": "static void cpu_stop_create(unsigned int cpu)\n{\n\tsched_set_stop_task(cpu, per_cpu(cpu_stopper.thread, cpu));\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_set_stop_task",
          "args": [
            "cpu",
            "per_cpu(cpu_stopper.thread, cpu)"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "sched_set_stop_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "3453-3496",
          "snippet": "void sched_set_stop_task(int cpu, struct task_struct *stop)\n{\n\tstatic struct lock_class_key stop_pi_lock;\n\tstruct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };\n\tstruct task_struct *old_stop = cpu_rq(cpu)->stop;\n\n\tif (stop) {\n\t\t/*\n\t\t * Make it appear like a SCHED_FIFO task, its something\n\t\t * userspace knows about and won't get confused about.\n\t\t *\n\t\t * Also, it will make PI more or less work without too\n\t\t * much confusion -- but then, stop work should not\n\t\t * rely on PI working anyway.\n\t\t */\n\t\tsched_setscheduler_nocheck(stop, SCHED_FIFO, &param);\n\n\t\tstop->sched_class = &stop_sched_class;\n\n\t\t/*\n\t\t * The PI code calls rt_mutex_setprio() with ->pi_lock held to\n\t\t * adjust the effective priority of a task. As a result,\n\t\t * rt_mutex_setprio() can trigger (RT) balancing operations,\n\t\t * which can then trigger wakeups of the stop thread to push\n\t\t * around the current task.\n\t\t *\n\t\t * The stop task itself will never be part of the PI-chain, it\n\t\t * never blocks, therefore that ->pi_lock recursion is safe.\n\t\t * Tell lockdep about this by placing the stop->pi_lock in its\n\t\t * own class.\n\t\t */\n\t\tlockdep_set_class(&stop->pi_lock, &stop_pi_lock);\n\t}\n\n\tcpu_rq(cpu)->stop = stop;\n\n\tif (old_stop) {\n\t\t/*\n\t\t * Reset it back to a normal scheduling class so that\n\t\t * it can die in pieces.\n\t\t */\n\t\told_stop->sched_class = &rt_sched_class;\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_set_stop_task(int cpu, struct task_struct *stop)\n{\n\tstatic struct lock_class_key stop_pi_lock;\n\tstruct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };\n\tstruct task_struct *old_stop = cpu_rq(cpu)->stop;\n\n\tif (stop) {\n\t\t/*\n\t\t * Make it appear like a SCHED_FIFO task, its something\n\t\t * userspace knows about and won't get confused about.\n\t\t *\n\t\t * Also, it will make PI more or less work without too\n\t\t * much confusion -- but then, stop work should not\n\t\t * rely on PI working anyway.\n\t\t */\n\t\tsched_setscheduler_nocheck(stop, SCHED_FIFO, &param);\n\n\t\tstop->sched_class = &stop_sched_class;\n\n\t\t/*\n\t\t * The PI code calls rt_mutex_setprio() with ->pi_lock held to\n\t\t * adjust the effective priority of a task. As a result,\n\t\t * rt_mutex_setprio() can trigger (RT) balancing operations,\n\t\t * which can then trigger wakeups of the stop thread to push\n\t\t * around the current task.\n\t\t *\n\t\t * The stop task itself will never be part of the PI-chain, it\n\t\t * never blocks, therefore that ->pi_lock recursion is safe.\n\t\t * Tell lockdep about this by placing the stop->pi_lock in its\n\t\t * own class.\n\t\t */\n\t\tlockdep_set_class(&stop->pi_lock, &stop_pi_lock);\n\t}\n\n\tcpu_rq(cpu)->stop = stop;\n\n\tif (old_stop) {\n\t\t/*\n\t\t * Reset it back to a normal scheduling class so that\n\t\t * it can die in pieces.\n\t\t */\n\t\told_stop->sched_class = &rt_sched_class;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_stopper.thread",
            "cpu"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic void cpu_stop_create(unsigned int cpu)\n{\n\tsched_set_stop_task(cpu, per_cpu(cpu_stopper.thread, cpu));\n}"
  },
  {
    "function_name": "stop_machine_park",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "526-536",
    "snippet": "void stop_machine_park(int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\t/*\n\t * Lockless. cpu_stopper_thread() will take stopper->lock and flush\n\t * the pending works before it parks, until then it is fine to queue\n\t * the new works.\n\t */\n\tstopper->enabled = false;\n\tkthread_park(stopper->thread);\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_park",
          "args": [
            "stopper->thread"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_park",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "653-679",
          "snippet": "int kthread_park(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\tif (WARN_ON(k->flags & PF_EXITING))\n\t\treturn -ENOSYS;\n\n\tif (WARN_ON_ONCE(test_bit(KTHREAD_SHOULD_PARK, &kthread->flags)))\n\t\treturn -EBUSY;\n\n\tset_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\tif (k != current) {\n\t\twake_up_process(k);\n\t\t/*\n\t\t * Wait for __kthread_parkme() to complete(), this means we\n\t\t * _will_ have TASK_PARKED and are about to call schedule().\n\t\t */\n\t\twait_for_completion(&kthread->parked);\n\t\t/*\n\t\t * Now wait for that schedule() to complete and the task to\n\t\t * get scheduled out.\n\t\t */\n\t\tWARN_ON_ONCE(!wait_task_inactive(k, TASK_PARKED));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nint kthread_park(struct task_struct *k)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\n\tif (WARN_ON(k->flags & PF_EXITING))\n\t\treturn -ENOSYS;\n\n\tif (WARN_ON_ONCE(test_bit(KTHREAD_SHOULD_PARK, &kthread->flags)))\n\t\treturn -EBUSY;\n\n\tset_bit(KTHREAD_SHOULD_PARK, &kthread->flags);\n\tif (k != current) {\n\t\twake_up_process(k);\n\t\t/*\n\t\t * Wait for __kthread_parkme() to complete(), this means we\n\t\t * _will_ have TASK_PARKED and are about to call schedule().\n\t\t */\n\t\twait_for_completion(&kthread->parked);\n\t\t/*\n\t\t * Now wait for that schedule() to complete and the task to\n\t\t * get scheduled out.\n\t\t */\n\t\tWARN_ON_ONCE(!wait_task_inactive(k, TASK_PARKED));\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_stopper",
            "cpu"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nvoid stop_machine_park(int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\t/*\n\t * Lockless. cpu_stopper_thread() will take stopper->lock and flush\n\t * the pending works before it parks, until then it is fine to queue\n\t * the new works.\n\t */\n\tstopper->enabled = false;\n\tkthread_park(stopper->thread);\n}"
  },
  {
    "function_name": "cpu_stopper_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "486-524",
    "snippet": "static void cpu_stopper_thread(unsigned int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tstruct cpu_stop_work *work;\n\nrepeat:\n\twork = NULL;\n\traw_spin_lock_irq(&stopper->lock);\n\tif (!list_empty(&stopper->works)) {\n\t\twork = list_first_entry(&stopper->works,\n\t\t\t\t\tstruct cpu_stop_work, list);\n\t\tlist_del_init(&work->list);\n\t}\n\traw_spin_unlock_irq(&stopper->lock);\n\n\tif (work) {\n\t\tcpu_stop_fn_t fn = work->fn;\n\t\tvoid *arg = work->arg;\n\t\tstruct cpu_stop_done *done = work->done;\n\t\tint ret;\n\n\t\t/* cpu stop callbacks must not sleep, make in_atomic() == T */\n\t\tstopper->caller = work->caller;\n\t\tstopper->fn = fn;\n\t\tpreempt_count_inc();\n\t\tret = fn(arg);\n\t\tif (done) {\n\t\t\tif (ret)\n\t\t\t\tdone->ret = ret;\n\t\t\tcpu_stop_signal_done(done);\n\t\t}\n\t\tpreempt_count_dec();\n\t\tstopper->fn = NULL;\n\t\tstopper->caller = 0;\n\t\tWARN_ONCE(preempt_count(),\n\t\t\t  \"cpu_stop: %ps(%p) leaked preempt count\\n\", fn, arg);\n\t\tgoto repeat;\n\t}\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);",
      "extern void sched_set_stop_task(int cpu, struct task_struct *stop);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "preempt_count()",
            "\"cpu_stop: %ps(%p) leaked preempt count\\n\"",
            "fn",
            "arg"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count_dec",
          "args": [],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_stop_signal_done",
          "args": [
            "done"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_signal_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "78-82",
          "snippet": "static void cpu_stop_signal_done(struct cpu_stop_done *done)\n{\n\tif (atomic_dec_and_test(&done->nr_todo))\n\t\tcomplete(&done->completion);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void cpu_stop_signal_done(struct cpu_stop_done *done)\n{\n\tif (atomic_dec_and_test(&done->nr_todo))\n\t\tcomplete(&done->completion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "arg"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "softlockup_start_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "511-515",
          "snippet": "static int softlockup_start_fn(void *data)\n{\n\twatchdog_enable(smp_processor_id());\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int softlockup_start_fn(void *data)\n{\n\twatchdog_enable(smp_processor_id());\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count_inc",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&stopper->lock"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&work->list"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&stopper->works",
            "structcpu_stop_work",
            "list"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&stopper->works"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&stopper->lock"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_stopper",
            "cpu"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\nextern void sched_set_stop_task(int cpu, struct task_struct *stop);\n\nstatic void cpu_stopper_thread(unsigned int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tstruct cpu_stop_work *work;\n\nrepeat:\n\twork = NULL;\n\traw_spin_lock_irq(&stopper->lock);\n\tif (!list_empty(&stopper->works)) {\n\t\twork = list_first_entry(&stopper->works,\n\t\t\t\t\tstruct cpu_stop_work, list);\n\t\tlist_del_init(&work->list);\n\t}\n\traw_spin_unlock_irq(&stopper->lock);\n\n\tif (work) {\n\t\tcpu_stop_fn_t fn = work->fn;\n\t\tvoid *arg = work->arg;\n\t\tstruct cpu_stop_done *done = work->done;\n\t\tint ret;\n\n\t\t/* cpu stop callbacks must not sleep, make in_atomic() == T */\n\t\tstopper->caller = work->caller;\n\t\tstopper->fn = fn;\n\t\tpreempt_count_inc();\n\t\tret = fn(arg);\n\t\tif (done) {\n\t\t\tif (ret)\n\t\t\t\tdone->ret = ret;\n\t\t\tcpu_stop_signal_done(done);\n\t\t}\n\t\tpreempt_count_dec();\n\t\tstopper->fn = NULL;\n\t\tstopper->caller = 0;\n\t\tWARN_ONCE(preempt_count(),\n\t\t\t  \"cpu_stop: %ps(%p) leaked preempt count\\n\", fn, arg);\n\t\tgoto repeat;\n\t}\n}"
  },
  {
    "function_name": "cpu_stop_should_run",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "474-484",
    "snippet": "static int cpu_stop_should_run(unsigned int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tunsigned long flags;\n\tint run;\n\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\trun = !list_empty(&stopper->works);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\treturn run;\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&stopper->lock",
            "flags"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&stopper->works"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&stopper->lock",
            "flags"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_stopper",
            "cpu"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic int cpu_stop_should_run(unsigned int cpu)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tunsigned long flags;\n\tint run;\n\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\trun = !list_empty(&stopper->works);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\treturn run;\n}"
  },
  {
    "function_name": "stop_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "463-472",
    "snippet": "static int stop_cpus(const struct cpumask *cpumask, cpu_stop_fn_t fn, void *arg)\n{\n\tint ret;\n\n\t/* static works are used, process one request at a time */\n\tmutex_lock(&stop_cpus_mutex);\n\tret = __stop_cpus(cpumask, fn, arg);\n\tmutex_unlock(&stop_cpus_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(stop_cpus_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stop_cpus_mutex"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__stop_cpus",
          "args": [
            "cpumask",
            "fn",
            "arg"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "__stop_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "423-433",
          "snippet": "static int __stop_cpus(const struct cpumask *cpumask,\n\t\t       cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\n\tcpu_stop_init_done(&done, cpumask_weight(cpumask));\n\tif (!queue_stop_cpus_work(cpumask, fn, arg, &done))\n\t\treturn -ENOENT;\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic int __stop_cpus(const struct cpumask *cpumask,\n\t\t       cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\n\tcpu_stop_init_done(&done, cpumask_weight(cpumask));\n\tif (!queue_stop_cpus_work(cpumask, fn, arg, &done))\n\t\treturn -ENOENT;\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&stop_cpus_mutex"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_MUTEX(stop_cpus_mutex);\n\nstatic int stop_cpus(const struct cpumask *cpumask, cpu_stop_fn_t fn, void *arg)\n{\n\tint ret;\n\n\t/* static works are used, process one request at a time */\n\tmutex_lock(&stop_cpus_mutex);\n\tret = __stop_cpus(cpumask, fn, arg);\n\tmutex_unlock(&stop_cpus_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__stop_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "423-433",
    "snippet": "static int __stop_cpus(const struct cpumask *cpumask,\n\t\t       cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\n\tcpu_stop_init_done(&done, cpumask_weight(cpumask));\n\tif (!queue_stop_cpus_work(cpumask, fn, arg, &done))\n\t\treturn -ENOENT;\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&done.completion"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_stop_cpus_work",
          "args": [
            "cpumask",
            "fn",
            "arg",
            "&done"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "queue_stop_cpus_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "391-421",
          "snippet": "static bool queue_stop_cpus_work(const struct cpumask *cpumask,\n\t\t\t\t cpu_stop_fn_t fn, void *arg,\n\t\t\t\t struct cpu_stop_done *done)\n{\n\tstruct cpu_stop_work *work;\n\tunsigned int cpu;\n\tbool queued = false;\n\n\t/*\n\t * Disable preemption while queueing to avoid getting\n\t * preempted by a stopper which might wait for other stoppers\n\t * to enter @fn which can lead to deadlock.\n\t */\n\tpreempt_disable();\n\tstop_cpus_in_progress = true;\n\tbarrier();\n\tfor_each_cpu(cpu, cpumask) {\n\t\twork = &per_cpu(cpu_stopper.stop_work, cpu);\n\t\twork->fn = fn;\n\t\twork->arg = arg;\n\t\twork->done = done;\n\t\twork->caller = _RET_IP_;\n\t\tif (cpu_stop_queue_work(cpu, work))\n\t\t\tqueued = true;\n\t}\n\tbarrier();\n\tstop_cpus_in_progress = false;\n\tpreempt_enable();\n\n\treturn queued;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);",
            "static bool stop_cpus_in_progress;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\nstatic bool stop_cpus_in_progress;\n\nstatic bool queue_stop_cpus_work(const struct cpumask *cpumask,\n\t\t\t\t cpu_stop_fn_t fn, void *arg,\n\t\t\t\t struct cpu_stop_done *done)\n{\n\tstruct cpu_stop_work *work;\n\tunsigned int cpu;\n\tbool queued = false;\n\n\t/*\n\t * Disable preemption while queueing to avoid getting\n\t * preempted by a stopper which might wait for other stoppers\n\t * to enter @fn which can lead to deadlock.\n\t */\n\tpreempt_disable();\n\tstop_cpus_in_progress = true;\n\tbarrier();\n\tfor_each_cpu(cpu, cpumask) {\n\t\twork = &per_cpu(cpu_stopper.stop_work, cpu);\n\t\twork->fn = fn;\n\t\twork->arg = arg;\n\t\twork->done = done;\n\t\twork->caller = _RET_IP_;\n\t\tif (cpu_stop_queue_work(cpu, work))\n\t\t\tqueued = true;\n\t}\n\tbarrier();\n\tstop_cpus_in_progress = false;\n\tpreempt_enable();\n\n\treturn queued;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_stop_init_done",
          "args": [
            "&done",
            "cpumask_weight(cpumask)"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_init_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "70-75",
          "snippet": "static void cpu_stop_init_done(struct cpu_stop_done *done, unsigned int nr_todo)\n{\n\tmemset(done, 0, sizeof(*done));\n\tatomic_set(&done->nr_todo, nr_todo);\n\tinit_completion(&done->completion);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void cpu_stop_init_done(struct cpu_stop_done *done, unsigned int nr_todo)\n{\n\tmemset(done, 0, sizeof(*done));\n\tatomic_set(&done->nr_todo, nr_todo);\n\tinit_completion(&done->completion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "cpumask"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic int __stop_cpus(const struct cpumask *cpumask,\n\t\t       cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\n\tcpu_stop_init_done(&done, cpumask_weight(cpumask));\n\tif (!queue_stop_cpus_work(cpumask, fn, arg, &done))\n\t\treturn -ENOENT;\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}"
  },
  {
    "function_name": "queue_stop_cpus_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "391-421",
    "snippet": "static bool queue_stop_cpus_work(const struct cpumask *cpumask,\n\t\t\t\t cpu_stop_fn_t fn, void *arg,\n\t\t\t\t struct cpu_stop_done *done)\n{\n\tstruct cpu_stop_work *work;\n\tunsigned int cpu;\n\tbool queued = false;\n\n\t/*\n\t * Disable preemption while queueing to avoid getting\n\t * preempted by a stopper which might wait for other stoppers\n\t * to enter @fn which can lead to deadlock.\n\t */\n\tpreempt_disable();\n\tstop_cpus_in_progress = true;\n\tbarrier();\n\tfor_each_cpu(cpu, cpumask) {\n\t\twork = &per_cpu(cpu_stopper.stop_work, cpu);\n\t\twork->fn = fn;\n\t\twork->arg = arg;\n\t\twork->done = done;\n\t\twork->caller = _RET_IP_;\n\t\tif (cpu_stop_queue_work(cpu, work))\n\t\t\tqueued = true;\n\t}\n\tbarrier();\n\tstop_cpus_in_progress = false;\n\tpreempt_enable();\n\n\treturn queued;\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);",
      "static bool stop_cpus_in_progress;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_stop_queue_work",
          "args": [
            "cpu",
            "work"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_stopper.stop_work",
            "cpu"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "cpumask"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\nstatic bool stop_cpus_in_progress;\n\nstatic bool queue_stop_cpus_work(const struct cpumask *cpumask,\n\t\t\t\t cpu_stop_fn_t fn, void *arg,\n\t\t\t\t struct cpu_stop_done *done)\n{\n\tstruct cpu_stop_work *work;\n\tunsigned int cpu;\n\tbool queued = false;\n\n\t/*\n\t * Disable preemption while queueing to avoid getting\n\t * preempted by a stopper which might wait for other stoppers\n\t * to enter @fn which can lead to deadlock.\n\t */\n\tpreempt_disable();\n\tstop_cpus_in_progress = true;\n\tbarrier();\n\tfor_each_cpu(cpu, cpumask) {\n\t\twork = &per_cpu(cpu_stopper.stop_work, cpu);\n\t\twork->fn = fn;\n\t\twork->arg = arg;\n\t\twork->done = done;\n\t\twork->caller = _RET_IP_;\n\t\tif (cpu_stop_queue_work(cpu, work))\n\t\t\tqueued = true;\n\t}\n\tbarrier();\n\tstop_cpus_in_progress = false;\n\tpreempt_enable();\n\n\treturn queued;\n}"
  },
  {
    "function_name": "stop_one_cpu_nowait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "384-389",
    "snippet": "bool stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,\n\t\t\tstruct cpu_stop_work *work_buf)\n{\n\t*work_buf = (struct cpu_stop_work){ .fn = fn, .arg = arg, .caller = _RET_IP_, };\n\treturn cpu_stop_queue_work(cpu, work_buf);\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_stop_queue_work",
          "args": [
            "cpu",
            "work_buf"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nbool stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,\n\t\t\tstruct cpu_stop_work *work_buf)\n{\n\t*work_buf = (struct cpu_stop_work){ .fn = fn, .arg = arg, .caller = _RET_IP_, };\n\treturn cpu_stop_queue_work(cpu, work_buf);\n}"
  },
  {
    "function_name": "stop_two_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "334-364",
    "snippet": "int stop_two_cpus(unsigned int cpu1, unsigned int cpu2, cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\tstruct cpu_stop_work work1, work2;\n\tstruct multi_stop_data msdata;\n\n\tmsdata = (struct multi_stop_data){\n\t\t.fn = fn,\n\t\t.data = arg,\n\t\t.num_threads = 2,\n\t\t.active_cpus = cpumask_of(cpu1),\n\t};\n\n\twork1 = work2 = (struct cpu_stop_work){\n\t\t.fn = multi_cpu_stop,\n\t\t.arg = &msdata,\n\t\t.done = &done,\n\t\t.caller = _RET_IP_,\n\t};\n\n\tcpu_stop_init_done(&done, 2);\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\n\tif (cpu1 > cpu2)\n\t\tswap(cpu1, cpu2);\n\tif (cpu_stop_queue_two_works(cpu1, &work1, cpu2, &work2))\n\t\treturn -ENOENT;\n\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&done.completion"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_stop_queue_two_works",
          "args": [
            "cpu1",
            "&work1",
            "cpu2",
            "&work2"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_two_works",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "261-322",
          "snippet": "static int cpu_stop_queue_two_works(int cpu1, struct cpu_stop_work *work1,\n\t\t\t\t    int cpu2, struct cpu_stop_work *work2)\n{\n\tstruct cpu_stopper *stopper1 = per_cpu_ptr(&cpu_stopper, cpu1);\n\tstruct cpu_stopper *stopper2 = per_cpu_ptr(&cpu_stopper, cpu2);\n\tDEFINE_WAKE_Q(wakeq);\n\tint err;\n\nretry:\n\t/*\n\t * The waking up of stopper threads has to happen in the same\n\t * scheduling context as the queueing.  Otherwise, there is a\n\t * possibility of one of the above stoppers being woken up by another\n\t * CPU, and preempting us. This will cause us to not wake up the other\n\t * stopper forever.\n\t */\n\tpreempt_disable();\n\traw_spin_lock_irq(&stopper1->lock);\n\traw_spin_lock_nested(&stopper2->lock, SINGLE_DEPTH_NESTING);\n\n\tif (!stopper1->enabled || !stopper2->enabled) {\n\t\terr = -ENOENT;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Ensure that if we race with __stop_cpus() the stoppers won't get\n\t * queued up in reverse order leading to system deadlock.\n\t *\n\t * We can't miss stop_cpus_in_progress if queue_stop_cpus_work() has\n\t * queued a work on cpu1 but not on cpu2, we hold both locks.\n\t *\n\t * It can be falsely true but it is safe to spin until it is cleared,\n\t * queue_stop_cpus_work() does everything under preempt_disable().\n\t */\n\tif (unlikely(stop_cpus_in_progress)) {\n\t\terr = -EDEADLK;\n\t\tgoto unlock;\n\t}\n\n\terr = 0;\n\t__cpu_stop_queue_work(stopper1, work1, &wakeq);\n\t__cpu_stop_queue_work(stopper2, work2, &wakeq);\n\nunlock:\n\traw_spin_unlock(&stopper2->lock);\n\traw_spin_unlock_irq(&stopper1->lock);\n\n\tif (unlikely(err == -EDEADLK)) {\n\t\tpreempt_enable();\n\n\t\twhile (stop_cpus_in_progress)\n\t\t\tcpu_relax();\n\n\t\tgoto retry;\n\t}\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);",
            "static bool stop_cpus_in_progress;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\nstatic bool stop_cpus_in_progress;\n\nstatic int cpu_stop_queue_two_works(int cpu1, struct cpu_stop_work *work1,\n\t\t\t\t    int cpu2, struct cpu_stop_work *work2)\n{\n\tstruct cpu_stopper *stopper1 = per_cpu_ptr(&cpu_stopper, cpu1);\n\tstruct cpu_stopper *stopper2 = per_cpu_ptr(&cpu_stopper, cpu2);\n\tDEFINE_WAKE_Q(wakeq);\n\tint err;\n\nretry:\n\t/*\n\t * The waking up of stopper threads has to happen in the same\n\t * scheduling context as the queueing.  Otherwise, there is a\n\t * possibility of one of the above stoppers being woken up by another\n\t * CPU, and preempting us. This will cause us to not wake up the other\n\t * stopper forever.\n\t */\n\tpreempt_disable();\n\traw_spin_lock_irq(&stopper1->lock);\n\traw_spin_lock_nested(&stopper2->lock, SINGLE_DEPTH_NESTING);\n\n\tif (!stopper1->enabled || !stopper2->enabled) {\n\t\terr = -ENOENT;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Ensure that if we race with __stop_cpus() the stoppers won't get\n\t * queued up in reverse order leading to system deadlock.\n\t *\n\t * We can't miss stop_cpus_in_progress if queue_stop_cpus_work() has\n\t * queued a work on cpu1 but not on cpu2, we hold both locks.\n\t *\n\t * It can be falsely true but it is safe to spin until it is cleared,\n\t * queue_stop_cpus_work() does everything under preempt_disable().\n\t */\n\tif (unlikely(stop_cpus_in_progress)) {\n\t\terr = -EDEADLK;\n\t\tgoto unlock;\n\t}\n\n\terr = 0;\n\t__cpu_stop_queue_work(stopper1, work1, &wakeq);\n\t__cpu_stop_queue_work(stopper2, work2, &wakeq);\n\nunlock:\n\traw_spin_unlock(&stopper2->lock);\n\traw_spin_unlock_irq(&stopper1->lock);\n\n\tif (unlikely(err == -EDEADLK)) {\n\t\tpreempt_enable();\n\n\t\twhile (stop_cpus_in_progress)\n\t\t\tcpu_relax();\n\n\t\tgoto retry;\n\t}\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "cpu1",
            "cpu2"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_reader",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "974-1018",
          "snippet": "static int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kzalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct swsusp_header *swsusp_header;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct swsusp_header *swsusp_header;\n\nstatic int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kzalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_state",
          "args": [
            "&msdata",
            "MULTI_STOP_PREPARE"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "set_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "181-188",
          "snippet": "static void set_state(struct multi_stop_data *msdata,\n\t\t      enum multi_stop_state newstate)\n{\n\t/* Reset ack counter. */\n\tatomic_set(&msdata->thread_ack, msdata->num_threads);\n\tsmp_wmb();\n\tWRITE_ONCE(msdata->state, newstate);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void set_state(struct multi_stop_data *msdata,\n\t\t      enum multi_stop_state newstate)\n{\n\t/* Reset ack counter. */\n\tatomic_set(&msdata->thread_ack, msdata->num_threads);\n\tsmp_wmb();\n\tWRITE_ONCE(msdata->state, newstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_stop_init_done",
          "args": [
            "&done",
            "2"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_init_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "70-75",
          "snippet": "static void cpu_stop_init_done(struct cpu_stop_done *done, unsigned int nr_todo)\n{\n\tmemset(done, 0, sizeof(*done));\n\tatomic_set(&done->nr_todo, nr_todo);\n\tinit_completion(&done->completion);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void cpu_stop_init_done(struct cpu_stop_done *done, unsigned int nr_todo)\n{\n\tmemset(done, 0, sizeof(*done));\n\tatomic_set(&done->nr_todo, nr_todo);\n\tinit_completion(&done->completion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu1"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nint stop_two_cpus(unsigned int cpu1, unsigned int cpu2, cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\tstruct cpu_stop_work work1, work2;\n\tstruct multi_stop_data msdata;\n\n\tmsdata = (struct multi_stop_data){\n\t\t.fn = fn,\n\t\t.data = arg,\n\t\t.num_threads = 2,\n\t\t.active_cpus = cpumask_of(cpu1),\n\t};\n\n\twork1 = work2 = (struct cpu_stop_work){\n\t\t.fn = multi_cpu_stop,\n\t\t.arg = &msdata,\n\t\t.done = &done,\n\t\t.caller = _RET_IP_,\n\t};\n\n\tcpu_stop_init_done(&done, 2);\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\n\tif (cpu1 > cpu2)\n\t\tswap(cpu1, cpu2);\n\tif (cpu_stop_queue_two_works(cpu1, &work1, cpu2, &work2))\n\t\treturn -ENOENT;\n\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}"
  },
  {
    "function_name": "cpu_stop_queue_two_works",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "261-322",
    "snippet": "static int cpu_stop_queue_two_works(int cpu1, struct cpu_stop_work *work1,\n\t\t\t\t    int cpu2, struct cpu_stop_work *work2)\n{\n\tstruct cpu_stopper *stopper1 = per_cpu_ptr(&cpu_stopper, cpu1);\n\tstruct cpu_stopper *stopper2 = per_cpu_ptr(&cpu_stopper, cpu2);\n\tDEFINE_WAKE_Q(wakeq);\n\tint err;\n\nretry:\n\t/*\n\t * The waking up of stopper threads has to happen in the same\n\t * scheduling context as the queueing.  Otherwise, there is a\n\t * possibility of one of the above stoppers being woken up by another\n\t * CPU, and preempting us. This will cause us to not wake up the other\n\t * stopper forever.\n\t */\n\tpreempt_disable();\n\traw_spin_lock_irq(&stopper1->lock);\n\traw_spin_lock_nested(&stopper2->lock, SINGLE_DEPTH_NESTING);\n\n\tif (!stopper1->enabled || !stopper2->enabled) {\n\t\terr = -ENOENT;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Ensure that if we race with __stop_cpus() the stoppers won't get\n\t * queued up in reverse order leading to system deadlock.\n\t *\n\t * We can't miss stop_cpus_in_progress if queue_stop_cpus_work() has\n\t * queued a work on cpu1 but not on cpu2, we hold both locks.\n\t *\n\t * It can be falsely true but it is safe to spin until it is cleared,\n\t * queue_stop_cpus_work() does everything under preempt_disable().\n\t */\n\tif (unlikely(stop_cpus_in_progress)) {\n\t\terr = -EDEADLK;\n\t\tgoto unlock;\n\t}\n\n\terr = 0;\n\t__cpu_stop_queue_work(stopper1, work1, &wakeq);\n\t__cpu_stop_queue_work(stopper2, work2, &wakeq);\n\nunlock:\n\traw_spin_unlock(&stopper2->lock);\n\traw_spin_unlock_irq(&stopper1->lock);\n\n\tif (unlikely(err == -EDEADLK)) {\n\t\tpreempt_enable();\n\n\t\twhile (stop_cpus_in_progress)\n\t\t\tcpu_relax();\n\n\t\tgoto retry;\n\t}\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);",
      "static bool stop_cpus_in_progress;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_q",
          "args": [
            "&wakeq"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_q",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "948-967",
          "snippet": "void wake_up_q(struct wake_q_head *head)\n{\n\tstruct wake_q_node *node = head->first;\n\n\twhile (node != WAKE_Q_TAIL) {\n\t\tstruct task_struct *task;\n\n\t\ttask = container_of(node, struct task_struct, wake_q);\n\t\t/* Task can safely be re-inserted now: */\n\t\tnode = node->next;\n\t\ttask->wake_q.next = NULL;\n\n\t\t/*\n\t\t * wake_up_process() executes a full barrier, which pairs with\n\t\t * the queueing in wake_q_add() so as not to miss wakeups.\n\t\t */\n\t\twake_up_process(task);\n\t\tput_task_struct(task);\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid wake_up_q(struct wake_q_head *head)\n{\n\tstruct wake_q_node *node = head->first;\n\n\twhile (node != WAKE_Q_TAIL) {\n\t\tstruct task_struct *task;\n\n\t\ttask = container_of(node, struct task_struct, wake_q);\n\t\t/* Task can safely be re-inserted now: */\n\t\tnode = node->next;\n\t\ttask->wake_q.next = NULL;\n\n\t\t/*\n\t\t * wake_up_process() executes a full barrier, which pairs with\n\t\t * the queueing in wake_q_add() so as not to miss wakeups.\n\t\t */\n\t\twake_up_process(task);\n\t\tput_task_struct(task);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err == -EDEADLK"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&stopper1->lock"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&stopper2->lock"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpu_stop_queue_work",
          "args": [
            "stopper2",
            "work2",
            "&wakeq"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "__cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "84-90",
          "snippet": "static void __cpu_stop_queue_work(struct cpu_stopper *stopper,\n\t\t\t\t\tstruct cpu_stop_work *work,\n\t\t\t\t\tstruct wake_q_head *wakeq)\n{\n\tlist_add_tail(&work->list, &stopper->works);\n\twake_q_add(wakeq, stopper->thread);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic void __cpu_stop_queue_work(struct cpu_stopper *stopper,\n\t\t\t\t\tstruct cpu_stop_work *work,\n\t\t\t\t\tstruct wake_q_head *wakeq)\n{\n\tlist_add_tail(&work->list, &stopper->works);\n\twake_q_add(wakeq, stopper->thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "stop_cpus_in_progress"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_nested",
          "args": [
            "&stopper2->lock",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "375-380",
          "snippet": "void __lockfunc _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)\n{\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)\n{\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&stopper1->lock"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_WAKE_Q",
          "args": [
            "wakeq"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpu_stopper",
            "cpu2"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpu_stopper",
            "cpu1"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\nstatic bool stop_cpus_in_progress;\n\nstatic int cpu_stop_queue_two_works(int cpu1, struct cpu_stop_work *work1,\n\t\t\t\t    int cpu2, struct cpu_stop_work *work2)\n{\n\tstruct cpu_stopper *stopper1 = per_cpu_ptr(&cpu_stopper, cpu1);\n\tstruct cpu_stopper *stopper2 = per_cpu_ptr(&cpu_stopper, cpu2);\n\tDEFINE_WAKE_Q(wakeq);\n\tint err;\n\nretry:\n\t/*\n\t * The waking up of stopper threads has to happen in the same\n\t * scheduling context as the queueing.  Otherwise, there is a\n\t * possibility of one of the above stoppers being woken up by another\n\t * CPU, and preempting us. This will cause us to not wake up the other\n\t * stopper forever.\n\t */\n\tpreempt_disable();\n\traw_spin_lock_irq(&stopper1->lock);\n\traw_spin_lock_nested(&stopper2->lock, SINGLE_DEPTH_NESTING);\n\n\tif (!stopper1->enabled || !stopper2->enabled) {\n\t\terr = -ENOENT;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Ensure that if we race with __stop_cpus() the stoppers won't get\n\t * queued up in reverse order leading to system deadlock.\n\t *\n\t * We can't miss stop_cpus_in_progress if queue_stop_cpus_work() has\n\t * queued a work on cpu1 but not on cpu2, we hold both locks.\n\t *\n\t * It can be falsely true but it is safe to spin until it is cleared,\n\t * queue_stop_cpus_work() does everything under preempt_disable().\n\t */\n\tif (unlikely(stop_cpus_in_progress)) {\n\t\terr = -EDEADLK;\n\t\tgoto unlock;\n\t}\n\n\terr = 0;\n\t__cpu_stop_queue_work(stopper1, work1, &wakeq);\n\t__cpu_stop_queue_work(stopper2, work2, &wakeq);\n\nunlock:\n\traw_spin_unlock(&stopper2->lock);\n\traw_spin_unlock_irq(&stopper1->lock);\n\n\tif (unlikely(err == -EDEADLK)) {\n\t\tpreempt_enable();\n\n\t\twhile (stop_cpus_in_progress)\n\t\t\tcpu_relax();\n\n\t\tgoto retry;\n\t}\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn err;\n}"
  },
  {
    "function_name": "multi_cpu_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "203-259",
    "snippet": "static int multi_cpu_stop(void *data)\n{\n\tstruct multi_stop_data *msdata = data;\n\tenum multi_stop_state newstate, curstate = MULTI_STOP_NONE;\n\tint cpu = smp_processor_id(), err = 0;\n\tconst struct cpumask *cpumask;\n\tunsigned long flags;\n\tbool is_active;\n\n\t/*\n\t * When called from stop_machine_from_inactive_cpu(), irq might\n\t * already be disabled.  Save the state and restore it on exit.\n\t */\n\tlocal_save_flags(flags);\n\n\tif (!msdata->active_cpus) {\n\t\tcpumask = cpu_online_mask;\n\t\tis_active = cpu == cpumask_first(cpumask);\n\t} else {\n\t\tcpumask = msdata->active_cpus;\n\t\tis_active = cpumask_test_cpu(cpu, cpumask);\n\t}\n\n\t/* Simple state machine */\n\tdo {\n\t\t/* Chill out and ensure we re-read multi_stop_state. */\n\t\tstop_machine_yield(cpumask);\n\t\tnewstate = READ_ONCE(msdata->state);\n\t\tif (newstate != curstate) {\n\t\t\tcurstate = newstate;\n\t\t\tswitch (curstate) {\n\t\t\tcase MULTI_STOP_DISABLE_IRQ:\n\t\t\t\tlocal_irq_disable();\n\t\t\t\thard_irq_disable();\n\t\t\t\tbreak;\n\t\t\tcase MULTI_STOP_RUN:\n\t\t\t\tif (is_active)\n\t\t\t\t\terr = msdata->fn(msdata->data);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tack_state(msdata);\n\t\t} else if (curstate > MULTI_STOP_PREPARE) {\n\t\t\t/*\n\t\t\t * At this stage all other CPUs we depend on must spin\n\t\t\t * in the same loop. Any reason for hard-lockup should\n\t\t\t * be detected and reported on their side.\n\t\t\t */\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t\trcu_momentary_dyntick_idle();\n\t} while (curstate != MULTI_STOP_EXIT);\n\n\tlocal_irq_restore(flags);\n\treturn err;\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_momentary_dyntick_idle",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_momentary_dyntick_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "402-411",
          "snippet": "notrace void rcu_momentary_dyntick_idle(void)\n{\n\tint seq;\n\n\traw_cpu_write(rcu_data.rcu_need_heavy_qs, false);\n\tseq = rcu_dynticks_inc(2);\n\t/* It is illegal to call this from idle state. */\n\tWARN_ON_ONCE(!(seq & 0x1));\n\trcu_preempt_deferred_qs(current);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nnotrace void rcu_momentary_dyntick_idle(void)\n{\n\tint seq;\n\n\traw_cpu_write(rcu_data.rcu_need_heavy_qs, false);\n\tseq = rcu_dynticks_inc(2);\n\t/* It is illegal to call this from idle state. */\n\tWARN_ON_ONCE(!(seq & 0x1));\n\trcu_preempt_deferred_qs(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ack_state",
          "args": [
            "msdata"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "ack_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "191-195",
          "snippet": "static void ack_state(struct multi_stop_data *msdata)\n{\n\tif (atomic_dec_and_test(&msdata->thread_ack))\n\t\tset_state(msdata, msdata->state + 1);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void ack_state(struct multi_stop_data *msdata)\n{\n\tif (atomic_dec_and_test(&msdata->thread_ack))\n\t\tset_state(msdata, msdata->state + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msdata->fn",
          "args": [
            "msdata->data"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "msdata->state"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop_machine_yield",
          "args": [
            "cpumask"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "stop_machine_yield",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "197-200",
          "snippet": "__weak stop_machine_yield(const struct cpumask *cpumask)\n{\n\tcpu_relax();\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\n__weak stop_machine_yield(const struct cpumask *cpumask)\n{\n\tcpu_relax();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "cpumask"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpumask"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "flags"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic int multi_cpu_stop(void *data)\n{\n\tstruct multi_stop_data *msdata = data;\n\tenum multi_stop_state newstate, curstate = MULTI_STOP_NONE;\n\tint cpu = smp_processor_id(), err = 0;\n\tconst struct cpumask *cpumask;\n\tunsigned long flags;\n\tbool is_active;\n\n\t/*\n\t * When called from stop_machine_from_inactive_cpu(), irq might\n\t * already be disabled.  Save the state and restore it on exit.\n\t */\n\tlocal_save_flags(flags);\n\n\tif (!msdata->active_cpus) {\n\t\tcpumask = cpu_online_mask;\n\t\tis_active = cpu == cpumask_first(cpumask);\n\t} else {\n\t\tcpumask = msdata->active_cpus;\n\t\tis_active = cpumask_test_cpu(cpu, cpumask);\n\t}\n\n\t/* Simple state machine */\n\tdo {\n\t\t/* Chill out and ensure we re-read multi_stop_state. */\n\t\tstop_machine_yield(cpumask);\n\t\tnewstate = READ_ONCE(msdata->state);\n\t\tif (newstate != curstate) {\n\t\t\tcurstate = newstate;\n\t\t\tswitch (curstate) {\n\t\t\tcase MULTI_STOP_DISABLE_IRQ:\n\t\t\t\tlocal_irq_disable();\n\t\t\t\thard_irq_disable();\n\t\t\t\tbreak;\n\t\t\tcase MULTI_STOP_RUN:\n\t\t\t\tif (is_active)\n\t\t\t\t\terr = msdata->fn(msdata->data);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tack_state(msdata);\n\t\t} else if (curstate > MULTI_STOP_PREPARE) {\n\t\t\t/*\n\t\t\t * At this stage all other CPUs we depend on must spin\n\t\t\t * in the same loop. Any reason for hard-lockup should\n\t\t\t * be detected and reported on their side.\n\t\t\t */\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t\trcu_momentary_dyntick_idle();\n\t} while (curstate != MULTI_STOP_EXIT);\n\n\tlocal_irq_restore(flags);\n\treturn err;\n}"
  },
  {
    "function_name": "stop_machine_yield",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "197-200",
    "snippet": "__weak stop_machine_yield(const struct cpumask *cpumask)\n{\n\tcpu_relax();\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\n__weak stop_machine_yield(const struct cpumask *cpumask)\n{\n\tcpu_relax();\n}"
  },
  {
    "function_name": "ack_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "191-195",
    "snippet": "static void ack_state(struct multi_stop_data *msdata)\n{\n\tif (atomic_dec_and_test(&msdata->thread_ack))\n\t\tset_state(msdata, msdata->state + 1);\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_state",
          "args": [
            "msdata",
            "msdata->state + 1"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "set_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "181-188",
          "snippet": "static void set_state(struct multi_stop_data *msdata,\n\t\t      enum multi_stop_state newstate)\n{\n\t/* Reset ack counter. */\n\tatomic_set(&msdata->thread_ack, msdata->num_threads);\n\tsmp_wmb();\n\tWRITE_ONCE(msdata->state, newstate);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void set_state(struct multi_stop_data *msdata,\n\t\t      enum multi_stop_state newstate)\n{\n\t/* Reset ack counter. */\n\tatomic_set(&msdata->thread_ack, msdata->num_threads);\n\tsmp_wmb();\n\tWRITE_ONCE(msdata->state, newstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&msdata->thread_ack"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void ack_state(struct multi_stop_data *msdata)\n{\n\tif (atomic_dec_and_test(&msdata->thread_ack))\n\t\tset_state(msdata, msdata->state + 1);\n}"
  },
  {
    "function_name": "set_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "181-188",
    "snippet": "static void set_state(struct multi_stop_data *msdata,\n\t\t      enum multi_stop_state newstate)\n{\n\t/* Reset ack counter. */\n\tatomic_set(&msdata->thread_ack, msdata->num_threads);\n\tsmp_wmb();\n\tWRITE_ONCE(msdata->state, newstate);\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "msdata->state",
            "newstate"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&msdata->thread_ack",
            "msdata->num_threads"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void set_state(struct multi_stop_data *msdata,\n\t\t      enum multi_stop_state newstate)\n{\n\t/* Reset ack counter. */\n\tatomic_set(&msdata->thread_ack, msdata->num_threads);\n\tsmp_wmb();\n\tWRITE_ONCE(msdata->state, newstate);\n}"
  },
  {
    "function_name": "stop_one_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "139-154",
    "snippet": "int stop_one_cpu(unsigned int cpu, cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\tstruct cpu_stop_work work = { .fn = fn, .arg = arg, .done = &done, .caller = _RET_IP_ };\n\n\tcpu_stop_init_done(&done, 1);\n\tif (!cpu_stop_queue_work(cpu, &work))\n\t\treturn -ENOENT;\n\t/*\n\t * In case @cpu == smp_proccessor_id() we can avoid a sleep+wakeup\n\t * cycle by doing a preemption:\n\t */\n\tcond_resched();\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&done.completion"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_stop_queue_work",
          "args": [
            "cpu",
            "&work"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_stop_init_done",
          "args": [
            "&done",
            "1"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_init_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "70-75",
          "snippet": "static void cpu_stop_init_done(struct cpu_stop_done *done, unsigned int nr_todo)\n{\n\tmemset(done, 0, sizeof(*done));\n\tatomic_set(&done->nr_todo, nr_todo);\n\tinit_completion(&done->completion);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void cpu_stop_init_done(struct cpu_stop_done *done, unsigned int nr_todo)\n{\n\tmemset(done, 0, sizeof(*done));\n\tatomic_set(&done->nr_todo, nr_todo);\n\tinit_completion(&done->completion);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nint stop_one_cpu(unsigned int cpu, cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\tstruct cpu_stop_work work = { .fn = fn, .arg = arg, .done = &done, .caller = _RET_IP_ };\n\n\tcpu_stop_init_done(&done, 1);\n\tif (!cpu_stop_queue_work(cpu, &work))\n\t\treturn -ENOENT;\n\t/*\n\t * In case @cpu == smp_proccessor_id() we can avoid a sleep+wakeup\n\t * cycle by doing a preemption:\n\t */\n\tcond_resched();\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}"
  },
  {
    "function_name": "cpu_stop_queue_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "93-113",
    "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_q",
          "args": [
            "&wakeq"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_q",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "948-967",
          "snippet": "void wake_up_q(struct wake_q_head *head)\n{\n\tstruct wake_q_node *node = head->first;\n\n\twhile (node != WAKE_Q_TAIL) {\n\t\tstruct task_struct *task;\n\n\t\ttask = container_of(node, struct task_struct, wake_q);\n\t\t/* Task can safely be re-inserted now: */\n\t\tnode = node->next;\n\t\ttask->wake_q.next = NULL;\n\n\t\t/*\n\t\t * wake_up_process() executes a full barrier, which pairs with\n\t\t * the queueing in wake_q_add() so as not to miss wakeups.\n\t\t */\n\t\twake_up_process(task);\n\t\tput_task_struct(task);\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid wake_up_q(struct wake_q_head *head)\n{\n\tstruct wake_q_node *node = head->first;\n\n\twhile (node != WAKE_Q_TAIL) {\n\t\tstruct task_struct *task;\n\n\t\ttask = container_of(node, struct task_struct, wake_q);\n\t\t/* Task can safely be re-inserted now: */\n\t\tnode = node->next;\n\t\ttask->wake_q.next = NULL;\n\n\t\t/*\n\t\t * wake_up_process() executes a full barrier, which pairs with\n\t\t * the queueing in wake_q_add() so as not to miss wakeups.\n\t\t */\n\t\twake_up_process(task);\n\t\tput_task_struct(task);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&stopper->lock",
            "flags"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_stop_signal_done",
          "args": [
            "work->done"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_signal_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "78-82",
          "snippet": "static void cpu_stop_signal_done(struct cpu_stop_done *done)\n{\n\tif (atomic_dec_and_test(&done->nr_todo))\n\t\tcomplete(&done->completion);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void cpu_stop_signal_done(struct cpu_stop_done *done)\n{\n\tif (atomic_dec_and_test(&done->nr_todo))\n\t\tcomplete(&done->completion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpu_stop_queue_work",
          "args": [
            "stopper",
            "work",
            "&wakeq"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "__cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "84-90",
          "snippet": "static void __cpu_stop_queue_work(struct cpu_stopper *stopper,\n\t\t\t\t\tstruct cpu_stop_work *work,\n\t\t\t\t\tstruct wake_q_head *wakeq)\n{\n\tlist_add_tail(&work->list, &stopper->works);\n\twake_q_add(wakeq, stopper->thread);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic void __cpu_stop_queue_work(struct cpu_stopper *stopper,\n\t\t\t\t\tstruct cpu_stop_work *work,\n\t\t\t\t\tstruct wake_q_head *wakeq)\n{\n\tlist_add_tail(&work->list, &stopper->works);\n\twake_q_add(wakeq, stopper->thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&stopper->lock",
            "flags"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_WAKE_Q",
          "args": [
            "wakeq"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_stopper",
            "cpu"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
  },
  {
    "function_name": "__cpu_stop_queue_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "84-90",
    "snippet": "static void __cpu_stop_queue_work(struct cpu_stopper *stopper,\n\t\t\t\t\tstruct cpu_stop_work *work,\n\t\t\t\t\tstruct wake_q_head *wakeq)\n{\n\tlist_add_tail(&work->list, &stopper->works);\n\twake_q_add(wakeq, stopper->thread);\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_q_add",
          "args": [
            "wakeq",
            "stopper->thread"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "wake_q_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "942-946",
          "snippet": "void wake_q_add_safe(struct wake_q_head *head, struct task_struct *task)\n{\n\tif (!__wake_q_add(head, task))\n\t\tput_task_struct(task);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid wake_q_add_safe(struct wake_q_head *head, struct task_struct *task)\n{\n\tif (!__wake_q_add(head, task))\n\t\tput_task_struct(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&work->list",
            "&stopper->works"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic void __cpu_stop_queue_work(struct cpu_stopper *stopper,\n\t\t\t\t\tstruct cpu_stop_work *work,\n\t\t\t\t\tstruct wake_q_head *wakeq)\n{\n\tlist_add_tail(&work->list, &stopper->works);\n\twake_q_add(wakeq, stopper->thread);\n}"
  },
  {
    "function_name": "cpu_stop_signal_done",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "78-82",
    "snippet": "static void cpu_stop_signal_done(struct cpu_stop_done *done)\n{\n\tif (atomic_dec_and_test(&done->nr_todo))\n\t\tcomplete(&done->completion);\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&done->completion"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&done->nr_todo"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void cpu_stop_signal_done(struct cpu_stop_done *done)\n{\n\tif (atomic_dec_and_test(&done->nr_todo))\n\t\tcomplete(&done->completion);\n}"
  },
  {
    "function_name": "cpu_stop_init_done",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "70-75",
    "snippet": "static void cpu_stop_init_done(struct cpu_stop_done *done, unsigned int nr_todo)\n{\n\tmemset(done, 0, sizeof(*done));\n\tatomic_set(&done->nr_todo, nr_todo);\n\tinit_completion(&done->completion);\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&done->completion"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&done->nr_todo",
            "nr_todo"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "done",
            "0",
            "sizeof(*done)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic void cpu_stop_init_done(struct cpu_stop_done *done, unsigned int nr_todo)\n{\n\tmemset(done, 0, sizeof(*done));\n\tatomic_set(&done->nr_todo, nr_todo);\n\tinit_completion(&done->completion);\n}"
  },
  {
    "function_name": "print_stop_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
    "lines": "52-64",
    "snippet": "void print_stop_info(const char *log_lvl, struct task_struct *task)\n{\n\t/*\n\t * If @task is a stopper task, it cannot migrate and task_cpu() is\n\t * stable.\n\t */\n\tstruct cpu_stopper *stopper = per_cpu_ptr(&cpu_stopper, task_cpu(task));\n\n\tif (task != stopper->thread)\n\t\treturn;\n\n\tprintk(\"%sStopper: %pS <- %pS\\n\", log_lvl, stopper->fn, (void *)stopper->caller);\n}",
    "includes": [
      "#include <linux/sched/wake_q.h>",
      "#include <linux/nmi.h>",
      "#include <linux/atomic.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kthread.h>",
      "#include <linux/init.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%sStopper: %pS <- %pS\\n\"",
            "log_lvl",
            "stopper->fn",
            "(void *)stopper->caller"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cpu_stopper",
            "task_cpu(task)"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "task"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nvoid print_stop_info(const char *log_lvl, struct task_struct *task)\n{\n\t/*\n\t * If @task is a stopper task, it cannot migrate and task_cpu() is\n\t * stable.\n\t */\n\tstruct cpu_stopper *stopper = per_cpu_ptr(&cpu_stopper, task_cpu(task));\n\n\tif (task != stopper->thread)\n\t\treturn;\n\n\tprintk(\"%sStopper: %pS <- %pS\\n\", log_lvl, stopper->fn, (void *)stopper->caller);\n}"
  }
]