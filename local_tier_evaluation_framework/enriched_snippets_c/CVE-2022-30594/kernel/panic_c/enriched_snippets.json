[
  {
    "function_name": "panic_on_taint_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "694-718",
    "snippet": "static int __init panic_on_taint_setup(char *s)\n{\n\tchar *taint_str;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\ttaint_str = strsep(&s, \",\");\n\tif (kstrtoul(taint_str, 16, &panic_on_taint))\n\t\treturn -EINVAL;\n\n\t/* make sure panic_on_taint doesn't hold out-of-range TAINT flags */\n\tpanic_on_taint &= TAINT_FLAGS_MAX;\n\n\tif (!panic_on_taint)\n\t\treturn -EINVAL;\n\n\tif (s && !strcmp(s, \"nousertaint\"))\n\t\tpanic_on_taint_nousertaint = true;\n\n\tpr_info(\"panic_on_taint: bitmask=0x%lx nousertaint_mode=%sabled\\n\",\n\t\tpanic_on_taint, panic_on_taint_nousertaint ? \"en\" : \"dis\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long panic_on_taint;",
      "bool panic_on_taint_nousertaint = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"panic_on_taint: bitmask=0x%lx nousertaint_mode=%sabled\\n\"",
            "panic_on_taint",
            "panic_on_taint_nousertaint ? \"en\" : \"dis\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"nousertaint\""
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "taint_str",
            "16",
            "&panic_on_taint"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&s",
            "\",\""
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nunsigned long panic_on_taint;\nbool panic_on_taint_nousertaint = false;\n\nstatic int __init panic_on_taint_setup(char *s)\n{\n\tchar *taint_str;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\ttaint_str = strsep(&s, \",\");\n\tif (kstrtoul(taint_str, 16, &panic_on_taint))\n\t\treturn -EINVAL;\n\n\t/* make sure panic_on_taint doesn't hold out-of-range TAINT flags */\n\tpanic_on_taint &= TAINT_FLAGS_MAX;\n\n\tif (!panic_on_taint)\n\t\treturn -EINVAL;\n\n\tif (s && !strcmp(s, \"nousertaint\"))\n\t\tpanic_on_taint_nousertaint = true;\n\n\tpr_info(\"panic_on_taint: bitmask=0x%lx nousertaint_mode=%sabled\\n\",\n\t\tpanic_on_taint, panic_on_taint_nousertaint ? \"en\" : \"dis\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "oops_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "684-691",
    "snippet": "static int __init oops_setup(char *s)\n{\n\tif (!s)\n\t\treturn -EINVAL;\n\tif (!strcmp(s, \"panic\"))\n\t\tpanic_on_oops = 1;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int panic_on_oops = CONFIG_PANIC_ON_OOPS_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"panic\""
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nint panic_on_oops = CONFIG_PANIC_ON_OOPS_VALUE;\n\nstatic int __init oops_setup(char *s)\n{\n\tif (!s)\n\t\treturn -EINVAL;\n\tif (!strcmp(s, \"panic\"))\n\t\tpanic_on_oops = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "__stack_chk_fail",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "667-673",
    "snippet": "void __stack_chk_fail(void)\n{\n\tinstrumentation_begin();\n\tpanic(\"stack-protector: Kernel stack is corrupted in: %pB\",\n\t\t__builtin_return_address(0));\n\tinstrumentation_end();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"stack-protector: Kernel stack is corrupted in: %pB\"",
            "__builtin_return_address(0)"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "179-361",
          "snippet": "void panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define PANIC_BLINK_SPD 18",
            "#define PANIC_TIMER_STEP 100"
          ],
          "globals_used": [
            "bool crash_kexec_post_notifiers;",
            "int panic_timeout = CONFIG_PANIC_TIMEOUT;",
            "long (*panic_blink)(int state);",
            "atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_BLINK_SPD 18\n#define PANIC_TIMER_STEP 100\n\nbool crash_kexec_post_notifiers;\nint panic_timeout = CONFIG_PANIC_TIMEOUT;\nlong (*panic_blink)(int state);\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\nvoid panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __stack_chk_fail(void)\n{\n\tinstrumentation_begin();\n\tpanic(\"stack-protector: Kernel stack is corrupted in: %pB\",\n\t\t__builtin_return_address(0));\n\tinstrumentation_end();\n}"
  },
  {
    "function_name": "register_warn_debugfs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "650-656",
    "snippet": "static __init int register_warn_debugfs(void)\n{\n\t/* Don't care about failure */\n\tdebugfs_create_file_unsafe(\"clear_warn_once\", 0200, NULL, NULL,\n\t\t\t\t   &clear_warn_once_fops);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file_unsafe",
          "args": [
            "\"clear_warn_once\"",
            "0200",
            "NULL",
            "NULL",
            "&clear_warn_once_fops"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic __init int register_warn_debugfs(void)\n{\n\t/* Don't care about failure */\n\tdebugfs_create_file_unsafe(\"clear_warn_once\", 0200, NULL, NULL,\n\t\t\t\t   &clear_warn_once_fops);\n\treturn 0;\n}"
  },
  {
    "function_name": "clear_warn_once_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "640-645",
    "snippet": "static int clear_warn_once_set(void *data, u64 val)\n{\n\tgeneric_bug_clear_once();\n\tmemset(__start_once, 0, __end_once - __start_once);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "__start_once",
            "0",
            "__end_once - __start_once"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_bug_clear_once",
          "args": [],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic int clear_warn_once_set(void *data, u64 val)\n{\n\tgeneric_bug_clear_once();\n\tmemset(__start_once, 0, __end_once - __start_once);\n\treturn 0;\n}"
  },
  {
    "function_name": "__warn_printk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "623-632",
    "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vprintk",
          "args": [
            "fmt",
            "args"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_deferred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3275-3283",
          "snippet": "int vprintk_deferred(const char *fmt, va_list args)\n{\n\tint r;\n\n\tr = vprintk_emit(0, LOGLEVEL_SCHED, NULL, fmt, args);\n\tdefer_console_output();\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint vprintk_deferred(const char *fmt, va_list args)\n{\n\tint r;\n\n\tr = vprintk_emit(0, LOGLEVEL_SCHED, NULL, fmt, args);\n\tdefer_console_output();\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "CUT_HERE"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
  },
  {
    "function_name": "warn_slowpath_fmt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "603-620",
    "snippet": "void warn_slowpath_fmt(const char *file, int line, unsigned taint,\n\t\t       const char *fmt, ...)\n{\n\tstruct warn_args args;\n\n\tpr_warn(CUT_HERE);\n\n\tif (!fmt) {\n\t\t__warn(file, line, __builtin_return_address(0), taint,\n\t\t       NULL, NULL);\n\t\treturn;\n\t}\n\n\targs.fmt = fmt;\n\tva_start(args.args, fmt);\n\t__warn(file, line, __builtin_return_address(0), taint, NULL, &args);\n\tva_end(args.args);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args.args"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__warn",
          "args": [
            "file",
            "line",
            "__builtin_return_address(0)",
            "taint",
            "NULL",
            "&args"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args.args",
            "fmt"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "CUT_HERE"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid warn_slowpath_fmt(const char *file, int line, unsigned taint,\n\t\t       const char *fmt, ...)\n{\n\tstruct warn_args args;\n\n\tpr_warn(CUT_HERE);\n\n\tif (!fmt) {\n\t\t__warn(file, line, __builtin_return_address(0), taint,\n\t\t       NULL, NULL);\n\t\treturn;\n\t}\n\n\targs.fmt = fmt;\n\tva_start(args.args, fmt);\n\t__warn(file, line, __builtin_return_address(0), taint, NULL, &args);\n\tva_end(args.args);\n}"
  },
  {
    "function_name": "__warn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "558-600",
    "snippet": "void __warn(const char *file, int line, void *caller, unsigned taint,\n\t    struct pt_regs *regs, struct warn_args *args)\n{\n\tdisable_trace_on_warning();\n\n\tif (file)\n\t\tpr_warn(\"WARNING: CPU: %d PID: %d at %s:%d %pS\\n\",\n\t\t\traw_smp_processor_id(), current->pid, file, line,\n\t\t\tcaller);\n\telse\n\t\tpr_warn(\"WARNING: CPU: %d PID: %d at %pS\\n\",\n\t\t\traw_smp_processor_id(), current->pid, caller);\n\n\tif (args)\n\t\tvprintk(args->fmt, args->args);\n\n\tprint_modules();\n\n\tif (regs)\n\t\tshow_regs(regs);\n\n\tif (panic_on_warn) {\n\t\t/*\n\t\t * This thread may hit another WARN() in the panic path.\n\t\t * Resetting this prevents additional WARN() from panicking the\n\t\t * system on this thread.  Other threads are blocked by the\n\t\t * panic_mutex in panic().\n\t\t */\n\t\tpanic_on_warn = 0;\n\t\tpanic(\"panic_on_warn set ...\\n\");\n\t}\n\n\tif (!regs)\n\t\tdump_stack();\n\n\tprint_irqtrace_events(current);\n\n\tprint_oops_end_marker();\n\ttrace_error_report_end(ERROR_DETECTOR_WARN, (unsigned long)caller);\n\n\t/* Just a warning, don't kill lockdep. */\n\tadd_taint(taint, LOCKDEP_STILL_OK);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int panic_on_warn"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "taint",
            "LOCKDEP_STILL_OK"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "add_taint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "440-451",
          "snippet": "void add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n\n\tif (tainted_mask & panic_on_taint) {\n\t\tpanic_on_taint = 0;\n\t\tpanic(\"panic_on_taint set ...\");\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;",
            "unsigned long panic_on_taint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\nunsigned long panic_on_taint;\n\nvoid add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n\n\tif (tainted_mask & panic_on_taint) {\n\t\tpanic_on_taint = 0;\n\t\tpanic(\"panic_on_taint set ...\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_error_report_end",
          "args": [
            "ERROR_DETECTOR_WARN",
            "(unsigned long)caller"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_oops_end_marker",
          "args": [],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "print_oops_end_marker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "537-540",
          "snippet": "static void print_oops_end_marker(void)\n{\n\tpr_warn(\"---[ end trace %016llx ]---\\n\", 0ULL);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic void print_oops_end_marker(void)\n{\n\tpr_warn(\"---[ end trace %016llx ]---\\n\", 0ULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "current"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "print_irqtrace_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4085-4102",
          "snippet": "void print_irqtrace_events(struct task_struct *curr)\n{\n\tconst struct irqtrace_events *trace = &curr->irqtrace;\n\n\tprintk(\"irq event stamp: %u\\n\", trace->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_enable_event, (void *)trace->hardirq_enable_ip,\n\t\t(void *)trace->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_disable_event, (void *)trace->hardirq_disable_ip,\n\t\t(void *)trace->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_enable_event, (void *)trace->softirq_enable_ip,\n\t\t(void *)trace->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_disable_event, (void *)trace->softirq_disable_ip,\n\t\t(void *)trace->softirq_disable_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tconst struct irqtrace_events *trace = &curr->irqtrace;\n\n\tprintk(\"irq event stamp: %u\\n\", trace->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_enable_event, (void *)trace->hardirq_enable_ip,\n\t\t(void *)trace->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_disable_event, (void *)trace->hardirq_disable_ip,\n\t\t(void *)trace->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_enable_event, (void *)trace->softirq_enable_ip,\n\t\t(void *)trace->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_disable_event, (void *)trace->softirq_disable_ip,\n\t\t(void *)trace->softirq_disable_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"panic_on_warn set ...\\n\""
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "panic_on_taint_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "694-718",
          "snippet": "static int __init panic_on_taint_setup(char *s)\n{\n\tchar *taint_str;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\ttaint_str = strsep(&s, \",\");\n\tif (kstrtoul(taint_str, 16, &panic_on_taint))\n\t\treturn -EINVAL;\n\n\t/* make sure panic_on_taint doesn't hold out-of-range TAINT flags */\n\tpanic_on_taint &= TAINT_FLAGS_MAX;\n\n\tif (!panic_on_taint)\n\t\treturn -EINVAL;\n\n\tif (s && !strcmp(s, \"nousertaint\"))\n\t\tpanic_on_taint_nousertaint = true;\n\n\tpr_info(\"panic_on_taint: bitmask=0x%lx nousertaint_mode=%sabled\\n\",\n\t\tpanic_on_taint, panic_on_taint_nousertaint ? \"en\" : \"dis\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long panic_on_taint;",
            "bool panic_on_taint_nousertaint = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nunsigned long panic_on_taint;\nbool panic_on_taint_nousertaint = false;\n\nstatic int __init panic_on_taint_setup(char *s)\n{\n\tchar *taint_str;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\ttaint_str = strsep(&s, \",\");\n\tif (kstrtoul(taint_str, 16, &panic_on_taint))\n\t\treturn -EINVAL;\n\n\t/* make sure panic_on_taint doesn't hold out-of-range TAINT flags */\n\tpanic_on_taint &= TAINT_FLAGS_MAX;\n\n\tif (!panic_on_taint)\n\t\treturn -EINVAL;\n\n\tif (s && !strcmp(s, \"nousertaint\"))\n\t\tpanic_on_taint_nousertaint = true;\n\n\tpr_info(\"panic_on_taint: bitmask=0x%lx nousertaint_mode=%sabled\\n\",\n\t\tpanic_on_taint, panic_on_taint_nousertaint ? \"en\" : \"dis\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "regs"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_modules",
          "args": [],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "print_modules",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4793-4810",
          "snippet": "void print_modules(void)\n{\n\tstruct module *mod;\n\tchar buf[MODULE_FLAGS_BUF_SIZE];\n\n\tprintk(KERN_DEFAULT \"Modules linked in:\");\n\t/* Most callers should already have preempt disabled, but make sure */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tpr_cont(\" %s%s\", mod->name, module_flags(mod, buf));\n\t}\n\tpreempt_enable();\n\tif (last_unloaded_module[0])\n\t\tpr_cont(\" [last unloaded: %s]\", last_unloaded_module);\n\tpr_cont(\"\\n\");\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define MODULE_FLAGS_BUF_SIZE (TAINT_FLAGS_COUNT + 4)"
          ],
          "globals_used": [
            "static LIST_HEAD(modules);",
            "static char last_unloaded_module[MODULE_NAME_LEN+1];",
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\n#define MODULE_FLAGS_BUF_SIZE (TAINT_FLAGS_COUNT + 4)\n\nstatic LIST_HEAD(modules);\nstatic char last_unloaded_module[MODULE_NAME_LEN+1];\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nvoid print_modules(void)\n{\n\tstruct module *mod;\n\tchar buf[MODULE_FLAGS_BUF_SIZE];\n\n\tprintk(KERN_DEFAULT \"Modules linked in:\");\n\t/* Most callers should already have preempt disabled, but make sure */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tpr_cont(\" %s%s\", mod->name, module_flags(mod, buf));\n\t}\n\tpreempt_enable();\n\tif (last_unloaded_module[0])\n\t\tpr_cont(\" [last unloaded: %s]\", last_unloaded_module);\n\tpr_cont(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "vprintk",
          "args": [
            "args->fmt",
            "args->args"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_deferred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3275-3283",
          "snippet": "int vprintk_deferred(const char *fmt, va_list args)\n{\n\tint r;\n\n\tr = vprintk_emit(0, LOGLEVEL_SCHED, NULL, fmt, args);\n\tdefer_console_output();\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint vprintk_deferred(const char *fmt, va_list args)\n{\n\tint r;\n\n\tr = vprintk_emit(0, LOGLEVEL_SCHED, NULL, fmt, args);\n\tdefer_console_output();\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: CPU: %d PID: %d at %pS\\n\"",
            "raw_smp_processor_id()",
            "current->pid",
            "caller"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"WARNING: CPU: %d PID: %d at %s:%d %pS\\n\"",
            "raw_smp_processor_id()",
            "current->pid",
            "file",
            "line",
            "caller"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_trace_on_warning",
          "args": [],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "disable_trace_on_warning",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1435-1442",
          "snippet": "void disable_trace_on_warning(void)\n{\n\tif (__disable_trace_on_warning) {\n\t\ttrace_array_printk_buf(global_trace.array_buffer.buffer, _THIS_IP_,\n\t\t\t\"Disabling tracing due to warning\\n\");\n\t\ttracing_off();\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __disable_trace_on_warning;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nint __disable_trace_on_warning;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid disable_trace_on_warning(void)\n{\n\tif (__disable_trace_on_warning) {\n\t\ttrace_array_printk_buf(global_trace.array_buffer.buffer, _THIS_IP_,\n\t\t\t\"Disabling tracing due to warning\\n\");\n\t\ttracing_off();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nint panic_on_warn;\n\nvoid __warn(const char *file, int line, void *caller, unsigned taint,\n\t    struct pt_regs *regs, struct warn_args *args)\n{\n\tdisable_trace_on_warning();\n\n\tif (file)\n\t\tpr_warn(\"WARNING: CPU: %d PID: %d at %s:%d %pS\\n\",\n\t\t\traw_smp_processor_id(), current->pid, file, line,\n\t\t\tcaller);\n\telse\n\t\tpr_warn(\"WARNING: CPU: %d PID: %d at %pS\\n\",\n\t\t\traw_smp_processor_id(), current->pid, caller);\n\n\tif (args)\n\t\tvprintk(args->fmt, args->args);\n\n\tprint_modules();\n\n\tif (regs)\n\t\tshow_regs(regs);\n\n\tif (panic_on_warn) {\n\t\t/*\n\t\t * This thread may hit another WARN() in the panic path.\n\t\t * Resetting this prevents additional WARN() from panicking the\n\t\t * system on this thread.  Other threads are blocked by the\n\t\t * panic_mutex in panic().\n\t\t */\n\t\tpanic_on_warn = 0;\n\t\tpanic(\"panic_on_warn set ...\\n\");\n\t}\n\n\tif (!regs)\n\t\tdump_stack();\n\n\tprint_irqtrace_events(current);\n\n\tprint_oops_end_marker();\n\ttrace_error_report_end(ERROR_DETECTOR_WARN, (unsigned long)caller);\n\n\t/* Just a warning, don't kill lockdep. */\n\tadd_taint(taint, LOCKDEP_STILL_OK);\n}"
  },
  {
    "function_name": "oops_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "546-551",
    "snippet": "void oops_exit(void)\n{\n\tdo_oops_enter_exit();\n\tprint_oops_end_marker();\n\tkmsg_dump(KMSG_DUMP_OOPS);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmsg_dump",
          "args": [
            "KMSG_DUMP_OOPS"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "kmsg_dump_rewind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3593-3597",
          "snippet": "void kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_oops_end_marker",
          "args": [],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "print_oops_end_marker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "537-540",
          "snippet": "static void print_oops_end_marker(void)\n{\n\tpr_warn(\"---[ end trace %016llx ]---\\n\", 0ULL);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic void print_oops_end_marker(void)\n{\n\tpr_warn(\"---[ end trace %016llx ]---\\n\", 0ULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_oops_enter_exit",
          "args": [],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "do_oops_enter_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "468-501",
          "snippet": "static void do_oops_enter_exit(void)\n{\n\tunsigned long flags;\n\tstatic int spin_counter;\n\n\tif (!pause_on_oops)\n\t\treturn;\n\n\tspin_lock_irqsave(&pause_on_oops_lock, flags);\n\tif (pause_on_oops_flag == 0) {\n\t\t/* This CPU may now print the oops message */\n\t\tpause_on_oops_flag = 1;\n\t} else {\n\t\t/* We need to stall this CPU */\n\t\tif (!spin_counter) {\n\t\t\t/* This CPU gets to do the counting */\n\t\t\tspin_counter = pause_on_oops;\n\t\t\tdo {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(MSEC_PER_SEC);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t} while (--spin_counter);\n\t\t\tpause_on_oops_flag = 0;\n\t\t} else {\n\t\t\t/* This CPU waits for a different one */\n\t\t\twhile (spin_counter) {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(1);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pause_on_oops_lock, flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pause_on_oops;",
            "static int pause_on_oops_flag;",
            "static DEFINE_SPINLOCK(pause_on_oops_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic int pause_on_oops;\nstatic int pause_on_oops_flag;\nstatic DEFINE_SPINLOCK(pause_on_oops_lock);\n\nstatic void do_oops_enter_exit(void)\n{\n\tunsigned long flags;\n\tstatic int spin_counter;\n\n\tif (!pause_on_oops)\n\t\treturn;\n\n\tspin_lock_irqsave(&pause_on_oops_lock, flags);\n\tif (pause_on_oops_flag == 0) {\n\t\t/* This CPU may now print the oops message */\n\t\tpause_on_oops_flag = 1;\n\t} else {\n\t\t/* We need to stall this CPU */\n\t\tif (!spin_counter) {\n\t\t\t/* This CPU gets to do the counting */\n\t\t\tspin_counter = pause_on_oops;\n\t\t\tdo {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(MSEC_PER_SEC);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t} while (--spin_counter);\n\t\t\tpause_on_oops_flag = 0;\n\t\t} else {\n\t\t\t/* This CPU waits for a different one */\n\t\t\twhile (spin_counter) {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(1);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pause_on_oops_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid oops_exit(void)\n{\n\tdo_oops_enter_exit();\n\tprint_oops_end_marker();\n\tkmsg_dump(KMSG_DUMP_OOPS);\n}"
  },
  {
    "function_name": "print_oops_end_marker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "537-540",
    "snippet": "static void print_oops_end_marker(void)\n{\n\tpr_warn(\"---[ end trace %016llx ]---\\n\", 0ULL);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"---[ end trace %016llx ]---\\n\"",
            "0ULL"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic void print_oops_end_marker(void)\n{\n\tpr_warn(\"---[ end trace %016llx ]---\\n\", 0ULL);\n}"
  },
  {
    "function_name": "oops_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "526-535",
    "snippet": "void oops_enter(void)\n{\n\ttracing_off();\n\t/* can't trust the integrity of the kernel anymore: */\n\tdebug_locks_off();\n\tdo_oops_enter_exit();\n\n\tif (sysctl_oops_all_cpu_backtrace)\n\t\ttrigger_all_cpu_backtrace();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trigger_all_cpu_backtrace",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_oops_enter_exit",
          "args": [],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "do_oops_enter_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "468-501",
          "snippet": "static void do_oops_enter_exit(void)\n{\n\tunsigned long flags;\n\tstatic int spin_counter;\n\n\tif (!pause_on_oops)\n\t\treturn;\n\n\tspin_lock_irqsave(&pause_on_oops_lock, flags);\n\tif (pause_on_oops_flag == 0) {\n\t\t/* This CPU may now print the oops message */\n\t\tpause_on_oops_flag = 1;\n\t} else {\n\t\t/* We need to stall this CPU */\n\t\tif (!spin_counter) {\n\t\t\t/* This CPU gets to do the counting */\n\t\t\tspin_counter = pause_on_oops;\n\t\t\tdo {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(MSEC_PER_SEC);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t} while (--spin_counter);\n\t\t\tpause_on_oops_flag = 0;\n\t\t} else {\n\t\t\t/* This CPU waits for a different one */\n\t\t\twhile (spin_counter) {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(1);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pause_on_oops_lock, flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pause_on_oops;",
            "static int pause_on_oops_flag;",
            "static DEFINE_SPINLOCK(pause_on_oops_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic int pause_on_oops;\nstatic int pause_on_oops_flag;\nstatic DEFINE_SPINLOCK(pause_on_oops_lock);\n\nstatic void do_oops_enter_exit(void)\n{\n\tunsigned long flags;\n\tstatic int spin_counter;\n\n\tif (!pause_on_oops)\n\t\treturn;\n\n\tspin_lock_irqsave(&pause_on_oops_lock, flags);\n\tif (pause_on_oops_flag == 0) {\n\t\t/* This CPU may now print the oops message */\n\t\tpause_on_oops_flag = 1;\n\t} else {\n\t\t/* We need to stall this CPU */\n\t\tif (!spin_counter) {\n\t\t\t/* This CPU gets to do the counting */\n\t\t\tspin_counter = pause_on_oops;\n\t\t\tdo {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(MSEC_PER_SEC);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t} while (--spin_counter);\n\t\t\tpause_on_oops_flag = 0;\n\t\t} else {\n\t\t\t/* This CPU waits for a different one */\n\t\t\twhile (spin_counter) {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(1);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pause_on_oops_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_off",
          "args": [],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1429-1432",
          "snippet": "void tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid oops_enter(void)\n{\n\ttracing_off();\n\t/* can't trust the integrity of the kernel anymore: */\n\tdebug_locks_off();\n\tdo_oops_enter_exit();\n\n\tif (sysctl_oops_all_cpu_backtrace)\n\t\ttrigger_all_cpu_backtrace();\n}"
  },
  {
    "function_name": "oops_may_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "507-510",
    "snippet": "bool oops_may_print(void)\n{\n\treturn pause_on_oops_flag == 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pause_on_oops_flag;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic int pause_on_oops_flag;\n\nbool oops_may_print(void)\n{\n\treturn pause_on_oops_flag == 0;\n}"
  },
  {
    "function_name": "do_oops_enter_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "468-501",
    "snippet": "static void do_oops_enter_exit(void)\n{\n\tunsigned long flags;\n\tstatic int spin_counter;\n\n\tif (!pause_on_oops)\n\t\treturn;\n\n\tspin_lock_irqsave(&pause_on_oops_lock, flags);\n\tif (pause_on_oops_flag == 0) {\n\t\t/* This CPU may now print the oops message */\n\t\tpause_on_oops_flag = 1;\n\t} else {\n\t\t/* We need to stall this CPU */\n\t\tif (!spin_counter) {\n\t\t\t/* This CPU gets to do the counting */\n\t\t\tspin_counter = pause_on_oops;\n\t\t\tdo {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(MSEC_PER_SEC);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t} while (--spin_counter);\n\t\t\tpause_on_oops_flag = 0;\n\t\t} else {\n\t\t\t/* This CPU waits for a different one */\n\t\t\twhile (spin_counter) {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(1);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pause_on_oops_lock, flags);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pause_on_oops;",
      "static int pause_on_oops_flag;",
      "static DEFINE_SPINLOCK(pause_on_oops_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pause_on_oops_lock",
            "flags"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pause_on_oops_lock"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_msec",
          "args": [
            "1"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "spin_msec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "454-462",
          "snippet": "static void spin_msec(int msecs)\n{\n\tint i;\n\n\tfor (i = 0; i < msecs; i++) {\n\t\ttouch_nmi_watchdog();\n\t\tmdelay(1);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic void spin_msec(int msecs)\n{\n\tint i;\n\n\tfor (i = 0; i < msecs; i++) {\n\t\ttouch_nmi_watchdog();\n\t\tmdelay(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pause_on_oops_lock"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pause_on_oops_lock",
            "flags"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic int pause_on_oops;\nstatic int pause_on_oops_flag;\nstatic DEFINE_SPINLOCK(pause_on_oops_lock);\n\nstatic void do_oops_enter_exit(void)\n{\n\tunsigned long flags;\n\tstatic int spin_counter;\n\n\tif (!pause_on_oops)\n\t\treturn;\n\n\tspin_lock_irqsave(&pause_on_oops_lock, flags);\n\tif (pause_on_oops_flag == 0) {\n\t\t/* This CPU may now print the oops message */\n\t\tpause_on_oops_flag = 1;\n\t} else {\n\t\t/* We need to stall this CPU */\n\t\tif (!spin_counter) {\n\t\t\t/* This CPU gets to do the counting */\n\t\t\tspin_counter = pause_on_oops;\n\t\t\tdo {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(MSEC_PER_SEC);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t} while (--spin_counter);\n\t\t\tpause_on_oops_flag = 0;\n\t\t} else {\n\t\t\t/* This CPU waits for a different one */\n\t\t\twhile (spin_counter) {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(1);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pause_on_oops_lock, flags);\n}"
  },
  {
    "function_name": "spin_msec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "454-462",
    "snippet": "static void spin_msec(int msecs)\n{\n\tint i;\n\n\tfor (i = 0; i < msecs; i++) {\n\t\ttouch_nmi_watchdog();\n\t\tmdelay(1);\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "1"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic void spin_msec(int msecs)\n{\n\tint i;\n\n\tfor (i = 0; i < msecs; i++) {\n\t\ttouch_nmi_watchdog();\n\t\tmdelay(1);\n\t}\n}"
  },
  {
    "function_name": "add_taint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "440-451",
    "snippet": "void add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n\n\tif (tainted_mask & panic_on_taint) {\n\t\tpanic_on_taint = 0;\n\t\tpanic(\"panic_on_taint set ...\");\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;",
      "unsigned long panic_on_taint;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"panic_on_taint set ...\""
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "panic_on_taint_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "694-718",
          "snippet": "static int __init panic_on_taint_setup(char *s)\n{\n\tchar *taint_str;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\ttaint_str = strsep(&s, \",\");\n\tif (kstrtoul(taint_str, 16, &panic_on_taint))\n\t\treturn -EINVAL;\n\n\t/* make sure panic_on_taint doesn't hold out-of-range TAINT flags */\n\tpanic_on_taint &= TAINT_FLAGS_MAX;\n\n\tif (!panic_on_taint)\n\t\treturn -EINVAL;\n\n\tif (s && !strcmp(s, \"nousertaint\"))\n\t\tpanic_on_taint_nousertaint = true;\n\n\tpr_info(\"panic_on_taint: bitmask=0x%lx nousertaint_mode=%sabled\\n\",\n\t\tpanic_on_taint, panic_on_taint_nousertaint ? \"en\" : \"dis\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long panic_on_taint;",
            "bool panic_on_taint_nousertaint = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nunsigned long panic_on_taint;\nbool panic_on_taint_nousertaint = false;\n\nstatic int __init panic_on_taint_setup(char *s)\n{\n\tchar *taint_str;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\ttaint_str = strsep(&s, \",\");\n\tif (kstrtoul(taint_str, 16, &panic_on_taint))\n\t\treturn -EINVAL;\n\n\t/* make sure panic_on_taint doesn't hold out-of-range TAINT flags */\n\tpanic_on_taint &= TAINT_FLAGS_MAX;\n\n\tif (!panic_on_taint)\n\t\treturn -EINVAL;\n\n\tif (s && !strcmp(s, \"nousertaint\"))\n\t\tpanic_on_taint_nousertaint = true;\n\n\tpr_info(\"panic_on_taint: bitmask=0x%lx nousertaint_mode=%sabled\\n\",\n\t\tpanic_on_taint, panic_on_taint_nousertaint ? \"en\" : \"dis\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "flag",
            "&tainted_mask"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Disabling lock debugging due to kernel taint\\n\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__debug_locks_off",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\nunsigned long panic_on_taint;\n\nvoid add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n\n\tif (tainted_mask & panic_on_taint) {\n\t\tpanic_on_taint = 0;\n\t\tpanic(\"panic_on_taint set ...\");\n\t}\n}"
  },
  {
    "function_name": "get_taint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "427-430",
    "snippet": "unsigned long get_taint(void)\n{\n\treturn tainted_mask;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\n\nunsigned long get_taint(void)\n{\n\treturn tainted_mask;\n}"
  },
  {
    "function_name": "test_taint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "421-424",
    "snippet": "int test_taint(unsigned flag)\n{\n\treturn test_bit(flag, &tainted_mask);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "flag",
            "&tainted_mask"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\n\nint test_taint(unsigned flag)\n{\n\treturn test_bit(flag, &tainted_mask);\n}"
  },
  {
    "function_name": "print_tainted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "398-419",
    "snippet": "const char *print_tainted(void)\n{\n\tstatic char buf[TAINT_FLAGS_COUNT + sizeof(\"Tainted: \")];\n\n\tBUILD_BUG_ON(ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT);\n\n\tif (tainted_mask) {\n\t\tchar *s;\n\t\tint i;\n\n\t\ts = buf + sprintf(buf, \"Tainted: \");\n\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++) {\n\t\t\tconst struct taint_flag *t = &taint_flags[i];\n\t\t\t*s++ = test_bit(i, &tainted_mask) ?\n\t\t\t\t\tt->c_true : t->c_false;\n\t\t}\n\t\t*s = 0;\n\t} else\n\t\tsnprintf(buf, sizeof(buf), \"Not tainted\");\n\n\treturn buf;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;",
      "const struct taint_flag taint_flags[TAINT_FLAGS_COUNT] = {\n\t[ TAINT_PROPRIETARY_MODULE ]\t= { 'P', 'G', true },\n\t[ TAINT_FORCED_MODULE ]\t\t= { 'F', ' ', true },\n\t[ TAINT_CPU_OUT_OF_SPEC ]\t= { 'S', ' ', false },\n\t[ TAINT_FORCED_RMMOD ]\t\t= { 'R', ' ', false },\n\t[ TAINT_MACHINE_CHECK ]\t\t= { 'M', ' ', false },\n\t[ TAINT_BAD_PAGE ]\t\t= { 'B', ' ', false },\n\t[ TAINT_USER ]\t\t\t= { 'U', ' ', false },\n\t[ TAINT_DIE ]\t\t\t= { 'D', ' ', false },\n\t[ TAINT_OVERRIDDEN_ACPI_TABLE ]\t= { 'A', ' ', false },\n\t[ TAINT_WARN ]\t\t\t= { 'W', ' ', false },\n\t[ TAINT_CRAP ]\t\t\t= { 'C', ' ', true },\n\t[ TAINT_FIRMWARE_WORKAROUND ]\t= { 'I', ' ', false },\n\t[ TAINT_OOT_MODULE ]\t\t= { 'O', ' ', true },\n\t[ TAINT_UNSIGNED_MODULE ]\t= { 'E', ' ', true },\n\t[ TAINT_SOFTLOCKUP ]\t\t= { 'L', ' ', false },\n\t[ TAINT_LIVEPATCH ]\t\t= { 'K', ' ', true },\n\t[ TAINT_AUX ]\t\t\t= { 'X', ' ', true },\n\t[ TAINT_RANDSTRUCT ]\t\t= { 'T', ' ', true },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"Not tainted\""
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "btf_snprintf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5972-5992",
          "snippet": "static void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "i",
            "&tainted_mask"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"Tainted: \""
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "taint_flags"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\nconst struct taint_flag taint_flags[TAINT_FLAGS_COUNT] = {\n\t[ TAINT_PROPRIETARY_MODULE ]\t= { 'P', 'G', true },\n\t[ TAINT_FORCED_MODULE ]\t\t= { 'F', ' ', true },\n\t[ TAINT_CPU_OUT_OF_SPEC ]\t= { 'S', ' ', false },\n\t[ TAINT_FORCED_RMMOD ]\t\t= { 'R', ' ', false },\n\t[ TAINT_MACHINE_CHECK ]\t\t= { 'M', ' ', false },\n\t[ TAINT_BAD_PAGE ]\t\t= { 'B', ' ', false },\n\t[ TAINT_USER ]\t\t\t= { 'U', ' ', false },\n\t[ TAINT_DIE ]\t\t\t= { 'D', ' ', false },\n\t[ TAINT_OVERRIDDEN_ACPI_TABLE ]\t= { 'A', ' ', false },\n\t[ TAINT_WARN ]\t\t\t= { 'W', ' ', false },\n\t[ TAINT_CRAP ]\t\t\t= { 'C', ' ', true },\n\t[ TAINT_FIRMWARE_WORKAROUND ]\t= { 'I', ' ', false },\n\t[ TAINT_OOT_MODULE ]\t\t= { 'O', ' ', true },\n\t[ TAINT_UNSIGNED_MODULE ]\t= { 'E', ' ', true },\n\t[ TAINT_SOFTLOCKUP ]\t\t= { 'L', ' ', false },\n\t[ TAINT_LIVEPATCH ]\t\t= { 'K', ' ', true },\n\t[ TAINT_AUX ]\t\t\t= { 'X', ' ', true },\n\t[ TAINT_RANDSTRUCT ]\t\t= { 'T', ' ', true },\n};\n\nconst char *print_tainted(void)\n{\n\tstatic char buf[TAINT_FLAGS_COUNT + sizeof(\"Tainted: \")];\n\n\tBUILD_BUG_ON(ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT);\n\n\tif (tainted_mask) {\n\t\tchar *s;\n\t\tint i;\n\n\t\ts = buf + sprintf(buf, \"Tainted: \");\n\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++) {\n\t\t\tconst struct taint_flag *t = &taint_flags[i];\n\t\t\t*s++ = test_bit(i, &tainted_mask) ?\n\t\t\t\t\tt->c_true : t->c_false;\n\t\t}\n\t\t*s = 0;\n\t} else\n\t\tsnprintf(buf, sizeof(buf), \"Not tainted\");\n\n\treturn buf;\n}"
  },
  {
    "function_name": "panic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "179-361",
    "snippet": "void panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [
      "#define PANIC_BLINK_SPD 18",
      "#define PANIC_TIMER_STEP 100"
    ],
    "globals_used": [
      "bool crash_kexec_post_notifiers;",
      "int panic_timeout = CONFIG_PANIC_TIMEOUT;",
      "long (*panic_blink)(int state);",
      "atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "PANIC_TIMER_STEP"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic_blink",
          "args": [
            "state ^= 1"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "299-303",
          "snippet": "void touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nvoid touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"---[ end Kernel panic - not syncing: %s ]---\\n\"",
            "buf"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disabled_wait",
          "args": [],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emergency_restart",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "emergency_restart",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "66-70",
          "snippet": "void emergency_restart(void)\n{\n\tkmsg_dump(KMSG_DUMP_EMERG);\n\tmachine_emergency_restart();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid emergency_restart(void)\n{\n\tkmsg_dump(KMSG_DUMP_EMERG);\n\tmachine_emergency_restart();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "PANIC_TIMER_STEP"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic_blink",
          "args": [
            "state ^= 1"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"Rebooting in %d seconds..\\n\"",
            "panic_timeout"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic_print_sys_info",
          "args": [],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "panic_print_sys_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "150-169",
          "snippet": "static void panic_print_sys_info(void)\n{\n\tif (panic_print & PANIC_PRINT_ALL_PRINTK_MSG)\n\t\tconsole_flush_on_panic(CONSOLE_REPLAY_ALL);\n\n\tif (panic_print & PANIC_PRINT_TASK_INFO)\n\t\tshow_state();\n\n\tif (panic_print & PANIC_PRINT_MEM_INFO)\n\t\tshow_mem(0, NULL);\n\n\tif (panic_print & PANIC_PRINT_TIMER_INFO)\n\t\tsysrq_timer_list_show();\n\n\tif (panic_print & PANIC_PRINT_LOCK_INFO)\n\t\tdebug_show_all_locks();\n\n\tif (panic_print & PANIC_PRINT_FTRACE_INFO)\n\t\tftrace_dump(DUMP_ALL);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define PANIC_PRINT_ALL_PRINTK_MSG\t0x00000020",
            "#define PANIC_PRINT_FTRACE_INFO\t\t0x00000010",
            "#define PANIC_PRINT_LOCK_INFO\t\t0x00000008",
            "#define PANIC_PRINT_TIMER_INFO\t\t0x00000004",
            "#define PANIC_PRINT_MEM_INFO\t\t0x00000002",
            "#define PANIC_PRINT_TASK_INFO\t\t0x00000001"
          ],
          "globals_used": [
            "unsigned long panic_print;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_PRINT_ALL_PRINTK_MSG\t0x00000020\n#define PANIC_PRINT_FTRACE_INFO\t\t0x00000010\n#define PANIC_PRINT_LOCK_INFO\t\t0x00000008\n#define PANIC_PRINT_TIMER_INFO\t\t0x00000004\n#define PANIC_PRINT_MEM_INFO\t\t0x00000002\n#define PANIC_PRINT_TASK_INFO\t\t0x00000001\n\nunsigned long panic_print;\n\nstatic void panic_print_sys_info(void)\n{\n\tif (panic_print & PANIC_PRINT_ALL_PRINTK_MSG)\n\t\tconsole_flush_on_panic(CONSOLE_REPLAY_ALL);\n\n\tif (panic_print & PANIC_PRINT_TASK_INFO)\n\t\tshow_state();\n\n\tif (panic_print & PANIC_PRINT_MEM_INFO)\n\t\tshow_mem(0, NULL);\n\n\tif (panic_print & PANIC_PRINT_TIMER_INFO)\n\t\tsysrq_timer_list_show();\n\n\tif (panic_print & PANIC_PRINT_LOCK_INFO)\n\t\tdebug_show_all_locks();\n\n\tif (panic_print & PANIC_PRINT_FTRACE_INFO)\n\t\tftrace_dump(DUMP_ALL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "console_flush_on_panic",
          "args": [
            "CONSOLE_FLUSH_PENDING"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "console_flush_on_panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2785-2800",
          "snippet": "void console_flush_on_panic(enum con_flush_mode mode)\n{\n\t/*\n\t * If someone else is holding the console lock, trylock will fail\n\t * and may_schedule may be set.  Ignore and proceed to unlock so\n\t * that messages are flushed out.  As this can be called from any\n\t * context and we don't want to get preempted while flushing,\n\t * ensure may_schedule is cleared.\n\t */\n\tconsole_trylock();\n\tconsole_may_schedule = 0;\n\n\tif (mode == CONSOLE_REPLAY_ALL)\n\t\tconsole_seq = prb_first_valid_seq(prb);\n\tconsole_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_may_schedule;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_may_schedule;\n\nvoid console_flush_on_panic(enum con_flush_mode mode)\n{\n\t/*\n\t * If someone else is holding the console lock, trylock will fail\n\t * and may_schedule may be set.  Ignore and proceed to unlock so\n\t * that messages are flushed out.  As this can be called from any\n\t * context and we don't want to get preempted while flushing,\n\t * ensure may_schedule is cleared.\n\t */\n\tconsole_trylock();\n\tconsole_may_schedule = 0;\n\n\tif (mode == CONSOLE_REPLAY_ALL)\n\t\tconsole_seq = prb_first_valid_seq(prb);\n\tconsole_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "162-169",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tlockdep_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "console_unblank",
          "args": [],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "console_unblank",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2757-2777",
          "snippet": "void console_unblank(void)\n{\n\tstruct console *c;\n\n\t/*\n\t * console_unblank can no longer be called in interrupt context unless\n\t * oops_in_progress is set to 1..\n\t */\n\tif (oops_in_progress) {\n\t\tif (down_trylock_console_sem() != 0)\n\t\t\treturn;\n\t} else\n\t\tconsole_lock();\n\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\tfor_each_console(c)\n\t\tif ((c->flags & CON_ENABLED) && c->unblank)\n\t\t\tc->unblank();\n\tconsole_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int oops_in_progress;",
            "static int console_may_schedule;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint oops_in_progress;\nstatic int console_may_schedule;\n\nvoid console_unblank(void)\n{\n\tstruct console *c;\n\n\t/*\n\t * console_unblank can no longer be called in interrupt context unless\n\t * oops_in_progress is set to 1..\n\t */\n\tif (oops_in_progress) {\n\t\tif (down_trylock_console_sem() != 0)\n\t\t\treturn;\n\t} else\n\t\tconsole_lock();\n\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\tfor_each_console(c)\n\t\tif ((c->flags & CON_ENABLED) && c->unblank)\n\t\t\tc->unblank();\n\tconsole_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unblank_screen",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__crash_kexec",
          "args": [
            "NULL"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "__crash_kexec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "945-966",
          "snippet": "void __noclone __crash_kexec(struct pt_regs *regs)\n{\n\t/* Take the kexec_mutex here to prevent sys_kexec_load\n\t * running on one cpu from replacing the crash kernel\n\t * we are using after a panic on a different cpu.\n\t *\n\t * If the crash kernel was not located in a fixed area\n\t * of memory the xchg(&kexec_crash_image) would be\n\t * sufficient.  But since I reuse the memory...\n\t */\n\tif (mutex_trylock(&kexec_mutex)) {\n\t\tif (kexec_crash_image) {\n\t\t\tstruct pt_regs fixed_regs;\n\n\t\t\tcrash_setup_regs(&fixed_regs, regs);\n\t\t\tcrash_save_vmcoreinfo();\n\t\t\tmachine_crash_shutdown(&fixed_regs);\n\t\t\tmachine_kexec(kexec_crash_image);\n\t\t}\n\t\tmutex_unlock(&kexec_mutex);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kimage *kexec_crash_image;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct kimage *kexec_crash_image;\n\nvoid __noclone __crash_kexec(struct pt_regs *regs)\n{\n\t/* Take the kexec_mutex here to prevent sys_kexec_load\n\t * running on one cpu from replacing the crash kernel\n\t * we are using after a panic on a different cpu.\n\t *\n\t * If the crash kernel was not located in a fixed area\n\t * of memory the xchg(&kexec_crash_image) would be\n\t * sufficient.  But since I reuse the memory...\n\t */\n\tif (mutex_trylock(&kexec_mutex)) {\n\t\tif (kexec_crash_image) {\n\t\t\tstruct pt_regs fixed_regs;\n\n\t\t\tcrash_setup_regs(&fixed_regs, regs);\n\t\t\tcrash_save_vmcoreinfo();\n\t\t\tmachine_crash_shutdown(&fixed_regs);\n\t\t\tmachine_kexec(kexec_crash_image);\n\t\t}\n\t\tmutex_unlock(&kexec_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmsg_dump",
          "args": [
            "KMSG_DUMP_PANIC"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "kmsg_dump_rewind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3593-3597",
          "snippet": "void kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_notifier_call_chain",
          "args": [
            "&panic_notifier_list",
            "0",
            "buf"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "193-203",
          "snippet": "int atomic_notifier_call_chain(struct atomic_notifier_head *nh,\n\t\t\t       unsigned long val, void *v)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_call_chain(struct atomic_notifier_head *nh,\n\t\t\t       unsigned long val, void *v)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crash_smp_send_stop",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "crash_smp_send_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "108-126",
          "snippet": "void __weak crash_smp_send_stop(void)\n{\n\tstatic int cpus_stopped;\n\n\t/*\n\t * This function can be called twice in panic path, but obviously\n\t * we execute this only once.\n\t */\n\tif (cpus_stopped)\n\t\treturn;\n\n\t/*\n\t * Note smp_send_stop is the usual smp shutdown function, which\n\t * unfortunately means it may not be hardened to work in a panic\n\t * situation.\n\t */\n\tsmp_send_stop();\n\tcpus_stopped = 1;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __weak crash_smp_send_stop(void)\n{\n\tstatic int cpus_stopped;\n\n\t/*\n\t * This function can be called twice in panic path, but obviously\n\t * we execute this only once.\n\t */\n\tif (cpus_stopped)\n\t\treturn;\n\n\t/*\n\t * Note smp_send_stop is the usual smp shutdown function, which\n\t * unfortunately means it may not be hardened to work in a panic\n\t * situation.\n\t */\n\tsmp_send_stop();\n\tcpus_stopped = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_panic",
          "args": [
            "buf"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "984-1001",
          "snippet": "void kgdb_panic(const char *msg)\n{\n\tif (!kgdb_io_module_registered)\n\t\treturn;\n\n\t/*\n\t * We don't want to get stuck waiting for input from user if\n\t * \"panic_timeout\" indicates the system should automatically\n\t * reboot on panic.\n\t */\n\tif (panic_timeout)\n\t\treturn;\n\n\tif (dbg_kdb_mode)\n\t\tkdb_printf(\"PANIC: %s\\n\", msg);\n\n\tkgdb_breakpoint();\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\tkgdb_io_module_registered;",
            "int dbg_kdb_mode = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nint dbg_kdb_mode = 1;\n\nvoid kgdb_panic(const char *msg)\n{\n\tif (!kgdb_io_module_registered)\n\t\treturn;\n\n\t/*\n\t * We don't want to get stuck waiting for input from user if\n\t * \"panic_timeout\" indicates the system should automatically\n\t * reboot on panic.\n\t */\n\tif (panic_timeout)\n\t\treturn;\n\n\tif (dbg_kdb_mode)\n\t\tkdb_printf(\"PANIC: %s\\n\", msg);\n\n\tkgdb_breakpoint();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_taint",
          "args": [
            "TAINT_DIE"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "test_taint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "421-424",
          "snippet": "int test_taint(unsigned flag)\n{\n\treturn test_bit(flag, &tainted_mask);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\n\nint test_taint(unsigned flag)\n{\n\treturn test_bit(flag, &tainted_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"Kernel panic - not syncing: %s\\n\"",
            "buf"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vscnprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "fmt",
            "args"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bust_spinlocks",
          "args": [
            "1"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_verbose",
          "args": [],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "console_verbose",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2459-2463",
          "snippet": "void console_verbose(void)\n{\n\tif (console_loglevel && !printk_console_no_auto_verbose)\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool printk_console_no_auto_verbose;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic bool printk_console_no_auto_verbose;\n\nvoid console_verbose(void)\n{\n\tif (console_loglevel && !printk_console_no_auto_verbose)\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic_smp_self_stop",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "panic_smp_self_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "87-91",
          "snippet": "void __weak panic_smp_self_stop(void)\n{\n\twhile (1)\n\t\tcpu_relax();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __weak panic_smp_self_stop(void)\n{\n\twhile (1)\n\t\tcpu_relax();\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&panic_cpu",
            "PANIC_CPU_INVALID",
            "this_cpu"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_BLINK_SPD 18\n#define PANIC_TIMER_STEP 100\n\nbool crash_kexec_post_notifiers;\nint panic_timeout = CONFIG_PANIC_TIMEOUT;\nlong (*panic_blink)(int state);\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\nvoid panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}"
  },
  {
    "function_name": "panic_print_sys_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "150-169",
    "snippet": "static void panic_print_sys_info(void)\n{\n\tif (panic_print & PANIC_PRINT_ALL_PRINTK_MSG)\n\t\tconsole_flush_on_panic(CONSOLE_REPLAY_ALL);\n\n\tif (panic_print & PANIC_PRINT_TASK_INFO)\n\t\tshow_state();\n\n\tif (panic_print & PANIC_PRINT_MEM_INFO)\n\t\tshow_mem(0, NULL);\n\n\tif (panic_print & PANIC_PRINT_TIMER_INFO)\n\t\tsysrq_timer_list_show();\n\n\tif (panic_print & PANIC_PRINT_LOCK_INFO)\n\t\tdebug_show_all_locks();\n\n\tif (panic_print & PANIC_PRINT_FTRACE_INFO)\n\t\tftrace_dump(DUMP_ALL);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [
      "#define PANIC_PRINT_ALL_PRINTK_MSG\t0x00000020",
      "#define PANIC_PRINT_FTRACE_INFO\t\t0x00000010",
      "#define PANIC_PRINT_LOCK_INFO\t\t0x00000008",
      "#define PANIC_PRINT_TIMER_INFO\t\t0x00000004",
      "#define PANIC_PRINT_MEM_INFO\t\t0x00000002",
      "#define PANIC_PRINT_TASK_INFO\t\t0x00000001"
    ],
    "globals_used": [
      "unsigned long panic_print;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_dump",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9808-9917",
          "snippet": "void ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\t/* Can not use kmalloc for iter.temp and iter.fmt */\n\titer.temp = static_temp_buf;\n\titer.temp_size = STATIC_TEMP_BUF_SIZE;\n\titer.fmt = static_fmt_buf;\n\titer.fmt_size = STATIC_FMT_BUF_SIZE;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\ttrace_iterator_reset(&iter);\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define STATIC_TEMP_BUF_SIZE\t128",
            "#define STATIC_FMT_BUF_SIZE\t128"
          ],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static char static_fmt_buf[STATIC_FMT_BUF_SIZE];",
            "static char static_temp_buf[STATIC_TEMP_BUF_SIZE]",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define STATIC_TEMP_BUF_SIZE\t128\n#define STATIC_FMT_BUF_SIZE\t128\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic char static_fmt_buf[STATIC_FMT_BUF_SIZE];\nstatic char static_temp_buf[STATIC_TEMP_BUF_SIZE];\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nvoid ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\t/* Can not use kmalloc for iter.temp and iter.fmt */\n\titer.temp = static_temp_buf;\n\titer.temp_size = STATIC_TEMP_BUF_SIZE;\n\titer.fmt = static_fmt_buf;\n\titer.fmt_size = STATIC_FMT_BUF_SIZE;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\ttrace_iterator_reset(&iter);\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_show_all_locks",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "debug_show_all_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6456-6478",
          "snippet": "void debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysrq_timer_list_show",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "sysrq_timer_list_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "265-281",
          "snippet": "void sysrq_timer_list_show(void)\n{\n\tu64 now = ktime_to_ns(ktime_get());\n\tint cpu;\n\n\ttimer_list_header(NULL, now);\n\n\tfor_each_online_cpu(cpu)\n\t\tprint_cpu(NULL, cpu, now);\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\ttimer_list_show_tickdevices_header(NULL);\n\tfor_each_online_cpu(cpu)\n\t\tprint_tickdevice(NULL, tick_get_device(cpu), cpu);\n#endif\n\treturn;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nvoid sysrq_timer_list_show(void)\n{\n\tu64 now = ktime_to_ns(ktime_get());\n\tint cpu;\n\n\ttimer_list_header(NULL, now);\n\n\tfor_each_online_cpu(cpu)\n\t\tprint_cpu(NULL, cpu, now);\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\ttimer_list_show_tickdevices_header(NULL);\n\tfor_each_online_cpu(cpu)\n\t\tprint_tickdevice(NULL, tick_get_device(cpu), cpu);\n#endif\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_mem",
          "args": [
            "0",
            "NULL"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_state",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_flush_on_panic",
          "args": [
            "CONSOLE_REPLAY_ALL"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "console_flush_on_panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2785-2800",
          "snippet": "void console_flush_on_panic(enum con_flush_mode mode)\n{\n\t/*\n\t * If someone else is holding the console lock, trylock will fail\n\t * and may_schedule may be set.  Ignore and proceed to unlock so\n\t * that messages are flushed out.  As this can be called from any\n\t * context and we don't want to get preempted while flushing,\n\t * ensure may_schedule is cleared.\n\t */\n\tconsole_trylock();\n\tconsole_may_schedule = 0;\n\n\tif (mode == CONSOLE_REPLAY_ALL)\n\t\tconsole_seq = prb_first_valid_seq(prb);\n\tconsole_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_may_schedule;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_may_schedule;\n\nvoid console_flush_on_panic(enum con_flush_mode mode)\n{\n\t/*\n\t * If someone else is holding the console lock, trylock will fail\n\t * and may_schedule may be set.  Ignore and proceed to unlock so\n\t * that messages are flushed out.  As this can be called from any\n\t * context and we don't want to get preempted while flushing,\n\t * ensure may_schedule is cleared.\n\t */\n\tconsole_trylock();\n\tconsole_may_schedule = 0;\n\n\tif (mode == CONSOLE_REPLAY_ALL)\n\t\tconsole_seq = prb_first_valid_seq(prb);\n\tconsole_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_PRINT_ALL_PRINTK_MSG\t0x00000020\n#define PANIC_PRINT_FTRACE_INFO\t\t0x00000010\n#define PANIC_PRINT_LOCK_INFO\t\t0x00000008\n#define PANIC_PRINT_TIMER_INFO\t\t0x00000004\n#define PANIC_PRINT_MEM_INFO\t\t0x00000002\n#define PANIC_PRINT_TASK_INFO\t\t0x00000001\n\nunsigned long panic_print;\n\nstatic void panic_print_sys_info(void)\n{\n\tif (panic_print & PANIC_PRINT_ALL_PRINTK_MSG)\n\t\tconsole_flush_on_panic(CONSOLE_REPLAY_ALL);\n\n\tif (panic_print & PANIC_PRINT_TASK_INFO)\n\t\tshow_state();\n\n\tif (panic_print & PANIC_PRINT_MEM_INFO)\n\t\tshow_mem(0, NULL);\n\n\tif (panic_print & PANIC_PRINT_TIMER_INFO)\n\t\tsysrq_timer_list_show();\n\n\tif (panic_print & PANIC_PRINT_LOCK_INFO)\n\t\tdebug_show_all_locks();\n\n\tif (panic_print & PANIC_PRINT_FTRACE_INFO)\n\t\tftrace_dump(DUMP_ALL);\n}"
  },
  {
    "function_name": "nmi_panic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "136-147",
    "snippet": "void nmi_panic(struct pt_regs *regs, const char *msg)\n{\n\tint old_cpu, cpu;\n\n\tcpu = raw_smp_processor_id();\n\told_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, cpu);\n\n\tif (old_cpu == PANIC_CPU_INVALID)\n\t\tpanic(\"%s\", msg);\n\telse if (old_cpu != cpu)\n\t\tnmi_panic_self_stop(regs);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nmi_panic_self_stop",
          "args": [
            "regs"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "nmi_panic_self_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "97-100",
          "snippet": "void __weak nmi_panic_self_stop(struct pt_regs *regs)\n{\n\tpanic_smp_self_stop();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __weak nmi_panic_self_stop(struct pt_regs *regs)\n{\n\tpanic_smp_self_stop();\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s\"",
            "msg"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "179-361",
          "snippet": "void panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define PANIC_BLINK_SPD 18",
            "#define PANIC_TIMER_STEP 100"
          ],
          "globals_used": [
            "bool crash_kexec_post_notifiers;",
            "int panic_timeout = CONFIG_PANIC_TIMEOUT;",
            "long (*panic_blink)(int state);",
            "atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_BLINK_SPD 18\n#define PANIC_TIMER_STEP 100\n\nbool crash_kexec_post_notifiers;\nint panic_timeout = CONFIG_PANIC_TIMEOUT;\nlong (*panic_blink)(int state);\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\nvoid panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&panic_cpu",
            "PANIC_CPU_INVALID",
            "cpu"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\nvoid nmi_panic(struct pt_regs *regs, const char *msg)\n{\n\tint old_cpu, cpu;\n\n\tcpu = raw_smp_processor_id();\n\told_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, cpu);\n\n\tif (old_cpu == PANIC_CPU_INVALID)\n\t\tpanic(\"%s\", msg);\n\telse if (old_cpu != cpu)\n\t\tnmi_panic_self_stop(regs);\n}"
  },
  {
    "function_name": "crash_smp_send_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "108-126",
    "snippet": "void __weak crash_smp_send_stop(void)\n{\n\tstatic int cpus_stopped;\n\n\t/*\n\t * This function can be called twice in panic path, but obviously\n\t * we execute this only once.\n\t */\n\tif (cpus_stopped)\n\t\treturn;\n\n\t/*\n\t * Note smp_send_stop is the usual smp shutdown function, which\n\t * unfortunately means it may not be hardened to work in a panic\n\t * situation.\n\t */\n\tsmp_send_stop();\n\tcpus_stopped = 1;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_send_stop",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "crash_smp_send_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "108-126",
          "snippet": "void __weak crash_smp_send_stop(void)\n{\n\tstatic int cpus_stopped;\n\n\t/*\n\t * This function can be called twice in panic path, but obviously\n\t * we execute this only once.\n\t */\n\tif (cpus_stopped)\n\t\treturn;\n\n\t/*\n\t * Note smp_send_stop is the usual smp shutdown function, which\n\t * unfortunately means it may not be hardened to work in a panic\n\t * situation.\n\t */\n\tsmp_send_stop();\n\tcpus_stopped = 1;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __weak crash_smp_send_stop(void)\n{\n\tstatic int cpus_stopped;\n\n\t/*\n\t * This function can be called twice in panic path, but obviously\n\t * we execute this only once.\n\t */\n\tif (cpus_stopped)\n\t\treturn;\n\n\t/*\n\t * Note smp_send_stop is the usual smp shutdown function, which\n\t * unfortunately means it may not be hardened to work in a panic\n\t * situation.\n\t */\n\tsmp_send_stop();\n\tcpus_stopped = 1;\n}"
  },
  {
    "function_name": "nmi_panic_self_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "97-100",
    "snippet": "void __weak nmi_panic_self_stop(struct pt_regs *regs)\n{\n\tpanic_smp_self_stop();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic_smp_self_stop",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "panic_smp_self_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "87-91",
          "snippet": "void __weak panic_smp_self_stop(void)\n{\n\twhile (1)\n\t\tcpu_relax();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __weak panic_smp_self_stop(void)\n{\n\twhile (1)\n\t\tcpu_relax();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __weak nmi_panic_self_stop(struct pt_regs *regs)\n{\n\tpanic_smp_self_stop();\n}"
  },
  {
    "function_name": "panic_smp_self_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "87-91",
    "snippet": "void __weak panic_smp_self_stop(void)\n{\n\twhile (1)\n\t\tcpu_relax();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __weak panic_smp_self_stop(void)\n{\n\twhile (1)\n\t\tcpu_relax();\n}"
  },
  {
    "function_name": "no_blink",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
    "lines": "75-78",
    "snippet": "static long no_blink(int state)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <trace/events/error_report.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bug.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/init.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/kexec.h>",
      "#include <linux/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "long (*panic_blink)(int state);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nlong (*panic_blink)(int state);\n\nstatic long no_blink(int state)\n{\n\treturn 0;\n}"
  }
]