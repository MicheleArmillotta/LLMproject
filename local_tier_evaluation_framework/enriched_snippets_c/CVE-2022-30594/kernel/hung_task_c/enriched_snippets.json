[
  {
    "function_name": "hung_task_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
    "lines": "379-390",
    "snippet": "static int __init hung_task_init(void)\n{\n\tatomic_notifier_chain_register(&panic_notifier_list, &panic_block);\n\n\t/* Disable hung task detector on suspend */\n\tpm_notifier(hungtask_pm_notify, 0);\n\n\twatchdog_task = kthread_run(watchdog, NULL, \"khungtaskd\");\n\thung_task_sysctl_init();\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *watchdog_task;",
      "static struct notifier_block panic_block = {\n\t.notifier_call = hung_task_panic,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hung_task_sysctl_init",
          "args": [],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "hung_task_sysctl_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
          "lines": "309-312",
          "snippet": "static void __init hung_task_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", hung_task_sysctls);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void __init hung_task_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", hung_task_sysctls);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "watchdog",
            "NULL",
            "\"khungtaskd\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_notifier",
          "args": [
            "hungtask_pm_notify",
            "0"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "pm_notifier_call_chain_robust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "83-90",
          "snippet": "int pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_notifier_chain_register",
          "args": [
            "&panic_notifier_list",
            "&panic_block"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_chain_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "140-150",
          "snippet": "int atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *watchdog_task;\nstatic struct notifier_block panic_block = {\n\t.notifier_call = hung_task_panic,\n};\n\nstatic int __init hung_task_init(void)\n{\n\tatomic_notifier_chain_register(&panic_notifier_list, &panic_block);\n\n\t/* Disable hung task detector on suspend */\n\tpm_notifier(hungtask_pm_notify, 0);\n\n\twatchdog_task = kthread_run(watchdog, NULL, \"khungtaskd\");\n\thung_task_sysctl_init();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
    "lines": "351-377",
    "snippet": "static int watchdog(void *dummy)\n{\n\tunsigned long hung_last_checked = jiffies;\n\n\tset_user_nice(current, 0);\n\n\tfor ( ; ; ) {\n\t\tunsigned long timeout = sysctl_hung_task_timeout_secs;\n\t\tunsigned long interval = sysctl_hung_task_check_interval_secs;\n\t\tlong t;\n\n\t\tif (interval == 0)\n\t\t\tinterval = timeout;\n\t\tinterval = min_t(unsigned long, interval, timeout);\n\t\tt = hung_timeout_jiffies(hung_last_checked, interval);\n\t\tif (t <= 0) {\n\t\t\tif (!atomic_xchg(&reset_hung_task, 0) &&\n\t\t\t    !hung_detector_suspended)\n\t\t\t\tcheck_hung_uninterruptible_tasks(timeout);\n\t\t\thung_last_checked = jiffies;\n\t\t\tcontinue;\n\t\t}\n\t\tschedule_timeout_interruptible(t);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long __read_mostly sysctl_hung_task_timeout_secs = CONFIG_DEFAULT_HUNG_TASK_TIMEOUT;",
      "unsigned long __read_mostly sysctl_hung_task_check_interval_secs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "t"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_hung_uninterruptible_tasks",
          "args": [
            "timeout"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "check_hung_uninterruptible_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
          "lines": "178-217",
          "snippet": "static void check_hung_uninterruptible_tasks(unsigned long timeout)\n{\n\tint max_count = sysctl_hung_task_check_count;\n\tunsigned long last_break = jiffies;\n\tstruct task_struct *g, *t;\n\n\t/*\n\t * If the system crashed already then all bets are off,\n\t * do not report extra hung tasks:\n\t */\n\tif (test_taint(TAINT_DIE) || did_panic)\n\t\treturn;\n\n\thung_task_show_lock = false;\n\trcu_read_lock();\n\tfor_each_process_thread(g, t) {\n\t\tif (!max_count--)\n\t\t\tgoto unlock;\n\t\tif (time_after(jiffies, last_break + HUNG_TASK_LOCK_BREAK)) {\n\t\t\tif (!rcu_lock_break(g, t))\n\t\t\t\tgoto unlock;\n\t\t\tlast_break = jiffies;\n\t\t}\n\t\t/* use \"==\" to skip the TASK_KILLABLE tasks waiting on NFS */\n\t\tif (READ_ONCE(t->__state) == TASK_UNINTERRUPTIBLE)\n\t\t\tcheck_hung_task(t, timeout);\n\t}\n unlock:\n\trcu_read_unlock();\n\tif (hung_task_show_lock)\n\t\tdebug_show_all_locks();\n\n\tif (hung_task_show_all_bt) {\n\t\thung_task_show_all_bt = false;\n\t\ttrigger_all_cpu_backtrace();\n\t}\n\n\tif (hung_task_call_panic)\n\t\tpanic(\"hung_task: blocked tasks\");\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define HUNG_TASK_LOCK_BREAK (HZ / 10)"
          ],
          "globals_used": [
            "static int __read_mostly did_panic;",
            "static bool hung_task_show_lock;",
            "static bool hung_task_call_panic;",
            "static bool hung_task_show_all_bt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define HUNG_TASK_LOCK_BREAK (HZ / 10)\n\nstatic int __read_mostly did_panic;\nstatic bool hung_task_show_lock;\nstatic bool hung_task_call_panic;\nstatic bool hung_task_show_all_bt;\n\nstatic void check_hung_uninterruptible_tasks(unsigned long timeout)\n{\n\tint max_count = sysctl_hung_task_check_count;\n\tunsigned long last_break = jiffies;\n\tstruct task_struct *g, *t;\n\n\t/*\n\t * If the system crashed already then all bets are off,\n\t * do not report extra hung tasks:\n\t */\n\tif (test_taint(TAINT_DIE) || did_panic)\n\t\treturn;\n\n\thung_task_show_lock = false;\n\trcu_read_lock();\n\tfor_each_process_thread(g, t) {\n\t\tif (!max_count--)\n\t\t\tgoto unlock;\n\t\tif (time_after(jiffies, last_break + HUNG_TASK_LOCK_BREAK)) {\n\t\t\tif (!rcu_lock_break(g, t))\n\t\t\t\tgoto unlock;\n\t\t\tlast_break = jiffies;\n\t\t}\n\t\t/* use \"==\" to skip the TASK_KILLABLE tasks waiting on NFS */\n\t\tif (READ_ONCE(t->__state) == TASK_UNINTERRUPTIBLE)\n\t\t\tcheck_hung_task(t, timeout);\n\t}\n unlock:\n\trcu_read_unlock();\n\tif (hung_task_show_lock)\n\t\tdebug_show_all_locks();\n\n\tif (hung_task_show_all_bt) {\n\t\thung_task_show_all_bt = false;\n\t\ttrigger_all_cpu_backtrace();\n\t}\n\n\tif (hung_task_call_panic)\n\t\tpanic(\"hung_task: blocked tasks\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&reset_hung_task",
            "0"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hung_timeout_jiffies",
          "args": [
            "hung_last_checked",
            "interval"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "hung_timeout_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
          "lines": "219-225",
          "snippet": "static long hung_timeout_jiffies(unsigned long last_checked,\n\t\t\t\t unsigned long timeout)\n{\n\t/* timeout of 0 will disable the watchdog */\n\treturn timeout ? last_checked - jiffies + timeout * HZ :\n\t\tMAX_SCHEDULE_TIMEOUT;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic long hung_timeout_jiffies(unsigned long last_checked,\n\t\t\t\t unsigned long timeout)\n{\n\t/* timeout of 0 will disable the watchdog */\n\treturn timeout ? last_checked - jiffies + timeout * HZ :\n\t\tMAX_SCHEDULE_TIMEOUT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "interval",
            "timeout"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "0"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly sysctl_hung_task_timeout_secs = CONFIG_DEFAULT_HUNG_TASK_TIMEOUT;\nunsigned long __read_mostly sysctl_hung_task_check_interval_secs;\n\nstatic int watchdog(void *dummy)\n{\n\tunsigned long hung_last_checked = jiffies;\n\n\tset_user_nice(current, 0);\n\n\tfor ( ; ; ) {\n\t\tunsigned long timeout = sysctl_hung_task_timeout_secs;\n\t\tunsigned long interval = sysctl_hung_task_check_interval_secs;\n\t\tlong t;\n\n\t\tif (interval == 0)\n\t\t\tinterval = timeout;\n\t\tinterval = min_t(unsigned long, interval, timeout);\n\t\tt = hung_timeout_jiffies(hung_last_checked, interval);\n\t\tif (t <= 0) {\n\t\t\tif (!atomic_xchg(&reset_hung_task, 0) &&\n\t\t\t    !hung_detector_suspended)\n\t\t\t\tcheck_hung_uninterruptible_tasks(timeout);\n\t\t\thung_last_checked = jiffies;\n\t\t\tcontinue;\n\t\t}\n\t\tschedule_timeout_interruptible(t);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hungtask_pm_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
    "lines": "328-346",
    "snippet": "static int hungtask_pm_notify(struct notifier_block *self,\n\t\t\t      unsigned long action, void *hcpu)\n{\n\tswitch (action) {\n\tcase PM_SUSPEND_PREPARE:\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_RESTORE_PREPARE:\n\t\thung_detector_suspended = true;\n\t\tbreak;\n\tcase PM_POST_SUSPEND:\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_RESTORE:\n\t\thung_detector_suspended = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int hungtask_pm_notify(struct notifier_block *self,\n\t\t\t      unsigned long action, void *hcpu)\n{\n\tswitch (action) {\n\tcase PM_SUSPEND_PREPARE:\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_RESTORE_PREPARE:\n\t\thung_detector_suspended = true;\n\t\tbreak;\n\tcase PM_POST_SUSPEND:\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_RESTORE:\n\t\thung_detector_suspended = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "reset_hung_task_detector",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
    "lines": "320-323",
    "snippet": "void reset_hung_task_detector(void)\n{\n\tatomic_set(&reset_hung_task, 1);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&reset_hung_task",
            "1"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nvoid reset_hung_task_detector(void)\n{\n\tatomic_set(&reset_hung_task, 1);\n}"
  },
  {
    "function_name": "hung_task_sysctl_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
    "lines": "309-312",
    "snippet": "static void __init hung_task_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", hung_task_sysctls);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_sysctl_init",
          "args": [
            "\"kernel\"",
            "hung_task_sysctls"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void __init hung_task_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", hung_task_sysctls);\n}"
  },
  {
    "function_name": "proc_dohung_task_timeout_secs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
    "lines": "231-246",
    "snippet": "static int proc_dohung_task_timeout_secs(struct ctl_table *table, int write,\n\t\t\t\t  void __user *buffer,\n\t\t\t\t  size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write)\n\t\tgoto out;\n\n\twake_up_process(watchdog_task);\n\n out:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *watchdog_task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "watchdog_task"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_doulongvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "proc_doulongvec_minmax",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "1603-1607",
          "snippet": "int proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nint proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *watchdog_task;\n\nstatic int proc_dohung_task_timeout_secs(struct ctl_table *table, int write,\n\t\t\t\t  void __user *buffer,\n\t\t\t\t  size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write)\n\t\tgoto out;\n\n\twake_up_process(watchdog_task);\n\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "hung_timeout_jiffies",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
    "lines": "219-225",
    "snippet": "static long hung_timeout_jiffies(unsigned long last_checked,\n\t\t\t\t unsigned long timeout)\n{\n\t/* timeout of 0 will disable the watchdog */\n\treturn timeout ? last_checked - jiffies + timeout * HZ :\n\t\tMAX_SCHEDULE_TIMEOUT;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic long hung_timeout_jiffies(unsigned long last_checked,\n\t\t\t\t unsigned long timeout)\n{\n\t/* timeout of 0 will disable the watchdog */\n\treturn timeout ? last_checked - jiffies + timeout * HZ :\n\t\tMAX_SCHEDULE_TIMEOUT;\n}"
  },
  {
    "function_name": "check_hung_uninterruptible_tasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
    "lines": "178-217",
    "snippet": "static void check_hung_uninterruptible_tasks(unsigned long timeout)\n{\n\tint max_count = sysctl_hung_task_check_count;\n\tunsigned long last_break = jiffies;\n\tstruct task_struct *g, *t;\n\n\t/*\n\t * If the system crashed already then all bets are off,\n\t * do not report extra hung tasks:\n\t */\n\tif (test_taint(TAINT_DIE) || did_panic)\n\t\treturn;\n\n\thung_task_show_lock = false;\n\trcu_read_lock();\n\tfor_each_process_thread(g, t) {\n\t\tif (!max_count--)\n\t\t\tgoto unlock;\n\t\tif (time_after(jiffies, last_break + HUNG_TASK_LOCK_BREAK)) {\n\t\t\tif (!rcu_lock_break(g, t))\n\t\t\t\tgoto unlock;\n\t\t\tlast_break = jiffies;\n\t\t}\n\t\t/* use \"==\" to skip the TASK_KILLABLE tasks waiting on NFS */\n\t\tif (READ_ONCE(t->__state) == TASK_UNINTERRUPTIBLE)\n\t\t\tcheck_hung_task(t, timeout);\n\t}\n unlock:\n\trcu_read_unlock();\n\tif (hung_task_show_lock)\n\t\tdebug_show_all_locks();\n\n\tif (hung_task_show_all_bt) {\n\t\thung_task_show_all_bt = false;\n\t\ttrigger_all_cpu_backtrace();\n\t}\n\n\tif (hung_task_call_panic)\n\t\tpanic(\"hung_task: blocked tasks\");\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define HUNG_TASK_LOCK_BREAK (HZ / 10)"
    ],
    "globals_used": [
      "static int __read_mostly did_panic;",
      "static bool hung_task_show_lock;",
      "static bool hung_task_call_panic;",
      "static bool hung_task_show_all_bt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"hung_task: blocked tasks\""
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_panic_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "74-85",
          "snippet": "static int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trigger_all_cpu_backtrace",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_show_all_locks",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "debug_show_all_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6456-6478",
          "snippet": "void debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_hung_task",
          "args": [
            "t",
            "timeout"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "check_hung_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
          "lines": "90-148",
          "snippet": "static void check_hung_task(struct task_struct *t, unsigned long timeout)\n{\n\tunsigned long switch_count = t->nvcsw + t->nivcsw;\n\n\t/*\n\t * Ensure the task is not frozen.\n\t * Also, skip vfork and any other user process that freezer should skip.\n\t */\n\tif (unlikely(t->flags & (PF_FROZEN | PF_FREEZER_SKIP)))\n\t    return;\n\n\t/*\n\t * When a freshly created task is scheduled once, changes its state to\n\t * TASK_UNINTERRUPTIBLE without having ever been switched out once, it\n\t * musn't be checked.\n\t */\n\tif (unlikely(!switch_count))\n\t\treturn;\n\n\tif (switch_count != t->last_switch_count) {\n\t\tt->last_switch_count = switch_count;\n\t\tt->last_switch_time = jiffies;\n\t\treturn;\n\t}\n\tif (time_is_after_jiffies(t->last_switch_time + timeout * HZ))\n\t\treturn;\n\n\ttrace_sched_process_hang(t);\n\n\tif (sysctl_hung_task_panic) {\n\t\tconsole_verbose();\n\t\thung_task_show_lock = true;\n\t\thung_task_call_panic = true;\n\t}\n\n\t/*\n\t * Ok, the task did not get scheduled for more than 2 minutes,\n\t * complain:\n\t */\n\tif (sysctl_hung_task_warnings) {\n\t\tif (sysctl_hung_task_warnings > 0)\n\t\t\tsysctl_hung_task_warnings--;\n\t\tpr_err(\"INFO: task %s:%d blocked for more than %ld seconds.\\n\",\n\t\t       t->comm, t->pid, (jiffies - t->last_switch_time) / HZ);\n\t\tpr_err(\"      %s %s %.*s\\n\",\n\t\t\tprint_tainted(), init_utsname()->release,\n\t\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\t\tinit_utsname()->version);\n\t\tpr_err(\"\\\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\\\"\"\n\t\t\t\" disables this message.\\n\");\n\t\tsched_show_task(t);\n\t\thung_task_show_lock = true;\n\n\t\tif (sysctl_hung_task_all_cpu_backtrace)\n\t\t\thung_task_show_all_bt = true;\n\t}\n\n\ttouch_nmi_watchdog();\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define sysctl_hung_task_all_cpu_backtrace 0"
          ],
          "globals_used": [
            "static bool hung_task_show_lock;",
            "static bool hung_task_call_panic;",
            "static bool hung_task_show_all_bt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define sysctl_hung_task_all_cpu_backtrace 0\n\nstatic bool hung_task_show_lock;\nstatic bool hung_task_call_panic;\nstatic bool hung_task_show_all_bt;\n\nstatic void check_hung_task(struct task_struct *t, unsigned long timeout)\n{\n\tunsigned long switch_count = t->nvcsw + t->nivcsw;\n\n\t/*\n\t * Ensure the task is not frozen.\n\t * Also, skip vfork and any other user process that freezer should skip.\n\t */\n\tif (unlikely(t->flags & (PF_FROZEN | PF_FREEZER_SKIP)))\n\t    return;\n\n\t/*\n\t * When a freshly created task is scheduled once, changes its state to\n\t * TASK_UNINTERRUPTIBLE without having ever been switched out once, it\n\t * musn't be checked.\n\t */\n\tif (unlikely(!switch_count))\n\t\treturn;\n\n\tif (switch_count != t->last_switch_count) {\n\t\tt->last_switch_count = switch_count;\n\t\tt->last_switch_time = jiffies;\n\t\treturn;\n\t}\n\tif (time_is_after_jiffies(t->last_switch_time + timeout * HZ))\n\t\treturn;\n\n\ttrace_sched_process_hang(t);\n\n\tif (sysctl_hung_task_panic) {\n\t\tconsole_verbose();\n\t\thung_task_show_lock = true;\n\t\thung_task_call_panic = true;\n\t}\n\n\t/*\n\t * Ok, the task did not get scheduled for more than 2 minutes,\n\t * complain:\n\t */\n\tif (sysctl_hung_task_warnings) {\n\t\tif (sysctl_hung_task_warnings > 0)\n\t\t\tsysctl_hung_task_warnings--;\n\t\tpr_err(\"INFO: task %s:%d blocked for more than %ld seconds.\\n\",\n\t\t       t->comm, t->pid, (jiffies - t->last_switch_time) / HZ);\n\t\tpr_err(\"      %s %s %.*s\\n\",\n\t\t\tprint_tainted(), init_utsname()->release,\n\t\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\t\tinit_utsname()->version);\n\t\tpr_err(\"\\\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\\\"\"\n\t\t\t\" disables this message.\\n\");\n\t\tsched_show_task(t);\n\t\thung_task_show_lock = true;\n\n\t\tif (sysctl_hung_task_all_cpu_backtrace)\n\t\t\thung_task_show_all_bt = true;\n\t}\n\n\ttouch_nmi_watchdog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "t->__state"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_lock_break",
          "args": [
            "g",
            "t"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lock_break",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
          "lines": "157-171",
          "snippet": "static bool rcu_lock_break(struct task_struct *g, struct task_struct *t)\n{\n\tbool can_cont;\n\n\tget_task_struct(g);\n\tget_task_struct(t);\n\trcu_read_unlock();\n\tcond_resched();\n\trcu_read_lock();\n\tcan_cont = pid_alive(g) && pid_alive(t);\n\tput_task_struct(t);\n\tput_task_struct(g);\n\n\treturn can_cont;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic bool rcu_lock_break(struct task_struct *g, struct task_struct *t)\n{\n\tbool can_cont;\n\n\tget_task_struct(g);\n\tget_task_struct(t);\n\trcu_read_unlock();\n\tcond_resched();\n\trcu_read_lock();\n\tcan_cont = pid_alive(g) && pid_alive(t);\n\tput_task_struct(t);\n\tput_task_struct(g);\n\n\treturn can_cont;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "last_break + HUNG_TASK_LOCK_BREAK"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "t"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_taint",
          "args": [
            "TAINT_DIE"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "test_taint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "421-424",
          "snippet": "int test_taint(unsigned flag)\n{\n\treturn test_bit(flag, &tainted_mask);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\n\nint test_taint(unsigned flag)\n{\n\treturn test_bit(flag, &tainted_mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define HUNG_TASK_LOCK_BREAK (HZ / 10)\n\nstatic int __read_mostly did_panic;\nstatic bool hung_task_show_lock;\nstatic bool hung_task_call_panic;\nstatic bool hung_task_show_all_bt;\n\nstatic void check_hung_uninterruptible_tasks(unsigned long timeout)\n{\n\tint max_count = sysctl_hung_task_check_count;\n\tunsigned long last_break = jiffies;\n\tstruct task_struct *g, *t;\n\n\t/*\n\t * If the system crashed already then all bets are off,\n\t * do not report extra hung tasks:\n\t */\n\tif (test_taint(TAINT_DIE) || did_panic)\n\t\treturn;\n\n\thung_task_show_lock = false;\n\trcu_read_lock();\n\tfor_each_process_thread(g, t) {\n\t\tif (!max_count--)\n\t\t\tgoto unlock;\n\t\tif (time_after(jiffies, last_break + HUNG_TASK_LOCK_BREAK)) {\n\t\t\tif (!rcu_lock_break(g, t))\n\t\t\t\tgoto unlock;\n\t\t\tlast_break = jiffies;\n\t\t}\n\t\t/* use \"==\" to skip the TASK_KILLABLE tasks waiting on NFS */\n\t\tif (READ_ONCE(t->__state) == TASK_UNINTERRUPTIBLE)\n\t\t\tcheck_hung_task(t, timeout);\n\t}\n unlock:\n\trcu_read_unlock();\n\tif (hung_task_show_lock)\n\t\tdebug_show_all_locks();\n\n\tif (hung_task_show_all_bt) {\n\t\thung_task_show_all_bt = false;\n\t\ttrigger_all_cpu_backtrace();\n\t}\n\n\tif (hung_task_call_panic)\n\t\tpanic(\"hung_task: blocked tasks\");\n}"
  },
  {
    "function_name": "rcu_lock_break",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
    "lines": "157-171",
    "snippet": "static bool rcu_lock_break(struct task_struct *g, struct task_struct *t)\n{\n\tbool can_cont;\n\n\tget_task_struct(g);\n\tget_task_struct(t);\n\trcu_read_unlock();\n\tcond_resched();\n\trcu_read_lock();\n\tcan_cont = pid_alive(g) && pid_alive(t);\n\tput_task_struct(t);\n\tput_task_struct(g);\n\n\treturn can_cont;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "g"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_alive",
          "args": [
            "t"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_alive",
          "args": [
            "g"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "t"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "g"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic bool rcu_lock_break(struct task_struct *g, struct task_struct *t)\n{\n\tbool can_cont;\n\n\tget_task_struct(g);\n\tget_task_struct(t);\n\trcu_read_unlock();\n\tcond_resched();\n\trcu_read_lock();\n\tcan_cont = pid_alive(g) && pid_alive(t);\n\tput_task_struct(t);\n\tput_task_struct(g);\n\n\treturn can_cont;\n}"
  },
  {
    "function_name": "check_hung_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
    "lines": "90-148",
    "snippet": "static void check_hung_task(struct task_struct *t, unsigned long timeout)\n{\n\tunsigned long switch_count = t->nvcsw + t->nivcsw;\n\n\t/*\n\t * Ensure the task is not frozen.\n\t * Also, skip vfork and any other user process that freezer should skip.\n\t */\n\tif (unlikely(t->flags & (PF_FROZEN | PF_FREEZER_SKIP)))\n\t    return;\n\n\t/*\n\t * When a freshly created task is scheduled once, changes its state to\n\t * TASK_UNINTERRUPTIBLE without having ever been switched out once, it\n\t * musn't be checked.\n\t */\n\tif (unlikely(!switch_count))\n\t\treturn;\n\n\tif (switch_count != t->last_switch_count) {\n\t\tt->last_switch_count = switch_count;\n\t\tt->last_switch_time = jiffies;\n\t\treturn;\n\t}\n\tif (time_is_after_jiffies(t->last_switch_time + timeout * HZ))\n\t\treturn;\n\n\ttrace_sched_process_hang(t);\n\n\tif (sysctl_hung_task_panic) {\n\t\tconsole_verbose();\n\t\thung_task_show_lock = true;\n\t\thung_task_call_panic = true;\n\t}\n\n\t/*\n\t * Ok, the task did not get scheduled for more than 2 minutes,\n\t * complain:\n\t */\n\tif (sysctl_hung_task_warnings) {\n\t\tif (sysctl_hung_task_warnings > 0)\n\t\t\tsysctl_hung_task_warnings--;\n\t\tpr_err(\"INFO: task %s:%d blocked for more than %ld seconds.\\n\",\n\t\t       t->comm, t->pid, (jiffies - t->last_switch_time) / HZ);\n\t\tpr_err(\"      %s %s %.*s\\n\",\n\t\t\tprint_tainted(), init_utsname()->release,\n\t\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\t\tinit_utsname()->version);\n\t\tpr_err(\"\\\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\\\"\"\n\t\t\t\" disables this message.\\n\");\n\t\tsched_show_task(t);\n\t\thung_task_show_lock = true;\n\n\t\tif (sysctl_hung_task_all_cpu_backtrace)\n\t\t\thung_task_show_all_bt = true;\n\t}\n\n\ttouch_nmi_watchdog();\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define sysctl_hung_task_all_cpu_backtrace 0"
    ],
    "globals_used": [
      "static bool hung_task_show_lock;",
      "static bool hung_task_call_panic;",
      "static bool hung_task_show_all_bt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_show_task",
          "args": [
            "t"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "sched_show_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8544-8572",
          "snippet": "void sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tpr_info(\"task:%-15.15s state:%c\", p->comm, task_state_to_char(p));\n\n\tif (task_is_running(p))\n\t\tpr_cont(\"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpr_cont(\" stack:%5lu pid:%5d ppid:%6d flags:0x%08lx\\n\",\n\t\tfree, task_pid_nr(p), ppid,\n\t\tread_task_thread_flags(p));\n\n\tprint_worker_info(KERN_INFO, p);\n\tprint_stop_info(KERN_INFO, p);\n\tshow_stack(p, NULL, KERN_INFO);\n\tput_task_stack(p);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tpr_info(\"task:%-15.15s state:%c\", p->comm, task_state_to_char(p));\n\n\tif (task_is_running(p))\n\t\tpr_cont(\"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpr_cont(\" stack:%5lu pid:%5d ppid:%6d flags:0x%08lx\\n\",\n\t\tfree, task_pid_nr(p), ppid,\n\t\tread_task_thread_flags(p));\n\n\tprint_worker_info(KERN_INFO, p);\n\tprint_stop_info(KERN_INFO, p);\n\tshow_stack(p, NULL, KERN_INFO);\n\tput_task_stack(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\\\"\"\n\t\t\t\" disables this message.\\n\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"      %s %s %.*s\\n\"",
            "print_tainted()",
            "init_utsname()->release",
            "(int)strcspn(init_utsname()->version, \" \")",
            "init_utsname()->version"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "init_utsname()->version",
            "\" \""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_tainted",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "print_tainted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "398-419",
          "snippet": "const char *print_tainted(void)\n{\n\tstatic char buf[TAINT_FLAGS_COUNT + sizeof(\"Tainted: \")];\n\n\tBUILD_BUG_ON(ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT);\n\n\tif (tainted_mask) {\n\t\tchar *s;\n\t\tint i;\n\n\t\ts = buf + sprintf(buf, \"Tainted: \");\n\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++) {\n\t\t\tconst struct taint_flag *t = &taint_flags[i];\n\t\t\t*s++ = test_bit(i, &tainted_mask) ?\n\t\t\t\t\tt->c_true : t->c_false;\n\t\t}\n\t\t*s = 0;\n\t} else\n\t\tsnprintf(buf, sizeof(buf), \"Not tainted\");\n\n\treturn buf;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;",
            "const struct taint_flag taint_flags[TAINT_FLAGS_COUNT] = {\n\t[ TAINT_PROPRIETARY_MODULE ]\t= { 'P', 'G', true },\n\t[ TAINT_FORCED_MODULE ]\t\t= { 'F', ' ', true },\n\t[ TAINT_CPU_OUT_OF_SPEC ]\t= { 'S', ' ', false },\n\t[ TAINT_FORCED_RMMOD ]\t\t= { 'R', ' ', false },\n\t[ TAINT_MACHINE_CHECK ]\t\t= { 'M', ' ', false },\n\t[ TAINT_BAD_PAGE ]\t\t= { 'B', ' ', false },\n\t[ TAINT_USER ]\t\t\t= { 'U', ' ', false },\n\t[ TAINT_DIE ]\t\t\t= { 'D', ' ', false },\n\t[ TAINT_OVERRIDDEN_ACPI_TABLE ]\t= { 'A', ' ', false },\n\t[ TAINT_WARN ]\t\t\t= { 'W', ' ', false },\n\t[ TAINT_CRAP ]\t\t\t= { 'C', ' ', true },\n\t[ TAINT_FIRMWARE_WORKAROUND ]\t= { 'I', ' ', false },\n\t[ TAINT_OOT_MODULE ]\t\t= { 'O', ' ', true },\n\t[ TAINT_UNSIGNED_MODULE ]\t= { 'E', ' ', true },\n\t[ TAINT_SOFTLOCKUP ]\t\t= { 'L', ' ', false },\n\t[ TAINT_LIVEPATCH ]\t\t= { 'K', ' ', true },\n\t[ TAINT_AUX ]\t\t\t= { 'X', ' ', true },\n\t[ TAINT_RANDSTRUCT ]\t\t= { 'T', ' ', true },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\nconst struct taint_flag taint_flags[TAINT_FLAGS_COUNT] = {\n\t[ TAINT_PROPRIETARY_MODULE ]\t= { 'P', 'G', true },\n\t[ TAINT_FORCED_MODULE ]\t\t= { 'F', ' ', true },\n\t[ TAINT_CPU_OUT_OF_SPEC ]\t= { 'S', ' ', false },\n\t[ TAINT_FORCED_RMMOD ]\t\t= { 'R', ' ', false },\n\t[ TAINT_MACHINE_CHECK ]\t\t= { 'M', ' ', false },\n\t[ TAINT_BAD_PAGE ]\t\t= { 'B', ' ', false },\n\t[ TAINT_USER ]\t\t\t= { 'U', ' ', false },\n\t[ TAINT_DIE ]\t\t\t= { 'D', ' ', false },\n\t[ TAINT_OVERRIDDEN_ACPI_TABLE ]\t= { 'A', ' ', false },\n\t[ TAINT_WARN ]\t\t\t= { 'W', ' ', false },\n\t[ TAINT_CRAP ]\t\t\t= { 'C', ' ', true },\n\t[ TAINT_FIRMWARE_WORKAROUND ]\t= { 'I', ' ', false },\n\t[ TAINT_OOT_MODULE ]\t\t= { 'O', ' ', true },\n\t[ TAINT_UNSIGNED_MODULE ]\t= { 'E', ' ', true },\n\t[ TAINT_SOFTLOCKUP ]\t\t= { 'L', ' ', false },\n\t[ TAINT_LIVEPATCH ]\t\t= { 'K', ' ', true },\n\t[ TAINT_AUX ]\t\t\t= { 'X', ' ', true },\n\t[ TAINT_RANDSTRUCT ]\t\t= { 'T', ' ', true },\n};\n\nconst char *print_tainted(void)\n{\n\tstatic char buf[TAINT_FLAGS_COUNT + sizeof(\"Tainted: \")];\n\n\tBUILD_BUG_ON(ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT);\n\n\tif (tainted_mask) {\n\t\tchar *s;\n\t\tint i;\n\n\t\ts = buf + sprintf(buf, \"Tainted: \");\n\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++) {\n\t\t\tconst struct taint_flag *t = &taint_flags[i];\n\t\t\t*s++ = test_bit(i, &tainted_mask) ?\n\t\t\t\t\tt->c_true : t->c_false;\n\t\t}\n\t\t*s = 0;\n\t} else\n\t\tsnprintf(buf, sizeof(buf), \"Not tainted\");\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: task %s:%d blocked for more than %ld seconds.\\n\"",
            "t->comm",
            "t->pid",
            "(jiffies - t->last_switch_time) / HZ"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_verbose",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "console_verbose",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2459-2463",
          "snippet": "void console_verbose(void)\n{\n\tif (console_loglevel && !printk_console_no_auto_verbose)\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool printk_console_no_auto_verbose;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic bool printk_console_no_auto_verbose;\n\nvoid console_verbose(void)\n{\n\tif (console_loglevel && !printk_console_no_auto_verbose)\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_process_hang",
          "args": [
            "t"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_is_after_jiffies",
          "args": [
            "t->last_switch_time + timeout * HZ"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!switch_count"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "t->flags & (PF_FROZEN | PF_FREEZER_SKIP)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define sysctl_hung_task_all_cpu_backtrace 0\n\nstatic bool hung_task_show_lock;\nstatic bool hung_task_call_panic;\nstatic bool hung_task_show_all_bt;\n\nstatic void check_hung_task(struct task_struct *t, unsigned long timeout)\n{\n\tunsigned long switch_count = t->nvcsw + t->nivcsw;\n\n\t/*\n\t * Ensure the task is not frozen.\n\t * Also, skip vfork and any other user process that freezer should skip.\n\t */\n\tif (unlikely(t->flags & (PF_FROZEN | PF_FREEZER_SKIP)))\n\t    return;\n\n\t/*\n\t * When a freshly created task is scheduled once, changes its state to\n\t * TASK_UNINTERRUPTIBLE without having ever been switched out once, it\n\t * musn't be checked.\n\t */\n\tif (unlikely(!switch_count))\n\t\treturn;\n\n\tif (switch_count != t->last_switch_count) {\n\t\tt->last_switch_count = switch_count;\n\t\tt->last_switch_time = jiffies;\n\t\treturn;\n\t}\n\tif (time_is_after_jiffies(t->last_switch_time + timeout * HZ))\n\t\treturn;\n\n\ttrace_sched_process_hang(t);\n\n\tif (sysctl_hung_task_panic) {\n\t\tconsole_verbose();\n\t\thung_task_show_lock = true;\n\t\thung_task_call_panic = true;\n\t}\n\n\t/*\n\t * Ok, the task did not get scheduled for more than 2 minutes,\n\t * complain:\n\t */\n\tif (sysctl_hung_task_warnings) {\n\t\tif (sysctl_hung_task_warnings > 0)\n\t\t\tsysctl_hung_task_warnings--;\n\t\tpr_err(\"INFO: task %s:%d blocked for more than %ld seconds.\\n\",\n\t\t       t->comm, t->pid, (jiffies - t->last_switch_time) / HZ);\n\t\tpr_err(\"      %s %s %.*s\\n\",\n\t\t\tprint_tainted(), init_utsname()->release,\n\t\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\t\tinit_utsname()->version);\n\t\tpr_err(\"\\\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\\\"\"\n\t\t\t\" disables this message.\\n\");\n\t\tsched_show_task(t);\n\t\thung_task_show_lock = true;\n\n\t\tif (sysctl_hung_task_all_cpu_backtrace)\n\t\t\thung_task_show_all_bt = true;\n\t}\n\n\ttouch_nmi_watchdog();\n}"
  },
  {
    "function_name": "hung_task_panic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/hung_task.c",
    "lines": "78-84",
    "snippet": "static int\nhung_task_panic(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tdid_panic = 1;\n\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __read_mostly did_panic;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/panic_notifier.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __read_mostly did_panic;\n\nstatic int\nhung_task_panic(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tdid_panic = 1;\n\n\treturn NOTIFY_DONE;\n}"
  }
]