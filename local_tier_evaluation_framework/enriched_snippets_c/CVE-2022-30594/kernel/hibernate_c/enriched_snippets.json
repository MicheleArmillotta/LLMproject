[
  {
    "function_name": "nohibernate_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1335-1340",
    "snippet": "static int __init nohibernate_setup(char *str)\n{\n\tnoresume = 1;\n\tnohibernate = 1;\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int noresume;",
      "static int nohibernate;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int noresume;\nstatic int nohibernate;\n\nstatic int __init nohibernate_setup(char *str)\n{\n\tnoresume = 1;\n\tnohibernate = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "resumedelay_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1326-1333",
    "snippet": "static int __init resumedelay_setup(char *str)\n{\n\tint rc = kstrtouint(str, 0, &resume_delay);\n\n\tif (rc)\n\t\treturn rc;\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int resume_delay;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "str",
            "0",
            "&resume_delay"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic unsigned int resume_delay;\n\nstatic int __init resumedelay_setup(char *str)\n{\n\tint rc = kstrtouint(str, 0, &resume_delay);\n\n\tif (rc)\n\t\treturn rc;\n\treturn 1;\n}"
  },
  {
    "function_name": "resumewait_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1320-1324",
    "snippet": "static int __init resumewait_setup(char *str)\n{\n\tresume_wait = 1;\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int resume_wait;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int resume_wait;\n\nstatic int __init resumewait_setup(char *str)\n{\n\tresume_wait = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "noresume_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1314-1318",
    "snippet": "static int __init noresume_setup(char *str)\n{\n\tnoresume = 1;\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int noresume;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int noresume;\n\nstatic int __init noresume_setup(char *str)\n{\n\tnoresume = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "hibernate_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1298-1312",
    "snippet": "static int __init hibernate_setup(char *str)\n{\n\tif (!strncmp(str, \"noresume\", 8)) {\n\t\tnoresume = 1;\n\t} else if (!strncmp(str, \"nocompress\", 10)) {\n\t\tnocompress = 1;\n\t} else if (!strncmp(str, \"no\", 2)) {\n\t\tnoresume = 1;\n\t\tnohibernate = 1;\n\t} else if (IS_ENABLED(CONFIG_STRICT_KERNEL_RWX)\n\t\t   && !strncmp(str, \"protect_image\", 13)) {\n\t\tenable_restore_image_protection();\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nocompress;",
      "static int noresume;",
      "static int nohibernate;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_restore_image_protection",
          "args": [],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "enable_restore_image_protection",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "71-71",
          "snippet": "static inline void enable_restore_image_protection(void) {}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void enable_restore_image_protection(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"protect_image\"",
            "13"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_STRICT_KERNEL_RWX"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"no\"",
            "2"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"nocompress\"",
            "10"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"noresume\"",
            "8"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nocompress;\nstatic int noresume;\nstatic int nohibernate;\n\nstatic int __init hibernate_setup(char *str)\n{\n\tif (!strncmp(str, \"noresume\", 8)) {\n\t\tnoresume = 1;\n\t} else if (!strncmp(str, \"nocompress\", 10)) {\n\t\tnocompress = 1;\n\t} else if (!strncmp(str, \"no\", 2)) {\n\t\tnoresume = 1;\n\t\tnohibernate = 1;\n\t} else if (IS_ENABLED(CONFIG_STRICT_KERNEL_RWX)\n\t\t   && !strncmp(str, \"protect_image\", 13)) {\n\t\tenable_restore_image_protection();\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "resume_offset_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1285-1296",
    "snippet": "static int __init resume_offset_setup(char *str)\n{\n\tunsigned long long offset;\n\n\tif (noresume)\n\t\treturn 1;\n\n\tif (sscanf(str, \"%llu\", &offset) == 1)\n\t\tswsusp_resume_block = offset;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int noresume;",
      "sector_t swsusp_resume_block;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%llu\"",
            "&offset"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int noresume;\nsector_t swsusp_resume_block;\n\nstatic int __init resume_offset_setup(char *str)\n{\n\tunsigned long long offset;\n\n\tif (noresume)\n\t\treturn 1;\n\n\tif (sscanf(str, \"%llu\", &offset) == 1)\n\t\tswsusp_resume_block = offset;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "resume_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1276-1283",
    "snippet": "static int __init resume_setup(char *str)\n{\n\tif (noresume)\n\t\treturn 1;\n\n\tstrncpy(resume_file, str, 255);\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int noresume;",
      "static char resume_file[256] = CONFIG_PM_STD_PARTITION;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "resume_file",
            "str",
            "255"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int noresume;\nstatic char resume_file[256] = CONFIG_PM_STD_PARTITION;\n\nstatic int __init resume_setup(char *str)\n{\n\tif (noresume)\n\t\treturn 1;\n\n\tstrncpy(resume_file, str, 255);\n\treturn 1;\n}"
  },
  {
    "function_name": "pm_disk_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1268-1271",
    "snippet": "static int __init pm_disk_init(void)\n{\n\treturn sysfs_create_group(power_kobj, &attr_group);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct attribute_group attr_group = {\n\t.attrs = g,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "power_kobj",
            "&attr_group"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct attribute_group attr_group = {\n\t.attrs = g,\n};\n\nstatic int __init pm_disk_init(void)\n{\n\treturn sysfs_create_group(power_kobj, &attr_group);\n}"
  },
  {
    "function_name": "reserved_size_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1237-1249",
    "snippet": "static ssize_t reserved_size_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t n)\n{\n\tunsigned long size;\n\n\tif (sscanf(buf, \"%lu\", &size) == 1) {\n\t\treserved_size = size;\n\t\treturn n;\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%lu\"",
            "&size"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic ssize_t reserved_size_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t n)\n{\n\tunsigned long size;\n\n\tif (sscanf(buf, \"%lu\", &size) == 1) {\n\t\treserved_size = size;\n\t\treturn n;\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "reserved_size_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1231-1235",
    "snippet": "static ssize_t reserved_size_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", reserved_size);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "reserved_size"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic ssize_t reserved_size_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", reserved_size);\n}"
  },
  {
    "function_name": "image_size_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1216-1227",
    "snippet": "static ssize_t image_size_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned long size;\n\n\tif (sscanf(buf, \"%lu\", &size) == 1) {\n\t\timage_size = size;\n\t\treturn n;\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%lu\"",
            "&size"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic ssize_t image_size_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned long size;\n\n\tif (sscanf(buf, \"%lu\", &size) == 1) {\n\t\timage_size = size;\n\t\treturn n;\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "image_size_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1210-1214",
    "snippet": "static ssize_t image_size_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t       char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", image_size);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "image_size"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic ssize_t image_size_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t       char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", image_size);\n}"
  },
  {
    "function_name": "resume_offset_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1193-1206",
    "snippet": "static ssize_t resume_offset_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, const char *buf,\n\t\t\t\t   size_t n)\n{\n\tunsigned long long offset;\n\tint rc;\n\n\trc = kstrtoull(buf, 0, &offset);\n\tif (rc)\n\t\treturn rc;\n\tswsusp_resume_block = offset;\n\n\treturn n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "sector_t swsusp_resume_block;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoull",
          "args": [
            "buf",
            "0",
            "&offset"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nsector_t swsusp_resume_block;\n\nstatic ssize_t resume_offset_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, const char *buf,\n\t\t\t\t   size_t n)\n{\n\tunsigned long long offset;\n\tint rc;\n\n\trc = kstrtoull(buf, 0, &offset);\n\tif (rc)\n\t\treturn rc;\n\tswsusp_resume_block = offset;\n\n\treturn n;\n}"
  },
  {
    "function_name": "resume_offset_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1187-1191",
    "snippet": "static ssize_t resume_offset_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%llu\\n\", (unsigned long long)swsusp_resume_block);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "sector_t swsusp_resume_block;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%llu\\n\"",
            "(unsigned long long)swsusp_resume_block"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nsector_t swsusp_resume_block;\n\nstatic ssize_t resume_offset_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%llu\\n\", (unsigned long long)swsusp_resume_block);\n}"
  },
  {
    "function_name": "resume_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1157-1183",
    "snippet": "static ssize_t resume_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t n)\n{\n\tdev_t res;\n\tint len = n;\n\tchar *name;\n\n\tif (len && buf[len-1] == '\\n')\n\t\tlen--;\n\tname = kstrndup(buf, len, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tres = name_to_dev_t(name);\n\tkfree(name);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tlock_system_sleep();\n\tswsusp_resume_device = res;\n\tunlock_system_sleep();\n\tpm_pr_dbg(\"Configured hibernation resume from disk to %u\\n\",\n\t\t  swsusp_resume_device);\n\tnoresume = 0;\n\tsoftware_resume();\n\treturn n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int noresume;",
      "dev_t swsusp_resume_device;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "software_resume",
          "args": [],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "software_resume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "914-1023",
          "snippet": "static int software_resume(void)\n{\n\tint error;\n\n\t/*\n\t * If the user said \"noresume\".. bail out early.\n\t */\n\tif (noresume || !hibernation_available())\n\t\treturn 0;\n\n\t/*\n\t * name_to_dev_t() below takes a sysfs buffer mutex when sysfs\n\t * is configured into the kernel. Since the regular hibernate\n\t * trigger path is via sysfs which takes a buffer mutex before\n\t * calling hibernate functions (which take system_transition_mutex)\n\t * this can cause lockdep to complain about a possible ABBA deadlock\n\t * which cannot happen since we're in the boot code here and\n\t * sysfs can't be invoked yet. Therefore, we use a subclass\n\t * here to avoid lockdep complaining.\n\t */\n\tmutex_lock_nested(&system_transition_mutex, SINGLE_DEPTH_NESTING);\n\n\tif (swsusp_resume_device)\n\t\tgoto Check_image;\n\n\tif (!strlen(resume_file)) {\n\t\terror = -ENOENT;\n\t\tgoto Unlock;\n\t}\n\n\tpm_pr_dbg(\"Checking hibernation image partition %s\\n\", resume_file);\n\n\tif (resume_delay) {\n\t\tpr_info(\"Waiting %dsec before reading resume device ...\\n\",\n\t\t\tresume_delay);\n\t\tssleep(resume_delay);\n\t}\n\n\t/* Check if the device is there */\n\tswsusp_resume_device = name_to_dev_t(resume_file);\n\tif (!swsusp_resume_device) {\n\t\t/*\n\t\t * Some device discovery might still be in progress; we need\n\t\t * to wait for this to finish.\n\t\t */\n\t\twait_for_device_probe();\n\n\t\tif (resume_wait) {\n\t\t\twhile ((swsusp_resume_device = name_to_dev_t(resume_file)) == 0)\n\t\t\t\tmsleep(10);\n\t\t\tasync_synchronize_full();\n\t\t}\n\n\t\tswsusp_resume_device = name_to_dev_t(resume_file);\n\t\tif (!swsusp_resume_device) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto Unlock;\n\t\t}\n\t}\n\n Check_image:\n\tpm_pr_dbg(\"Hibernation image partition %d:%d present\\n\",\n\t\tMAJOR(swsusp_resume_device), MINOR(swsusp_resume_device));\n\n\tpm_pr_dbg(\"Looking for hibernation image.\\n\");\n\terror = swsusp_check();\n\tif (error)\n\t\tgoto Unlock;\n\n\t/* The snapshot device should not be opened while we're running */\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tswsusp_close(FMODE_READ | FMODE_EXCL);\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"resume from hibernation\\n\");\n\tpm_prepare_console();\n\terror = pm_notifier_call_chain_robust(PM_RESTORE_PREPARE, PM_POST_RESTORE);\n\tif (error)\n\t\tgoto Restore;\n\n\tpm_pr_dbg(\"Preparing processes for hibernation restore.\\n\");\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Close_Finish;\n\n\terror = freeze_kernel_threads();\n\tif (error) {\n\t\tthaw_processes();\n\t\tgoto Close_Finish;\n\t}\n\n\terror = load_image_and_restore();\n\tthaw_processes();\n Finish:\n\tpm_notifier_call_chain(PM_POST_RESTORE);\n Restore:\n\tpm_restore_console();\n\tpr_info(\"resume failed (%d)\\n\", error);\n\thibernate_release();\n\t/* For success case, the suspend path will release the lock */\n Unlock:\n\tmutex_unlock(&system_transition_mutex);\n\tpm_pr_dbg(\"Hibernation image not present or could not be loaded.\\n\");\n\treturn error;\n Close_Finish:\n\tswsusp_close(FMODE_READ | FMODE_EXCL);\n\tgoto Finish;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int noresume;",
            "static int resume_wait;",
            "static unsigned int resume_delay;",
            "static char resume_file[256] = CONFIG_PM_STD_PARTITION;",
            "dev_t swsusp_resume_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int noresume;\nstatic int resume_wait;\nstatic unsigned int resume_delay;\nstatic char resume_file[256] = CONFIG_PM_STD_PARTITION;\ndev_t swsusp_resume_device;\n\nstatic int software_resume(void)\n{\n\tint error;\n\n\t/*\n\t * If the user said \"noresume\".. bail out early.\n\t */\n\tif (noresume || !hibernation_available())\n\t\treturn 0;\n\n\t/*\n\t * name_to_dev_t() below takes a sysfs buffer mutex when sysfs\n\t * is configured into the kernel. Since the regular hibernate\n\t * trigger path is via sysfs which takes a buffer mutex before\n\t * calling hibernate functions (which take system_transition_mutex)\n\t * this can cause lockdep to complain about a possible ABBA deadlock\n\t * which cannot happen since we're in the boot code here and\n\t * sysfs can't be invoked yet. Therefore, we use a subclass\n\t * here to avoid lockdep complaining.\n\t */\n\tmutex_lock_nested(&system_transition_mutex, SINGLE_DEPTH_NESTING);\n\n\tif (swsusp_resume_device)\n\t\tgoto Check_image;\n\n\tif (!strlen(resume_file)) {\n\t\terror = -ENOENT;\n\t\tgoto Unlock;\n\t}\n\n\tpm_pr_dbg(\"Checking hibernation image partition %s\\n\", resume_file);\n\n\tif (resume_delay) {\n\t\tpr_info(\"Waiting %dsec before reading resume device ...\\n\",\n\t\t\tresume_delay);\n\t\tssleep(resume_delay);\n\t}\n\n\t/* Check if the device is there */\n\tswsusp_resume_device = name_to_dev_t(resume_file);\n\tif (!swsusp_resume_device) {\n\t\t/*\n\t\t * Some device discovery might still be in progress; we need\n\t\t * to wait for this to finish.\n\t\t */\n\t\twait_for_device_probe();\n\n\t\tif (resume_wait) {\n\t\t\twhile ((swsusp_resume_device = name_to_dev_t(resume_file)) == 0)\n\t\t\t\tmsleep(10);\n\t\t\tasync_synchronize_full();\n\t\t}\n\n\t\tswsusp_resume_device = name_to_dev_t(resume_file);\n\t\tif (!swsusp_resume_device) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto Unlock;\n\t\t}\n\t}\n\n Check_image:\n\tpm_pr_dbg(\"Hibernation image partition %d:%d present\\n\",\n\t\tMAJOR(swsusp_resume_device), MINOR(swsusp_resume_device));\n\n\tpm_pr_dbg(\"Looking for hibernation image.\\n\");\n\terror = swsusp_check();\n\tif (error)\n\t\tgoto Unlock;\n\n\t/* The snapshot device should not be opened while we're running */\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tswsusp_close(FMODE_READ | FMODE_EXCL);\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"resume from hibernation\\n\");\n\tpm_prepare_console();\n\terror = pm_notifier_call_chain_robust(PM_RESTORE_PREPARE, PM_POST_RESTORE);\n\tif (error)\n\t\tgoto Restore;\n\n\tpm_pr_dbg(\"Preparing processes for hibernation restore.\\n\");\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Close_Finish;\n\n\terror = freeze_kernel_threads();\n\tif (error) {\n\t\tthaw_processes();\n\t\tgoto Close_Finish;\n\t}\n\n\terror = load_image_and_restore();\n\tthaw_processes();\n Finish:\n\tpm_notifier_call_chain(PM_POST_RESTORE);\n Restore:\n\tpm_restore_console();\n\tpr_info(\"resume failed (%d)\\n\", error);\n\thibernate_release();\n\t/* For success case, the suspend path will release the lock */\n Unlock:\n\tmutex_unlock(&system_transition_mutex);\n\tpm_pr_dbg(\"Hibernation image not present or could not be loaded.\\n\");\n\treturn error;\n Close_Finish:\n\tswsusp_close(FMODE_READ | FMODE_EXCL);\n\tgoto Finish;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Configured hibernation resume from disk to %u\\n\"",
            "swsusp_resume_device"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "__pm_pr_dbg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "553-572",
          "snippet": "void __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "name_to_dev_t",
          "args": [
            "name"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "buf",
            "len",
            "GFP_KERNEL"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int noresume;\ndev_t swsusp_resume_device;\n\nstatic ssize_t resume_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t n)\n{\n\tdev_t res;\n\tint len = n;\n\tchar *name;\n\n\tif (len && buf[len-1] == '\\n')\n\t\tlen--;\n\tname = kstrndup(buf, len, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tres = name_to_dev_t(name);\n\tkfree(name);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tlock_system_sleep();\n\tswsusp_resume_device = res;\n\tunlock_system_sleep();\n\tpm_pr_dbg(\"Configured hibernation resume from disk to %u\\n\",\n\t\t  swsusp_resume_device);\n\tnoresume = 0;\n\tsoftware_resume();\n\treturn n;\n}"
  },
  {
    "function_name": "resume_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1150-1155",
    "snippet": "static ssize_t resume_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sprintf(buf, \"%d:%d\\n\", MAJOR(swsusp_resume_device),\n\t\t       MINOR(swsusp_resume_device));\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "dev_t swsusp_resume_device;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d:%d\\n\"",
            "MAJOR(swsusp_resume_device)",
            "MINOR(swsusp_resume_device)"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "swsusp_resume_device"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "swsusp_resume_device"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\ndev_t swsusp_resume_device;\n\nstatic ssize_t resume_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sprintf(buf, \"%d:%d\\n\", MAJOR(swsusp_resume_device),\n\t\t       MINOR(swsusp_resume_device));\n}"
  },
  {
    "function_name": "disk_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1099-1146",
    "snippet": "static ssize_t disk_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t n)\n{\n\tint error = 0;\n\tint i;\n\tint len;\n\tchar *p;\n\tint mode = HIBERNATION_INVALID;\n\n\tif (!hibernation_available())\n\t\treturn -EPERM;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tlock_system_sleep();\n\tfor (i = HIBERNATION_FIRST; i <= HIBERNATION_MAX; i++) {\n\t\tif (len == strlen(hibernation_modes[i])\n\t\t    && !strncmp(buf, hibernation_modes[i], len)) {\n\t\t\tmode = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode != HIBERNATION_INVALID) {\n\t\tswitch (mode) {\n\t\tcase HIBERNATION_SHUTDOWN:\n\t\tcase HIBERNATION_REBOOT:\n#ifdef CONFIG_SUSPEND\n\t\tcase HIBERNATION_SUSPEND:\n#endif\n\t\tcase HIBERNATION_TEST_RESUME:\n\t\t\thibernation_mode = mode;\n\t\t\tbreak;\n\t\tcase HIBERNATION_PLATFORM:\n\t\t\tif (hibernation_ops)\n\t\t\t\thibernation_mode = mode;\n\t\t\telse\n\t\t\t\terror = -EINVAL;\n\t\t}\n\t} else\n\t\terror = -EINVAL;\n\n\tif (!error)\n\t\tpm_pr_dbg(\"Hibernation mode set to '%s'\\n\",\n\t\t\t       hibernation_modes[mode]);\n\tunlock_system_sleep();\n\treturn error ? error : n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define HIBERNATION_FIRST (HIBERNATION_INVALID + 1)",
      "#define HIBERNATION_MAX (__HIBERNATION_AFTER_LAST-1)"
    ],
    "globals_used": [
      "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
      "static const struct platform_hibernation_ops *hibernation_ops;",
      "static const char * const hibernation_modes[] = {\n\t[HIBERNATION_PLATFORM]\t= \"platform\",\n\t[HIBERNATION_SHUTDOWN]\t= \"shutdown\",\n\t[HIBERNATION_REBOOT]\t= \"reboot\",\n#ifdef CONFIG_SUSPEND\n\t[HIBERNATION_SUSPEND]\t= \"suspend\",\n#endif\n\t[HIBERNATION_TEST_RESUME]\t= \"test_resume\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Hibernation mode set to '%s'\\n\"",
            "hibernation_modes[mode]"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "__pm_pr_dbg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "553-572",
          "snippet": "void __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "hibernation_modes[i]",
            "len"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hibernation_modes[i]"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buf",
            "'\\n'",
            "n"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_available",
          "args": [],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "83-88",
          "snippet": "bool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nohibernate;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\n#define HIBERNATION_FIRST (HIBERNATION_INVALID + 1)\n#define HIBERNATION_MAX (__HIBERNATION_AFTER_LAST-1)\n\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nstatic const struct platform_hibernation_ops *hibernation_ops;\nstatic const char * const hibernation_modes[] = {\n\t[HIBERNATION_PLATFORM]\t= \"platform\",\n\t[HIBERNATION_SHUTDOWN]\t= \"shutdown\",\n\t[HIBERNATION_REBOOT]\t= \"reboot\",\n#ifdef CONFIG_SUSPEND\n\t[HIBERNATION_SUSPEND]\t= \"suspend\",\n#endif\n\t[HIBERNATION_TEST_RESUME]\t= \"test_resume\",\n};\n\nstatic ssize_t disk_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t n)\n{\n\tint error = 0;\n\tint i;\n\tint len;\n\tchar *p;\n\tint mode = HIBERNATION_INVALID;\n\n\tif (!hibernation_available())\n\t\treturn -EPERM;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tlock_system_sleep();\n\tfor (i = HIBERNATION_FIRST; i <= HIBERNATION_MAX; i++) {\n\t\tif (len == strlen(hibernation_modes[i])\n\t\t    && !strncmp(buf, hibernation_modes[i], len)) {\n\t\t\tmode = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode != HIBERNATION_INVALID) {\n\t\tswitch (mode) {\n\t\tcase HIBERNATION_SHUTDOWN:\n\t\tcase HIBERNATION_REBOOT:\n#ifdef CONFIG_SUSPEND\n\t\tcase HIBERNATION_SUSPEND:\n#endif\n\t\tcase HIBERNATION_TEST_RESUME:\n\t\t\thibernation_mode = mode;\n\t\t\tbreak;\n\t\tcase HIBERNATION_PLATFORM:\n\t\t\tif (hibernation_ops)\n\t\t\t\thibernation_mode = mode;\n\t\t\telse\n\t\t\t\terror = -EINVAL;\n\t\t}\n\t} else\n\t\terror = -EINVAL;\n\n\tif (!error)\n\t\tpm_pr_dbg(\"Hibernation mode set to '%s'\\n\",\n\t\t\t       hibernation_modes[mode]);\n\tunlock_system_sleep();\n\treturn error ? error : n;\n}"
  },
  {
    "function_name": "disk_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "1064-1097",
    "snippet": "static ssize_t disk_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tint i;\n\tchar *start = buf;\n\n\tif (!hibernation_available())\n\t\treturn sprintf(buf, \"[disabled]\\n\");\n\n\tfor (i = HIBERNATION_FIRST; i <= HIBERNATION_MAX; i++) {\n\t\tif (!hibernation_modes[i])\n\t\t\tcontinue;\n\t\tswitch (i) {\n\t\tcase HIBERNATION_SHUTDOWN:\n\t\tcase HIBERNATION_REBOOT:\n#ifdef CONFIG_SUSPEND\n\t\tcase HIBERNATION_SUSPEND:\n#endif\n\t\tcase HIBERNATION_TEST_RESUME:\n\t\t\tbreak;\n\t\tcase HIBERNATION_PLATFORM:\n\t\t\tif (hibernation_ops)\n\t\t\t\tbreak;\n\t\t\t/* not a valid mode, continue with loop */\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == hibernation_mode)\n\t\t\tbuf += sprintf(buf, \"[%s] \", hibernation_modes[i]);\n\t\telse\n\t\t\tbuf += sprintf(buf, \"%s \", hibernation_modes[i]);\n\t}\n\tbuf += sprintf(buf, \"\\n\");\n\treturn buf-start;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define HIBERNATION_FIRST (HIBERNATION_INVALID + 1)",
      "#define HIBERNATION_MAX (__HIBERNATION_AFTER_LAST-1)"
    ],
    "globals_used": [
      "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
      "static const struct platform_hibernation_ops *hibernation_ops;",
      "static const char * const hibernation_modes[] = {\n\t[HIBERNATION_PLATFORM]\t= \"platform\",\n\t[HIBERNATION_SHUTDOWN]\t= \"shutdown\",\n\t[HIBERNATION_REBOOT]\t= \"reboot\",\n#ifdef CONFIG_SUSPEND\n\t[HIBERNATION_SUSPEND]\t= \"suspend\",\n#endif\n\t[HIBERNATION_TEST_RESUME]\t= \"test_resume\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"\\n\""
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s \"",
            "hibernation_modes[i]"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"[%s] \"",
            "hibernation_modes[i]"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"[disabled]\\n\""
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_available",
          "args": [],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "83-88",
          "snippet": "bool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nohibernate;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\n#define HIBERNATION_FIRST (HIBERNATION_INVALID + 1)\n#define HIBERNATION_MAX (__HIBERNATION_AFTER_LAST-1)\n\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nstatic const struct platform_hibernation_ops *hibernation_ops;\nstatic const char * const hibernation_modes[] = {\n\t[HIBERNATION_PLATFORM]\t= \"platform\",\n\t[HIBERNATION_SHUTDOWN]\t= \"shutdown\",\n\t[HIBERNATION_REBOOT]\t= \"reboot\",\n#ifdef CONFIG_SUSPEND\n\t[HIBERNATION_SUSPEND]\t= \"suspend\",\n#endif\n\t[HIBERNATION_TEST_RESUME]\t= \"test_resume\",\n};\n\nstatic ssize_t disk_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tint i;\n\tchar *start = buf;\n\n\tif (!hibernation_available())\n\t\treturn sprintf(buf, \"[disabled]\\n\");\n\n\tfor (i = HIBERNATION_FIRST; i <= HIBERNATION_MAX; i++) {\n\t\tif (!hibernation_modes[i])\n\t\t\tcontinue;\n\t\tswitch (i) {\n\t\tcase HIBERNATION_SHUTDOWN:\n\t\tcase HIBERNATION_REBOOT:\n#ifdef CONFIG_SUSPEND\n\t\tcase HIBERNATION_SUSPEND:\n#endif\n\t\tcase HIBERNATION_TEST_RESUME:\n\t\t\tbreak;\n\t\tcase HIBERNATION_PLATFORM:\n\t\t\tif (hibernation_ops)\n\t\t\t\tbreak;\n\t\t\t/* not a valid mode, continue with loop */\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == hibernation_mode)\n\t\t\tbuf += sprintf(buf, \"[%s] \", hibernation_modes[i]);\n\t\telse\n\t\t\tbuf += sprintf(buf, \"%s \", hibernation_modes[i]);\n\t}\n\tbuf += sprintf(buf, \"\\n\");\n\treturn buf-start;\n}"
  },
  {
    "function_name": "software_resume",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "914-1023",
    "snippet": "static int software_resume(void)\n{\n\tint error;\n\n\t/*\n\t * If the user said \"noresume\".. bail out early.\n\t */\n\tif (noresume || !hibernation_available())\n\t\treturn 0;\n\n\t/*\n\t * name_to_dev_t() below takes a sysfs buffer mutex when sysfs\n\t * is configured into the kernel. Since the regular hibernate\n\t * trigger path is via sysfs which takes a buffer mutex before\n\t * calling hibernate functions (which take system_transition_mutex)\n\t * this can cause lockdep to complain about a possible ABBA deadlock\n\t * which cannot happen since we're in the boot code here and\n\t * sysfs can't be invoked yet. Therefore, we use a subclass\n\t * here to avoid lockdep complaining.\n\t */\n\tmutex_lock_nested(&system_transition_mutex, SINGLE_DEPTH_NESTING);\n\n\tif (swsusp_resume_device)\n\t\tgoto Check_image;\n\n\tif (!strlen(resume_file)) {\n\t\terror = -ENOENT;\n\t\tgoto Unlock;\n\t}\n\n\tpm_pr_dbg(\"Checking hibernation image partition %s\\n\", resume_file);\n\n\tif (resume_delay) {\n\t\tpr_info(\"Waiting %dsec before reading resume device ...\\n\",\n\t\t\tresume_delay);\n\t\tssleep(resume_delay);\n\t}\n\n\t/* Check if the device is there */\n\tswsusp_resume_device = name_to_dev_t(resume_file);\n\tif (!swsusp_resume_device) {\n\t\t/*\n\t\t * Some device discovery might still be in progress; we need\n\t\t * to wait for this to finish.\n\t\t */\n\t\twait_for_device_probe();\n\n\t\tif (resume_wait) {\n\t\t\twhile ((swsusp_resume_device = name_to_dev_t(resume_file)) == 0)\n\t\t\t\tmsleep(10);\n\t\t\tasync_synchronize_full();\n\t\t}\n\n\t\tswsusp_resume_device = name_to_dev_t(resume_file);\n\t\tif (!swsusp_resume_device) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto Unlock;\n\t\t}\n\t}\n\n Check_image:\n\tpm_pr_dbg(\"Hibernation image partition %d:%d present\\n\",\n\t\tMAJOR(swsusp_resume_device), MINOR(swsusp_resume_device));\n\n\tpm_pr_dbg(\"Looking for hibernation image.\\n\");\n\terror = swsusp_check();\n\tif (error)\n\t\tgoto Unlock;\n\n\t/* The snapshot device should not be opened while we're running */\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tswsusp_close(FMODE_READ | FMODE_EXCL);\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"resume from hibernation\\n\");\n\tpm_prepare_console();\n\terror = pm_notifier_call_chain_robust(PM_RESTORE_PREPARE, PM_POST_RESTORE);\n\tif (error)\n\t\tgoto Restore;\n\n\tpm_pr_dbg(\"Preparing processes for hibernation restore.\\n\");\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Close_Finish;\n\n\terror = freeze_kernel_threads();\n\tif (error) {\n\t\tthaw_processes();\n\t\tgoto Close_Finish;\n\t}\n\n\terror = load_image_and_restore();\n\tthaw_processes();\n Finish:\n\tpm_notifier_call_chain(PM_POST_RESTORE);\n Restore:\n\tpm_restore_console();\n\tpr_info(\"resume failed (%d)\\n\", error);\n\thibernate_release();\n\t/* For success case, the suspend path will release the lock */\n Unlock:\n\tmutex_unlock(&system_transition_mutex);\n\tpm_pr_dbg(\"Hibernation image not present or could not be loaded.\\n\");\n\treturn error;\n Close_Finish:\n\tswsusp_close(FMODE_READ | FMODE_EXCL);\n\tgoto Finish;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int noresume;",
      "static int resume_wait;",
      "static unsigned int resume_delay;",
      "static char resume_file[256] = CONFIG_PM_STD_PARTITION;",
      "dev_t swsusp_resume_device;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swsusp_close",
          "args": [
            "FMODE_READ | FMODE_EXCL"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_close",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "1572-1580",
          "snippet": "void swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nvoid swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Hibernation image not present or could not be loaded.\\n\""
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&system_transition_mutex"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate_release",
          "args": [],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "78-81",
          "snippet": "void hibernate_release(void)\n{\n\tatomic_inc(&hibernate_atomic);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t hibernate_atomic = ATOMIC_INIT(1);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic atomic_t hibernate_atomic = ATOMIC_INIT(1);\n\nvoid hibernate_release(void)\n{\n\tatomic_inc(&hibernate_atomic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"resume failed (%d)\\n\"",
            "error"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_restore_console",
          "args": [],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "pm_restore_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
          "lines": "143-152",
          "snippet": "void pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_notifier_call_chain",
          "args": [
            "PM_POST_RESTORE"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "pm_notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "92-95",
          "snippet": "int pm_notifier_call_chain(unsigned long val)\n{\n\treturn blocking_notifier_call_chain(&pm_chain_head, val, NULL);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain(unsigned long val)\n{\n\treturn blocking_notifier_call_chain(&pm_chain_head, val, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_processes",
          "args": [],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_thaw_processes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "285-287",
          "snippet": "static inline void suspend_thaw_processes(void)\n{\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void suspend_thaw_processes(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_image_and_restore",
          "args": [],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "load_image_and_restore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "683-707",
          "snippet": "static int load_image_and_restore(void)\n{\n\tint error;\n\tunsigned int flags;\n\n\tpm_pr_dbg(\"Loading hibernation image.\\n\");\n\n\tlock_device_hotplug();\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Unlock;\n\n\terror = swsusp_read(&flags);\n\tswsusp_close(FMODE_READ | FMODE_EXCL);\n\tif (!error)\n\t\terror = hibernation_restore(flags & SF_PLATFORM_MODE);\n\n\tpr_err(\"Failed to load image, recovering.\\n\");\n\tswsusp_free();\n\tfree_basic_memory_bitmaps();\n Unlock:\n\tunlock_device_hotplug();\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int load_image_and_restore(void)\n{\n\tint error;\n\tunsigned int flags;\n\n\tpm_pr_dbg(\"Loading hibernation image.\\n\");\n\n\tlock_device_hotplug();\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Unlock;\n\n\terror = swsusp_read(&flags);\n\tswsusp_close(FMODE_READ | FMODE_EXCL);\n\tif (!error)\n\t\terror = hibernation_restore(flags & SF_PLATFORM_MODE);\n\n\tpr_err(\"Failed to load image, recovering.\\n\");\n\tswsusp_free();\n\tfree_basic_memory_bitmaps();\n Unlock:\n\tunlock_device_hotplug();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeze_kernel_threads",
          "args": [],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "freeze_kernel_threads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/process.c",
          "lines": "170-187",
          "snippet": "int freeze_kernel_threads(void)\n{\n\tint error;\n\n\tpr_info(\"Freezing remaining freezable tasks ... \");\n\n\tpm_nosig_freezing = true;\n\terror = try_to_freeze_tasks(false);\n\tif (!error)\n\t\tpr_cont(\"done.\");\n\n\tpr_cont(\"\\n\");\n\tBUG_ON(in_atomic());\n\n\tif (error)\n\t\tthaw_kernel_threads();\n\treturn error;\n}",
          "includes": [
            "#include <linux/cpuset.h>",
            "#include <trace/events/power.h>",
            "#include <linux/kmod.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/suspend.h>",
            "#include <linux/oom.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nint freeze_kernel_threads(void)\n{\n\tint error;\n\n\tpr_info(\"Freezing remaining freezable tasks ... \");\n\n\tpm_nosig_freezing = true;\n\terror = try_to_freeze_tasks(false);\n\tif (!error)\n\t\tpr_cont(\"done.\");\n\n\tpr_cont(\"\\n\");\n\tBUG_ON(in_atomic());\n\n\tif (error)\n\t\tthaw_kernel_threads();\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeze_processes",
          "args": [],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_freeze_processes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "280-283",
          "snippet": "static inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Preparing processes for hibernation restore.\\n\""
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_notifier_call_chain_robust",
          "args": [
            "PM_RESTORE_PREPARE",
            "PM_POST_RESTORE"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "pm_notifier_call_chain_robust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "83-90",
          "snippet": "int pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_prepare_console",
          "args": [],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "pm_prepare_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
          "lines": "130-141",
          "snippet": "void pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [
            "#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)"
          ],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\n#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"resume from hibernation\\n\""
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernate_acquire",
          "args": [],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_acquire",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "73-76",
          "snippet": "bool hibernate_acquire(void)\n{\n\treturn atomic_add_unless(&hibernate_atomic, -1, 0);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t hibernate_atomic = ATOMIC_INIT(1);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic atomic_t hibernate_atomic = ATOMIC_INIT(1);\n\nbool hibernate_acquire(void)\n{\n\treturn atomic_add_unless(&hibernate_atomic, -1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_check",
          "args": [],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "1521-1566",
          "snippet": "int swsusp_check(void)\n{\n\tint error;\n\tvoid *holder;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\n\t\t\t\t\t    FMODE_READ | FMODE_EXCL, &holder);\n\tif (!IS_ERR(hib_resume_bdev)) {\n\t\tset_blocksize(hib_resume_bdev, PAGE_SIZE);\n\t\tclear_page(swsusp_header);\n\t\terror = hib_submit_io(REQ_OP_READ, 0,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t\tif (error)\n\t\t\tgoto put;\n\n\t\tif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\n\t\t\tmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\n\t\t\t/* Reset swap signature now */\n\t\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\t\tswsusp_header, NULL);\n\t\t} else {\n\t\t\terror = -EINVAL;\n\t\t}\n\t\tif (!error && swsusp_header->flags & SF_HW_SIG &&\n\t\t    swsusp_header->hw_sig != swsusp_hardware_signature) {\n\t\t\tpr_info(\"Suspend image hardware signature mismatch (%08x now %08x); aborting resume.\\n\",\n\t\t\t\tswsusp_header->hw_sig, swsusp_hardware_signature);\n\t\t\terror = -EINVAL;\n\t\t}\n\nput:\n\t\tif (error)\n\t\t\tblkdev_put(hib_resume_bdev, FMODE_READ | FMODE_EXCL);\n\t\telse\n\t\t\tpr_debug(\"Image signature found, resuming\\n\");\n\t} else {\n\t\terror = PTR_ERR(hib_resume_bdev);\n\t}\n\n\tif (error)\n\t\tpr_debug(\"Image not found (code %d)\\n\", error);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIBERNATE_SIG\t\"S1SUSPEND\""
          ],
          "globals_used": [
            "u32 swsusp_hardware_signature;",
            "static struct swsusp_header *swsusp_header;",
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nu32 swsusp_hardware_signature;\nstatic struct swsusp_header *swsusp_header;\nstatic struct block_device *hib_resume_bdev;\n\nint swsusp_check(void)\n{\n\tint error;\n\tvoid *holder;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\n\t\t\t\t\t    FMODE_READ | FMODE_EXCL, &holder);\n\tif (!IS_ERR(hib_resume_bdev)) {\n\t\tset_blocksize(hib_resume_bdev, PAGE_SIZE);\n\t\tclear_page(swsusp_header);\n\t\terror = hib_submit_io(REQ_OP_READ, 0,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t\tif (error)\n\t\t\tgoto put;\n\n\t\tif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\n\t\t\tmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\n\t\t\t/* Reset swap signature now */\n\t\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\t\tswsusp_header, NULL);\n\t\t} else {\n\t\t\terror = -EINVAL;\n\t\t}\n\t\tif (!error && swsusp_header->flags & SF_HW_SIG &&\n\t\t    swsusp_header->hw_sig != swsusp_hardware_signature) {\n\t\t\tpr_info(\"Suspend image hardware signature mismatch (%08x now %08x); aborting resume.\\n\",\n\t\t\t\tswsusp_header->hw_sig, swsusp_hardware_signature);\n\t\t\terror = -EINVAL;\n\t\t}\n\nput:\n\t\tif (error)\n\t\t\tblkdev_put(hib_resume_bdev, FMODE_READ | FMODE_EXCL);\n\t\telse\n\t\t\tpr_debug(\"Image signature found, resuming\\n\");\n\t} else {\n\t\terror = PTR_ERR(hib_resume_bdev);\n\t}\n\n\tif (error)\n\t\tpr_debug(\"Image not found (code %d)\\n\", error);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Looking for hibernation image.\\n\""
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Hibernation image partition %d:%d present\\n\"",
            "MAJOR(swsusp_resume_device)",
            "MINOR(swsusp_resume_device)"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "__pm_pr_dbg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "553-572",
          "snippet": "void __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "swsusp_resume_device"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "swsusp_resume_device"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_to_dev_t",
          "args": [
            "resume_file"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "async_synchronize_full",
          "args": [],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "async_synchronize_full",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
          "lines": "242-245",
          "snippet": "void async_synchronize_full(void)\n{\n\tasync_synchronize_full_domain(NULL);\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nvoid async_synchronize_full(void)\n{\n\tasync_synchronize_full_domain(NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "10"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "2045-2052",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "name_to_dev_t",
          "args": [
            "resume_file"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_device_probe",
          "args": [],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_to_dev_t",
          "args": [
            "resume_file"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssleep",
          "args": [
            "resume_delay"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Waiting %dsec before reading resume device ...\\n\"",
            "resume_delay"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "resume_file"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&system_transition_mutex",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "521-524",
          "snippet": "void __sched mutex_lock_nested(struct mutex *lock, unsigned int subclass)\n{\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, subclass, NULL, _RET_IP_);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_nested(struct mutex *lock, unsigned int subclass)\n{\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, subclass, NULL, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_available",
          "args": [],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "83-88",
          "snippet": "bool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nohibernate;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int noresume;\nstatic int resume_wait;\nstatic unsigned int resume_delay;\nstatic char resume_file[256] = CONFIG_PM_STD_PARTITION;\ndev_t swsusp_resume_device;\n\nstatic int software_resume(void)\n{\n\tint error;\n\n\t/*\n\t * If the user said \"noresume\".. bail out early.\n\t */\n\tif (noresume || !hibernation_available())\n\t\treturn 0;\n\n\t/*\n\t * name_to_dev_t() below takes a sysfs buffer mutex when sysfs\n\t * is configured into the kernel. Since the regular hibernate\n\t * trigger path is via sysfs which takes a buffer mutex before\n\t * calling hibernate functions (which take system_transition_mutex)\n\t * this can cause lockdep to complain about a possible ABBA deadlock\n\t * which cannot happen since we're in the boot code here and\n\t * sysfs can't be invoked yet. Therefore, we use a subclass\n\t * here to avoid lockdep complaining.\n\t */\n\tmutex_lock_nested(&system_transition_mutex, SINGLE_DEPTH_NESTING);\n\n\tif (swsusp_resume_device)\n\t\tgoto Check_image;\n\n\tif (!strlen(resume_file)) {\n\t\terror = -ENOENT;\n\t\tgoto Unlock;\n\t}\n\n\tpm_pr_dbg(\"Checking hibernation image partition %s\\n\", resume_file);\n\n\tif (resume_delay) {\n\t\tpr_info(\"Waiting %dsec before reading resume device ...\\n\",\n\t\t\tresume_delay);\n\t\tssleep(resume_delay);\n\t}\n\n\t/* Check if the device is there */\n\tswsusp_resume_device = name_to_dev_t(resume_file);\n\tif (!swsusp_resume_device) {\n\t\t/*\n\t\t * Some device discovery might still be in progress; we need\n\t\t * to wait for this to finish.\n\t\t */\n\t\twait_for_device_probe();\n\n\t\tif (resume_wait) {\n\t\t\twhile ((swsusp_resume_device = name_to_dev_t(resume_file)) == 0)\n\t\t\t\tmsleep(10);\n\t\t\tasync_synchronize_full();\n\t\t}\n\n\t\tswsusp_resume_device = name_to_dev_t(resume_file);\n\t\tif (!swsusp_resume_device) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto Unlock;\n\t\t}\n\t}\n\n Check_image:\n\tpm_pr_dbg(\"Hibernation image partition %d:%d present\\n\",\n\t\tMAJOR(swsusp_resume_device), MINOR(swsusp_resume_device));\n\n\tpm_pr_dbg(\"Looking for hibernation image.\\n\");\n\terror = swsusp_check();\n\tif (error)\n\t\tgoto Unlock;\n\n\t/* The snapshot device should not be opened while we're running */\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tswsusp_close(FMODE_READ | FMODE_EXCL);\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"resume from hibernation\\n\");\n\tpm_prepare_console();\n\terror = pm_notifier_call_chain_robust(PM_RESTORE_PREPARE, PM_POST_RESTORE);\n\tif (error)\n\t\tgoto Restore;\n\n\tpm_pr_dbg(\"Preparing processes for hibernation restore.\\n\");\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Close_Finish;\n\n\terror = freeze_kernel_threads();\n\tif (error) {\n\t\tthaw_processes();\n\t\tgoto Close_Finish;\n\t}\n\n\terror = load_image_and_restore();\n\tthaw_processes();\n Finish:\n\tpm_notifier_call_chain(PM_POST_RESTORE);\n Restore:\n\tpm_restore_console();\n\tpr_info(\"resume failed (%d)\\n\", error);\n\thibernate_release();\n\t/* For success case, the suspend path will release the lock */\n Unlock:\n\tmutex_unlock(&system_transition_mutex);\n\tpm_pr_dbg(\"Hibernation image not present or could not be loaded.\\n\");\n\treturn error;\n Close_Finish:\n\tswsusp_close(FMODE_READ | FMODE_EXCL);\n\tgoto Finish;\n}"
  },
  {
    "function_name": "hibernate_quiet_exec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "809-896",
    "snippet": "int hibernate_quiet_exec(int (*func)(void *data), void *data)\n{\n\tint error;\n\n\tlock_system_sleep();\n\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tpm_prepare_console();\n\n\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);\n\tif (error)\n\t\tgoto restore;\n\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto exit;\n\n\tlock_device_hotplug();\n\n\tpm_suspend_clear_flags();\n\n\terror = platform_begin(true);\n\tif (error)\n\t\tgoto thaw;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto thaw;\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error)\n\t\tgoto dpm_complete;\n\n\tsuspend_console();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\tif (error)\n\t\tgoto dpm_resume;\n\n\terror = dpm_suspend_end(PMSG_FREEZE);\n\tif (error)\n\t\tgoto dpm_resume;\n\n\terror = platform_pre_snapshot(true);\n\tif (error)\n\t\tgoto skip;\n\n\terror = func(data);\n\nskip:\n\tplatform_finish(true);\n\n\tdpm_resume_start(PMSG_THAW);\n\ndpm_resume:\n\tdpm_resume(PMSG_THAW);\n\n\tresume_console();\n\ndpm_complete:\n\tdpm_complete(PMSG_THAW);\n\n\tthaw_kernel_threads();\n\nthaw:\n\tplatform_end(true);\n\n\tunlock_device_hotplug();\n\n\tthaw_processes();\n\nexit:\n\tpm_notifier_call_chain(PM_POST_HIBERNATION);\n\nrestore:\n\tpm_restore_console();\n\n\thibernate_release();\n\nunlock:\n\tunlock_system_sleep();\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate_release",
          "args": [],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "78-81",
          "snippet": "void hibernate_release(void)\n{\n\tatomic_inc(&hibernate_atomic);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t hibernate_atomic = ATOMIC_INIT(1);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic atomic_t hibernate_atomic = ATOMIC_INIT(1);\n\nvoid hibernate_release(void)\n{\n\tatomic_inc(&hibernate_atomic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_restore_console",
          "args": [],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "pm_restore_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
          "lines": "143-152",
          "snippet": "void pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_notifier_call_chain",
          "args": [
            "PM_POST_HIBERNATION"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "pm_notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "92-95",
          "snippet": "int pm_notifier_call_chain(unsigned long val)\n{\n\treturn blocking_notifier_call_chain(&pm_chain_head, val, NULL);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain(unsigned long val)\n{\n\treturn blocking_notifier_call_chain(&pm_chain_head, val, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_processes",
          "args": [],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_thaw_processes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "285-287",
          "snippet": "static inline void suspend_thaw_processes(void)\n{\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void suspend_thaw_processes(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_end",
          "args": [
            "true"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "platform_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "154-158",
          "snippet": "static void platform_end(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_end(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_kernel_threads",
          "args": [],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_kernel_threads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/process.c",
          "lines": "227-245",
          "snippet": "void thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & PF_KTHREAD)\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}",
          "includes": [
            "#include <linux/cpuset.h>",
            "#include <trace/events/power.h>",
            "#include <linux/kmod.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/suspend.h>",
            "#include <linux/oom.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nvoid thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & PF_KTHREAD)\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpm_complete",
          "args": [
            "PMSG_THAW"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resume_console",
          "args": [],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "resume_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2484-2491",
          "snippet": "void resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "bool console_suspend_enabled = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nbool console_suspend_enabled = true;\n\nvoid resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpm_resume",
          "args": [
            "PMSG_THAW"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_resume_start",
          "args": [
            "PMSG_THAW"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_finish",
          "args": [
            "true"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "platform_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "198-202",
          "snippet": "static void platform_finish(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->finish();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_finish(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "data"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "flush_smp_call_function_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "561-682",
          "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [
            "#define CFD_SEQ_HDLEND\t9",
            "#define CFD_SEQ_DEQUEUE\t6",
            "#define CFD_SEQ_HANDLE\t5",
            "#define CFD_SEQ_NOCPU\t0xffff"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "static void flush_smp_call_function_queue(bool warn_cpu_offline);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CFD_SEQ_HDLEND\t9\n#define CFD_SEQ_DEQUEUE\t6\n#define CFD_SEQ_HANDLE\t5\n#define CFD_SEQ_NOCPU\t0xffff\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline);\n\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_pre_snapshot",
          "args": [
            "true"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "platform_pre_snapshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "168-172",
          "snippet": "static int platform_pre_snapshot(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_snapshot() : 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic int platform_pre_snapshot(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_snapshot() : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpm_suspend_end",
          "args": [
            "PMSG_FREEZE"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_suspend",
          "args": [
            "PMSG_FREEZE"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suspend_console",
          "args": [],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2474-2482",
          "snippet": "void suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "bool console_suspend_enabled = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nbool console_suspend_enabled = true;\n\nvoid suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpm_prepare",
          "args": [
            "PMSG_FREEZE"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeze_kernel_threads",
          "args": [],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "freeze_kernel_threads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/process.c",
          "lines": "170-187",
          "snippet": "int freeze_kernel_threads(void)\n{\n\tint error;\n\n\tpr_info(\"Freezing remaining freezable tasks ... \");\n\n\tpm_nosig_freezing = true;\n\terror = try_to_freeze_tasks(false);\n\tif (!error)\n\t\tpr_cont(\"done.\");\n\n\tpr_cont(\"\\n\");\n\tBUG_ON(in_atomic());\n\n\tif (error)\n\t\tthaw_kernel_threads();\n\treturn error;\n}",
          "includes": [
            "#include <linux/cpuset.h>",
            "#include <trace/events/power.h>",
            "#include <linux/kmod.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/suspend.h>",
            "#include <linux/oom.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nint freeze_kernel_threads(void)\n{\n\tint error;\n\n\tpr_info(\"Freezing remaining freezable tasks ... \");\n\n\tpm_nosig_freezing = true;\n\terror = try_to_freeze_tasks(false);\n\tif (!error)\n\t\tpr_cont(\"done.\");\n\n\tpr_cont(\"\\n\");\n\tBUG_ON(in_atomic());\n\n\tif (error)\n\t\tthaw_kernel_threads();\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_begin",
          "args": [
            "true"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "platform_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "144-148",
          "snippet": "static int platform_begin(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->begin(PMSG_FREEZE) : 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic int platform_begin(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->begin(PMSG_FREEZE) : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_suspend_clear_flags",
          "args": [],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug",
          "args": [],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeze_processes",
          "args": [],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_freeze_processes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "280-283",
          "snippet": "static inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_notifier_call_chain_robust",
          "args": [
            "PM_HIBERNATION_PREPARE",
            "PM_POST_HIBERNATION"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "pm_notifier_call_chain_robust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "83-90",
          "snippet": "int pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_prepare_console",
          "args": [],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "pm_prepare_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
          "lines": "130-141",
          "snippet": "void pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [
            "#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)"
          ],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\n#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate_acquire",
          "args": [],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_acquire",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "73-76",
          "snippet": "bool hibernate_acquire(void)\n{\n\treturn atomic_add_unless(&hibernate_atomic, -1, 0);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t hibernate_atomic = ATOMIC_INIT(1);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic atomic_t hibernate_atomic = ATOMIC_INIT(1);\n\nbool hibernate_acquire(void)\n{\n\treturn atomic_add_unless(&hibernate_atomic, -1, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nint hibernate_quiet_exec(int (*func)(void *data), void *data)\n{\n\tint error;\n\n\tlock_system_sleep();\n\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tpm_prepare_console();\n\n\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);\n\tif (error)\n\t\tgoto restore;\n\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto exit;\n\n\tlock_device_hotplug();\n\n\tpm_suspend_clear_flags();\n\n\terror = platform_begin(true);\n\tif (error)\n\t\tgoto thaw;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto thaw;\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error)\n\t\tgoto dpm_complete;\n\n\tsuspend_console();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\tif (error)\n\t\tgoto dpm_resume;\n\n\terror = dpm_suspend_end(PMSG_FREEZE);\n\tif (error)\n\t\tgoto dpm_resume;\n\n\terror = platform_pre_snapshot(true);\n\tif (error)\n\t\tgoto skip;\n\n\terror = func(data);\n\nskip:\n\tplatform_finish(true);\n\n\tdpm_resume_start(PMSG_THAW);\n\ndpm_resume:\n\tdpm_resume(PMSG_THAW);\n\n\tresume_console();\n\ndpm_complete:\n\tdpm_complete(PMSG_THAW);\n\n\tthaw_kernel_threads();\n\nthaw:\n\tplatform_end(true);\n\n\tunlock_device_hotplug();\n\n\tthaw_processes();\n\nexit:\n\tpm_notifier_call_chain(PM_POST_HIBERNATION);\n\nrestore:\n\tpm_restore_console();\n\n\thibernate_release();\n\nunlock:\n\tunlock_system_sleep();\n\n\treturn error;\n}"
  },
  {
    "function_name": "hibernate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "712-800",
    "snippet": "int hibernate(void)\n{\n\tbool snapshot_test = false;\n\tint error;\n\n\tif (!hibernation_available()) {\n\t\tpm_pr_dbg(\"Hibernation not available.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tlock_system_sleep();\n\t/* The snapshot device should not be opened while we're running */\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"hibernation entry\\n\");\n\tpm_prepare_console();\n\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);\n\tif (error)\n\t\tgoto Restore;\n\n\tksys_sync_helper();\n\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Exit;\n\n\tlock_device_hotplug();\n\t/* Allocate memory management structures */\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Thaw;\n\n\terror = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);\n\tif (error || freezer_test_done)\n\t\tgoto Free_bitmaps;\n\n\tif (in_suspend) {\n\t\tunsigned int flags = 0;\n\n\t\tif (hibernation_mode == HIBERNATION_PLATFORM)\n\t\t\tflags |= SF_PLATFORM_MODE;\n\t\tif (nocompress)\n\t\t\tflags |= SF_NOCOMPRESS_MODE;\n\t\telse\n\t\t        flags |= SF_CRC32_MODE;\n\n\t\tpm_pr_dbg(\"Writing hibernation image.\\n\");\n\t\terror = swsusp_write(flags);\n\t\tswsusp_free();\n\t\tif (!error) {\n\t\t\tif (hibernation_mode == HIBERNATION_TEST_RESUME)\n\t\t\t\tsnapshot_test = true;\n\t\t\telse\n\t\t\t\tpower_down();\n\t\t}\n\t\tin_suspend = 0;\n\t\tpm_restore_gfp_mask();\n\t} else {\n\t\tpm_pr_dbg(\"Hibernation image restored successfully.\\n\");\n\t}\n\n Free_bitmaps:\n\tfree_basic_memory_bitmaps();\n Thaw:\n\tunlock_device_hotplug();\n\tif (snapshot_test) {\n\t\tpm_pr_dbg(\"Checking hibernation image\\n\");\n\t\terror = swsusp_check();\n\t\tif (!error)\n\t\t\terror = load_image_and_restore();\n\t}\n\tthaw_processes();\n\n\t/* Don't bother checking whether freezer_test_done is true */\n\tfreezer_test_done = false;\n Exit:\n\tpm_notifier_call_chain(PM_POST_HIBERNATION);\n Restore:\n\tpm_restore_console();\n\thibernate_release();\n Unlock:\n\tunlock_system_sleep();\n\tpr_info(\"hibernation exit\\n\");\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nocompress;",
      "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
      "bool freezer_test_done;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"hibernation exit\\n\""
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate_release",
          "args": [],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "78-81",
          "snippet": "void hibernate_release(void)\n{\n\tatomic_inc(&hibernate_atomic);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t hibernate_atomic = ATOMIC_INIT(1);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic atomic_t hibernate_atomic = ATOMIC_INIT(1);\n\nvoid hibernate_release(void)\n{\n\tatomic_inc(&hibernate_atomic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_restore_console",
          "args": [],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "pm_restore_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
          "lines": "143-152",
          "snippet": "void pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_notifier_call_chain",
          "args": [
            "PM_POST_HIBERNATION"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "pm_notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "92-95",
          "snippet": "int pm_notifier_call_chain(unsigned long val)\n{\n\treturn blocking_notifier_call_chain(&pm_chain_head, val, NULL);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain(unsigned long val)\n{\n\treturn blocking_notifier_call_chain(&pm_chain_head, val, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_processes",
          "args": [],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_thaw_processes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "285-287",
          "snippet": "static inline void suspend_thaw_processes(void)\n{\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void suspend_thaw_processes(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_image_and_restore",
          "args": [],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "load_image_and_restore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "683-707",
          "snippet": "static int load_image_and_restore(void)\n{\n\tint error;\n\tunsigned int flags;\n\n\tpm_pr_dbg(\"Loading hibernation image.\\n\");\n\n\tlock_device_hotplug();\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Unlock;\n\n\terror = swsusp_read(&flags);\n\tswsusp_close(FMODE_READ | FMODE_EXCL);\n\tif (!error)\n\t\terror = hibernation_restore(flags & SF_PLATFORM_MODE);\n\n\tpr_err(\"Failed to load image, recovering.\\n\");\n\tswsusp_free();\n\tfree_basic_memory_bitmaps();\n Unlock:\n\tunlock_device_hotplug();\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int load_image_and_restore(void)\n{\n\tint error;\n\tunsigned int flags;\n\n\tpm_pr_dbg(\"Loading hibernation image.\\n\");\n\n\tlock_device_hotplug();\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Unlock;\n\n\terror = swsusp_read(&flags);\n\tswsusp_close(FMODE_READ | FMODE_EXCL);\n\tif (!error)\n\t\terror = hibernation_restore(flags & SF_PLATFORM_MODE);\n\n\tpr_err(\"Failed to load image, recovering.\\n\");\n\tswsusp_free();\n\tfree_basic_memory_bitmaps();\n Unlock:\n\tunlock_device_hotplug();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_check",
          "args": [],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "1521-1566",
          "snippet": "int swsusp_check(void)\n{\n\tint error;\n\tvoid *holder;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\n\t\t\t\t\t    FMODE_READ | FMODE_EXCL, &holder);\n\tif (!IS_ERR(hib_resume_bdev)) {\n\t\tset_blocksize(hib_resume_bdev, PAGE_SIZE);\n\t\tclear_page(swsusp_header);\n\t\terror = hib_submit_io(REQ_OP_READ, 0,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t\tif (error)\n\t\t\tgoto put;\n\n\t\tif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\n\t\t\tmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\n\t\t\t/* Reset swap signature now */\n\t\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\t\tswsusp_header, NULL);\n\t\t} else {\n\t\t\terror = -EINVAL;\n\t\t}\n\t\tif (!error && swsusp_header->flags & SF_HW_SIG &&\n\t\t    swsusp_header->hw_sig != swsusp_hardware_signature) {\n\t\t\tpr_info(\"Suspend image hardware signature mismatch (%08x now %08x); aborting resume.\\n\",\n\t\t\t\tswsusp_header->hw_sig, swsusp_hardware_signature);\n\t\t\terror = -EINVAL;\n\t\t}\n\nput:\n\t\tif (error)\n\t\t\tblkdev_put(hib_resume_bdev, FMODE_READ | FMODE_EXCL);\n\t\telse\n\t\t\tpr_debug(\"Image signature found, resuming\\n\");\n\t} else {\n\t\terror = PTR_ERR(hib_resume_bdev);\n\t}\n\n\tif (error)\n\t\tpr_debug(\"Image not found (code %d)\\n\", error);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIBERNATE_SIG\t\"S1SUSPEND\""
          ],
          "globals_used": [
            "u32 swsusp_hardware_signature;",
            "static struct swsusp_header *swsusp_header;",
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nu32 swsusp_hardware_signature;\nstatic struct swsusp_header *swsusp_header;\nstatic struct block_device *hib_resume_bdev;\n\nint swsusp_check(void)\n{\n\tint error;\n\tvoid *holder;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\n\t\t\t\t\t    FMODE_READ | FMODE_EXCL, &holder);\n\tif (!IS_ERR(hib_resume_bdev)) {\n\t\tset_blocksize(hib_resume_bdev, PAGE_SIZE);\n\t\tclear_page(swsusp_header);\n\t\terror = hib_submit_io(REQ_OP_READ, 0,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t\tif (error)\n\t\t\tgoto put;\n\n\t\tif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\n\t\t\tmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\n\t\t\t/* Reset swap signature now */\n\t\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\t\tswsusp_header, NULL);\n\t\t} else {\n\t\t\terror = -EINVAL;\n\t\t}\n\t\tif (!error && swsusp_header->flags & SF_HW_SIG &&\n\t\t    swsusp_header->hw_sig != swsusp_hardware_signature) {\n\t\t\tpr_info(\"Suspend image hardware signature mismatch (%08x now %08x); aborting resume.\\n\",\n\t\t\t\tswsusp_header->hw_sig, swsusp_hardware_signature);\n\t\t\terror = -EINVAL;\n\t\t}\n\nput:\n\t\tif (error)\n\t\t\tblkdev_put(hib_resume_bdev, FMODE_READ | FMODE_EXCL);\n\t\telse\n\t\t\tpr_debug(\"Image signature found, resuming\\n\");\n\t} else {\n\t\terror = PTR_ERR(hib_resume_bdev);\n\t}\n\n\tif (error)\n\t\tpr_debug(\"Image not found (code %d)\\n\", error);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Checking hibernation image\\n\""
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_basic_memory_bitmaps",
          "args": [],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "free_basic_memory_bitmaps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1162-1179",
          "snippet": "void free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nvoid free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Hibernation image restored successfully.\\n\""
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_restore_gfp_mask",
          "args": [],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "power_down",
          "args": [],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "power_down",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "639-681",
          "snippet": "static void power_down(void)\n{\n#ifdef CONFIG_SUSPEND\n\tint error;\n\n\tif (hibernation_mode == HIBERNATION_SUSPEND) {\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tif (error) {\n\t\t\thibernation_mode = hibernation_ops ?\n\t\t\t\t\t\tHIBERNATION_PLATFORM :\n\t\t\t\t\t\tHIBERNATION_SHUTDOWN;\n\t\t} else {\n\t\t\t/* Restore swap signature. */\n\t\t\terror = swsusp_unmark();\n\t\t\tif (error)\n\t\t\t\tpr_err(\"Swap will be unusable! Try swapon -a.\\n\");\n\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\tswitch (hibernation_mode) {\n\tcase HIBERNATION_REBOOT:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\tcase HIBERNATION_PLATFORM:\n\t\thibernation_platform_enter();\n\t\tfallthrough;\n\tcase HIBERNATION_SHUTDOWN:\n\t\tif (pm_power_off)\n\t\t\tkernel_power_off();\n\t\tbreak;\n\t}\n\tkernel_halt();\n\t/*\n\t * Valid image is on the disk, if we continue we risk serious data\n\t * corruption after resume.\n\t */\n\tpr_crit(\"Power down manually\\n\");\n\twhile (1)\n\t\tcpu_relax();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void power_down(void)\n{\n#ifdef CONFIG_SUSPEND\n\tint error;\n\n\tif (hibernation_mode == HIBERNATION_SUSPEND) {\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tif (error) {\n\t\t\thibernation_mode = hibernation_ops ?\n\t\t\t\t\t\tHIBERNATION_PLATFORM :\n\t\t\t\t\t\tHIBERNATION_SHUTDOWN;\n\t\t} else {\n\t\t\t/* Restore swap signature. */\n\t\t\terror = swsusp_unmark();\n\t\t\tif (error)\n\t\t\t\tpr_err(\"Swap will be unusable! Try swapon -a.\\n\");\n\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\tswitch (hibernation_mode) {\n\tcase HIBERNATION_REBOOT:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\tcase HIBERNATION_PLATFORM:\n\t\thibernation_platform_enter();\n\t\tfallthrough;\n\tcase HIBERNATION_SHUTDOWN:\n\t\tif (pm_power_off)\n\t\t\tkernel_power_off();\n\t\tbreak;\n\t}\n\tkernel_halt();\n\t/*\n\t * Valid image is on the disk, if we continue we risk serious data\n\t * corruption after resume.\n\t */\n\tpr_crit(\"Power down manually\\n\");\n\twhile (1)\n\t\tcpu_relax();\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_free",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1506-1549",
          "snippet": "void swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define BM_END_OF_MAP\t(~0UL)"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "static void *buffer;",
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static unsigned int alloc_normal, alloc_highmem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define BM_END_OF_MAP\t(~0UL)\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstatic void *buffer;\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic unsigned int alloc_normal, alloc_highmem;\n\nvoid swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_write",
          "args": [
            "flags"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "914-953",
          "snippet": "int swsusp_write(unsigned int flags)\n{\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\tunsigned long pages;\n\tint error;\n\n\tpages = snapshot_get_image_size();\n\terror = get_swap_writer(&handle);\n\tif (error) {\n\t\tpr_err(\"Cannot get swap writer\\n\");\n\t\treturn error;\n\t}\n\tif (flags & SF_NOCOMPRESS_MODE) {\n\t\tif (!enough_swap(pages)) {\n\t\t\tpr_err(\"Not enough free swap\\n\");\n\t\t\terror = -ENOSPC;\n\t\t\tgoto out_finish;\n\t\t}\n\t}\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_read_next(&snapshot);\n\tif (error < (int)PAGE_SIZE) {\n\t\tif (error >= 0)\n\t\t\terror = -EFAULT;\n\n\t\tgoto out_finish;\n\t}\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = swap_write_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (flags & SF_NOCOMPRESS_MODE) ?\n\t\t\tsave_image(&handle, &snapshot, pages - 1) :\n\t\t\tsave_image_lzo(&handle, &snapshot, pages - 1);\n\t}\nout_finish:\n\terror = swap_writer_finish(&handle, flags, error);\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint swsusp_write(unsigned int flags)\n{\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\tunsigned long pages;\n\tint error;\n\n\tpages = snapshot_get_image_size();\n\terror = get_swap_writer(&handle);\n\tif (error) {\n\t\tpr_err(\"Cannot get swap writer\\n\");\n\t\treturn error;\n\t}\n\tif (flags & SF_NOCOMPRESS_MODE) {\n\t\tif (!enough_swap(pages)) {\n\t\t\tpr_err(\"Not enough free swap\\n\");\n\t\t\terror = -ENOSPC;\n\t\t\tgoto out_finish;\n\t\t}\n\t}\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_read_next(&snapshot);\n\tif (error < (int)PAGE_SIZE) {\n\t\tif (error >= 0)\n\t\t\terror = -EFAULT;\n\n\t\tgoto out_finish;\n\t}\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = swap_write_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (flags & SF_NOCOMPRESS_MODE) ?\n\t\t\tsave_image(&handle, &snapshot, pages - 1) :\n\t\t\tsave_image_lzo(&handle, &snapshot, pages - 1);\n\t}\nout_finish:\n\terror = swap_writer_finish(&handle, flags, error);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Writing hibernation image.\\n\""
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_snapshot",
          "args": [
            "hibernation_mode == HIBERNATION_PLATFORM"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_snapshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "366-439",
          "snippet": "int hibernation_snapshot(int platform_mode)\n{\n\tpm_message_t msg;\n\tint error;\n\n\tpm_suspend_clear_flags();\n\terror = platform_begin(platform_mode);\n\tif (error)\n\t\tgoto Close;\n\n\t/* Preallocate image memory before shutting down devices. */\n\terror = hibernate_preallocate_memory();\n\tif (error)\n\t\tgoto Close;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto Cleanup;\n\n\tif (hibernation_test(TEST_FREEZER)) {\n\n\t\t/*\n\t\t * Indicate to the caller that we are returning due to a\n\t\t * successful freezer test.\n\t\t */\n\t\tfreezer_test_done = true;\n\t\tgoto Thaw;\n\t}\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error) {\n\t\tdpm_complete(PMSG_RECOVER);\n\t\tgoto Thaw;\n\t}\n\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\n\tif (error || hibernation_test(TEST_DEVICES))\n\t\tplatform_recover(platform_mode);\n\telse\n\t\terror = create_image(platform_mode);\n\n\t/*\n\t * In the case that we call create_image() above, the control\n\t * returns here (1) after the image has been created or the\n\t * image creation has failed and (2) after a successful restore.\n\t */\n\n\t/* We may need to release the preallocated image pages here. */\n\tif (error || !in_suspend)\n\t\tswsusp_free();\n\n\tmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;\n\tdpm_resume(msg);\n\n\tif (error || !in_suspend)\n\t\tpm_restore_gfp_mask();\n\n\tresume_console();\n\tdpm_complete(msg);\n\n Close:\n\tplatform_end(platform_mode);\n\treturn error;\n\n Thaw:\n\tthaw_kernel_threads();\n Cleanup:\n\tswsusp_free();\n\tgoto Close;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool freezer_test_done;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nbool freezer_test_done;\n\nint hibernation_snapshot(int platform_mode)\n{\n\tpm_message_t msg;\n\tint error;\n\n\tpm_suspend_clear_flags();\n\terror = platform_begin(platform_mode);\n\tif (error)\n\t\tgoto Close;\n\n\t/* Preallocate image memory before shutting down devices. */\n\terror = hibernate_preallocate_memory();\n\tif (error)\n\t\tgoto Close;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto Cleanup;\n\n\tif (hibernation_test(TEST_FREEZER)) {\n\n\t\t/*\n\t\t * Indicate to the caller that we are returning due to a\n\t\t * successful freezer test.\n\t\t */\n\t\tfreezer_test_done = true;\n\t\tgoto Thaw;\n\t}\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error) {\n\t\tdpm_complete(PMSG_RECOVER);\n\t\tgoto Thaw;\n\t}\n\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\n\tif (error || hibernation_test(TEST_DEVICES))\n\t\tplatform_recover(platform_mode);\n\telse\n\t\terror = create_image(platform_mode);\n\n\t/*\n\t * In the case that we call create_image() above, the control\n\t * returns here (1) after the image has been created or the\n\t * image creation has failed and (2) after a successful restore.\n\t */\n\n\t/* We may need to release the preallocated image pages here. */\n\tif (error || !in_suspend)\n\t\tswsusp_free();\n\n\tmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;\n\tdpm_resume(msg);\n\n\tif (error || !in_suspend)\n\t\tpm_restore_gfp_mask();\n\n\tresume_console();\n\tdpm_complete(msg);\n\n Close:\n\tplatform_end(platform_mode);\n\treturn error;\n\n Thaw:\n\tthaw_kernel_threads();\n Cleanup:\n\tswsusp_free();\n\tgoto Close;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_basic_memory_bitmaps",
          "args": [],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "create_basic_memory_bitmaps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1112-1153",
          "snippet": "int create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n#define PG_ANY\t\t0\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nint create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug",
          "args": [],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeze_processes",
          "args": [],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_freeze_processes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "280-283",
          "snippet": "static inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ksys_sync_helper",
          "args": [],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "ksys_sync_helper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "54-64",
          "snippet": "void ksys_sync_helper(void)\n{\n\tktime_t start;\n\tlong elapsed_msecs;\n\n\tstart = ktime_get();\n\tksys_sync();\n\telapsed_msecs = ktime_to_ms(ktime_sub(ktime_get(), start));\n\tpr_info(\"Filesystems sync: %ld.%03ld seconds\\n\",\n\t\telapsed_msecs / MSEC_PER_SEC, elapsed_msecs % MSEC_PER_SEC);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid ksys_sync_helper(void)\n{\n\tktime_t start;\n\tlong elapsed_msecs;\n\n\tstart = ktime_get();\n\tksys_sync();\n\telapsed_msecs = ktime_to_ms(ktime_sub(ktime_get(), start));\n\tpr_info(\"Filesystems sync: %ld.%03ld seconds\\n\",\n\t\telapsed_msecs / MSEC_PER_SEC, elapsed_msecs % MSEC_PER_SEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_notifier_call_chain_robust",
          "args": [
            "PM_HIBERNATION_PREPARE",
            "PM_POST_HIBERNATION"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "pm_notifier_call_chain_robust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "83-90",
          "snippet": "int pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_prepare_console",
          "args": [],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "pm_prepare_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
          "lines": "130-141",
          "snippet": "void pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [
            "#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)"
          ],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\n#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"hibernation entry\\n\""
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernate_acquire",
          "args": [],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_acquire",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "73-76",
          "snippet": "bool hibernate_acquire(void)\n{\n\treturn atomic_add_unless(&hibernate_atomic, -1, 0);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t hibernate_atomic = ATOMIC_INIT(1);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic atomic_t hibernate_atomic = ATOMIC_INIT(1);\n\nbool hibernate_acquire(void)\n{\n\treturn atomic_add_unless(&hibernate_atomic, -1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Hibernation not available.\\n\""
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_available",
          "args": [],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "83-88",
          "snippet": "bool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nohibernate;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nocompress;\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nbool freezer_test_done;\n\nint hibernate(void)\n{\n\tbool snapshot_test = false;\n\tint error;\n\n\tif (!hibernation_available()) {\n\t\tpm_pr_dbg(\"Hibernation not available.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tlock_system_sleep();\n\t/* The snapshot device should not be opened while we're running */\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"hibernation entry\\n\");\n\tpm_prepare_console();\n\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);\n\tif (error)\n\t\tgoto Restore;\n\n\tksys_sync_helper();\n\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Exit;\n\n\tlock_device_hotplug();\n\t/* Allocate memory management structures */\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Thaw;\n\n\terror = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);\n\tif (error || freezer_test_done)\n\t\tgoto Free_bitmaps;\n\n\tif (in_suspend) {\n\t\tunsigned int flags = 0;\n\n\t\tif (hibernation_mode == HIBERNATION_PLATFORM)\n\t\t\tflags |= SF_PLATFORM_MODE;\n\t\tif (nocompress)\n\t\t\tflags |= SF_NOCOMPRESS_MODE;\n\t\telse\n\t\t        flags |= SF_CRC32_MODE;\n\n\t\tpm_pr_dbg(\"Writing hibernation image.\\n\");\n\t\terror = swsusp_write(flags);\n\t\tswsusp_free();\n\t\tif (!error) {\n\t\t\tif (hibernation_mode == HIBERNATION_TEST_RESUME)\n\t\t\t\tsnapshot_test = true;\n\t\t\telse\n\t\t\t\tpower_down();\n\t\t}\n\t\tin_suspend = 0;\n\t\tpm_restore_gfp_mask();\n\t} else {\n\t\tpm_pr_dbg(\"Hibernation image restored successfully.\\n\");\n\t}\n\n Free_bitmaps:\n\tfree_basic_memory_bitmaps();\n Thaw:\n\tunlock_device_hotplug();\n\tif (snapshot_test) {\n\t\tpm_pr_dbg(\"Checking hibernation image\\n\");\n\t\terror = swsusp_check();\n\t\tif (!error)\n\t\t\terror = load_image_and_restore();\n\t}\n\tthaw_processes();\n\n\t/* Don't bother checking whether freezer_test_done is true */\n\tfreezer_test_done = false;\n Exit:\n\tpm_notifier_call_chain(PM_POST_HIBERNATION);\n Restore:\n\tpm_restore_console();\n\thibernate_release();\n Unlock:\n\tunlock_system_sleep();\n\tpr_info(\"hibernation exit\\n\");\n\n\treturn error;\n}"
  },
  {
    "function_name": "load_image_and_restore",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "683-707",
    "snippet": "static int load_image_and_restore(void)\n{\n\tint error;\n\tunsigned int flags;\n\n\tpm_pr_dbg(\"Loading hibernation image.\\n\");\n\n\tlock_device_hotplug();\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Unlock;\n\n\terror = swsusp_read(&flags);\n\tswsusp_close(FMODE_READ | FMODE_EXCL);\n\tif (!error)\n\t\terror = hibernation_restore(flags & SF_PLATFORM_MODE);\n\n\tpr_err(\"Failed to load image, recovering.\\n\");\n\tswsusp_free();\n\tfree_basic_memory_bitmaps();\n Unlock:\n\tunlock_device_hotplug();\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_basic_memory_bitmaps",
          "args": [],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "free_basic_memory_bitmaps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1162-1179",
          "snippet": "void free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nvoid free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_free",
          "args": [],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1506-1549",
          "snippet": "void swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define BM_END_OF_MAP\t(~0UL)"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "static void *buffer;",
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static unsigned int alloc_normal, alloc_highmem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define BM_END_OF_MAP\t(~0UL)\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstatic void *buffer;\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic unsigned int alloc_normal, alloc_highmem;\n\nvoid swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to load image, recovering.\\n\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_restore",
          "args": [
            "flags & SF_PLATFORM_MODE"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_restore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "532-554",
          "snippet": "int hibernation_restore(int platform_mode)\n{\n\tint error;\n\n\tpm_prepare_console();\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\terror = dpm_suspend_start(PMSG_QUIESCE);\n\tif (!error) {\n\t\terror = resume_target_kernel(platform_mode);\n\t\t/*\n\t\t * The above should either succeed and jump to the new kernel,\n\t\t * or return with an error. Otherwise things are just\n\t\t * undefined, so let's be paranoid.\n\t\t */\n\t\tBUG_ON(!error);\n\t}\n\tdpm_resume_end(PMSG_RECOVER);\n\tpm_restore_gfp_mask();\n\tresume_console();\n\tpm_restore_console();\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nint hibernation_restore(int platform_mode)\n{\n\tint error;\n\n\tpm_prepare_console();\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\terror = dpm_suspend_start(PMSG_QUIESCE);\n\tif (!error) {\n\t\terror = resume_target_kernel(platform_mode);\n\t\t/*\n\t\t * The above should either succeed and jump to the new kernel,\n\t\t * or return with an error. Otherwise things are just\n\t\t * undefined, so let's be paranoid.\n\t\t */\n\t\tBUG_ON(!error);\n\t}\n\tdpm_resume_end(PMSG_RECOVER);\n\tpm_restore_gfp_mask();\n\tresume_console();\n\tpm_restore_console();\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_close",
          "args": [
            "FMODE_READ | FMODE_EXCL"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_close",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "1572-1580",
          "snippet": "void swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct block_device *hib_resume_bdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct block_device *hib_resume_bdev;\n\nvoid swsusp_close(fmode_t mode)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_read",
          "args": [
            "&flags"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "1486-1515",
          "snippet": "int swsusp_read(unsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_write_next(&snapshot);\n\tif (error < (int)PAGE_SIZE)\n\t\treturn error < 0 ? error : -EFAULT;\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = get_swap_reader(&handle, flags_p);\n\tif (error)\n\t\tgoto end;\n\tif (!error)\n\t\terror = swap_read_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (*flags_p & SF_NOCOMPRESS_MODE) ?\n\t\t\tload_image(&handle, &snapshot, header->pages - 1) :\n\t\t\tload_image_lzo(&handle, &snapshot, header->pages - 1);\n\t}\n\tswap_reader_finish(&handle);\nend:\n\tif (!error)\n\t\tpr_debug(\"Image successfully loaded\\n\");\n\telse\n\t\tpr_debug(\"Error %d resuming\\n\", error);\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint swsusp_read(unsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_write_next(&snapshot);\n\tif (error < (int)PAGE_SIZE)\n\t\treturn error < 0 ? error : -EFAULT;\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = get_swap_reader(&handle, flags_p);\n\tif (error)\n\t\tgoto end;\n\tif (!error)\n\t\terror = swap_read_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (*flags_p & SF_NOCOMPRESS_MODE) ?\n\t\t\tload_image(&handle, &snapshot, header->pages - 1) :\n\t\t\tload_image_lzo(&handle, &snapshot, header->pages - 1);\n\t}\n\tswap_reader_finish(&handle);\nend:\n\tif (!error)\n\t\tpr_debug(\"Image successfully loaded\\n\");\n\telse\n\t\tpr_debug(\"Error %d resuming\\n\", error);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_basic_memory_bitmaps",
          "args": [],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "create_basic_memory_bitmaps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1112-1153",
          "snippet": "int create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n#define PG_ANY\t\t0\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nint create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug",
          "args": [],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_pr_dbg",
          "args": [
            "\"Loading hibernation image.\\n\""
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int load_image_and_restore(void)\n{\n\tint error;\n\tunsigned int flags;\n\n\tpm_pr_dbg(\"Loading hibernation image.\\n\");\n\n\tlock_device_hotplug();\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Unlock;\n\n\terror = swsusp_read(&flags);\n\tswsusp_close(FMODE_READ | FMODE_EXCL);\n\tif (!error)\n\t\terror = hibernation_restore(flags & SF_PLATFORM_MODE);\n\n\tpr_err(\"Failed to load image, recovering.\\n\");\n\tswsusp_free();\n\tfree_basic_memory_bitmaps();\n Unlock:\n\tunlock_device_hotplug();\n\n\treturn error;\n}"
  },
  {
    "function_name": "power_down",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "639-681",
    "snippet": "static void power_down(void)\n{\n#ifdef CONFIG_SUSPEND\n\tint error;\n\n\tif (hibernation_mode == HIBERNATION_SUSPEND) {\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tif (error) {\n\t\t\thibernation_mode = hibernation_ops ?\n\t\t\t\t\t\tHIBERNATION_PLATFORM :\n\t\t\t\t\t\tHIBERNATION_SHUTDOWN;\n\t\t} else {\n\t\t\t/* Restore swap signature. */\n\t\t\terror = swsusp_unmark();\n\t\t\tif (error)\n\t\t\t\tpr_err(\"Swap will be unusable! Try swapon -a.\\n\");\n\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\tswitch (hibernation_mode) {\n\tcase HIBERNATION_REBOOT:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\tcase HIBERNATION_PLATFORM:\n\t\thibernation_platform_enter();\n\t\tfallthrough;\n\tcase HIBERNATION_SHUTDOWN:\n\t\tif (pm_power_off)\n\t\t\tkernel_power_off();\n\t\tbreak;\n\t}\n\tkernel_halt();\n\t/*\n\t * Valid image is on the disk, if we continue we risk serious data\n\t * corruption after resume.\n\t */\n\tpr_crit(\"Power down manually\\n\");\n\twhile (1)\n\t\tcpu_relax();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Power down manually\\n\""
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_halt",
          "args": [],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_halt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "273-281",
          "snippet": "void kernel_halt(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_HALT);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"System halted\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_halt();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid kernel_halt(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_HALT);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"System halted\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_halt();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_power_off",
          "args": [],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_power_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "289-299",
          "snippet": "void kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void (*pm_power_off_prepare)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid (*pm_power_off_prepare)(void);\n\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_platform_enter",
          "args": [],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_platform_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "559-630",
          "snippet": "int hibernation_platform_enter(void)\n{\n\tint error;\n\n\tif (!hibernation_ops)\n\t\treturn -ENOSYS;\n\n\t/*\n\t * We have cancelled the power transition by running\n\t * hibernation_ops->finish() before saving the image, so we should let\n\t * the firmware know that we're going to enter the sleep state after all\n\t */\n\terror = hibernation_ops->begin(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Close;\n\n\tentering_platform_hibernation = true;\n\tsuspend_console();\n\terror = dpm_suspend_start(PMSG_HIBERNATE);\n\tif (error) {\n\t\tif (hibernation_ops->recover)\n\t\t\thibernation_ops->recover();\n\t\tgoto Resume_devices;\n\t}\n\n\terror = dpm_suspend_end(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Resume_devices;\n\n\terror = hibernation_ops->prepare();\n\tif (error)\n\t\tgoto Platform_finish;\n\n\terror = pm_sleep_disable_secondary_cpus();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\tsyscore_suspend();\n\tif (pm_wakeup_pending()) {\n\t\terror = -EAGAIN;\n\t\tgoto Power_up;\n\t}\n\n\thibernation_ops->enter();\n\t/* We should never get here */\n\twhile (1);\n\n Power_up:\n\tsyscore_resume();\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n Platform_finish:\n\thibernation_ops->finish();\n\n\tdpm_resume_start(PMSG_RESTORE);\n\n Resume_devices:\n\tentering_platform_hibernation = false;\n\tdpm_resume_end(PMSG_RESTORE);\n\tresume_console();\n\n Close:\n\thibernation_ops->end();\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;",
            "static bool entering_platform_hibernation;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\nstatic bool entering_platform_hibernation;\n\nint hibernation_platform_enter(void)\n{\n\tint error;\n\n\tif (!hibernation_ops)\n\t\treturn -ENOSYS;\n\n\t/*\n\t * We have cancelled the power transition by running\n\t * hibernation_ops->finish() before saving the image, so we should let\n\t * the firmware know that we're going to enter the sleep state after all\n\t */\n\terror = hibernation_ops->begin(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Close;\n\n\tentering_platform_hibernation = true;\n\tsuspend_console();\n\terror = dpm_suspend_start(PMSG_HIBERNATE);\n\tif (error) {\n\t\tif (hibernation_ops->recover)\n\t\t\thibernation_ops->recover();\n\t\tgoto Resume_devices;\n\t}\n\n\terror = dpm_suspend_end(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Resume_devices;\n\n\terror = hibernation_ops->prepare();\n\tif (error)\n\t\tgoto Platform_finish;\n\n\terror = pm_sleep_disable_secondary_cpus();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\tsyscore_suspend();\n\tif (pm_wakeup_pending()) {\n\t\terror = -EAGAIN;\n\t\tgoto Power_up;\n\t}\n\n\thibernation_ops->enter();\n\t/* We should never get here */\n\twhile (1);\n\n Power_up:\n\tsyscore_resume();\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n Platform_finish:\n\thibernation_ops->finish();\n\n\tdpm_resume_start(PMSG_RESTORE);\n\n Resume_devices:\n\tentering_platform_hibernation = false;\n\tdpm_resume_end(PMSG_RESTORE);\n\tresume_console();\n\n Close:\n\thibernation_ops->end();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_restart",
          "args": [
            "NULL"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_restart",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "246-257",
          "snippet": "void kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tif (!cmd)\n\t\tpr_emerg(\"Restarting system\\n\");\n\telse\n\t\tpr_emerg(\"Restarting system with command '%s'\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_restart(cmd);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tif (!cmd)\n\t\tpr_emerg(\"Restarting system\\n\");\n\telse\n\t\tpr_emerg(\"Restarting system with command '%s'\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_restart(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Swap will be unusable! Try swapon -a.\\n\""
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_unmark",
          "args": [],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_unmark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "1587-1609",
          "snippet": "int swsusp_unmark(void)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(HIBERNATE_SIG,swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->sig,swsusp_header->orig_sig, 10);\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Cannot find swsusp signature!\\n\");\n\t\terror = -ENODEV;\n\t}\n\n\t/*\n\t * We just returned from suspend, we don't need the image any more.\n\t */\n\tfree_all_swap_pages(root_swap);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIBERNATE_SIG\t\"S1SUSPEND\""
          ],
          "globals_used": [
            "static struct swsusp_header *swsusp_header;",
            "static unsigned short root_swap = 0xffff;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nstatic struct swsusp_header *swsusp_header;\nstatic unsigned short root_swap = 0xffff;\n\nint swsusp_unmark(void)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, 0, swsusp_resume_block,\n\t\t      swsusp_header, NULL);\n\tif (!memcmp(HIBERNATE_SIG,swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->sig,swsusp_header->orig_sig, 10);\n\t\terror = hib_submit_io(REQ_OP_WRITE, REQ_SYNC,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Cannot find swsusp signature!\\n\");\n\t\terror = -ENODEV;\n\t}\n\n\t/*\n\t * We just returned from suspend, we don't need the image any more.\n\t */\n\tfree_all_swap_pages(root_swap);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "suspend_devices_and_enter",
          "args": [
            "PM_SUSPEND_MEM"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_devices_and_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "199-202",
          "snippet": "static inline int suspend_devices_and_enter(suspend_state_t state)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int suspend_devices_and_enter(suspend_state_t state)\n{\n\treturn -ENOSYS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void power_down(void)\n{\n#ifdef CONFIG_SUSPEND\n\tint error;\n\n\tif (hibernation_mode == HIBERNATION_SUSPEND) {\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tif (error) {\n\t\t\thibernation_mode = hibernation_ops ?\n\t\t\t\t\t\tHIBERNATION_PLATFORM :\n\t\t\t\t\t\tHIBERNATION_SHUTDOWN;\n\t\t} else {\n\t\t\t/* Restore swap signature. */\n\t\t\terror = swsusp_unmark();\n\t\t\tif (error)\n\t\t\t\tpr_err(\"Swap will be unusable! Try swapon -a.\\n\");\n\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\tswitch (hibernation_mode) {\n\tcase HIBERNATION_REBOOT:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\tcase HIBERNATION_PLATFORM:\n\t\thibernation_platform_enter();\n\t\tfallthrough;\n\tcase HIBERNATION_SHUTDOWN:\n\t\tif (pm_power_off)\n\t\t\tkernel_power_off();\n\t\tbreak;\n\t}\n\tkernel_halt();\n\t/*\n\t * Valid image is on the disk, if we continue we risk serious data\n\t * corruption after resume.\n\t */\n\tpr_crit(\"Power down manually\\n\");\n\twhile (1)\n\t\tcpu_relax();\n}"
  },
  {
    "function_name": "hibernation_platform_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "559-630",
    "snippet": "int hibernation_platform_enter(void)\n{\n\tint error;\n\n\tif (!hibernation_ops)\n\t\treturn -ENOSYS;\n\n\t/*\n\t * We have cancelled the power transition by running\n\t * hibernation_ops->finish() before saving the image, so we should let\n\t * the firmware know that we're going to enter the sleep state after all\n\t */\n\terror = hibernation_ops->begin(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Close;\n\n\tentering_platform_hibernation = true;\n\tsuspend_console();\n\terror = dpm_suspend_start(PMSG_HIBERNATE);\n\tif (error) {\n\t\tif (hibernation_ops->recover)\n\t\t\thibernation_ops->recover();\n\t\tgoto Resume_devices;\n\t}\n\n\terror = dpm_suspend_end(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Resume_devices;\n\n\terror = hibernation_ops->prepare();\n\tif (error)\n\t\tgoto Platform_finish;\n\n\terror = pm_sleep_disable_secondary_cpus();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\tsyscore_suspend();\n\tif (pm_wakeup_pending()) {\n\t\terror = -EAGAIN;\n\t\tgoto Power_up;\n\t}\n\n\thibernation_ops->enter();\n\t/* We should never get here */\n\twhile (1);\n\n Power_up:\n\tsyscore_resume();\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n Platform_finish:\n\thibernation_ops->finish();\n\n\tdpm_resume_start(PMSG_RESTORE);\n\n Resume_devices:\n\tentering_platform_hibernation = false;\n\tdpm_resume_end(PMSG_RESTORE);\n\tresume_console();\n\n Close:\n\thibernation_ops->end();\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;",
      "static bool entering_platform_hibernation;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->end",
          "args": [],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resume_console",
          "args": [],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "resume_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2484-2491",
          "snippet": "void resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "bool console_suspend_enabled = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nbool console_suspend_enabled = true;\n\nvoid resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpm_resume_end",
          "args": [
            "PMSG_RESTORE"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_resume_start",
          "args": [
            "PMSG_RESTORE"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_ops->finish",
          "args": [],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/preload/bpf_preload_kern.c",
          "lines": "51-70",
          "snippet": "static int finish(void)\n{\n\tint magic = BPF_PRELOAD_END;\n\tstruct pid *tgid;\n\tloff_t pos = 0;\n\tssize_t n;\n\n\t/* send the last magic to UMD. It will do a normal exit. */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\n\ttgid = umd_ops.info.tgid;\n\tif (tgid) {\n\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\t\tumd_cleanup_helper(&umd_ops.info);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"bpf_preload.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int finish(void);",
            "static struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_preload.h\"\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/pid.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int finish(void);\nstatic struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};\n\nstatic int finish(void)\n{\n\tint magic = BPF_PRELOAD_END;\n\tstruct pid *tgid;\n\tloff_t pos = 0;\n\tssize_t n;\n\n\t/* send the last magic to UMD. It will do a normal exit. */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\n\ttgid = umd_ops.info.tgid;\n\tif (tgid) {\n\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\t\tumd_cleanup_helper(&umd_ops.info);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_sleep_enable_secondary_cpus",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "pm_sleep_enable_secondary_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "323-327",
          "snippet": "static inline void pm_sleep_enable_secondary_cpus(void)\n{\n\tsuspend_enable_secondary_cpus();\n\tcpuidle_resume();\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void pm_sleep_enable_secondary_cpus(void)\n{\n\tsuspend_enable_secondary_cpus();\n\tcpuidle_resume();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_resume",
          "args": [],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "irq_pm_syscore_resume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
          "lines": "234-237",
          "snippet": "static void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_ops->enter",
          "args": [],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_wakeup_pending",
          "args": [],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_suspend",
          "args": [],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_sleep_disable_secondary_cpus",
          "args": [],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "pm_sleep_disable_secondary_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "317-321",
          "snippet": "static inline int pm_sleep_disable_secondary_cpus(void)\n{\n\tcpuidle_pause();\n\treturn suspend_disable_secondary_cpus();\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int pm_sleep_disable_secondary_cpus(void)\n{\n\tcpuidle_pause();\n\treturn suspend_disable_secondary_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_ops->prepare",
          "args": [],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_suspend_end",
          "args": [
            "PMSG_HIBERNATE"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_ops->recover",
          "args": [],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_suspend_start",
          "args": [
            "PMSG_HIBERNATE"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suspend_console",
          "args": [],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2474-2482",
          "snippet": "void suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "bool console_suspend_enabled = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nbool console_suspend_enabled = true;\n\nvoid suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_ops->begin",
          "args": [
            "PMSG_HIBERNATE"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\nstatic bool entering_platform_hibernation;\n\nint hibernation_platform_enter(void)\n{\n\tint error;\n\n\tif (!hibernation_ops)\n\t\treturn -ENOSYS;\n\n\t/*\n\t * We have cancelled the power transition by running\n\t * hibernation_ops->finish() before saving the image, so we should let\n\t * the firmware know that we're going to enter the sleep state after all\n\t */\n\terror = hibernation_ops->begin(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Close;\n\n\tentering_platform_hibernation = true;\n\tsuspend_console();\n\terror = dpm_suspend_start(PMSG_HIBERNATE);\n\tif (error) {\n\t\tif (hibernation_ops->recover)\n\t\t\thibernation_ops->recover();\n\t\tgoto Resume_devices;\n\t}\n\n\terror = dpm_suspend_end(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Resume_devices;\n\n\terror = hibernation_ops->prepare();\n\tif (error)\n\t\tgoto Platform_finish;\n\n\terror = pm_sleep_disable_secondary_cpus();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\tsyscore_suspend();\n\tif (pm_wakeup_pending()) {\n\t\terror = -EAGAIN;\n\t\tgoto Power_up;\n\t}\n\n\thibernation_ops->enter();\n\t/* We should never get here */\n\twhile (1);\n\n Power_up:\n\tsyscore_resume();\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n Platform_finish:\n\thibernation_ops->finish();\n\n\tdpm_resume_start(PMSG_RESTORE);\n\n Resume_devices:\n\tentering_platform_hibernation = false;\n\tdpm_resume_end(PMSG_RESTORE);\n\tresume_console();\n\n Close:\n\thibernation_ops->end();\n\n\treturn error;\n}"
  },
  {
    "function_name": "hibernation_restore",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "532-554",
    "snippet": "int hibernation_restore(int platform_mode)\n{\n\tint error;\n\n\tpm_prepare_console();\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\terror = dpm_suspend_start(PMSG_QUIESCE);\n\tif (!error) {\n\t\terror = resume_target_kernel(platform_mode);\n\t\t/*\n\t\t * The above should either succeed and jump to the new kernel,\n\t\t * or return with an error. Otherwise things are just\n\t\t * undefined, so let's be paranoid.\n\t\t */\n\t\tBUG_ON(!error);\n\t}\n\tdpm_resume_end(PMSG_RECOVER);\n\tpm_restore_gfp_mask();\n\tresume_console();\n\tpm_restore_console();\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_restore_console",
          "args": [],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "pm_restore_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
          "lines": "143-152",
          "snippet": "void pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "resume_console",
          "args": [],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "resume_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2484-2491",
          "snippet": "void resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "bool console_suspend_enabled = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nbool console_suspend_enabled = true;\n\nvoid resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_restore_gfp_mask",
          "args": [],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_resume_end",
          "args": [
            "PMSG_RECOVER"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!error"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resume_target_kernel",
          "args": [
            "platform_mode"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "resume_target_kernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "455-522",
          "snippet": "static int resume_target_kernel(bool platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_QUIESCE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting resume\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_restore(platform_mode);\n\tif (error)\n\t\tgoto Cleanup;\n\n\tcpuidle_pause();\n\n\terror = hibernate_resume_nonboot_cpu_disable();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error)\n\t\tgoto Enable_irqs;\n\n\tsave_processor_state();\n\terror = restore_highmem();\n\tif (!error) {\n\t\terror = swsusp_arch_resume();\n\t\t/*\n\t\t * The code below is only ever reached in case of a failure.\n\t\t * Otherwise, execution continues at the place where\n\t\t * swsusp_arch_suspend() was called.\n\t\t */\n\t\tBUG_ON(!error);\n\t\t/*\n\t\t * This call to restore_highmem() reverts the changes made by\n\t\t * the previous one.\n\t\t */\n\t\trestore_highmem();\n\t}\n\t/*\n\t * The only reason why swsusp_arch_resume() can fail is memory being\n\t * very tight, so we have to free it as soon as we can to avoid\n\t * subsequent failures.\n\t */\n\tswsusp_free();\n\trestore_processor_state();\n\ttouch_softlockup_watchdog();\n\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n Cleanup:\n\tplatform_restore_cleanup(platform_mode);\n\n\tdpm_resume_start(PMSG_RECOVER);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int resume_target_kernel(bool platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_QUIESCE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting resume\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_restore(platform_mode);\n\tif (error)\n\t\tgoto Cleanup;\n\n\tcpuidle_pause();\n\n\terror = hibernate_resume_nonboot_cpu_disable();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error)\n\t\tgoto Enable_irqs;\n\n\tsave_processor_state();\n\terror = restore_highmem();\n\tif (!error) {\n\t\terror = swsusp_arch_resume();\n\t\t/*\n\t\t * The code below is only ever reached in case of a failure.\n\t\t * Otherwise, execution continues at the place where\n\t\t * swsusp_arch_suspend() was called.\n\t\t */\n\t\tBUG_ON(!error);\n\t\t/*\n\t\t * This call to restore_highmem() reverts the changes made by\n\t\t * the previous one.\n\t\t */\n\t\trestore_highmem();\n\t}\n\t/*\n\t * The only reason why swsusp_arch_resume() can fail is memory being\n\t * very tight, so we have to free it as soon as we can to avoid\n\t * subsequent failures.\n\t */\n\tswsusp_free();\n\trestore_processor_state();\n\ttouch_softlockup_watchdog();\n\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n Cleanup:\n\tplatform_restore_cleanup(platform_mode);\n\n\tdpm_resume_start(PMSG_RECOVER);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpm_suspend_start",
          "args": [
            "PMSG_QUIESCE"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_restrict_gfp_mask",
          "args": [],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suspend_console",
          "args": [],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2474-2482",
          "snippet": "void suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "bool console_suspend_enabled = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nbool console_suspend_enabled = true;\n\nvoid suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_prepare_console",
          "args": [],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "pm_prepare_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
          "lines": "130-141",
          "snippet": "void pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [
            "#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)"
          ],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\n#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nint hibernation_restore(int platform_mode)\n{\n\tint error;\n\n\tpm_prepare_console();\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\terror = dpm_suspend_start(PMSG_QUIESCE);\n\tif (!error) {\n\t\terror = resume_target_kernel(platform_mode);\n\t\t/*\n\t\t * The above should either succeed and jump to the new kernel,\n\t\t * or return with an error. Otherwise things are just\n\t\t * undefined, so let's be paranoid.\n\t\t */\n\t\tBUG_ON(!error);\n\t}\n\tdpm_resume_end(PMSG_RECOVER);\n\tpm_restore_gfp_mask();\n\tresume_console();\n\tpm_restore_console();\n\treturn error;\n}"
  },
  {
    "function_name": "resume_target_kernel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "455-522",
    "snippet": "static int resume_target_kernel(bool platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_QUIESCE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting resume\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_restore(platform_mode);\n\tif (error)\n\t\tgoto Cleanup;\n\n\tcpuidle_pause();\n\n\terror = hibernate_resume_nonboot_cpu_disable();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error)\n\t\tgoto Enable_irqs;\n\n\tsave_processor_state();\n\terror = restore_highmem();\n\tif (!error) {\n\t\terror = swsusp_arch_resume();\n\t\t/*\n\t\t * The code below is only ever reached in case of a failure.\n\t\t * Otherwise, execution continues at the place where\n\t\t * swsusp_arch_suspend() was called.\n\t\t */\n\t\tBUG_ON(!error);\n\t\t/*\n\t\t * This call to restore_highmem() reverts the changes made by\n\t\t * the previous one.\n\t\t */\n\t\trestore_highmem();\n\t}\n\t/*\n\t * The only reason why swsusp_arch_resume() can fail is memory being\n\t * very tight, so we have to free it as soon as we can to avoid\n\t * subsequent failures.\n\t */\n\tswsusp_free();\n\trestore_processor_state();\n\ttouch_softlockup_watchdog();\n\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n Cleanup:\n\tplatform_restore_cleanup(platform_mode);\n\n\tdpm_resume_start(PMSG_RECOVER);\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dpm_resume_start",
          "args": [
            "PMSG_RECOVER"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_restore_cleanup",
          "args": [
            "platform_mode"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "platform_restore_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "231-235",
          "snippet": "static void platform_restore_cleanup(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->restore_cleanup();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_restore_cleanup(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->restore_cleanup();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_sleep_enable_secondary_cpus",
          "args": [],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "pm_sleep_enable_secondary_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "323-327",
          "snippet": "static inline void pm_sleep_enable_secondary_cpus(void)\n{\n\tsuspend_enable_secondary_cpus();\n\tcpuidle_resume();\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void pm_sleep_enable_secondary_cpus(void)\n{\n\tsuspend_enable_secondary_cpus();\n\tcpuidle_resume();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_resume",
          "args": [],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "irq_pm_syscore_resume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
          "lines": "234-237",
          "snippet": "static void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog",
          "args": [],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "299-303",
          "snippet": "void touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nvoid touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_processor_state",
          "args": [],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_free",
          "args": [],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1506-1549",
          "snippet": "void swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define BM_END_OF_MAP\t(~0UL)"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "static void *buffer;",
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static unsigned int alloc_normal, alloc_highmem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define BM_END_OF_MAP\t(~0UL)\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstatic void *buffer;\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic unsigned int alloc_normal, alloc_highmem;\n\nvoid swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_highmem",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "restore_highmem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "224-224",
          "snippet": "static inline int restore_highmem(void) { return 0; }",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int restore_highmem(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!error"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_arch_resume",
          "args": [],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_processor_state",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_suspend",
          "args": [],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernate_resume_nonboot_cpu_disable",
          "args": [],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_resume_nonboot_cpu_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "441-444",
          "snippet": "int __weak hibernate_resume_nonboot_cpu_disable(void)\n{\n\treturn suspend_disable_secondary_cpus();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nint __weak hibernate_resume_nonboot_cpu_disable(void)\n{\n\treturn suspend_disable_secondary_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidle_pause",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_pre_restore",
          "args": [
            "platform_mode"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "platform_pre_restore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "214-218",
          "snippet": "static int platform_pre_restore(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_restore() : 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic int platform_pre_restore(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_restore() : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Some devices failed to power down, aborting resume\\n\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_suspend_end",
          "args": [
            "PMSG_QUIESCE"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int resume_target_kernel(bool platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_QUIESCE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting resume\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_restore(platform_mode);\n\tif (error)\n\t\tgoto Cleanup;\n\n\tcpuidle_pause();\n\n\terror = hibernate_resume_nonboot_cpu_disable();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error)\n\t\tgoto Enable_irqs;\n\n\tsave_processor_state();\n\terror = restore_highmem();\n\tif (!error) {\n\t\terror = swsusp_arch_resume();\n\t\t/*\n\t\t * The code below is only ever reached in case of a failure.\n\t\t * Otherwise, execution continues at the place where\n\t\t * swsusp_arch_suspend() was called.\n\t\t */\n\t\tBUG_ON(!error);\n\t\t/*\n\t\t * This call to restore_highmem() reverts the changes made by\n\t\t * the previous one.\n\t\t */\n\t\trestore_highmem();\n\t}\n\t/*\n\t * The only reason why swsusp_arch_resume() can fail is memory being\n\t * very tight, so we have to free it as soon as we can to avoid\n\t * subsequent failures.\n\t */\n\tswsusp_free();\n\trestore_processor_state();\n\ttouch_softlockup_watchdog();\n\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n Cleanup:\n\tplatform_restore_cleanup(platform_mode);\n\n\tdpm_resume_start(PMSG_RECOVER);\n\n\treturn error;\n}"
  },
  {
    "function_name": "hibernate_resume_nonboot_cpu_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "441-444",
    "snippet": "int __weak hibernate_resume_nonboot_cpu_disable(void)\n{\n\treturn suspend_disable_secondary_cpus();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "suspend_disable_secondary_cpus",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nint __weak hibernate_resume_nonboot_cpu_disable(void)\n{\n\treturn suspend_disable_secondary_cpus();\n}"
  },
  {
    "function_name": "hibernation_snapshot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "366-439",
    "snippet": "int hibernation_snapshot(int platform_mode)\n{\n\tpm_message_t msg;\n\tint error;\n\n\tpm_suspend_clear_flags();\n\terror = platform_begin(platform_mode);\n\tif (error)\n\t\tgoto Close;\n\n\t/* Preallocate image memory before shutting down devices. */\n\terror = hibernate_preallocate_memory();\n\tif (error)\n\t\tgoto Close;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto Cleanup;\n\n\tif (hibernation_test(TEST_FREEZER)) {\n\n\t\t/*\n\t\t * Indicate to the caller that we are returning due to a\n\t\t * successful freezer test.\n\t\t */\n\t\tfreezer_test_done = true;\n\t\tgoto Thaw;\n\t}\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error) {\n\t\tdpm_complete(PMSG_RECOVER);\n\t\tgoto Thaw;\n\t}\n\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\n\tif (error || hibernation_test(TEST_DEVICES))\n\t\tplatform_recover(platform_mode);\n\telse\n\t\terror = create_image(platform_mode);\n\n\t/*\n\t * In the case that we call create_image() above, the control\n\t * returns here (1) after the image has been created or the\n\t * image creation has failed and (2) after a successful restore.\n\t */\n\n\t/* We may need to release the preallocated image pages here. */\n\tif (error || !in_suspend)\n\t\tswsusp_free();\n\n\tmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;\n\tdpm_resume(msg);\n\n\tif (error || !in_suspend)\n\t\tpm_restore_gfp_mask();\n\n\tresume_console();\n\tdpm_complete(msg);\n\n Close:\n\tplatform_end(platform_mode);\n\treturn error;\n\n Thaw:\n\tthaw_kernel_threads();\n Cleanup:\n\tswsusp_free();\n\tgoto Close;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool freezer_test_done;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swsusp_free",
          "args": [],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1506-1549",
          "snippet": "void swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define BM_END_OF_MAP\t(~0UL)"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "static void *buffer;",
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static unsigned int alloc_normal, alloc_highmem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define BM_END_OF_MAP\t(~0UL)\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstatic void *buffer;\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic unsigned int alloc_normal, alloc_highmem;\n\nvoid swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_kernel_threads",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_kernel_threads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/process.c",
          "lines": "227-245",
          "snippet": "void thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & PF_KTHREAD)\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}",
          "includes": [
            "#include <linux/cpuset.h>",
            "#include <trace/events/power.h>",
            "#include <linux/kmod.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/suspend.h>",
            "#include <linux/oom.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nvoid thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & PF_KTHREAD)\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_end",
          "args": [
            "platform_mode"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "platform_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "154-158",
          "snippet": "static void platform_end(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_end(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpm_complete",
          "args": [
            "msg"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resume_console",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "resume_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2484-2491",
          "snippet": "void resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "bool console_suspend_enabled = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nbool console_suspend_enabled = true;\n\nvoid resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_restore_gfp_mask",
          "args": [],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_resume",
          "args": [
            "msg"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_image",
          "args": [
            "platform_mode"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "create_image",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "289-358",
          "snippet": "static int create_image(int platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_FREEZE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_snapshot(platform_mode);\n\tif (error || hibernation_test(TEST_PLATFORM))\n\t\tgoto Platform_finish;\n\n\terror = pm_sleep_disable_secondary_cpus();\n\tif (error || hibernation_test(TEST_CPUS))\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error) {\n\t\tpr_err(\"Some system devices failed to power down, aborting\\n\");\n\t\tgoto Enable_irqs;\n\t}\n\n\tif (hibernation_test(TEST_CORE) || pm_wakeup_pending())\n\t\tgoto Power_up;\n\n\tin_suspend = 1;\n\tsave_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, true);\n\terror = swsusp_arch_suspend();\n\t/* Restore control flow magically appears here */\n\trestore_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, false);\n\tif (error)\n\t\tpr_err(\"Error %d creating image\\n\", error);\n\n\tif (!in_suspend) {\n\t\tevents_check_enabled = false;\n\t\tclear_or_poison_free_pages();\n\t}\n\n\tplatform_leave(platform_mode);\n\n Power_up:\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n\t/* Allow architectures to do nosmt-specific post-resume dances */\n\tif (!in_suspend)\n\t\terror = arch_resume_nosmt();\n\n Platform_finish:\n\tplatform_finish(platform_mode);\n\n\tdpm_resume_start(in_suspend ?\n\t\t(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int create_image(int platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_FREEZE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_snapshot(platform_mode);\n\tif (error || hibernation_test(TEST_PLATFORM))\n\t\tgoto Platform_finish;\n\n\terror = pm_sleep_disable_secondary_cpus();\n\tif (error || hibernation_test(TEST_CPUS))\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error) {\n\t\tpr_err(\"Some system devices failed to power down, aborting\\n\");\n\t\tgoto Enable_irqs;\n\t}\n\n\tif (hibernation_test(TEST_CORE) || pm_wakeup_pending())\n\t\tgoto Power_up;\n\n\tin_suspend = 1;\n\tsave_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, true);\n\terror = swsusp_arch_suspend();\n\t/* Restore control flow magically appears here */\n\trestore_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, false);\n\tif (error)\n\t\tpr_err(\"Error %d creating image\\n\", error);\n\n\tif (!in_suspend) {\n\t\tevents_check_enabled = false;\n\t\tclear_or_poison_free_pages();\n\t}\n\n\tplatform_leave(platform_mode);\n\n Power_up:\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n\t/* Allow architectures to do nosmt-specific post-resume dances */\n\tif (!in_suspend)\n\t\terror = arch_resume_nosmt();\n\n Platform_finish:\n\tplatform_finish(platform_mode);\n\n\tdpm_resume_start(in_suspend ?\n\t\t(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_recover",
          "args": [
            "platform_mode"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "platform_recover",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "241-245",
          "snippet": "static void platform_recover(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops && hibernation_ops->recover)\n\t\thibernation_ops->recover();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_recover(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops && hibernation_ops->recover)\n\t\thibernation_ops->recover();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_test",
          "args": [
            "TEST_DEVICES"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_test",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "137-137",
          "snippet": "static int hibernation_test(int level) { return 0; }",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int hibernation_test(int level) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "dpm_suspend",
          "args": [
            "PMSG_FREEZE"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_restrict_gfp_mask",
          "args": [],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suspend_console",
          "args": [],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2474-2482",
          "snippet": "void suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "bool console_suspend_enabled = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nbool console_suspend_enabled = true;\n\nvoid suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpm_complete",
          "args": [
            "PMSG_RECOVER"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_prepare",
          "args": [
            "PMSG_FREEZE"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeze_kernel_threads",
          "args": [],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "freeze_kernel_threads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/process.c",
          "lines": "170-187",
          "snippet": "int freeze_kernel_threads(void)\n{\n\tint error;\n\n\tpr_info(\"Freezing remaining freezable tasks ... \");\n\n\tpm_nosig_freezing = true;\n\terror = try_to_freeze_tasks(false);\n\tif (!error)\n\t\tpr_cont(\"done.\");\n\n\tpr_cont(\"\\n\");\n\tBUG_ON(in_atomic());\n\n\tif (error)\n\t\tthaw_kernel_threads();\n\treturn error;\n}",
          "includes": [
            "#include <linux/cpuset.h>",
            "#include <trace/events/power.h>",
            "#include <linux/kmod.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/suspend.h>",
            "#include <linux/oom.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nint freeze_kernel_threads(void)\n{\n\tint error;\n\n\tpr_info(\"Freezing remaining freezable tasks ... \");\n\n\tpm_nosig_freezing = true;\n\terror = try_to_freeze_tasks(false);\n\tif (!error)\n\t\tpr_cont(\"done.\");\n\n\tpr_cont(\"\\n\");\n\tBUG_ON(in_atomic());\n\n\tif (error)\n\t\tthaw_kernel_threads();\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate_preallocate_memory",
          "args": [],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_preallocate_memory",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1739-1890",
          "snippet": "int hibernate_preallocate_memory(void)\n{\n\tstruct zone *zone;\n\tunsigned long saveable, size, max_size, count, highmem, pages = 0;\n\tunsigned long alloc, save_highmem, pages_highmem, avail_normal;\n\tktime_t start, stop;\n\tint error;\n\n\tpr_info(\"Preallocating image memory\\n\");\n\tstart = ktime_get();\n\n\terror = memory_bm_create(&orig_bm, GFP_IMAGE, PG_ANY);\n\tif (error) {\n\t\tpr_err(\"Cannot allocate original bitmap\\n\");\n\t\tgoto err_out;\n\t}\n\n\terror = memory_bm_create(&copy_bm, GFP_IMAGE, PG_ANY);\n\tif (error) {\n\t\tpr_err(\"Cannot allocate copy bitmap\\n\");\n\t\tgoto err_out;\n\t}\n\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\n\t/* Count the number of saveable data pages. */\n\tsave_highmem = count_highmem_pages();\n\tsaveable = count_data_pages();\n\n\t/*\n\t * Compute the total number of page frames we can use (count) and the\n\t * number of pages needed for image metadata (size).\n\t */\n\tcount = saveable;\n\tsaveable += save_highmem;\n\thighmem = save_highmem;\n\tsize = 0;\n\tfor_each_populated_zone(zone) {\n\t\tsize += snapshot_additional_pages(zone);\n\t\tif (is_highmem(zone))\n\t\t\thighmem += zone_page_state(zone, NR_FREE_PAGES);\n\t\telse\n\t\t\tcount += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\tavail_normal = count;\n\tcount += highmem;\n\tcount -= totalreserve_pages;\n\n\t/* Compute the maximum number of saveable pages to leave in memory. */\n\tmax_size = (count - (size + PAGES_FOR_IO)) / 2\n\t\t\t- 2 * DIV_ROUND_UP(reserved_size, PAGE_SIZE);\n\t/* Compute the desired number of image pages specified by image_size. */\n\tsize = DIV_ROUND_UP(image_size, PAGE_SIZE);\n\tif (size > max_size)\n\t\tsize = max_size;\n\t/*\n\t * If the desired number of image pages is at least as large as the\n\t * current number of saveable pages in memory, allocate page frames for\n\t * the image and we're done.\n\t */\n\tif (size >= saveable) {\n\t\tpages = preallocate_image_highmem(save_highmem);\n\t\tpages += preallocate_image_memory(saveable - pages, avail_normal);\n\t\tgoto out;\n\t}\n\n\t/* Estimate the minimum size of the image. */\n\tpages = minimum_image_size(saveable);\n\t/*\n\t * To avoid excessive pressure on the normal zone, leave room in it to\n\t * accommodate an image of the minimum size (unless it's already too\n\t * small, in which case don't preallocate pages from it at all).\n\t */\n\tif (avail_normal > pages)\n\t\tavail_normal -= pages;\n\telse\n\t\tavail_normal = 0;\n\tif (size < pages)\n\t\tsize = min_t(unsigned long, pages, max_size);\n\n\t/*\n\t * Let the memory management subsystem know that we're going to need a\n\t * large number of page frames to allocate and make it free some memory.\n\t * NOTE: If this is not done, performance will be hurt badly in some\n\t * test cases.\n\t */\n\tshrink_all_memory(saveable - size);\n\n\t/*\n\t * The number of saveable pages in memory was too high, so apply some\n\t * pressure to decrease it.  First, make room for the largest possible\n\t * image and fail if that doesn't work.  Next, try to decrease the size\n\t * of the image as much as indicated by 'size' using allocations from\n\t * highmem and non-highmem zones separately.\n\t */\n\tpages_highmem = preallocate_image_highmem(highmem / 2);\n\talloc = count - max_size;\n\tif (alloc > pages_highmem)\n\t\talloc -= pages_highmem;\n\telse\n\t\talloc = 0;\n\tpages = preallocate_image_memory(alloc, avail_normal);\n\tif (pages < alloc) {\n\t\t/* We have exhausted non-highmem pages, try highmem. */\n\t\talloc -= pages;\n\t\tpages += pages_highmem;\n\t\tpages_highmem = preallocate_image_highmem(alloc);\n\t\tif (pages_highmem < alloc) {\n\t\t\tpr_err(\"Image allocation is %lu pages short\\n\",\n\t\t\t\talloc - pages_highmem);\n\t\t\tgoto err_out;\n\t\t}\n\t\tpages += pages_highmem;\n\t\t/*\n\t\t * size is the desired number of saveable pages to leave in\n\t\t * memory, so try to preallocate (all memory - size) pages.\n\t\t */\n\t\talloc = (count - pages) - size;\n\t\tpages += preallocate_image_highmem(alloc);\n\t} else {\n\t\t/*\n\t\t * There are approximately max_size saveable pages at this point\n\t\t * and we want to reduce this number down to size.\n\t\t */\n\t\talloc = max_size - size;\n\t\tsize = preallocate_highmem_fraction(alloc, highmem, count);\n\t\tpages_highmem += size;\n\t\talloc -= size;\n\t\tsize = preallocate_image_memory(alloc, avail_normal);\n\t\tpages_highmem += preallocate_image_highmem(alloc - size);\n\t\tpages += pages_highmem + size;\n\t}\n\n\t/*\n\t * We only need as many page frames for the image as there are saveable\n\t * pages in memory, but we have allocated more.  Release the excessive\n\t * ones now.\n\t */\n\tpages -= free_unnecessary_pages();\n\n out:\n\tstop = ktime_get();\n\tpr_info(\"Allocated %lu pages for snapshot\\n\", pages);\n\tswsusp_show_speed(start, stop, pages, \"Allocated\");\n\n\treturn 0;\n\n err_out:\n\tswsusp_free();\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define GFP_IMAGE\t(GFP_KERNEL | __GFP_NOWARN)",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "unsigned long reserved_size;",
            "unsigned long image_size;",
            "struct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;",
            "static unsigned int alloc_normal, alloc_highmem;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define GFP_IMAGE\t(GFP_KERNEL | __GFP_NOWARN)\n#define PG_ANY\t\t0\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nunsigned long reserved_size;\nunsigned long image_size;\nstruct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;\nstatic unsigned int alloc_normal, alloc_highmem;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint hibernate_preallocate_memory(void)\n{\n\tstruct zone *zone;\n\tunsigned long saveable, size, max_size, count, highmem, pages = 0;\n\tunsigned long alloc, save_highmem, pages_highmem, avail_normal;\n\tktime_t start, stop;\n\tint error;\n\n\tpr_info(\"Preallocating image memory\\n\");\n\tstart = ktime_get();\n\n\terror = memory_bm_create(&orig_bm, GFP_IMAGE, PG_ANY);\n\tif (error) {\n\t\tpr_err(\"Cannot allocate original bitmap\\n\");\n\t\tgoto err_out;\n\t}\n\n\terror = memory_bm_create(&copy_bm, GFP_IMAGE, PG_ANY);\n\tif (error) {\n\t\tpr_err(\"Cannot allocate copy bitmap\\n\");\n\t\tgoto err_out;\n\t}\n\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\n\t/* Count the number of saveable data pages. */\n\tsave_highmem = count_highmem_pages();\n\tsaveable = count_data_pages();\n\n\t/*\n\t * Compute the total number of page frames we can use (count) and the\n\t * number of pages needed for image metadata (size).\n\t */\n\tcount = saveable;\n\tsaveable += save_highmem;\n\thighmem = save_highmem;\n\tsize = 0;\n\tfor_each_populated_zone(zone) {\n\t\tsize += snapshot_additional_pages(zone);\n\t\tif (is_highmem(zone))\n\t\t\thighmem += zone_page_state(zone, NR_FREE_PAGES);\n\t\telse\n\t\t\tcount += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\tavail_normal = count;\n\tcount += highmem;\n\tcount -= totalreserve_pages;\n\n\t/* Compute the maximum number of saveable pages to leave in memory. */\n\tmax_size = (count - (size + PAGES_FOR_IO)) / 2\n\t\t\t- 2 * DIV_ROUND_UP(reserved_size, PAGE_SIZE);\n\t/* Compute the desired number of image pages specified by image_size. */\n\tsize = DIV_ROUND_UP(image_size, PAGE_SIZE);\n\tif (size > max_size)\n\t\tsize = max_size;\n\t/*\n\t * If the desired number of image pages is at least as large as the\n\t * current number of saveable pages in memory, allocate page frames for\n\t * the image and we're done.\n\t */\n\tif (size >= saveable) {\n\t\tpages = preallocate_image_highmem(save_highmem);\n\t\tpages += preallocate_image_memory(saveable - pages, avail_normal);\n\t\tgoto out;\n\t}\n\n\t/* Estimate the minimum size of the image. */\n\tpages = minimum_image_size(saveable);\n\t/*\n\t * To avoid excessive pressure on the normal zone, leave room in it to\n\t * accommodate an image of the minimum size (unless it's already too\n\t * small, in which case don't preallocate pages from it at all).\n\t */\n\tif (avail_normal > pages)\n\t\tavail_normal -= pages;\n\telse\n\t\tavail_normal = 0;\n\tif (size < pages)\n\t\tsize = min_t(unsigned long, pages, max_size);\n\n\t/*\n\t * Let the memory management subsystem know that we're going to need a\n\t * large number of page frames to allocate and make it free some memory.\n\t * NOTE: If this is not done, performance will be hurt badly in some\n\t * test cases.\n\t */\n\tshrink_all_memory(saveable - size);\n\n\t/*\n\t * The number of saveable pages in memory was too high, so apply some\n\t * pressure to decrease it.  First, make room for the largest possible\n\t * image and fail if that doesn't work.  Next, try to decrease the size\n\t * of the image as much as indicated by 'size' using allocations from\n\t * highmem and non-highmem zones separately.\n\t */\n\tpages_highmem = preallocate_image_highmem(highmem / 2);\n\talloc = count - max_size;\n\tif (alloc > pages_highmem)\n\t\talloc -= pages_highmem;\n\telse\n\t\talloc = 0;\n\tpages = preallocate_image_memory(alloc, avail_normal);\n\tif (pages < alloc) {\n\t\t/* We have exhausted non-highmem pages, try highmem. */\n\t\talloc -= pages;\n\t\tpages += pages_highmem;\n\t\tpages_highmem = preallocate_image_highmem(alloc);\n\t\tif (pages_highmem < alloc) {\n\t\t\tpr_err(\"Image allocation is %lu pages short\\n\",\n\t\t\t\talloc - pages_highmem);\n\t\t\tgoto err_out;\n\t\t}\n\t\tpages += pages_highmem;\n\t\t/*\n\t\t * size is the desired number of saveable pages to leave in\n\t\t * memory, so try to preallocate (all memory - size) pages.\n\t\t */\n\t\talloc = (count - pages) - size;\n\t\tpages += preallocate_image_highmem(alloc);\n\t} else {\n\t\t/*\n\t\t * There are approximately max_size saveable pages at this point\n\t\t * and we want to reduce this number down to size.\n\t\t */\n\t\talloc = max_size - size;\n\t\tsize = preallocate_highmem_fraction(alloc, highmem, count);\n\t\tpages_highmem += size;\n\t\talloc -= size;\n\t\tsize = preallocate_image_memory(alloc, avail_normal);\n\t\tpages_highmem += preallocate_image_highmem(alloc - size);\n\t\tpages += pages_highmem + size;\n\t}\n\n\t/*\n\t * We only need as many page frames for the image as there are saveable\n\t * pages in memory, but we have allocated more.  Release the excessive\n\t * ones now.\n\t */\n\tpages -= free_unnecessary_pages();\n\n out:\n\tstop = ktime_get();\n\tpr_info(\"Allocated %lu pages for snapshot\\n\", pages);\n\tswsusp_show_speed(start, stop, pages, \"Allocated\");\n\n\treturn 0;\n\n err_out:\n\tswsusp_free();\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_begin",
          "args": [
            "platform_mode"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "platform_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "144-148",
          "snippet": "static int platform_begin(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->begin(PMSG_FREEZE) : 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic int platform_begin(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->begin(PMSG_FREEZE) : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_suspend_clear_flags",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nbool freezer_test_done;\n\nint hibernation_snapshot(int platform_mode)\n{\n\tpm_message_t msg;\n\tint error;\n\n\tpm_suspend_clear_flags();\n\terror = platform_begin(platform_mode);\n\tif (error)\n\t\tgoto Close;\n\n\t/* Preallocate image memory before shutting down devices. */\n\terror = hibernate_preallocate_memory();\n\tif (error)\n\t\tgoto Close;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto Cleanup;\n\n\tif (hibernation_test(TEST_FREEZER)) {\n\n\t\t/*\n\t\t * Indicate to the caller that we are returning due to a\n\t\t * successful freezer test.\n\t\t */\n\t\tfreezer_test_done = true;\n\t\tgoto Thaw;\n\t}\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error) {\n\t\tdpm_complete(PMSG_RECOVER);\n\t\tgoto Thaw;\n\t}\n\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\n\tif (error || hibernation_test(TEST_DEVICES))\n\t\tplatform_recover(platform_mode);\n\telse\n\t\terror = create_image(platform_mode);\n\n\t/*\n\t * In the case that we call create_image() above, the control\n\t * returns here (1) after the image has been created or the\n\t * image creation has failed and (2) after a successful restore.\n\t */\n\n\t/* We may need to release the preallocated image pages here. */\n\tif (error || !in_suspend)\n\t\tswsusp_free();\n\n\tmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;\n\tdpm_resume(msg);\n\n\tif (error || !in_suspend)\n\t\tpm_restore_gfp_mask();\n\n\tresume_console();\n\tdpm_complete(msg);\n\n Close:\n\tplatform_end(platform_mode);\n\treturn error;\n\n Thaw:\n\tthaw_kernel_threads();\n Cleanup:\n\tswsusp_free();\n\tgoto Close;\n}"
  },
  {
    "function_name": "create_image",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "289-358",
    "snippet": "static int create_image(int platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_FREEZE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_snapshot(platform_mode);\n\tif (error || hibernation_test(TEST_PLATFORM))\n\t\tgoto Platform_finish;\n\n\terror = pm_sleep_disable_secondary_cpus();\n\tif (error || hibernation_test(TEST_CPUS))\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error) {\n\t\tpr_err(\"Some system devices failed to power down, aborting\\n\");\n\t\tgoto Enable_irqs;\n\t}\n\n\tif (hibernation_test(TEST_CORE) || pm_wakeup_pending())\n\t\tgoto Power_up;\n\n\tin_suspend = 1;\n\tsave_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, true);\n\terror = swsusp_arch_suspend();\n\t/* Restore control flow magically appears here */\n\trestore_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, false);\n\tif (error)\n\t\tpr_err(\"Error %d creating image\\n\", error);\n\n\tif (!in_suspend) {\n\t\tevents_check_enabled = false;\n\t\tclear_or_poison_free_pages();\n\t}\n\n\tplatform_leave(platform_mode);\n\n Power_up:\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n\t/* Allow architectures to do nosmt-specific post-resume dances */\n\tif (!in_suspend)\n\t\terror = arch_resume_nosmt();\n\n Platform_finish:\n\tplatform_finish(platform_mode);\n\n\tdpm_resume_start(in_suspend ?\n\t\t(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE);\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dpm_resume_start",
          "args": [
            "in_suspend ?\n\t\t(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_finish",
          "args": [
            "platform_mode"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "platform_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "198-202",
          "snippet": "static void platform_finish(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->finish();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_finish(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_resume_nosmt",
          "args": [],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "arch_resume_nosmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "275-278",
          "snippet": "__weak int arch_resume_nosmt(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\n__weak int arch_resume_nosmt(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_sleep_enable_secondary_cpus",
          "args": [],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "pm_sleep_enable_secondary_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "323-327",
          "snippet": "static inline void pm_sleep_enable_secondary_cpus(void)\n{\n\tsuspend_enable_secondary_cpus();\n\tcpuidle_resume();\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void pm_sleep_enable_secondary_cpus(void)\n{\n\tsuspend_enable_secondary_cpus();\n\tcpuidle_resume();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_resume",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "irq_pm_syscore_resume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
          "lines": "234-237",
          "snippet": "static void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_leave",
          "args": [
            "platform_mode"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "platform_leave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "183-187",
          "snippet": "static void platform_leave(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->leave();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_leave(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->leave();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_or_poison_free_pages",
          "args": [],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "clear_or_poison_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "1189-1209",
          "snippet": "void clear_or_poison_free_pages(void)\n{\n\tstruct memory_bitmap *bm = free_pages_map;\n\tunsigned long pfn;\n\n\tif (WARN_ON(!(free_pages_map)))\n\t\treturn;\n\n\tif (page_poisoning_enabled() || want_init_on_free()) {\n\t\tmemory_bm_position_reset(bm);\n\t\tpfn = memory_bm_next_pfn(bm);\n\t\twhile (pfn != BM_END_OF_MAP) {\n\t\t\tif (pfn_valid(pfn))\n\t\t\t\tclear_or_poison_free_page(pfn_to_page(pfn));\n\n\t\t\tpfn = memory_bm_next_pfn(bm);\n\t\t}\n\t\tmemory_bm_position_reset(bm);\n\t\tpr_info(\"free pages cleared after restore\\n\");\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define BM_END_OF_MAP\t(~0UL)"
          ],
          "globals_used": [
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define BM_END_OF_MAP\t(~0UL)\n\nstatic struct memory_bitmap *free_pages_map;\n\nvoid clear_or_poison_free_pages(void)\n{\n\tstruct memory_bitmap *bm = free_pages_map;\n\tunsigned long pfn;\n\n\tif (WARN_ON(!(free_pages_map)))\n\t\treturn;\n\n\tif (page_poisoning_enabled() || want_init_on_free()) {\n\t\tmemory_bm_position_reset(bm);\n\t\tpfn = memory_bm_next_pfn(bm);\n\t\twhile (pfn != BM_END_OF_MAP) {\n\t\t\tif (pfn_valid(pfn))\n\t\t\t\tclear_or_poison_free_page(pfn_to_page(pfn));\n\n\t\t\tpfn = memory_bm_next_pfn(bm);\n\t\t}\n\t\tmemory_bm_position_reset(bm);\n\t\tpr_info(\"free pages cleared after restore\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error %d creating image\\n\"",
            "error"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"machine_suspend\")",
            "PM_EVENT_HIBERNATE",
            "false"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"machine_suspend\""
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_processor_state",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_arch_suspend",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"machine_suspend\")",
            "PM_EVENT_HIBERNATE",
            "true"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"machine_suspend\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_processor_state",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_wakeup_pending",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_test",
          "args": [
            "TEST_CORE"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_test",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "137-137",
          "snippet": "static int hibernation_test(int level) { return 0; }",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int hibernation_test(int level) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Some system devices failed to power down, aborting\\n\""
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_suspend",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_sleep_disable_secondary_cpus",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "pm_sleep_disable_secondary_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "317-321",
          "snippet": "static inline int pm_sleep_disable_secondary_cpus(void)\n{\n\tcpuidle_pause();\n\treturn suspend_disable_secondary_cpus();\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int pm_sleep_disable_secondary_cpus(void)\n{\n\tcpuidle_pause();\n\treturn suspend_disable_secondary_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_pre_snapshot",
          "args": [
            "platform_mode"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "platform_pre_snapshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "168-172",
          "snippet": "static int platform_pre_snapshot(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_snapshot() : 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic int platform_pre_snapshot(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_snapshot() : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Some devices failed to power down, aborting\\n\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_suspend_end",
          "args": [
            "PMSG_FREEZE"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int create_image(int platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_FREEZE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_snapshot(platform_mode);\n\tif (error || hibernation_test(TEST_PLATFORM))\n\t\tgoto Platform_finish;\n\n\terror = pm_sleep_disable_secondary_cpus();\n\tif (error || hibernation_test(TEST_CPUS))\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error) {\n\t\tpr_err(\"Some system devices failed to power down, aborting\\n\");\n\t\tgoto Enable_irqs;\n\t}\n\n\tif (hibernation_test(TEST_CORE) || pm_wakeup_pending())\n\t\tgoto Power_up;\n\n\tin_suspend = 1;\n\tsave_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, true);\n\terror = swsusp_arch_suspend();\n\t/* Restore control flow magically appears here */\n\trestore_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, false);\n\tif (error)\n\t\tpr_err(\"Error %d creating image\\n\", error);\n\n\tif (!in_suspend) {\n\t\tevents_check_enabled = false;\n\t\tclear_or_poison_free_pages();\n\t}\n\n\tplatform_leave(platform_mode);\n\n Power_up:\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n\t/* Allow architectures to do nosmt-specific post-resume dances */\n\tif (!in_suspend)\n\t\terror = arch_resume_nosmt();\n\n Platform_finish:\n\tplatform_finish(platform_mode);\n\n\tdpm_resume_start(in_suspend ?\n\t\t(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE);\n\n\treturn error;\n}"
  },
  {
    "function_name": "arch_resume_nosmt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "275-278",
    "snippet": "__weak int arch_resume_nosmt(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\n__weak int arch_resume_nosmt(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "swsusp_show_speed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "254-273",
    "snippet": "void swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\"",
            "msg",
            "k",
            "centisecs / 100",
            "centisecs % 100",
            "kps / 1000",
            "(kps % 1000) / 10"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_divns",
          "args": [
            "diff",
            "10*NSEC_PER_MSEC"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_divns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "303-320",
          "snippet": "s64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (u32) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\ns64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (u32) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "stop",
            "start"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nvoid swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t/* avoid div-by-zero */\n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}"
  },
  {
    "function_name": "platform_recover",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "241-245",
    "snippet": "static void platform_recover(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops && hibernation_ops->recover)\n\t\thibernation_ops->recover();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->recover",
          "args": [],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_recover(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops && hibernation_ops->recover)\n\t\thibernation_ops->recover();\n}"
  },
  {
    "function_name": "platform_restore_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "231-235",
    "snippet": "static void platform_restore_cleanup(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->restore_cleanup();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->restore_cleanup",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_restore_cleanup(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->restore_cleanup();\n}"
  },
  {
    "function_name": "platform_pre_restore",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "214-218",
    "snippet": "static int platform_pre_restore(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_restore() : 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->pre_restore",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic int platform_pre_restore(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_restore() : 0;\n}"
  },
  {
    "function_name": "platform_finish",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "198-202",
    "snippet": "static void platform_finish(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->finish();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->finish",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/preload/bpf_preload_kern.c",
          "lines": "51-70",
          "snippet": "static int finish(void)\n{\n\tint magic = BPF_PRELOAD_END;\n\tstruct pid *tgid;\n\tloff_t pos = 0;\n\tssize_t n;\n\n\t/* send the last magic to UMD. It will do a normal exit. */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\n\ttgid = umd_ops.info.tgid;\n\tif (tgid) {\n\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\t\tumd_cleanup_helper(&umd_ops.info);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"bpf_preload.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int finish(void);",
            "static struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_preload.h\"\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/pid.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int finish(void);\nstatic struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};\n\nstatic int finish(void)\n{\n\tint magic = BPF_PRELOAD_END;\n\tstruct pid *tgid;\n\tloff_t pos = 0;\n\tssize_t n;\n\n\t/* send the last magic to UMD. It will do a normal exit. */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\n\ttgid = umd_ops.info.tgid;\n\tif (tgid) {\n\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\t\tumd_cleanup_helper(&umd_ops.info);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_finish(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->finish();\n}"
  },
  {
    "function_name": "platform_leave",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "183-187",
    "snippet": "static void platform_leave(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->leave();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->leave",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_leave(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->leave();\n}"
  },
  {
    "function_name": "platform_pre_snapshot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "168-172",
    "snippet": "static int platform_pre_snapshot(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_snapshot() : 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->pre_snapshot",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic int platform_pre_snapshot(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_snapshot() : 0;\n}"
  },
  {
    "function_name": "platform_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "154-158",
    "snippet": "static void platform_end(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->end();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->end",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic void platform_end(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->end();\n}"
  },
  {
    "function_name": "platform_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "144-148",
    "snippet": "static int platform_begin(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->begin(PMSG_FREEZE) : 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_ops->begin",
          "args": [
            "PMSG_FREEZE"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic int platform_begin(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->begin(PMSG_FREEZE) : 0;\n}"
  },
  {
    "function_name": "hibernation_test",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "137-137",
    "snippet": "static int hibernation_test(int level) { return 0; }",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int hibernation_test(int level) { return 0; }"
  },
  {
    "function_name": "hibernation_test",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "128-135",
    "snippet": "static int hibernation_test(int level)\n{\n\tif (pm_test_level == level) {\n\t\thibernation_debug_sleep();\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hibernation_debug_sleep",
          "args": [],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_debug_sleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
          "lines": "122-126",
          "snippet": "static void hibernation_debug_sleep(void)\n{\n\tpr_info(\"debug: Waiting for 5 seconds.\\n\");\n\tmdelay(5000);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/secretmem.h>",
            "#include <linux/security.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic void hibernation_debug_sleep(void)\n{\n\tpr_info(\"debug: Waiting for 5 seconds.\\n\");\n\tmdelay(5000);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int hibernation_test(int level)\n{\n\tif (pm_test_level == level) {\n\t\thibernation_debug_sleep();\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "hibernation_debug_sleep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "122-126",
    "snippet": "static void hibernation_debug_sleep(void)\n{\n\tpr_info(\"debug: Waiting for 5 seconds.\\n\");\n\tmdelay(5000);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "5000"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"debug: Waiting for 5 seconds.\\n\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic void hibernation_debug_sleep(void)\n{\n\tpr_info(\"debug: Waiting for 5 seconds.\\n\");\n\tmdelay(5000);\n}"
  },
  {
    "function_name": "system_entering_hibernation",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "115-118",
    "snippet": "bool system_entering_hibernation(void)\n{\n\treturn entering_platform_hibernation;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool entering_platform_hibernation;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic bool entering_platform_hibernation;\n\nbool system_entering_hibernation(void)\n{\n\treturn entering_platform_hibernation;\n}"
  },
  {
    "function_name": "hibernation_set_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "94-110",
    "snippet": "void hibernation_set_ops(const struct platform_hibernation_ops *ops)\n{\n\tif (ops && !(ops->begin && ops->end &&  ops->pre_snapshot\n\t    && ops->prepare && ops->finish && ops->enter && ops->pre_restore\n\t    && ops->restore_cleanup && ops->leave)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tlock_system_sleep();\n\thibernation_ops = ops;\n\tif (ops)\n\t\thibernation_mode = HIBERNATION_PLATFORM;\n\telse if (hibernation_mode == HIBERNATION_PLATFORM)\n\t\thibernation_mode = HIBERNATION_SHUTDOWN;\n\n\tunlock_system_sleep();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
      "static const struct platform_hibernation_ops *hibernation_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_runtime.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_runtime.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nvoid hibernation_set_ops(const struct platform_hibernation_ops *ops)\n{\n\tif (ops && !(ops->begin && ops->end &&  ops->pre_snapshot\n\t    && ops->prepare && ops->finish && ops->enter && ops->pre_restore\n\t    && ops->restore_cleanup && ops->leave)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tlock_system_sleep();\n\thibernation_ops = ops;\n\tif (ops)\n\t\thibernation_mode = HIBERNATION_PLATFORM;\n\telse if (hibernation_mode == HIBERNATION_PLATFORM)\n\t\thibernation_mode = HIBERNATION_SHUTDOWN;\n\n\tunlock_system_sleep();\n}"
  },
  {
    "function_name": "hibernation_available",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "83-88",
    "snippet": "bool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nohibernate;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "secretmem_active",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_HIBERNATION"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active();\n}"
  },
  {
    "function_name": "hibernate_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "78-81",
    "snippet": "void hibernate_release(void)\n{\n\tatomic_inc(&hibernate_atomic);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t hibernate_atomic = ATOMIC_INIT(1);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&hibernate_atomic"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic atomic_t hibernate_atomic = ATOMIC_INIT(1);\n\nvoid hibernate_release(void)\n{\n\tatomic_inc(&hibernate_atomic);\n}"
  },
  {
    "function_name": "hibernate_acquire",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/hibernate.c",
    "lines": "73-76",
    "snippet": "bool hibernate_acquire(void)\n{\n\treturn atomic_add_unless(&hibernate_atomic, -1, 0);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <trace/events/power.h>",
      "#include <linux/secretmem.h>",
      "#include <linux/security.h>",
      "#include <linux/ktime.h>",
      "#include <linux/genhd.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/gfp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/nmi.h>",
      "#include <linux/pm.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/delay.h>",
      "#include <linux/async.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/suspend.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t hibernate_atomic = ATOMIC_INIT(1);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_add_unless",
          "args": [
            "&hibernate_atomic",
            "-1",
            "0"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/secretmem.h>\n#include <linux/security.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic atomic_t hibernate_atomic = ATOMIC_INIT(1);\n\nbool hibernate_acquire(void)\n{\n\treturn atomic_add_unless(&hibernate_atomic, -1, 0);\n}"
  }
]