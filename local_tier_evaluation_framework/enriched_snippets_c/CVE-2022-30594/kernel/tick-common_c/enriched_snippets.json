[
  {
    "function_name": "tick_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "575-579",
    "snippet": "void __init tick_init(void)\n{\n\ttick_broadcast_init();\n\ttick_nohz_init();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_init",
          "args": [],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "526-565",
          "snippet": "void __init tick_nohz_init(void)\n{\n\tint cpu, ret;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\t/*\n\t * Full dynticks uses irq work to drive the tick rescheduling on safe\n\t * locking contexts. But then we need irq work to raise its own\n\t * interrupts to avoid circular dependency on the tick\n\t */\n\tif (!arch_irq_work_has_interrupt()) {\n\t\tpr_warn(\"NO_HZ: Can't run full dynticks because arch doesn't support irq work self-IPIs\\n\");\n\t\tcpumask_clear(tick_nohz_full_mask);\n\t\ttick_nohz_full_running = false;\n\t\treturn;\n\t}\n\n\tif (IS_ENABLED(CONFIG_PM_SLEEP_SMP) &&\n\t\t\t!IS_ENABLED(CONFIG_PM_SLEEP_SMP_NONZERO_CPU)) {\n\t\tcpu = smp_processor_id();\n\n\t\tif (cpumask_test_cpu(cpu, tick_nohz_full_mask)) {\n\t\t\tpr_warn(\"NO_HZ: Clearing %d from nohz_full range \"\n\t\t\t\t\"for timekeeping\\n\", cpu);\n\t\t\tcpumask_clear_cpu(cpu, tick_nohz_full_mask);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, tick_nohz_full_mask)\n\t\tcontext_tracking_cpu_set(cpu);\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"kernel/nohz:predown\", NULL,\n\t\t\t\t\ttick_nohz_cpu_down);\n\tWARN_ON(ret < 0);\n\tpr_info(\"NO_HZ: Full dynticks CPUs: %*pbl.\\n\",\n\t\tcpumask_pr_args(tick_nohz_full_mask));\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid __init tick_nohz_init(void)\n{\n\tint cpu, ret;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\t/*\n\t * Full dynticks uses irq work to drive the tick rescheduling on safe\n\t * locking contexts. But then we need irq work to raise its own\n\t * interrupts to avoid circular dependency on the tick\n\t */\n\tif (!arch_irq_work_has_interrupt()) {\n\t\tpr_warn(\"NO_HZ: Can't run full dynticks because arch doesn't support irq work self-IPIs\\n\");\n\t\tcpumask_clear(tick_nohz_full_mask);\n\t\ttick_nohz_full_running = false;\n\t\treturn;\n\t}\n\n\tif (IS_ENABLED(CONFIG_PM_SLEEP_SMP) &&\n\t\t\t!IS_ENABLED(CONFIG_PM_SLEEP_SMP_NONZERO_CPU)) {\n\t\tcpu = smp_processor_id();\n\n\t\tif (cpumask_test_cpu(cpu, tick_nohz_full_mask)) {\n\t\t\tpr_warn(\"NO_HZ: Clearing %d from nohz_full range \"\n\t\t\t\t\"for timekeeping\\n\", cpu);\n\t\t\tcpumask_clear_cpu(cpu, tick_nohz_full_mask);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, tick_nohz_full_mask)\n\t\tcontext_tracking_cpu_set(cpu);\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"kernel/nohz:predown\", NULL,\n\t\t\t\t\ttick_nohz_cpu_down);\n\tWARN_ON(ret < 0);\n\tpr_info(\"NO_HZ: Full dynticks CPUs: %*pbl.\\n\",\n\t\tcpumask_pr_args(tick_nohz_full_mask));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_init",
          "args": [],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_init_sysfs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "744-744",
          "snippet": "static inline int tick_broadcast_init_sysfs(void) { return 0; }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic inline int tick_broadcast_init_sysfs(void) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid __init tick_init(void)\n{\n\ttick_broadcast_init();\n\ttick_nohz_init();\n}"
  },
  {
    "function_name": "tick_unfreeze",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "551-569",
    "snippet": "void tick_unfreeze(void)\n{\n\traw_spin_lock(&tick_freeze_lock);\n\n\tif (tick_freeze_depth == num_online_cpus()) {\n\t\ttimekeeping_resume();\n\t\tsched_clock_resume();\n\t\tsystem_state = SYSTEM_RUNNING;\n\t\ttrace_suspend_resume(TPS(\"timekeeping_freeze\"),\n\t\t\t\t     smp_processor_id(), false);\n\t} else {\n\t\ttouch_softlockup_watchdog();\n\t\ttick_resume_local();\n\t}\n\n\ttick_freeze_depth--;\n\n\traw_spin_unlock(&tick_freeze_lock);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&tick_freeze_lock"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_resume_local",
          "args": [],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "tick_resume_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "461-480",
          "snippet": "void tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n\n\t/*\n\t * Ensure that hrtimers are up to date and the clockevents device\n\t * is reprogrammed correctly when high resolution timers are\n\t * enabled.\n\t */\n\thrtimers_resume_local();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n\n\t/*\n\t * Ensure that hrtimers are up to date and the clockevents device\n\t * is reprogrammed correctly when high resolution timers are\n\t * enabled.\n\t */\n\thrtimers_resume_local();\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog",
          "args": [],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "299-303",
          "snippet": "void touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nvoid touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"timekeeping_freeze\")",
            "smp_processor_id()",
            "false"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"timekeeping_freeze\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_resume",
          "args": [],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_resume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.h",
          "lines": "22-22",
          "snippet": "static inline void sched_clock_resume(void) { }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void sched_clock_resume(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_resume",
          "args": [],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_resume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1756-1816",
          "snippet": "void timekeeping_resume(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *clock = tk->tkr_mono.clock;\n\tunsigned long flags;\n\tstruct timespec64 ts_new, ts_delta;\n\tu64 cycle_now, nsec;\n\tbool inject_sleeptime = false;\n\n\tread_persistent_clock64(&ts_new);\n\n\tclockevents_resume();\n\tclocksource_resume();\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\t/*\n\t * After system resumes, we need to calculate the suspended time and\n\t * compensate it for the OS time. There are 3 sources that could be\n\t * used: Nonstop clocksource during suspend, persistent clock and rtc\n\t * device.\n\t *\n\t * One specific platform may have 1 or 2 or all of them, and the\n\t * preference will be:\n\t *\tsuspend-nonstop clocksource -> persistent clock -> rtc\n\t * The less preferred source will only be tried if there is no better\n\t * usable source. The rtc part is handled separately in rtc core code.\n\t */\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tnsec = clocksource_stop_suspend_timing(clock, cycle_now);\n\tif (nsec > 0) {\n\t\tts_delta = ns_to_timespec64(nsec);\n\t\tinject_sleeptime = true;\n\t} else if (timespec64_compare(&ts_new, &timekeeping_suspend_time) > 0) {\n\t\tts_delta = timespec64_sub(ts_new, timekeeping_suspend_time);\n\t\tinject_sleeptime = true;\n\t}\n\n\tif (inject_sleeptime) {\n\t\tsuspend_timing_needed = false;\n\t\t__timekeeping_inject_sleeptime(tk, &ts_delta);\n\t}\n\n\t/* Re-base the last cycle value */\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->ntp_error = 0;\n\ttimekeeping_suspended = 0;\n\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttouch_softlockup_watchdog();\n\n\t/* Resume the clockevent device(s) and hrtimers */\n\ttick_resume();\n\t/* Notify timerfd as resume is equivalent to clock_was_set() */\n\ttimerfd_resume();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)"
          ],
          "globals_used": [
            "static bool suspend_timing_needed;",
            "static struct timespec64 timekeeping_suspend_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n\nstatic bool suspend_timing_needed;\nstatic struct timespec64 timekeeping_suspend_time;\n\nvoid timekeeping_resume(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *clock = tk->tkr_mono.clock;\n\tunsigned long flags;\n\tstruct timespec64 ts_new, ts_delta;\n\tu64 cycle_now, nsec;\n\tbool inject_sleeptime = false;\n\n\tread_persistent_clock64(&ts_new);\n\n\tclockevents_resume();\n\tclocksource_resume();\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\t/*\n\t * After system resumes, we need to calculate the suspended time and\n\t * compensate it for the OS time. There are 3 sources that could be\n\t * used: Nonstop clocksource during suspend, persistent clock and rtc\n\t * device.\n\t *\n\t * One specific platform may have 1 or 2 or all of them, and the\n\t * preference will be:\n\t *\tsuspend-nonstop clocksource -> persistent clock -> rtc\n\t * The less preferred source will only be tried if there is no better\n\t * usable source. The rtc part is handled separately in rtc core code.\n\t */\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tnsec = clocksource_stop_suspend_timing(clock, cycle_now);\n\tif (nsec > 0) {\n\t\tts_delta = ns_to_timespec64(nsec);\n\t\tinject_sleeptime = true;\n\t} else if (timespec64_compare(&ts_new, &timekeeping_suspend_time) > 0) {\n\t\tts_delta = timespec64_sub(ts_new, timekeeping_suspend_time);\n\t\tinject_sleeptime = true;\n\t}\n\n\tif (inject_sleeptime) {\n\t\tsuspend_timing_needed = false;\n\t\t__timekeeping_inject_sleeptime(tk, &ts_delta);\n\t}\n\n\t/* Re-base the last cycle value */\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->ntp_error = 0;\n\ttimekeeping_suspended = 0;\n\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttouch_softlockup_watchdog();\n\n\t/* Resume the clockevent device(s) and hrtimers */\n\ttick_resume();\n\t/* Notify timerfd as resume is equivalent to clock_was_set() */\n\ttimerfd_resume();\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&tick_freeze_lock"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_unfreeze(void)\n{\n\traw_spin_lock(&tick_freeze_lock);\n\n\tif (tick_freeze_depth == num_online_cpus()) {\n\t\ttimekeeping_resume();\n\t\tsched_clock_resume();\n\t\tsystem_state = SYSTEM_RUNNING;\n\t\ttrace_suspend_resume(TPS(\"timekeeping_freeze\"),\n\t\t\t\t     smp_processor_id(), false);\n\t} else {\n\t\ttouch_softlockup_watchdog();\n\t\ttick_resume_local();\n\t}\n\n\ttick_freeze_depth--;\n\n\traw_spin_unlock(&tick_freeze_lock);\n}"
  },
  {
    "function_name": "tick_freeze",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "524-540",
    "snippet": "void tick_freeze(void)\n{\n\traw_spin_lock(&tick_freeze_lock);\n\n\ttick_freeze_depth++;\n\tif (tick_freeze_depth == num_online_cpus()) {\n\t\ttrace_suspend_resume(TPS(\"timekeeping_freeze\"),\n\t\t\t\t     smp_processor_id(), true);\n\t\tsystem_state = SYSTEM_SUSPEND;\n\t\tsched_clock_suspend();\n\t\ttimekeeping_suspend();\n\t} else {\n\t\ttick_suspend_local();\n\t}\n\n\traw_spin_unlock(&tick_freeze_lock);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&tick_freeze_lock"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_suspend_local",
          "args": [],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "tick_suspend_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "447-452",
          "snippet": "void tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_suspend",
          "args": [],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_suspend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1818-1885",
          "snippet": "int timekeeping_suspend(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64\t\tdelta, delta_delta;\n\tstatic struct timespec64\told_delta;\n\tstruct clocksource *curr_clock;\n\tu64 cycle_now;\n\n\tread_persistent_clock64(&timekeeping_suspend_time);\n\n\t/*\n\t * On some systems the persistent_clock can not be detected at\n\t * timekeeping_init by its return value, so if we see a valid\n\t * value returned, update the persistent_clock_exists flag.\n\t */\n\tif (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)\n\t\tpersistent_clock_exists = true;\n\n\tsuspend_timing_needed = true;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\ttimekeeping_forward_now(tk);\n\ttimekeeping_suspended = 1;\n\n\t/*\n\t * Since we've called forward_now, cycle_last stores the value\n\t * just read from the current clocksource. Save this to potentially\n\t * use in suspend timing.\n\t */\n\tcurr_clock = tk->tkr_mono.clock;\n\tcycle_now = tk->tkr_mono.cycle_last;\n\tclocksource_start_suspend_timing(curr_clock, cycle_now);\n\n\tif (persistent_clock_exists) {\n\t\t/*\n\t\t * To avoid drift caused by repeated suspend/resumes,\n\t\t * which each can add ~1 second drift error,\n\t\t * try to compensate so the difference in system time\n\t\t * and persistent_clock time stays close to constant.\n\t\t */\n\t\tdelta = timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);\n\t\tdelta_delta = timespec64_sub(delta, old_delta);\n\t\tif (abs(delta_delta.tv_sec) >= 2) {\n\t\t\t/*\n\t\t\t * if delta_delta is too large, assume time correction\n\t\t\t * has occurred and set old_delta to the current delta.\n\t\t\t */\n\t\t\told_delta = delta;\n\t\t} else {\n\t\t\t/* Otherwise try to adjust old_system to compensate */\n\t\t\ttimekeeping_suspend_time =\n\t\t\t\ttimespec64_add(timekeeping_suspend_time, delta_delta);\n\t\t}\n\t}\n\n\ttimekeeping_update(tk, TK_MIRROR);\n\thalt_fast_timekeeper(tk);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttick_suspend();\n\tclocksource_suspend();\n\tclockevents_suspend();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_MIRROR\t\t(1 << 1)"
          ],
          "globals_used": [
            "static bool suspend_timing_needed;",
            "static bool persistent_clock_exists;",
            "static struct timespec64 timekeeping_suspend_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_MIRROR\t\t(1 << 1)\n\nstatic bool suspend_timing_needed;\nstatic bool persistent_clock_exists;\nstatic struct timespec64 timekeeping_suspend_time;\n\nint timekeeping_suspend(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64\t\tdelta, delta_delta;\n\tstatic struct timespec64\told_delta;\n\tstruct clocksource *curr_clock;\n\tu64 cycle_now;\n\n\tread_persistent_clock64(&timekeeping_suspend_time);\n\n\t/*\n\t * On some systems the persistent_clock can not be detected at\n\t * timekeeping_init by its return value, so if we see a valid\n\t * value returned, update the persistent_clock_exists flag.\n\t */\n\tif (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)\n\t\tpersistent_clock_exists = true;\n\n\tsuspend_timing_needed = true;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\ttimekeeping_forward_now(tk);\n\ttimekeeping_suspended = 1;\n\n\t/*\n\t * Since we've called forward_now, cycle_last stores the value\n\t * just read from the current clocksource. Save this to potentially\n\t * use in suspend timing.\n\t */\n\tcurr_clock = tk->tkr_mono.clock;\n\tcycle_now = tk->tkr_mono.cycle_last;\n\tclocksource_start_suspend_timing(curr_clock, cycle_now);\n\n\tif (persistent_clock_exists) {\n\t\t/*\n\t\t * To avoid drift caused by repeated suspend/resumes,\n\t\t * which each can add ~1 second drift error,\n\t\t * try to compensate so the difference in system time\n\t\t * and persistent_clock time stays close to constant.\n\t\t */\n\t\tdelta = timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);\n\t\tdelta_delta = timespec64_sub(delta, old_delta);\n\t\tif (abs(delta_delta.tv_sec) >= 2) {\n\t\t\t/*\n\t\t\t * if delta_delta is too large, assume time correction\n\t\t\t * has occurred and set old_delta to the current delta.\n\t\t\t */\n\t\t\told_delta = delta;\n\t\t} else {\n\t\t\t/* Otherwise try to adjust old_system to compensate */\n\t\t\ttimekeeping_suspend_time =\n\t\t\t\ttimespec64_add(timekeeping_suspend_time, delta_delta);\n\t\t}\n\t}\n\n\ttimekeeping_update(tk, TK_MIRROR);\n\thalt_fast_timekeeper(tk);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttick_suspend();\n\tclocksource_suspend();\n\tclockevents_suspend();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock_suspend",
          "args": [],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_suspend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.h",
          "lines": "21-21",
          "snippet": "static inline int sched_clock_suspend(void) { return 0; }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int sched_clock_suspend(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"timekeeping_freeze\")",
            "smp_processor_id()",
            "true"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"timekeeping_freeze\""
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&tick_freeze_lock"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_freeze(void)\n{\n\traw_spin_lock(&tick_freeze_lock);\n\n\ttick_freeze_depth++;\n\tif (tick_freeze_depth == num_online_cpus()) {\n\t\ttrace_suspend_resume(TPS(\"timekeeping_freeze\"),\n\t\t\t\t     smp_processor_id(), true);\n\t\tsystem_state = SYSTEM_SUSPEND;\n\t\tsched_clock_suspend();\n\t\ttimekeeping_suspend();\n\t} else {\n\t\ttick_suspend_local();\n\t}\n\n\traw_spin_unlock(&tick_freeze_lock);\n}"
  },
  {
    "function_name": "tick_resume",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "505-509",
    "snippet": "void tick_resume(void)\n{\n\ttick_resume_broadcast();\n\ttick_resume_local();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_resume_local",
          "args": [],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "tick_resume_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "461-480",
          "snippet": "void tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n\n\t/*\n\t * Ensure that hrtimers are up to date and the clockevents device\n\t * is reprogrammed correctly when high resolution timers are\n\t * enabled.\n\t */\n\thrtimers_resume_local();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n\n\t/*\n\t * Ensure that hrtimers are up to date and the clockevents device\n\t * is reprogrammed correctly when high resolution timers are\n\t * enabled.\n\t */\n\thrtimers_resume_local();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_resume_broadcast",
          "args": [],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "tick_resume_broadcast",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "578-602",
          "snippet": "void tick_resume_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc) {\n\t\tclockevents_tick_resume(bc);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_broadcast_start_periodic(bc);\n\t\t\tbreak;\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_resume_broadcast_oneshot(bc);\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static cpumask_var_t tick_broadcast_mask",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_resume_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc) {\n\t\tclockevents_tick_resume(bc);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_broadcast_start_periodic(bc);\n\t\t\tbreak;\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_resume_broadcast_oneshot(bc);\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_resume(void)\n{\n\ttick_resume_broadcast();\n\ttick_resume_local();\n}"
  },
  {
    "function_name": "tick_suspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "491-495",
    "snippet": "void tick_suspend(void)\n{\n\ttick_suspend_local();\n\ttick_suspend_broadcast();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_suspend_broadcast",
          "args": [],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "tick_suspend_broadcast",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "548-560",
          "snippet": "void tick_suspend_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\tclockevents_shutdown(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_suspend_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\tclockevents_shutdown(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_suspend_local",
          "args": [],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "tick_suspend_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "447-452",
          "snippet": "void tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_suspend(void)\n{\n\ttick_suspend_local();\n\ttick_suspend_broadcast();\n}"
  },
  {
    "function_name": "tick_resume_local",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "461-480",
    "snippet": "void tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n\n\t/*\n\t * Ensure that hrtimers are up to date and the clockevents device\n\t * is reprogrammed correctly when high resolution timers are\n\t * enabled.\n\t */\n\thrtimers_resume_local();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimers_resume_local",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimers_resume_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1004-1009",
          "snippet": "void hrtimers_resume_local(void)\n{\n\tlockdep_assert_irqs_disabled();\n\t/* Retrigger on the local CPU */\n\tretrigger_next_event(NULL);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimers_resume_local(void)\n{\n\tlockdep_assert_irqs_disabled();\n\t/* Retrigger on the local CPU */\n\tretrigger_next_event(NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_resume_oneshot",
          "args": [],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "tick_resume_oneshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "50-56",
          "snippet": "void tick_resume_oneshot(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\tclockevents_program_event(dev, ktime_get(), true);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_resume_oneshot(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\tclockevents_program_event(dev, ktime_get(), true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_setup_periodic",
          "args": [
            "td->evtdev",
            "0"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_periodic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "152-180",
          "snippet": "void tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned int seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add_ns(next, TICK_NSEC);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ktime_t tick_next_period;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\n\nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned int seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add_ns(next, TICK_NSEC);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_tick_resume",
          "args": [
            "td->evtdev"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_tick_resume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "181-189",
          "snippet": "int clockevents_tick_resume(struct clock_event_device *dev)\n{\n\tint ret = 0;\n\n\tif (dev->tick_resume)\n\t\tret = dev->tick_resume(dev);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_tick_resume(struct clock_event_device *dev)\n{\n\tint ret = 0;\n\n\tif (dev->tick_resume)\n\t\tret = dev->tick_resume(dev);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_resume_check_broadcast",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "tick_resume_check_broadcast",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "570-576",
          "snippet": "bool tick_resume_check_broadcast(void)\n{\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT)\n\t\treturn false;\n\telse\n\t\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_mask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static cpumask_var_t tick_broadcast_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\n\nbool tick_resume_check_broadcast(void)\n{\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT)\n\t\treturn false;\n\telse\n\t\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n\n\t/*\n\t * Ensure that hrtimers are up to date and the clockevents device\n\t * is reprogrammed correctly when high resolution timers are\n\t * enabled.\n\t */\n\thrtimers_resume_local();\n}"
  },
  {
    "function_name": "tick_suspend_local",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "447-452",
    "snippet": "void tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_shutdown",
          "args": [
            "td->evtdev"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "171-175",
          "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}"
  },
  {
    "function_name": "tick_shutdown",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "421-437",
    "snippet": "void tick_shutdown(unsigned int cpu)\n{\n\tstruct tick_device *td = &per_cpu(tick_cpu_device, cpu);\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttd->mode = TICKDEV_MODE_PERIODIC;\n\tif (dev) {\n\t\t/*\n\t\t * Prevent that the clock events layer tries to call\n\t\t * the set mode function!\n\t\t */\n\t\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\t\tclockevents_exchange_device(dev, NULL);\n\t\tdev->event_handler = clockevents_handle_noop;\n\t\ttd->evtdev = NULL;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_exchange_device",
          "args": [
            "dev",
            "NULL"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_exchange_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "568-585",
          "snippet": "void clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_move(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevents_released);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevents_released);\n\nvoid clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_move(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_set_state",
          "args": [
            "dev",
            "CLOCK_EVT_STATE_DETACHED"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_set_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-internal.h",
          "lines": "44-48",
          "snippet": "static inline void clockevent_set_state(struct clock_event_device *dev,\n\t\t\t\t\tenum clock_event_state state)\n{\n\tdev->state_use_accessors = state;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline void clockevent_set_state(struct clock_event_device *dev,\n\t\t\t\t\tenum clock_event_state state)\n{\n\tdev->state_use_accessors = state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "cpu"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_shutdown(unsigned int cpu)\n{\n\tstruct tick_device *td = &per_cpu(tick_cpu_device, cpu);\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttd->mode = TICKDEV_MODE_PERIODIC;\n\tif (dev) {\n\t\t/*\n\t\t * Prevent that the clock events layer tries to call\n\t\t * the set mode function!\n\t\t */\n\t\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\t\tclockevents_exchange_device(dev, NULL);\n\t\tdev->event_handler = clockevents_handle_noop;\n\t\ttd->evtdev = NULL;\n\t}\n}"
  },
  {
    "function_name": "tick_handover_do_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "408-412",
    "snippet": "void tick_handover_do_timer(void)\n{\n\tif (tick_do_timer_cpu == smp_processor_id())\n\t\ttick_do_timer_cpu = cpumask_first(cpu_online_mask);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int tick_do_timer_cpu"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_do_timer_cpu;\n\nvoid tick_handover_do_timer(void)\n{\n\tif (tick_do_timer_cpu == smp_processor_id())\n\t\ttick_do_timer_cpu = cpumask_first(cpu_online_mask);\n}"
  },
  {
    "function_name": "tick_broadcast_oneshot_control",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "390-398",
    "snippet": "int tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tif (!(td->evtdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn 0;\n\n\treturn __tick_broadcast_oneshot_control(state);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tick_broadcast_oneshot_control",
          "args": [
            "state"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "__tick_broadcast_oneshot_control",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "1134-1142",
          "snippet": "int __tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\tif (!bc || (bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint __tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\tif (!bc || (bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tif (!(td->evtdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn 0;\n\n\treturn __tick_broadcast_oneshot_control(state);\n}"
  },
  {
    "function_name": "tick_check_new_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "341-377",
    "snippet": "void tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\tif (!tick_check_replacement(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t/*\n\t * Replace the eventually existing device by the new\n\t * device. If the current device is the broadcast device, do\n\t * not give it back to the clockevents layer !\n\t */\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t/*\n\t * Can the new device be used as a broadcast device ?\n\t */\n\ttick_install_broadcast_device(newdev, cpu);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_install_broadcast_device",
          "args": [
            "newdev",
            "cpu"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "tick_install_broadcast_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "162-203",
          "snippet": "void tick_install_broadcast_device(struct clock_event_device *dev, int cpu)\n{\n\tstruct clock_event_device *cur = tick_broadcast_device.evtdev;\n\n\tif (tick_set_oneshot_wakeup_device(dev, cpu))\n\t\treturn;\n\n\tif (!tick_check_broadcast_device(cur, dev))\n\t\treturn;\n\n\tif (!try_module_get(dev->owner))\n\t\treturn;\n\n\tclockevents_exchange_device(cur, dev);\n\tif (cur)\n\t\tcur->event_handler = clockevents_handle_noop;\n\ttick_broadcast_device.evtdev = dev;\n\tif (!cpumask_empty(tick_broadcast_mask))\n\t\ttick_broadcast_start_periodic(dev);\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * If the system already runs in oneshot mode, switch the newly\n\t * registered broadcast device to oneshot mode explicitly.\n\t */\n\tif (tick_broadcast_oneshot_active()) {\n\t\ttick_broadcast_switch_to_oneshot();\n\t\treturn;\n\t}\n\n\t/*\n\t * Inform all cpus about this. We might be in a situation\n\t * where we did not switch to oneshot mode because the per cpu\n\t * devices are affected by CLOCK_EVT_FEAT_C3STOP and the lack\n\t * of a oneshot capable broadcast device. Without that\n\t * notification the systems stays stuck in periodic mode\n\t * forever.\n\t */\n\ttick_clock_notify();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static cpumask_var_t tick_broadcast_mask",
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nvoid tick_install_broadcast_device(struct clock_event_device *dev, int cpu)\n{\n\tstruct clock_event_device *cur = tick_broadcast_device.evtdev;\n\n\tif (tick_set_oneshot_wakeup_device(dev, cpu))\n\t\treturn;\n\n\tif (!tick_check_broadcast_device(cur, dev))\n\t\treturn;\n\n\tif (!try_module_get(dev->owner))\n\t\treturn;\n\n\tclockevents_exchange_device(cur, dev);\n\tif (cur)\n\t\tcur->event_handler = clockevents_handle_noop;\n\ttick_broadcast_device.evtdev = dev;\n\tif (!cpumask_empty(tick_broadcast_mask))\n\t\ttick_broadcast_start_periodic(dev);\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * If the system already runs in oneshot mode, switch the newly\n\t * registered broadcast device to oneshot mode explicitly.\n\t */\n\tif (tick_broadcast_oneshot_active()) {\n\t\ttick_broadcast_switch_to_oneshot();\n\t\treturn;\n\t}\n\n\t/*\n\t * Inform all cpus about this. We might be in a situation\n\t * where we did not switch to oneshot mode because the per cpu\n\t * devices are affected by CLOCK_EVT_FEAT_C3STOP and the lack\n\t * of a oneshot capable broadcast device. Without that\n\t * notification the systems stays stuck in periodic mode\n\t * forever.\n\t */\n\ttick_clock_notify();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_oneshot_notify",
          "args": [],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "tick_oneshot_notify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1510-1515",
          "snippet": "void tick_oneshot_notify(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tset_bit(0, &ts->check_clocks);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_oneshot_notify(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tset_bit(0, &ts->check_clocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_setup_device",
          "args": [
            "td",
            "newdev",
            "cpu",
            "cpumask_of(cpu)"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "205-275",
          "snippet": "static void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tvoid (*handler)(struct clock_event_device *) = NULL;\n\tktime_t next_event = 0;\n\n\t/*\n\t * First device setup ?\n\t */\n\tif (!td->evtdev) {\n\t\t/*\n\t\t * If no cpu took the do_timer update, assign it to\n\t\t * this cpu:\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\n\t\t\ttick_do_timer_cpu = cpu;\n\n\t\t\ttick_next_period = ktime_get();\n#ifdef CONFIG_NO_HZ_FULL\n\t\t\t/*\n\t\t\t * The boot CPU may be nohz_full, in which case set\n\t\t\t * tick_do_timer_boot_cpu so the first housekeeping\n\t\t\t * secondary that comes up will take do_timer from\n\t\t\t * us.\n\t\t\t */\n\t\t\tif (tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_boot_cpu = cpu;\n\n\t\t} else if (tick_do_timer_boot_cpu != -1 &&\n\t\t\t\t\t\t!tick_nohz_full_cpu(cpu)) {\n\t\t\ttick_take_do_timer_from_boot();\n\t\t\ttick_do_timer_boot_cpu = -1;\n\t\t\tWARN_ON(tick_do_timer_cpu != cpu);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * Startup in periodic mode first.\n\t\t */\n\t\ttd->mode = TICKDEV_MODE_PERIODIC;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t/*\n\t * When the device is not per cpu, pin the interrupt to the\n\t * current cpu:\n\t */\n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t/*\n\t * When global broadcasting is active, check if the current\n\t * device is registered as a placeholder for broadcast mode.\n\t * This allows us to handle this x86 misfeature in a generic\n\t * way. This function also returns !=0 when we keep the\n\t * current active broadcast state for this CPU.\n\t */\n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ktime_t tick_next_period;",
            "int tick_do_timer_cpu"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nint tick_do_timer_cpu;\n\nstatic void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tvoid (*handler)(struct clock_event_device *) = NULL;\n\tktime_t next_event = 0;\n\n\t/*\n\t * First device setup ?\n\t */\n\tif (!td->evtdev) {\n\t\t/*\n\t\t * If no cpu took the do_timer update, assign it to\n\t\t * this cpu:\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\n\t\t\ttick_do_timer_cpu = cpu;\n\n\t\t\ttick_next_period = ktime_get();\n#ifdef CONFIG_NO_HZ_FULL\n\t\t\t/*\n\t\t\t * The boot CPU may be nohz_full, in which case set\n\t\t\t * tick_do_timer_boot_cpu so the first housekeeping\n\t\t\t * secondary that comes up will take do_timer from\n\t\t\t * us.\n\t\t\t */\n\t\t\tif (tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_boot_cpu = cpu;\n\n\t\t} else if (tick_do_timer_boot_cpu != -1 &&\n\t\t\t\t\t\t!tick_nohz_full_cpu(cpu)) {\n\t\t\ttick_take_do_timer_from_boot();\n\t\t\ttick_do_timer_boot_cpu = -1;\n\t\t\tWARN_ON(tick_do_timer_cpu != cpu);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * Startup in periodic mode first.\n\t\t */\n\t\ttd->mode = TICKDEV_MODE_PERIODIC;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t/*\n\t * When the device is not per cpu, pin the interrupt to the\n\t * current cpu:\n\t */\n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t/*\n\t * When global broadcasting is active, check if the current\n\t * device is registered as a placeholder for broadcast mode.\n\t * This allows us to handle this x86 misfeature in a generic\n\t * way. This function also returns !=0 when we keep the\n\t * current active broadcast state for this CPU.\n\t */\n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_exchange_device",
          "args": [
            "curdev",
            "newdev"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_exchange_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "568-585",
          "snippet": "void clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_move(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevents_released);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevents_released);\n\nvoid clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_move(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_shutdown",
          "args": [
            "curdev"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "171-175",
          "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_is_broadcast_device",
          "args": [
            "curdev"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "tick_is_broadcast_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "208-211",
          "snippet": "int tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "newdev->owner"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1068-1084",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_replacement",
          "args": [
            "curdev",
            "newdev"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_replacement",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "328-335",
          "snippet": "bool tick_check_replacement(struct clock_event_device *curdev,\n\t\t\t    struct clock_event_device *newdev)\n{\n\tif (!tick_check_percpu(curdev, newdev, smp_processor_id()))\n\t\treturn false;\n\n\treturn tick_check_preferred(curdev, newdev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nbool tick_check_replacement(struct clock_event_device *curdev,\n\t\t\t    struct clock_event_device *newdev)\n{\n\tif (!tick_check_percpu(curdev, newdev, smp_processor_id()))\n\t\treturn false;\n\n\treturn tick_check_preferred(curdev, newdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "cpu"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\tif (!tick_check_replacement(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t/*\n\t * Replace the eventually existing device by the new\n\t * device. If the current device is the broadcast device, do\n\t * not give it back to the clockevents layer !\n\t */\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t/*\n\t * Can the new device be used as a broadcast device ?\n\t */\n\ttick_install_broadcast_device(newdev, cpu);\n}"
  },
  {
    "function_name": "tick_check_replacement",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "328-335",
    "snippet": "bool tick_check_replacement(struct clock_event_device *curdev,\n\t\t\t    struct clock_event_device *newdev)\n{\n\tif (!tick_check_percpu(curdev, newdev, smp_processor_id()))\n\t\treturn false;\n\n\treturn tick_check_preferred(curdev, newdev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_check_preferred",
          "args": [
            "curdev",
            "newdev"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_preferred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "304-322",
          "snippet": "static bool tick_check_preferred(struct clock_event_device *curdev,\n\t\t\t\t struct clock_event_device *newdev)\n{\n\t/* Prefer oneshot capable device */\n\tif (!(newdev->features & CLOCK_EVT_FEAT_ONESHOT)) {\n\t\tif (curdev && (curdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn false;\n\t\tif (tick_oneshot_mode_active())\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * Use the higher rated one, but prefer a CPU local device with a lower\n\t * rating than a non-CPU local device\n\t */\n\treturn !curdev ||\n\t\tnewdev->rating > curdev->rating ||\n\t       !cpumask_equal(curdev->cpumask, newdev->cpumask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool tick_check_preferred(struct clock_event_device *curdev,\n\t\t\t\t struct clock_event_device *newdev)\n{\n\t/* Prefer oneshot capable device */\n\tif (!(newdev->features & CLOCK_EVT_FEAT_ONESHOT)) {\n\t\tif (curdev && (curdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn false;\n\t\tif (tick_oneshot_mode_active())\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * Use the higher rated one, but prefer a CPU local device with a lower\n\t * rating than a non-CPU local device\n\t */\n\treturn !curdev ||\n\t\tnewdev->rating > curdev->rating ||\n\t       !cpumask_equal(curdev->cpumask, newdev->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_percpu",
          "args": [
            "curdev",
            "newdev",
            "smp_processor_id()"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "288-302",
          "snippet": "static bool tick_check_percpu(struct clock_event_device *curdev,\n\t\t\t      struct clock_event_device *newdev, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\treturn false;\n\tif (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn true;\n\t/* Check if irq affinity can be set */\n\tif (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))\n\t\treturn false;\n\t/* Prefer an existing cpu local device */\n\tif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool tick_check_percpu(struct clock_event_device *curdev,\n\t\t\t      struct clock_event_device *newdev, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\treturn false;\n\tif (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn true;\n\t/* Check if irq affinity can be set */\n\tif (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))\n\t\treturn false;\n\t/* Prefer an existing cpu local device */\n\tif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nbool tick_check_replacement(struct clock_event_device *curdev,\n\t\t\t    struct clock_event_device *newdev)\n{\n\tif (!tick_check_percpu(curdev, newdev, smp_processor_id()))\n\t\treturn false;\n\n\treturn tick_check_preferred(curdev, newdev);\n}"
  },
  {
    "function_name": "tick_check_preferred",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "304-322",
    "snippet": "static bool tick_check_preferred(struct clock_event_device *curdev,\n\t\t\t\t struct clock_event_device *newdev)\n{\n\t/* Prefer oneshot capable device */\n\tif (!(newdev->features & CLOCK_EVT_FEAT_ONESHOT)) {\n\t\tif (curdev && (curdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn false;\n\t\tif (tick_oneshot_mode_active())\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * Use the higher rated one, but prefer a CPU local device with a lower\n\t * rating than a non-CPU local device\n\t */\n\treturn !curdev ||\n\t\tnewdev->rating > curdev->rating ||\n\t       !cpumask_equal(curdev->cpumask, newdev->cpumask);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "curdev->cpumask",
            "newdev->cpumask"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_oneshot_mode_active",
          "args": [],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "tick_oneshot_mode_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "106-116",
          "snippet": "int tick_oneshot_mode_active(void)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = __this_cpu_read(tick_cpu_device.mode) == TICKDEV_MODE_ONESHOT;\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_oneshot_mode_active(void)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = __this_cpu_read(tick_cpu_device.mode) == TICKDEV_MODE_ONESHOT;\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool tick_check_preferred(struct clock_event_device *curdev,\n\t\t\t\t struct clock_event_device *newdev)\n{\n\t/* Prefer oneshot capable device */\n\tif (!(newdev->features & CLOCK_EVT_FEAT_ONESHOT)) {\n\t\tif (curdev && (curdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn false;\n\t\tif (tick_oneshot_mode_active())\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * Use the higher rated one, but prefer a CPU local device with a lower\n\t * rating than a non-CPU local device\n\t */\n\treturn !curdev ||\n\t\tnewdev->rating > curdev->rating ||\n\t       !cpumask_equal(curdev->cpumask, newdev->cpumask);\n}"
  },
  {
    "function_name": "tick_check_percpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "288-302",
    "snippet": "static bool tick_check_percpu(struct clock_event_device *curdev,\n\t\t\t      struct clock_event_device *newdev, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\treturn false;\n\tif (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn true;\n\t/* Check if irq affinity can be set */\n\tif (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))\n\t\treturn false;\n\t/* Prefer an existing cpu local device */\n\tif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "curdev->cpumask",
            "cpumask_of(cpu)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_can_set_affinity",
          "args": [
            "newdev->irq"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "irq_can_set_affinity_usr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "171-177",
          "snippet": "bool irq_can_set_affinity_usr(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn __irq_can_set_affinity(desc) &&\n\t\t!irqd_affinity_is_managed(&desc->irq_data);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nbool irq_can_set_affinity_usr(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn __irq_can_set_affinity(desc) &&\n\t\t!irqd_affinity_is_managed(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "newdev->cpumask",
            "cpumask_of(cpu)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "newdev->cpumask"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool tick_check_percpu(struct clock_event_device *curdev,\n\t\t\t      struct clock_event_device *newdev, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\treturn false;\n\tif (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn true;\n\t/* Check if irq affinity can be set */\n\tif (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))\n\t\treturn false;\n\t/* Prefer an existing cpu local device */\n\tif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "tick_install_replacement",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "277-286",
    "snippet": "void tick_install_replacement(struct clock_event_device *newdev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tint cpu = smp_processor_id();\n\n\tclockevents_exchange_device(td->evtdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_oneshot_notify",
          "args": [],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "tick_oneshot_notify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1510-1515",
          "snippet": "void tick_oneshot_notify(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tset_bit(0, &ts->check_clocks);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_oneshot_notify(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tset_bit(0, &ts->check_clocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_setup_device",
          "args": [
            "td",
            "newdev",
            "cpu",
            "cpumask_of(cpu)"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "205-275",
          "snippet": "static void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tvoid (*handler)(struct clock_event_device *) = NULL;\n\tktime_t next_event = 0;\n\n\t/*\n\t * First device setup ?\n\t */\n\tif (!td->evtdev) {\n\t\t/*\n\t\t * If no cpu took the do_timer update, assign it to\n\t\t * this cpu:\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\n\t\t\ttick_do_timer_cpu = cpu;\n\n\t\t\ttick_next_period = ktime_get();\n#ifdef CONFIG_NO_HZ_FULL\n\t\t\t/*\n\t\t\t * The boot CPU may be nohz_full, in which case set\n\t\t\t * tick_do_timer_boot_cpu so the first housekeeping\n\t\t\t * secondary that comes up will take do_timer from\n\t\t\t * us.\n\t\t\t */\n\t\t\tif (tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_boot_cpu = cpu;\n\n\t\t} else if (tick_do_timer_boot_cpu != -1 &&\n\t\t\t\t\t\t!tick_nohz_full_cpu(cpu)) {\n\t\t\ttick_take_do_timer_from_boot();\n\t\t\ttick_do_timer_boot_cpu = -1;\n\t\t\tWARN_ON(tick_do_timer_cpu != cpu);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * Startup in periodic mode first.\n\t\t */\n\t\ttd->mode = TICKDEV_MODE_PERIODIC;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t/*\n\t * When the device is not per cpu, pin the interrupt to the\n\t * current cpu:\n\t */\n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t/*\n\t * When global broadcasting is active, check if the current\n\t * device is registered as a placeholder for broadcast mode.\n\t * This allows us to handle this x86 misfeature in a generic\n\t * way. This function also returns !=0 when we keep the\n\t * current active broadcast state for this CPU.\n\t */\n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ktime_t tick_next_period;",
            "int tick_do_timer_cpu"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nint tick_do_timer_cpu;\n\nstatic void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tvoid (*handler)(struct clock_event_device *) = NULL;\n\tktime_t next_event = 0;\n\n\t/*\n\t * First device setup ?\n\t */\n\tif (!td->evtdev) {\n\t\t/*\n\t\t * If no cpu took the do_timer update, assign it to\n\t\t * this cpu:\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\n\t\t\ttick_do_timer_cpu = cpu;\n\n\t\t\ttick_next_period = ktime_get();\n#ifdef CONFIG_NO_HZ_FULL\n\t\t\t/*\n\t\t\t * The boot CPU may be nohz_full, in which case set\n\t\t\t * tick_do_timer_boot_cpu so the first housekeeping\n\t\t\t * secondary that comes up will take do_timer from\n\t\t\t * us.\n\t\t\t */\n\t\t\tif (tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_boot_cpu = cpu;\n\n\t\t} else if (tick_do_timer_boot_cpu != -1 &&\n\t\t\t\t\t\t!tick_nohz_full_cpu(cpu)) {\n\t\t\ttick_take_do_timer_from_boot();\n\t\t\ttick_do_timer_boot_cpu = -1;\n\t\t\tWARN_ON(tick_do_timer_cpu != cpu);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * Startup in periodic mode first.\n\t\t */\n\t\ttd->mode = TICKDEV_MODE_PERIODIC;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t/*\n\t * When the device is not per cpu, pin the interrupt to the\n\t * current cpu:\n\t */\n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t/*\n\t * When global broadcasting is active, check if the current\n\t * device is registered as a placeholder for broadcast mode.\n\t * This allows us to handle this x86 misfeature in a generic\n\t * way. This function also returns !=0 when we keep the\n\t * current active broadcast state for this CPU.\n\t */\n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_exchange_device",
          "args": [
            "td->evtdev",
            "newdev"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_exchange_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "568-585",
          "snippet": "void clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_move(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevents_released);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevents_released);\n\nvoid clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_move(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_install_replacement(struct clock_event_device *newdev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tint cpu = smp_processor_id();\n\n\tclockevents_exchange_device(td->evtdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n}"
  },
  {
    "function_name": "tick_setup_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "205-275",
    "snippet": "static void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tvoid (*handler)(struct clock_event_device *) = NULL;\n\tktime_t next_event = 0;\n\n\t/*\n\t * First device setup ?\n\t */\n\tif (!td->evtdev) {\n\t\t/*\n\t\t * If no cpu took the do_timer update, assign it to\n\t\t * this cpu:\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\n\t\t\ttick_do_timer_cpu = cpu;\n\n\t\t\ttick_next_period = ktime_get();\n#ifdef CONFIG_NO_HZ_FULL\n\t\t\t/*\n\t\t\t * The boot CPU may be nohz_full, in which case set\n\t\t\t * tick_do_timer_boot_cpu so the first housekeeping\n\t\t\t * secondary that comes up will take do_timer from\n\t\t\t * us.\n\t\t\t */\n\t\t\tif (tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_boot_cpu = cpu;\n\n\t\t} else if (tick_do_timer_boot_cpu != -1 &&\n\t\t\t\t\t\t!tick_nohz_full_cpu(cpu)) {\n\t\t\ttick_take_do_timer_from_boot();\n\t\t\ttick_do_timer_boot_cpu = -1;\n\t\t\tWARN_ON(tick_do_timer_cpu != cpu);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * Startup in periodic mode first.\n\t\t */\n\t\ttd->mode = TICKDEV_MODE_PERIODIC;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t/*\n\t * When the device is not per cpu, pin the interrupt to the\n\t * current cpu:\n\t */\n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t/*\n\t * When global broadcasting is active, check if the current\n\t * device is registered as a placeholder for broadcast mode.\n\t * This allows us to handle this x86 misfeature in a generic\n\t * way. This function also returns !=0 when we keep the\n\t * current active broadcast state for this CPU.\n\t */\n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ktime_t tick_next_period;",
      "int tick_do_timer_cpu"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_setup_oneshot",
          "args": [
            "newdev",
            "handler",
            "next_event"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_oneshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "61-68",
          "snippet": "void tick_setup_oneshot(struct clock_event_device *newdev,\n\t\t\tvoid (*handler)(struct clock_event_device *),\n\t\t\tktime_t next_event)\n{\n\tnewdev->event_handler = handler;\n\tclockevents_switch_state(newdev, CLOCK_EVT_STATE_ONESHOT);\n\tclockevents_program_event(newdev, next_event, true);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_setup_oneshot(struct clock_event_device *newdev,\n\t\t\tvoid (*handler)(struct clock_event_device *),\n\t\t\tktime_t next_event)\n{\n\tnewdev->event_handler = handler;\n\tclockevents_switch_state(newdev, CLOCK_EVT_STATE_ONESHOT);\n\tclockevents_program_event(newdev, next_event, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_setup_periodic",
          "args": [
            "newdev",
            "0"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_periodic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "152-180",
          "snippet": "void tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned int seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add_ns(next, TICK_NSEC);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ktime_t tick_next_period;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\n\nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned int seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add_ns(next, TICK_NSEC);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_device_uses_broadcast",
          "args": [
            "newdev",
            "cpu"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "tick_device_uses_broadcast",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "246-325",
          "snippet": "int tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\t/*\n\t * Devices might be registered with both periodic and oneshot\n\t * mode disabled. This signals, that the device needs to be\n\t * operated from the broadcast device and is a placeholder for\n\t * the cpu local device.\n\t */\n\tif (!tick_device_is_functional(dev)) {\n\t\tdev->event_handler = tick_handle_periodic;\n\t\ttick_device_setup_broadcast_func(dev);\n\t\tcpumask_set_cpu(cpu, tick_broadcast_mask);\n\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_broadcast_start_periodic(bc);\n\t\telse\n\t\t\ttick_broadcast_setup_oneshot(bc);\n\t\tret = 1;\n\t} else {\n\t\t/*\n\t\t * Clear the broadcast bit for this cpu if the\n\t\t * device is not power state affected.\n\t\t */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\t\telse\n\t\t\ttick_device_setup_broadcast_func(dev);\n\n\t\t/*\n\t\t * Clear the broadcast bit if the CPU is not in\n\t\t * periodic broadcast on state.\n\t\t */\n\t\tif (!cpumask_test_cpu(cpu, tick_broadcast_on))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\t/*\n\t\t\t * If the system is in oneshot mode we can\n\t\t\t * unconditionally clear the oneshot mask bit,\n\t\t\t * because the CPU is running and therefore\n\t\t\t * not in an idle state which causes the power\n\t\t\t * state affected device to stop. Let the\n\t\t\t * caller initialize the device.\n\t\t\t */\n\t\t\ttick_broadcast_clear_oneshot(cpu);\n\t\t\tret = 0;\n\t\t\tbreak;\n\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\t/*\n\t\t\t * If the system is in periodic mode, check\n\t\t\t * whether the broadcast device can be\n\t\t\t * switched off now.\n\t\t\t */\n\t\t\tif (cpumask_empty(tick_broadcast_mask) && bc)\n\t\t\t\tclockevents_shutdown(bc);\n\t\t\t/*\n\t\t\t * If we kept the cpu in the broadcast mask,\n\t\t\t * tell the caller to leave the per cpu device\n\t\t\t * in shutdown state. The periodic interrupt\n\t\t\t * is delivered by the broadcast device, if\n\t\t\t * the broadcast device exists and is not\n\t\t\t * hrtimer based.\n\t\t\t */\n\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\t\t\tret = cpumask_test_cpu(cpu, tick_broadcast_mask);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static cpumask_var_t tick_broadcast_mask",
            "static cpumask_var_t tick_broadcast_on",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);",
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\nstatic cpumask_var_t tick_broadcast_on;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nint tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\t/*\n\t * Devices might be registered with both periodic and oneshot\n\t * mode disabled. This signals, that the device needs to be\n\t * operated from the broadcast device and is a placeholder for\n\t * the cpu local device.\n\t */\n\tif (!tick_device_is_functional(dev)) {\n\t\tdev->event_handler = tick_handle_periodic;\n\t\ttick_device_setup_broadcast_func(dev);\n\t\tcpumask_set_cpu(cpu, tick_broadcast_mask);\n\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_broadcast_start_periodic(bc);\n\t\telse\n\t\t\ttick_broadcast_setup_oneshot(bc);\n\t\tret = 1;\n\t} else {\n\t\t/*\n\t\t * Clear the broadcast bit for this cpu if the\n\t\t * device is not power state affected.\n\t\t */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\t\telse\n\t\t\ttick_device_setup_broadcast_func(dev);\n\n\t\t/*\n\t\t * Clear the broadcast bit if the CPU is not in\n\t\t * periodic broadcast on state.\n\t\t */\n\t\tif (!cpumask_test_cpu(cpu, tick_broadcast_on))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\t/*\n\t\t\t * If the system is in oneshot mode we can\n\t\t\t * unconditionally clear the oneshot mask bit,\n\t\t\t * because the CPU is running and therefore\n\t\t\t * not in an idle state which causes the power\n\t\t\t * state affected device to stop. Let the\n\t\t\t * caller initialize the device.\n\t\t\t */\n\t\t\ttick_broadcast_clear_oneshot(cpu);\n\t\t\tret = 0;\n\t\t\tbreak;\n\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\t/*\n\t\t\t * If the system is in periodic mode, check\n\t\t\t * whether the broadcast device can be\n\t\t\t * switched off now.\n\t\t\t */\n\t\t\tif (cpumask_empty(tick_broadcast_mask) && bc)\n\t\t\t\tclockevents_shutdown(bc);\n\t\t\t/*\n\t\t\t * If we kept the cpu in the broadcast mask,\n\t\t\t * tell the caller to leave the per cpu device\n\t\t\t * in shutdown state. The periodic interrupt\n\t\t\t * is delivered by the broadcast device, if\n\t\t\t * the broadcast device exists and is not\n\t\t\t * hrtimer based.\n\t\t\t */\n\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\t\t\tret = cpumask_test_cpu(cpu, tick_broadcast_mask);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_affinity",
          "args": [
            "newdev->irq",
            "cpumask"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_affinity_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "541-575",
          "snippet": "int\nirq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irq_affinity_notify *old_notify;\n\tunsigned long flags;\n\n\t/* The release function is promised process context */\n\tmight_sleep();\n\n\tif (!desc || desc->istate & IRQS_NMI)\n\t\treturn -EINVAL;\n\n\t/* Complete initialisation of *notify */\n\tif (notify) {\n\t\tnotify->irq = irq;\n\t\tkref_init(&notify->kref);\n\t\tINIT_WORK(&notify->work, irq_affinity_notify);\n\t}\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_notify = desc->affinity_notify;\n\tdesc->affinity_notify = notify;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (old_notify) {\n\t\tif (cancel_work_sync(&old_notify->work)) {\n\t\t\t/* Pending work had a ref, put that one too */\n\t\t\tkref_put(&old_notify->kref, old_notify->release);\n\t\t}\n\t\tkref_put(&old_notify->kref, old_notify->release);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint\nirq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irq_affinity_notify *old_notify;\n\tunsigned long flags;\n\n\t/* The release function is promised process context */\n\tmight_sleep();\n\n\tif (!desc || desc->istate & IRQS_NMI)\n\t\treturn -EINVAL;\n\n\t/* Complete initialisation of *notify */\n\tif (notify) {\n\t\tnotify->irq = irq;\n\t\tkref_init(&notify->kref);\n\t\tINIT_WORK(&notify->work, irq_affinity_notify);\n\t}\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_notify = desc->affinity_notify;\n\tdesc->affinity_notify = notify;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (old_notify) {\n\t\tif (cancel_work_sync(&old_notify->work)) {\n\t\t\t/* Pending work had a ref, put that one too */\n\t\t\tkref_put(&old_notify->kref, old_notify->release);\n\t\t}\n\t\tkref_put(&old_notify->kref, old_notify->release);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "newdev->cpumask",
            "cpumask"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "tick_do_timer_cpu != cpu"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_take_do_timer_from_boot",
          "args": [],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "tick_take_do_timer_from_boot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "192-199",
          "snippet": "static void tick_take_do_timer_from_boot(void)\n{\n\tint cpu = smp_processor_id();\n\tint from = tick_do_timer_boot_cpu;\n\n\tif (from >= 0 && from != cpu)\n\t\tsmp_call_function_single(from, giveup_do_timer, &cpu, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_take_do_timer_from_boot(void)\n{\n\tint cpu = smp_processor_id();\n\tint from = tick_do_timer_boot_cpu;\n\n\tif (from >= 0 && from != cpu)\n\t\tsmp_call_function_single(from, giveup_do_timer, &cpu, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "cpu"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "cpu"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nint tick_do_timer_cpu;\n\nstatic void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tvoid (*handler)(struct clock_event_device *) = NULL;\n\tktime_t next_event = 0;\n\n\t/*\n\t * First device setup ?\n\t */\n\tif (!td->evtdev) {\n\t\t/*\n\t\t * If no cpu took the do_timer update, assign it to\n\t\t * this cpu:\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\n\t\t\ttick_do_timer_cpu = cpu;\n\n\t\t\ttick_next_period = ktime_get();\n#ifdef CONFIG_NO_HZ_FULL\n\t\t\t/*\n\t\t\t * The boot CPU may be nohz_full, in which case set\n\t\t\t * tick_do_timer_boot_cpu so the first housekeeping\n\t\t\t * secondary that comes up will take do_timer from\n\t\t\t * us.\n\t\t\t */\n\t\t\tif (tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_boot_cpu = cpu;\n\n\t\t} else if (tick_do_timer_boot_cpu != -1 &&\n\t\t\t\t\t\t!tick_nohz_full_cpu(cpu)) {\n\t\t\ttick_take_do_timer_from_boot();\n\t\t\ttick_do_timer_boot_cpu = -1;\n\t\t\tWARN_ON(tick_do_timer_cpu != cpu);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * Startup in periodic mode first.\n\t\t */\n\t\ttd->mode = TICKDEV_MODE_PERIODIC;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t/*\n\t * When the device is not per cpu, pin the interrupt to the\n\t * current cpu:\n\t */\n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t/*\n\t * When global broadcasting is active, check if the current\n\t * device is registered as a placeholder for broadcast mode.\n\t * This allows us to handle this x86 misfeature in a generic\n\t * way. This function also returns !=0 when we keep the\n\t * current active broadcast state for this CPU.\n\t */\n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}"
  },
  {
    "function_name": "tick_take_do_timer_from_boot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "192-199",
    "snippet": "static void tick_take_do_timer_from_boot(void)\n{\n\tint cpu = smp_processor_id();\n\tint from = tick_do_timer_boot_cpu;\n\n\tif (from >= 0 && from != cpu)\n\t\tsmp_call_function_single(from, giveup_do_timer, &cpu, 1);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "from",
            "giveup_do_timer",
            "&cpu",
            "1"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/up.c",
          "lines": "12-25",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_take_do_timer_from_boot(void)\n{\n\tint cpu = smp_processor_id();\n\tint from = tick_do_timer_boot_cpu;\n\n\tif (from >= 0 && from != cpu)\n\t\tsmp_call_function_single(from, giveup_do_timer, &cpu, 1);\n}"
  },
  {
    "function_name": "giveup_do_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "183-190",
    "snippet": "static void giveup_do_timer(void *info)\n{\n\tint cpu = *(unsigned int *)info;\n\n\tWARN_ON(tick_do_timer_cpu != smp_processor_id());\n\n\ttick_do_timer_cpu = cpu;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int tick_do_timer_cpu"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "tick_do_timer_cpu != smp_processor_id()"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_do_timer_cpu;\n\nstatic void giveup_do_timer(void *info)\n{\n\tint cpu = *(unsigned int *)info;\n\n\tWARN_ON(tick_do_timer_cpu != smp_processor_id());\n\n\ttick_do_timer_cpu = cpu;\n}"
  },
  {
    "function_name": "tick_setup_periodic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "152-180",
    "snippet": "void tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned int seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add_ns(next, TICK_NSEC);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ktime_t tick_next_period;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "next",
            "TICK_NSEC"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevents_program_event",
          "args": [
            "dev",
            "next",
            "false"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "303-337",
          "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "dev",
            "CLOCK_EVT_STATE_ONESHOT"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "147-165",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&jiffies_seq",
            "seq"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&jiffies_seq"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_broadcast_oneshot_active",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_oneshot_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "1118-1121",
          "snippet": "int tick_broadcast_oneshot_active(void)\n{\n\treturn tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint tick_broadcast_oneshot_active(void)\n{\n\treturn tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_device_is_functional",
          "args": [
            "dev"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "tick_device_is_functional",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-internal.h",
          "lines": "34-37",
          "snippet": "static inline int tick_device_is_functional(struct clock_event_device *dev)\n{\n\treturn !(dev->features & CLOCK_EVT_FEAT_DUMMY);\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline int tick_device_is_functional(struct clock_event_device *dev)\n{\n\treturn !(dev->features & CLOCK_EVT_FEAT_DUMMY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_set_periodic_handler",
          "args": [
            "dev",
            "broadcast"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "tick_set_periodic_handler",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "514-520",
          "snippet": "void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)\n{\n\tif (!broadcast)\n\t\tdev->event_handler = tick_handle_periodic;\n\telse\n\t\tdev->event_handler = tick_handle_periodic_broadcast;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)\n{\n\tif (!broadcast)\n\t\tdev->event_handler = tick_handle_periodic;\n\telse\n\t\tdev->event_handler = tick_handle_periodic_broadcast;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\n\nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned int seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add_ns(next, TICK_NSEC);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "tick_handle_periodic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "107-147",
    "snippet": "void tick_handle_periodic(struct clock_event_device *dev)\n{\n\tint cpu = smp_processor_id();\n\tktime_t next = dev->next_event;\n\n\ttick_periodic(cpu);\n\n#if defined(CONFIG_HIGH_RES_TIMERS) || defined(CONFIG_NO_HZ_COMMON)\n\t/*\n\t * The cpu might have transitioned to HIGHRES or NOHZ mode via\n\t * update_process_times() -> run_local_timers() ->\n\t * hrtimer_run_queues().\n\t */\n\tif (dev->event_handler != tick_handle_periodic)\n\t\treturn;\n#endif\n\n\tif (!clockevent_state_oneshot(dev))\n\t\treturn;\n\tfor (;;) {\n\t\t/*\n\t\t * Setup the next period for devices, which do not have\n\t\t * periodic mode:\n\t\t */\n\t\tnext = ktime_add_ns(next, TICK_NSEC);\n\n\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\treturn;\n\t\t/*\n\t\t * Have to be careful here. If we're in oneshot mode,\n\t\t * before we call tick_periodic() in a loop, we need\n\t\t * to be sure we're using a real hardware clocksource.\n\t\t * Otherwise we could get trapped in an infinite\n\t\t * loop, as the tick_periodic() increments jiffies,\n\t\t * which then will increment time, possibly causing\n\t\t * the loop to trigger again and again.\n\t\t */\n\t\tif (timekeeping_valid_for_hres())\n\t\t\ttick_periodic(cpu);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_periodic",
          "args": [
            "cpu"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "tick_periodic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "85-102",
          "snippet": "static void tick_periodic(int cpu)\n{\n\tif (tick_do_timer_cpu == cpu) {\n\t\traw_spin_lock(&jiffies_lock);\n\t\twrite_seqcount_begin(&jiffies_seq);\n\n\t\t/* Keep track of the next tick event */\n\t\ttick_next_period = ktime_add_ns(tick_next_period, TICK_NSEC);\n\n\t\tdo_timer(1);\n\t\twrite_seqcount_end(&jiffies_seq);\n\t\traw_spin_unlock(&jiffies_lock);\n\t\tupdate_wall_time();\n\t}\n\n\tupdate_process_times(user_mode(get_irq_regs()));\n\tprofile_tick(CPU_PROFILING);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ktime_t tick_next_period;",
            "int tick_do_timer_cpu"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nint tick_do_timer_cpu;\n\nstatic void tick_periodic(int cpu)\n{\n\tif (tick_do_timer_cpu == cpu) {\n\t\traw_spin_lock(&jiffies_lock);\n\t\twrite_seqcount_begin(&jiffies_seq);\n\n\t\t/* Keep track of the next tick event */\n\t\ttick_next_period = ktime_add_ns(tick_next_period, TICK_NSEC);\n\n\t\tdo_timer(1);\n\t\twrite_seqcount_end(&jiffies_seq);\n\t\traw_spin_unlock(&jiffies_lock);\n\t\tupdate_wall_time();\n\t}\n\n\tupdate_process_times(user_mode(get_irq_regs()));\n\tprofile_tick(CPU_PROFILING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_valid_for_hres",
          "args": [],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_valid_for_hres",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1518-1532",
          "snippet": "int timekeeping_valid_for_hres(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->flags & CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint timekeeping_valid_for_hres(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->flags & CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_program_event",
          "args": [
            "dev",
            "next",
            "false"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "303-337",
          "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "next",
            "TICK_NSEC"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "dev"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_handle_periodic(struct clock_event_device *dev)\n{\n\tint cpu = smp_processor_id();\n\tktime_t next = dev->next_event;\n\n\ttick_periodic(cpu);\n\n#if defined(CONFIG_HIGH_RES_TIMERS) || defined(CONFIG_NO_HZ_COMMON)\n\t/*\n\t * The cpu might have transitioned to HIGHRES or NOHZ mode via\n\t * update_process_times() -> run_local_timers() ->\n\t * hrtimer_run_queues().\n\t */\n\tif (dev->event_handler != tick_handle_periodic)\n\t\treturn;\n#endif\n\n\tif (!clockevent_state_oneshot(dev))\n\t\treturn;\n\tfor (;;) {\n\t\t/*\n\t\t * Setup the next period for devices, which do not have\n\t\t * periodic mode:\n\t\t */\n\t\tnext = ktime_add_ns(next, TICK_NSEC);\n\n\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\treturn;\n\t\t/*\n\t\t * Have to be careful here. If we're in oneshot mode,\n\t\t * before we call tick_periodic() in a loop, we need\n\t\t * to be sure we're using a real hardware clocksource.\n\t\t * Otherwise we could get trapped in an infinite\n\t\t * loop, as the tick_periodic() increments jiffies,\n\t\t * which then will increment time, possibly causing\n\t\t * the loop to trigger again and again.\n\t\t */\n\t\tif (timekeeping_valid_for_hres())\n\t\t\ttick_periodic(cpu);\n\t}\n}"
  },
  {
    "function_name": "tick_periodic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "85-102",
    "snippet": "static void tick_periodic(int cpu)\n{\n\tif (tick_do_timer_cpu == cpu) {\n\t\traw_spin_lock(&jiffies_lock);\n\t\twrite_seqcount_begin(&jiffies_seq);\n\n\t\t/* Keep track of the next tick event */\n\t\ttick_next_period = ktime_add_ns(tick_next_period, TICK_NSEC);\n\n\t\tdo_timer(1);\n\t\twrite_seqcount_end(&jiffies_seq);\n\t\traw_spin_unlock(&jiffies_lock);\n\t\tupdate_wall_time();\n\t}\n\n\tupdate_process_times(user_mode(get_irq_regs()));\n\tprofile_tick(CPU_PROFILING);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ktime_t tick_next_period;",
      "int tick_do_timer_cpu"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_tick",
          "args": [
            "CPU_PROFILING"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "profile_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
          "lines": "330-337",
          "snippet": "void profile_tick(int type)\n{\n\tstruct pt_regs *regs = get_irq_regs();\n\n\tif (!user_mode(regs) && cpumask_available(prof_cpu_mask) &&\n\t    cpumask_test_cpu(smp_processor_id(), prof_cpu_mask))\n\t\tprofile_hit(type, (void *)profile_pc(regs));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/sections.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/mm.h>",
            "#include <linux/notifier.h>",
            "#include <linux/memblock.h>",
            "#include <linux/profile.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t prof_cpu_mask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nvoid profile_tick(int type)\n{\n\tstruct pt_regs *regs = get_irq_regs();\n\n\tif (!user_mode(regs) && cpumask_available(prof_cpu_mask) &&\n\t    cpumask_test_cpu(smp_processor_id(), prof_cpu_mask))\n\t\tprofile_hit(type, (void *)profile_pc(regs));\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_process_times",
          "args": [
            "user_mode(get_irq_regs())"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "update_process_times",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1776-1793",
          "snippet": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\tPRANDOM_ADD_NOISE(jiffies, user_tick, p, 0);\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\tPRANDOM_ADD_NOISE(jiffies, user_tick, p, 0);\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "get_irq_regs()"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "irqentry_exit_to_user_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "303-309",
          "snippet": "noinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\texit_to_user_mode_prepare(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__visible noinstr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nnoinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\texit_to_user_mode_prepare(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_irq_regs",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_wall_time",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "update_wall_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2208-2212",
          "snippet": "void update_wall_time(void)\n{\n\tif (timekeeping_advance(TK_ADV_TICK))\n\t\tclock_was_set_delayed();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid update_wall_time(void)\n{\n\tif (timekeeping_advance(TK_ADV_TICK))\n\t\tclock_was_set_delayed();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&jiffies_seq"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_timer",
          "args": [
            "1"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "giveup_do_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "183-190",
          "snippet": "static void giveup_do_timer(void *info)\n{\n\tint cpu = *(unsigned int *)info;\n\n\tWARN_ON(tick_do_timer_cpu != smp_processor_id());\n\n\ttick_do_timer_cpu = cpu;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int tick_do_timer_cpu"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_do_timer_cpu;\n\nstatic void giveup_do_timer(void *info)\n{\n\tint cpu = *(unsigned int *)info;\n\n\tWARN_ON(tick_do_timer_cpu != smp_processor_id());\n\n\ttick_do_timer_cpu = cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "tick_next_period",
            "TICK_NSEC"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&jiffies_seq"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nint tick_do_timer_cpu;\n\nstatic void tick_periodic(int cpu)\n{\n\tif (tick_do_timer_cpu == cpu) {\n\t\traw_spin_lock(&jiffies_lock);\n\t\twrite_seqcount_begin(&jiffies_seq);\n\n\t\t/* Keep track of the next tick event */\n\t\ttick_next_period = ktime_add_ns(tick_next_period, TICK_NSEC);\n\n\t\tdo_timer(1);\n\t\twrite_seqcount_end(&jiffies_seq);\n\t\traw_spin_unlock(&jiffies_lock);\n\t\tupdate_wall_time();\n\t}\n\n\tupdate_process_times(user_mode(get_irq_regs()));\n\tprofile_tick(CPU_PROFILING);\n}"
  },
  {
    "function_name": "tick_is_oneshot_available",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "71-80",
    "snippet": "int tick_is_oneshot_available(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn 0;\n\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn 1;\n\treturn tick_broadcast_oneshot_available();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_broadcast_oneshot_available",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_oneshot_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "1126-1131",
          "snippet": "bool tick_broadcast_oneshot_available(void)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\treturn bc ? bc->features & CLOCK_EVT_FEAT_ONESHOT : false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nbool tick_broadcast_oneshot_available(void)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\treturn bc ? bc->features & CLOCK_EVT_FEAT_ONESHOT : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "tick_cpu_device.evtdev"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_is_oneshot_available(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn 0;\n\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn 1;\n\treturn tick_broadcast_oneshot_available();\n}"
  },
  {
    "function_name": "tick_get_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
    "lines": "63-66",
    "snippet": "struct tick_device *tick_get_device(int cpu)\n{\n\treturn &per_cpu(tick_cpu_device, cpu);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/nmi.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "cpu"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstruct tick_device *tick_get_device(int cpu)\n{\n\treturn &per_cpu(tick_cpu_device, cpu);\n}"
  }
]