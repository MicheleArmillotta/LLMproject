[
  {
    "function_name": "kcmp_cookies_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcmp.c",
    "lines": "228-238",
    "snippet": "static __init int kcmp_cookies_init(void)\n{\n\tint i;\n\n\tget_random_bytes(cookies, sizeof(cookies));\n\n\tfor (i = 0; i < KCMP_TYPES; i++)\n\t\tcookies[i][1] |= (~(~0UL >>  1) | 1);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long cookies[KCMP_TYPES][2]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "cookies",
            "sizeof(cookies)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic unsigned long cookies[KCMP_TYPES][2];\n\nstatic __init int kcmp_cookies_init(void)\n{\n\tint i;\n\n\tget_random_bytes(cookies, sizeof(cookies));\n\n\tfor (i = 0; i < KCMP_TYPES; i++)\n\t\tcookies[i][1] |= (~(~0UL >>  1) | 1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kcmp_epoll_target",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcmp.c",
    "lines": "126-132",
    "snippet": "static int kcmp_epoll_target(struct task_struct *task1,\n\t\t\t     struct task_struct *task2,\n\t\t\t     unsigned long idx1,\n\t\t\t     struct kcmp_epoll_slot __user *uslot)\n{\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int kcmp_epoll_target(struct task_struct *task1,\n\t\t\t     struct task_struct *task2,\n\t\t\t     unsigned long idx1,\n\t\t\t     struct kcmp_epoll_slot __user *uslot)\n{\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "kcmp_epoll_target",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcmp.c",
    "lines": "98-124",
    "snippet": "static int kcmp_epoll_target(struct task_struct *task1,\n\t\t\t     struct task_struct *task2,\n\t\t\t     unsigned long idx1,\n\t\t\t     struct kcmp_epoll_slot __user *uslot)\n{\n\tstruct file *filp, *filp_epoll, *filp_tgt;\n\tstruct kcmp_epoll_slot slot;\n\n\tif (copy_from_user(&slot, uslot, sizeof(slot)))\n\t\treturn -EFAULT;\n\n\tfilp = get_file_raw_ptr(task1, idx1);\n\tif (!filp)\n\t\treturn -EBADF;\n\n\tfilp_epoll = fget_task(task2, slot.efd);\n\tif (!filp_epoll)\n\t\treturn -EBADF;\n\n\tfilp_tgt = get_epoll_tfile_raw_ptr(filp_epoll, slot.tfd, slot.toff);\n\tfput(filp_epoll);\n\n\tif (IS_ERR(filp_tgt))\n\t\treturn PTR_ERR(filp_tgt);\n\n\treturn kcmp_ptr(filp, filp_tgt, KCMP_FILE);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcmp_ptr",
          "args": [
            "filp",
            "filp_tgt",
            "KCMP_FILE"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "kcmp_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcmp.c",
          "lines": "50-58",
          "snippet": "static int kcmp_ptr(void *v1, void *v2, enum kcmp_type type)\n{\n\tlong t1, t2;\n\n\tt1 = kptr_obfuscate((long)v1, type);\n\tt2 = kptr_obfuscate((long)v2, type);\n\n\treturn (t1 < t2) | ((t1 > t2) << 1);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/file.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/list.h>",
            "#include <linux/capability.h>",
            "#include <linux/kcmp.h>",
            "#include <linux/err.h>",
            "#include <linux/bug.h>",
            "#include <linux/cache.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int kcmp_ptr(void *v1, void *v2, enum kcmp_type type)\n{\n\tlong t1, t2;\n\n\tt1 = kptr_obfuscate((long)v1, type);\n\tt2 = kptr_obfuscate((long)v2, type);\n\n\treturn (t1 < t2) | ((t1 > t2) << 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "filp_tgt"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filp_tgt"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp_epoll"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_epoll_tfile_raw_ptr",
          "args": [
            "filp_epoll",
            "slot.tfd",
            "slot.toff"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fget_task",
          "args": [
            "task2",
            "slot.efd"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file_raw_ptr",
          "args": [
            "task1",
            "idx1"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "get_file_raw_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcmp.c",
          "lines": "61-71",
          "snippet": "static struct file *\nget_file_raw_ptr(struct task_struct *task, unsigned int idx)\n{\n\tstruct file *file;\n\n\trcu_read_lock();\n\tfile = task_lookup_fd_rcu(task, idx);\n\trcu_read_unlock();\n\n\treturn file;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/file.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/list.h>",
            "#include <linux/capability.h>",
            "#include <linux/kcmp.h>",
            "#include <linux/err.h>",
            "#include <linux/bug.h>",
            "#include <linux/cache.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic struct file *\nget_file_raw_ptr(struct task_struct *task, unsigned int idx)\n{\n\tstruct file *file;\n\n\trcu_read_lock();\n\tfile = task_lookup_fd_rcu(task, idx);\n\trcu_read_unlock();\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&slot",
            "uslot",
            "sizeof(slot)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int kcmp_epoll_target(struct task_struct *task1,\n\t\t\t     struct task_struct *task2,\n\t\t\t     unsigned long idx1,\n\t\t\t     struct kcmp_epoll_slot __user *uslot)\n{\n\tstruct file *filp, *filp_epoll, *filp_tgt;\n\tstruct kcmp_epoll_slot slot;\n\n\tif (copy_from_user(&slot, uslot, sizeof(slot)))\n\t\treturn -EFAULT;\n\n\tfilp = get_file_raw_ptr(task1, idx1);\n\tif (!filp)\n\t\treturn -EBADF;\n\n\tfilp_epoll = fget_task(task2, slot.efd);\n\tif (!filp_epoll)\n\t\treturn -EBADF;\n\n\tfilp_tgt = get_epoll_tfile_raw_ptr(filp_epoll, slot.tfd, slot.toff);\n\tfput(filp_epoll);\n\n\tif (IS_ERR(filp_tgt))\n\t\treturn PTR_ERR(filp_tgt);\n\n\treturn kcmp_ptr(filp, filp_tgt, KCMP_FILE);\n}"
  },
  {
    "function_name": "kcmp_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcmp.c",
    "lines": "80-95",
    "snippet": "static int kcmp_lock(struct rw_semaphore *l1, struct rw_semaphore *l2)\n{\n\tint err;\n\n\tif (l2 > l1)\n\t\tswap(l1, l2);\n\n\terr = down_read_killable(l1);\n\tif (!err && likely(l1 != l2)) {\n\t\terr = down_read_killable_nested(l2, SINGLE_DEPTH_NESTING);\n\t\tif (err)\n\t\t\tup_read(l1);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "l1"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read_killable_nested",
          "args": [
            "l2",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_killable_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "1591-1602",
          "snippet": "int down_read_killable_nested(struct rw_semaphore *sem, int subclass)\n{\n\tmight_sleep();\n\trwsem_acquire_read(&sem->dep_map, subclass, 0, _RET_IP_);\n\n\tif (LOCK_CONTENDED_RETURN(sem, __down_read_trylock, __down_read_killable)) {\n\t\trwsem_release(&sem->dep_map, _RET_IP_);\n\t\treturn -EINTR;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint down_read_killable_nested(struct rw_semaphore *sem, int subclass)\n{\n\tmight_sleep();\n\trwsem_acquire_read(&sem->dep_map, subclass, 0, _RET_IP_);\n\n\tif (LOCK_CONTENDED_RETURN(sem, __down_read_trylock, __down_read_killable)) {\n\t\trwsem_release(&sem->dep_map, _RET_IP_);\n\t\treturn -EINTR;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "l1 != l2"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_killable",
          "args": [
            "l1"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_killable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rwsem.c",
          "lines": "1481-1492",
          "snippet": "int __sched down_read_killable(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire_read(&sem->dep_map, 0, 0, _RET_IP_);\n\n\tif (LOCK_CONTENDED_RETURN(sem, __down_read_trylock, __down_read_killable)) {\n\t\trwsem_release(&sem->dep_map, _RET_IP_);\n\t\treturn -EINTR;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"rwbase_rt.c\"",
            "#include \"rtmutex.c\"",
            "#include \"lock_events.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwbase_rt.c\"\n#include \"rtmutex.c\"\n#include \"lock_events.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint __sched down_read_killable(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire_read(&sem->dep_map, 0, 0, _RET_IP_);\n\n\tif (LOCK_CONTENDED_RETURN(sem, __down_read_trylock, __down_read_killable)) {\n\t\trwsem_release(&sem->dep_map, _RET_IP_);\n\t\treturn -EINTR;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "l1",
            "l2"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_reader",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "974-1018",
          "snippet": "static int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kzalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct swsusp_header *swsusp_header;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct swsusp_header *swsusp_header;\n\nstatic int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kzalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int kcmp_lock(struct rw_semaphore *l1, struct rw_semaphore *l2)\n{\n\tint err;\n\n\tif (l2 > l1)\n\t\tswap(l1, l2);\n\n\terr = down_read_killable(l1);\n\tif (!err && likely(l1 != l2)) {\n\t\terr = down_read_killable_nested(l2, SINGLE_DEPTH_NESTING);\n\t\tif (err)\n\t\t\tup_read(l1);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "kcmp_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcmp.c",
    "lines": "73-78",
    "snippet": "static void kcmp_unlock(struct rw_semaphore *l1, struct rw_semaphore *l2)\n{\n\tif (likely(l2 != l1))\n\t\tup_read(l2);\n\tup_read(l1);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "l1"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "l2 != l1"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void kcmp_unlock(struct rw_semaphore *l1, struct rw_semaphore *l2)\n{\n\tif (likely(l2 != l1))\n\t\tup_read(l2);\n\tup_read(l1);\n}"
  },
  {
    "function_name": "get_file_raw_ptr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcmp.c",
    "lines": "61-71",
    "snippet": "static struct file *\nget_file_raw_ptr(struct task_struct *task, unsigned int idx)\n{\n\tstruct file *file;\n\n\trcu_read_lock();\n\tfile = task_lookup_fd_rcu(task, idx);\n\trcu_read_unlock();\n\n\treturn file;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lookup_fd_rcu",
          "args": [
            "task",
            "idx"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic struct file *\nget_file_raw_ptr(struct task_struct *task, unsigned int idx)\n{\n\tstruct file *file;\n\n\trcu_read_lock();\n\tfile = task_lookup_fd_rcu(task, idx);\n\trcu_read_unlock();\n\n\treturn file;\n}"
  },
  {
    "function_name": "kcmp_ptr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcmp.c",
    "lines": "50-58",
    "snippet": "static int kcmp_ptr(void *v1, void *v2, enum kcmp_type type)\n{\n\tlong t1, t2;\n\n\tt1 = kptr_obfuscate((long)v1, type);\n\tt2 = kptr_obfuscate((long)v2, type);\n\n\treturn (t1 < t2) | ((t1 > t2) << 1);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kptr_obfuscate",
          "args": [
            "(long)v2",
            "type"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "kptr_obfuscate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcmp.c",
          "lines": "39-42",
          "snippet": "static long kptr_obfuscate(long v, int type)\n{\n\treturn (v ^ cookies[type][0]) * cookies[type][1];\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/file.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/list.h>",
            "#include <linux/capability.h>",
            "#include <linux/kcmp.h>",
            "#include <linux/err.h>",
            "#include <linux/bug.h>",
            "#include <linux/cache.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long cookies[KCMP_TYPES][2]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic unsigned long cookies[KCMP_TYPES][2];\n\nstatic long kptr_obfuscate(long v, int type)\n{\n\treturn (v ^ cookies[type][0]) * cookies[type][1];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int kcmp_ptr(void *v1, void *v2, enum kcmp_type type)\n{\n\tlong t1, t2;\n\n\tt1 = kptr_obfuscate((long)v1, type);\n\tt2 = kptr_obfuscate((long)v2, type);\n\n\treturn (t1 < t2) | ((t1 > t2) << 1);\n}"
  },
  {
    "function_name": "kptr_obfuscate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcmp.c",
    "lines": "39-42",
    "snippet": "static long kptr_obfuscate(long v, int type)\n{\n\treturn (v ^ cookies[type][0]) * cookies[type][1];\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long cookies[KCMP_TYPES][2]"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic unsigned long cookies[KCMP_TYPES][2];\n\nstatic long kptr_obfuscate(long v, int type)\n{\n\treturn (v ^ cookies[type][0]) * cookies[type][1];\n}"
  },
  {
    "function_name": "kcmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcmp.c",
    "lines": "135-226",
    "snippet": "SYSCALL_DEFINE5(kcmp, pid_t, pid1, pid_t, pid2, int, type,\n\t\tunsigned long, idx1, unsigned long, idx2)\n{\n\tstruct task_struct *task1, *task2;\n\tint ret;\n\n\trcu_read_lock();\n\n\t/*\n\t * Tasks are looked up in caller's PID namespace only.\n\t */\n\ttask1 = find_task_by_vpid(pid1);\n\ttask2 = find_task_by_vpid(pid2);\n\tif (!task1 || !task2)\n\t\tgoto err_no_task;\n\n\tget_task_struct(task1);\n\tget_task_struct(task2);\n\n\trcu_read_unlock();\n\n\t/*\n\t * One should have enough rights to inspect task details.\n\t */\n\tret = kcmp_lock(&task1->signal->exec_update_lock,\n\t\t\t&task2->signal->exec_update_lock);\n\tif (ret)\n\t\tgoto err;\n\tif (!ptrace_may_access(task1, PTRACE_MODE_READ_REALCREDS) ||\n\t    !ptrace_may_access(task2, PTRACE_MODE_READ_REALCREDS)) {\n\t\tret = -EPERM;\n\t\tgoto err_unlock;\n\t}\n\n\tswitch (type) {\n\tcase KCMP_FILE: {\n\t\tstruct file *filp1, *filp2;\n\n\t\tfilp1 = get_file_raw_ptr(task1, idx1);\n\t\tfilp2 = get_file_raw_ptr(task2, idx2);\n\n\t\tif (filp1 && filp2)\n\t\t\tret = kcmp_ptr(filp1, filp2, KCMP_FILE);\n\t\telse\n\t\t\tret = -EBADF;\n\t\tbreak;\n\t}\n\tcase KCMP_VM:\n\t\tret = kcmp_ptr(task1->mm, task2->mm, KCMP_VM);\n\t\tbreak;\n\tcase KCMP_FILES:\n\t\tret = kcmp_ptr(task1->files, task2->files, KCMP_FILES);\n\t\tbreak;\n\tcase KCMP_FS:\n\t\tret = kcmp_ptr(task1->fs, task2->fs, KCMP_FS);\n\t\tbreak;\n\tcase KCMP_SIGHAND:\n\t\tret = kcmp_ptr(task1->sighand, task2->sighand, KCMP_SIGHAND);\n\t\tbreak;\n\tcase KCMP_IO:\n\t\tret = kcmp_ptr(task1->io_context, task2->io_context, KCMP_IO);\n\t\tbreak;\n\tcase KCMP_SYSVSEM:\n#ifdef CONFIG_SYSVIPC\n\t\tret = kcmp_ptr(task1->sysvsem.undo_list,\n\t\t\t       task2->sysvsem.undo_list,\n\t\t\t       KCMP_SYSVSEM);\n#else\n\t\tret = -EOPNOTSUPP;\n#endif\n\t\tbreak;\n\tcase KCMP_EPOLL_TFD:\n\t\tret = kcmp_epoll_target(task1, task2, idx1, (void *)idx2);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nerr_unlock:\n\tkcmp_unlock(&task1->signal->exec_update_lock,\n\t\t    &task2->signal->exec_update_lock);\nerr:\n\tput_task_struct(task1);\n\tput_task_struct(task2);\n\n\treturn ret;\n\nerr_no_task:\n\trcu_read_unlock();\n\treturn -ESRCH;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/file.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/list.h>",
      "#include <linux/capability.h>",
      "#include <linux/kcmp.h>",
      "#include <linux/err.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/file.h>\n#include <linux/eventpoll.h>\n#include <linux/list.h>\n#include <linux/capability.h>\n#include <linux/kcmp.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE5(kcmp, pid_t, pid1, pid_t, pid2, int, type,\n\t\tunsigned long, idx1, unsigned long, idx2)\n{\n\tstruct task_struct *task1, *task2;\n\tint ret;\n\n\trcu_read_lock();\n\n\t/*\n\t * Tasks are looked up in caller's PID namespace only.\n\t */\n\ttask1 = find_task_by_vpid(pid1);\n\ttask2 = find_task_by_vpid(pid2);\n\tif (!task1 || !task2)\n\t\tgoto err_no_task;\n\n\tget_task_struct(task1);\n\tget_task_struct(task2);\n\n\trcu_read_unlock();\n\n\t/*\n\t * One should have enough rights to inspect task details.\n\t */\n\tret = kcmp_lock(&task1->signal->exec_update_lock,\n\t\t\t&task2->signal->exec_update_lock);\n\tif (ret)\n\t\tgoto err;\n\tif (!ptrace_may_access(task1, PTRACE_MODE_READ_REALCREDS) ||\n\t    !ptrace_may_access(task2, PTRACE_MODE_READ_REALCREDS)) {\n\t\tret = -EPERM;\n\t\tgoto err_unlock;\n\t}\n\n\tswitch (type) {\n\tcase KCMP_FILE: {\n\t\tstruct file *filp1, *filp2;\n\n\t\tfilp1 = get_file_raw_ptr(task1, idx1);\n\t\tfilp2 = get_file_raw_ptr(task2, idx2);\n\n\t\tif (filp1 && filp2)\n\t\t\tret = kcmp_ptr(filp1, filp2, KCMP_FILE);\n\t\telse\n\t\t\tret = -EBADF;\n\t\tbreak;\n\t}\n\tcase KCMP_VM:\n\t\tret = kcmp_ptr(task1->mm, task2->mm, KCMP_VM);\n\t\tbreak;\n\tcase KCMP_FILES:\n\t\tret = kcmp_ptr(task1->files, task2->files, KCMP_FILES);\n\t\tbreak;\n\tcase KCMP_FS:\n\t\tret = kcmp_ptr(task1->fs, task2->fs, KCMP_FS);\n\t\tbreak;\n\tcase KCMP_SIGHAND:\n\t\tret = kcmp_ptr(task1->sighand, task2->sighand, KCMP_SIGHAND);\n\t\tbreak;\n\tcase KCMP_IO:\n\t\tret = kcmp_ptr(task1->io_context, task2->io_context, KCMP_IO);\n\t\tbreak;\n\tcase KCMP_SYSVSEM:\n#ifdef CONFIG_SYSVIPC\n\t\tret = kcmp_ptr(task1->sysvsem.undo_list,\n\t\t\t       task2->sysvsem.undo_list,\n\t\t\t       KCMP_SYSVSEM);\n#else\n\t\tret = -EOPNOTSUPP;\n#endif\n\t\tbreak;\n\tcase KCMP_EPOLL_TFD:\n\t\tret = kcmp_epoll_target(task1, task2, idx1, (void *)idx2);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nerr_unlock:\n\tkcmp_unlock(&task1->signal->exec_update_lock,\n\t\t    &task2->signal->exec_update_lock);\nerr:\n\tput_task_struct(task1);\n\tput_task_struct(task2);\n\n\treturn ret;\n\nerr_no_task:\n\trcu_read_unlock();\n\treturn -ESRCH;\n}"
  }
]