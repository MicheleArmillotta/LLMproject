[
  {
    "function_name": "update_curr_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "495-497",
    "snippet": "static void update_curr_idle(struct rq *rq)\n{\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void update_curr_idle(struct rq *rq)\n{\n}"
  },
  {
    "function_name": "prio_changed_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "489-493",
    "snippet": "static void\nprio_changed_idle(struct rq *rq, struct task_struct *p, int oldprio)\n{\n\tBUG();\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void\nprio_changed_idle(struct rq *rq, struct task_struct *p, int oldprio)\n{\n\tBUG();\n}"
  },
  {
    "function_name": "switched_to_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "484-487",
    "snippet": "static void switched_to_idle(struct rq *rq, struct task_struct *p)\n{\n\tBUG();\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void switched_to_idle(struct rq *rq, struct task_struct *p)\n{\n\tBUG();\n}"
  },
  {
    "function_name": "task_tick_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "480-482",
    "snippet": "static void task_tick_idle(struct rq *rq, struct task_struct *curr, int queued)\n{\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void task_tick_idle(struct rq *rq, struct task_struct *curr, int queued)\n{\n}"
  },
  {
    "function_name": "dequeue_task_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "463-470",
    "snippet": "static void\ndequeue_task_idle(struct rq *rq, struct task_struct *p, int flags)\n{\n\traw_spin_rq_unlock_irq(rq);\n\tprintk(KERN_ERR \"bad: scheduling from the idle thread!\\n\");\n\tdump_stack();\n\traw_spin_rq_lock_irq(rq);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_rq_lock_irq",
          "args": [
            "rq"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_rq_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1333-1339",
          "snippet": "static inline unsigned long _raw_spin_rq_lock_irqsave(struct rq *rq)\n{\n\tunsigned long flags;\n\tlocal_irq_save(flags);\n\traw_spin_rq_lock(rq);\n\treturn flags;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline unsigned long _raw_spin_rq_lock_irqsave(struct rq *rq)\n{\n\tunsigned long flags;\n\tlocal_irq_save(flags);\n\traw_spin_rq_lock(rq);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"bad: scheduling from the idle thread!\\n\""
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_rq_unlock_irq",
          "args": [
            "rq"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "raw_spin_rq_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1327-1331",
          "snippet": "static inline void raw_spin_rq_unlock_irq(struct rq *rq)\n{\n\traw_spin_rq_unlock(rq);\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void raw_spin_rq_unlock_irq(struct rq *rq)\n{\n\traw_spin_rq_unlock(rq);\n\tlocal_irq_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};\n\nstatic void\ndequeue_task_idle(struct rq *rq, struct task_struct *p, int flags)\n{\n\traw_spin_rq_unlock_irq(rq);\n\tprintk(KERN_ERR \"bad: scheduling from the idle thread!\\n\");\n\tdump_stack();\n\traw_spin_rq_lock_irq(rq);\n}"
  },
  {
    "function_name": "pick_next_task_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "450-457",
    "snippet": "struct task_struct *pick_next_task_idle(struct rq *rq)\n{\n\tstruct task_struct *next = rq->idle;\n\n\tset_next_task_idle(rq, next, true);\n\n\treturn next;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_next_task_idle",
          "args": [
            "rq",
            "next",
            "true"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "set_next_task_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
          "lines": "436-441",
          "snippet": "static void set_next_task_idle(struct rq *rq, struct task_struct *next, bool first)\n{\n\tupdate_idle_core(rq);\n\tschedstat_inc(rq->sched_goidle);\n\tqueue_core_balance(rq);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void set_next_task_idle(struct rq *rq, struct task_struct *next, bool first)\n{\n\tupdate_idle_core(rq);\n\tschedstat_inc(rq->sched_goidle);\n\tqueue_core_balance(rq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};\n\nstruct task_struct *pick_next_task_idle(struct rq *rq)\n{\n\tstruct task_struct *next = rq->idle;\n\n\tset_next_task_idle(rq, next, true);\n\n\treturn next;\n}"
  },
  {
    "function_name": "pick_task_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "444-447",
    "snippet": "static struct task_struct *pick_task_idle(struct rq *rq)\n{\n\treturn rq->idle;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};\n\nstatic struct task_struct *pick_task_idle(struct rq *rq)\n{\n\treturn rq->idle;\n}"
  },
  {
    "function_name": "set_next_task_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "436-441",
    "snippet": "static void set_next_task_idle(struct rq *rq, struct task_struct *next, bool first)\n{\n\tupdate_idle_core(rq);\n\tschedstat_inc(rq->sched_goidle);\n\tqueue_core_balance(rq);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_core_balance",
          "args": [
            "rq"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "queue_core_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5983-5995",
          "snippet": "void queue_core_balance(struct rq *rq)\n{\n\tif (!sched_core_enabled(rq))\n\t\treturn;\n\n\tif (!rq->core->core_cookie)\n\t\treturn;\n\n\tif (!rq->nr_running) /* not forced idle */\n\t\treturn;\n\n\tqueue_balance_callback(rq, &per_cpu(core_balance_head, rq->cpu), sched_core_balance);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid queue_core_balance(struct rq *rq)\n{\n\tif (!sched_core_enabled(rq))\n\t\treturn;\n\n\tif (!rq->core->core_cookie)\n\t\treturn;\n\n\tif (!rq->nr_running) /* not forced idle */\n\t\treturn;\n\n\tqueue_balance_callback(rq, &per_cpu(core_balance_head, rq->cpu), sched_core_balance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedstat_inc",
          "args": [
            "rq->sched_goidle"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_idle_core",
          "args": [
            "rq"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_core",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1362-1362",
          "snippet": "static inline void update_idle_core(struct rq *rq) { }",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void update_idle_core(struct rq *rq) { }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void set_next_task_idle(struct rq *rq, struct task_struct *next, bool first)\n{\n\tupdate_idle_core(rq);\n\tschedstat_inc(rq->sched_goidle);\n\tqueue_core_balance(rq);\n}"
  },
  {
    "function_name": "put_prev_task_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "432-434",
    "snippet": "static void put_prev_task_idle(struct rq *rq, struct task_struct *prev)\n{\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void put_prev_task_idle(struct rq *rq, struct task_struct *prev)\n{\n}"
  },
  {
    "function_name": "check_preempt_curr_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "427-430",
    "snippet": "static void check_preempt_curr_idle(struct rq *rq, struct task_struct *p, int flags)\n{\n\tresched_curr(rq);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "976-998",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void check_preempt_curr_idle(struct rq *rq, struct task_struct *p, int flags)\n{\n\tresched_curr(rq);\n}"
  },
  {
    "function_name": "balance_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "417-421",
    "snippet": "static int\nbalance_idle(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\treturn WARN_ON_ONCE(1);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic int\nbalance_idle(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\treturn WARN_ON_ONCE(1);\n}"
  },
  {
    "function_name": "select_task_rq_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "411-415",
    "snippet": "static int\nselect_task_rq_idle(struct task_struct *p, int cpu, int flags)\n{\n\treturn task_cpu(p); /* IDLE tasks as never migrated */\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic int\nselect_task_rq_idle(struct task_struct *p, int cpu, int flags)\n{\n\treturn task_cpu(p); /* IDLE tasks as never migrated */\n}"
  },
  {
    "function_name": "cpu_startup_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "398-404",
    "snippet": "void cpu_startup_entry(enum cpuhp_state state)\n{\n\tarch_cpu_idle_prepare();\n\tcpuhp_online_idle(state);\n\twhile (1)\n\t\tdo_idle();\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_idle",
          "args": [],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "do_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
          "lines": "261-338",
          "snippet": "static void do_idle(void)\n{\n\tint cpu = smp_processor_id();\n\n\t/*\n\t * Check if we need to update blocked load\n\t */\n\tnohz_run_idle_balance(cpu);\n\n\t/*\n\t * If the arch has a polling bit, we maintain an invariant:\n\t *\n\t * Our polling bit is clear if we're not scheduled (i.e. if rq->curr !=\n\t * rq->idle). This means that, if rq->idle has the polling bit set,\n\t * then setting need_resched is guaranteed to cause the CPU to\n\t * reschedule.\n\t */\n\n\t__current_set_polling();\n\ttick_nohz_idle_enter();\n\n\twhile (!need_resched()) {\n\t\trmb();\n\n\t\tlocal_irq_disable();\n\n\t\tif (cpu_is_offline(cpu)) {\n\t\t\ttick_nohz_idle_stop_tick();\n\t\t\tcpuhp_report_idle_dead();\n\t\t\tarch_cpu_idle_dead();\n\t\t}\n\n\t\tarch_cpu_idle_enter();\n\t\trcu_nocb_flush_deferred_wakeup();\n\n\t\t/*\n\t\t * In poll mode we reenable interrupts and spin. Also if we\n\t\t * detected in the wakeup from idle path that the tick\n\t\t * broadcast device expired for us, we don't want to go deep\n\t\t * idle as we know that the IPI is going to arrive right away.\n\t\t */\n\t\tif (cpu_idle_force_poll || tick_check_broadcast_expired()) {\n\t\t\ttick_nohz_idle_restart_tick();\n\t\t\tcpu_idle_poll();\n\t\t} else {\n\t\t\tcpuidle_idle_call();\n\t\t}\n\t\tarch_cpu_idle_exit();\n\t}\n\n\t/*\n\t * Since we fell out of the loop above, we know TIF_NEED_RESCHED must\n\t * be set, propagate it into PREEMPT_NEED_RESCHED.\n\t *\n\t * This is required because for polling idle loops we will not have had\n\t * an IPI to fold the state for us.\n\t */\n\tpreempt_set_need_resched();\n\ttick_nohz_idle_exit();\n\t__current_clr_polling();\n\n\t/*\n\t * We promise to call sched_ttwu_pending() and reschedule if\n\t * need_resched() is set while polling is set. That means that clearing\n\t * polling needs to be visible before doing these things.\n\t */\n\tsmp_mb__after_atomic();\n\n\t/*\n\t * RCU relies on this call to be done outside of an RCU read-side\n\t * critical section.\n\t */\n\tflush_smp_call_function_from_idle();\n\tschedule_idle();\n\n\tif (unlikely(klp_patch_pending(current)))\n\t\tklp_update_patch_state(current);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};\n\nstatic void do_idle(void)\n{\n\tint cpu = smp_processor_id();\n\n\t/*\n\t * Check if we need to update blocked load\n\t */\n\tnohz_run_idle_balance(cpu);\n\n\t/*\n\t * If the arch has a polling bit, we maintain an invariant:\n\t *\n\t * Our polling bit is clear if we're not scheduled (i.e. if rq->curr !=\n\t * rq->idle). This means that, if rq->idle has the polling bit set,\n\t * then setting need_resched is guaranteed to cause the CPU to\n\t * reschedule.\n\t */\n\n\t__current_set_polling();\n\ttick_nohz_idle_enter();\n\n\twhile (!need_resched()) {\n\t\trmb();\n\n\t\tlocal_irq_disable();\n\n\t\tif (cpu_is_offline(cpu)) {\n\t\t\ttick_nohz_idle_stop_tick();\n\t\t\tcpuhp_report_idle_dead();\n\t\t\tarch_cpu_idle_dead();\n\t\t}\n\n\t\tarch_cpu_idle_enter();\n\t\trcu_nocb_flush_deferred_wakeup();\n\n\t\t/*\n\t\t * In poll mode we reenable interrupts and spin. Also if we\n\t\t * detected in the wakeup from idle path that the tick\n\t\t * broadcast device expired for us, we don't want to go deep\n\t\t * idle as we know that the IPI is going to arrive right away.\n\t\t */\n\t\tif (cpu_idle_force_poll || tick_check_broadcast_expired()) {\n\t\t\ttick_nohz_idle_restart_tick();\n\t\t\tcpu_idle_poll();\n\t\t} else {\n\t\t\tcpuidle_idle_call();\n\t\t}\n\t\tarch_cpu_idle_exit();\n\t}\n\n\t/*\n\t * Since we fell out of the loop above, we know TIF_NEED_RESCHED must\n\t * be set, propagate it into PREEMPT_NEED_RESCHED.\n\t *\n\t * This is required because for polling idle loops we will not have had\n\t * an IPI to fold the state for us.\n\t */\n\tpreempt_set_need_resched();\n\ttick_nohz_idle_exit();\n\t__current_clr_polling();\n\n\t/*\n\t * We promise to call sched_ttwu_pending() and reschedule if\n\t * need_resched() is set while polling is set. That means that clearing\n\t * polling needs to be visible before doing these things.\n\t */\n\tsmp_mb__after_atomic();\n\n\t/*\n\t * RCU relies on this call to be done outside of an RCU read-side\n\t * critical section.\n\t */\n\tflush_smp_call_function_from_idle();\n\tschedule_idle();\n\n\tif (unlikely(klp_patch_pending(current)))\n\t\tklp_update_patch_state(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_online_idle",
          "args": [
            "state"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_online_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1304-1320",
          "snippet": "void cpuhp_online_idle(enum cpuhp_state state)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\t/* Happens for the boot cpu */\n\tif (state != CPUHP_AP_ONLINE_IDLE)\n\t\treturn;\n\n\t/*\n\t * Unpart the stopper thread before we start the idle loop (and start\n\t * scheduling); this ensures the stopper task is always available.\n\t */\n\tstop_machine_unpark(smp_processor_id());\n\n\tst->state = CPUHP_AP_ONLINE_IDLE;\n\tcomplete_ap_thread(st, true);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid cpuhp_online_idle(enum cpuhp_state state)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\t/* Happens for the boot cpu */\n\tif (state != CPUHP_AP_ONLINE_IDLE)\n\t\treturn;\n\n\t/*\n\t * Unpart the stopper thread before we start the idle loop (and start\n\t * scheduling); this ensures the stopper task is always available.\n\t */\n\tstop_machine_unpark(smp_processor_id());\n\n\tst->state = CPUHP_AP_ONLINE_IDLE;\n\tcomplete_ap_thread(st, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_cpu_idle_prepare",
          "args": [],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "arch_cpu_idle_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
          "lines": "74-74",
          "snippet": "void __weak arch_cpu_idle_prepare(void) { }",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_prepare(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid cpu_startup_entry(enum cpuhp_state state)\n{\n\tarch_cpu_idle_prepare();\n\tcpuhp_online_idle(state);\n\twhile (1)\n\t\tdo_idle();\n}"
  },
  {
    "function_name": "play_idle_precise",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "361-395",
    "snippet": "void play_idle_precise(u64 duration_ns, u64 latency_ns)\n{\n\tstruct idle_timer it;\n\n\t/*\n\t * Only FIFO tasks can disable the tick since they don't need the forced\n\t * preemption.\n\t */\n\tWARN_ON_ONCE(current->policy != SCHED_FIFO);\n\tWARN_ON_ONCE(current->nr_cpus_allowed != 1);\n\tWARN_ON_ONCE(!(current->flags & PF_KTHREAD));\n\tWARN_ON_ONCE(!(current->flags & PF_NO_SETAFFINITY));\n\tWARN_ON_ONCE(!duration_ns);\n\tWARN_ON_ONCE(current->mm);\n\n\trcu_sleep_check();\n\tpreempt_disable();\n\tcurrent->flags |= PF_IDLE;\n\tcpuidle_use_deepest_state(latency_ns);\n\n\tit.done = 0;\n\thrtimer_init_on_stack(&it.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\tit.timer.function = idle_inject_timer_fn;\n\thrtimer_start(&it.timer, ns_to_ktime(duration_ns),\n\t\t      HRTIMER_MODE_REL_PINNED_HARD);\n\n\twhile (!READ_ONCE(it.done))\n\t\tdo_idle();\n\n\tcpuidle_use_deepest_state(0);\n\tcurrent->flags &= ~PF_IDLE;\n\n\tpreempt_fold_need_resched();\n\tpreempt_enable();\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_fold_need_resched",
          "args": [],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuidle_use_deepest_state",
          "args": [
            "0"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_idle",
          "args": [],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "do_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
          "lines": "261-338",
          "snippet": "static void do_idle(void)\n{\n\tint cpu = smp_processor_id();\n\n\t/*\n\t * Check if we need to update blocked load\n\t */\n\tnohz_run_idle_balance(cpu);\n\n\t/*\n\t * If the arch has a polling bit, we maintain an invariant:\n\t *\n\t * Our polling bit is clear if we're not scheduled (i.e. if rq->curr !=\n\t * rq->idle). This means that, if rq->idle has the polling bit set,\n\t * then setting need_resched is guaranteed to cause the CPU to\n\t * reschedule.\n\t */\n\n\t__current_set_polling();\n\ttick_nohz_idle_enter();\n\n\twhile (!need_resched()) {\n\t\trmb();\n\n\t\tlocal_irq_disable();\n\n\t\tif (cpu_is_offline(cpu)) {\n\t\t\ttick_nohz_idle_stop_tick();\n\t\t\tcpuhp_report_idle_dead();\n\t\t\tarch_cpu_idle_dead();\n\t\t}\n\n\t\tarch_cpu_idle_enter();\n\t\trcu_nocb_flush_deferred_wakeup();\n\n\t\t/*\n\t\t * In poll mode we reenable interrupts and spin. Also if we\n\t\t * detected in the wakeup from idle path that the tick\n\t\t * broadcast device expired for us, we don't want to go deep\n\t\t * idle as we know that the IPI is going to arrive right away.\n\t\t */\n\t\tif (cpu_idle_force_poll || tick_check_broadcast_expired()) {\n\t\t\ttick_nohz_idle_restart_tick();\n\t\t\tcpu_idle_poll();\n\t\t} else {\n\t\t\tcpuidle_idle_call();\n\t\t}\n\t\tarch_cpu_idle_exit();\n\t}\n\n\t/*\n\t * Since we fell out of the loop above, we know TIF_NEED_RESCHED must\n\t * be set, propagate it into PREEMPT_NEED_RESCHED.\n\t *\n\t * This is required because for polling idle loops we will not have had\n\t * an IPI to fold the state for us.\n\t */\n\tpreempt_set_need_resched();\n\ttick_nohz_idle_exit();\n\t__current_clr_polling();\n\n\t/*\n\t * We promise to call sched_ttwu_pending() and reschedule if\n\t * need_resched() is set while polling is set. That means that clearing\n\t * polling needs to be visible before doing these things.\n\t */\n\tsmp_mb__after_atomic();\n\n\t/*\n\t * RCU relies on this call to be done outside of an RCU read-side\n\t * critical section.\n\t */\n\tflush_smp_call_function_from_idle();\n\tschedule_idle();\n\n\tif (unlikely(klp_patch_pending(current)))\n\t\tklp_update_patch_state(current);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};\n\nstatic void do_idle(void)\n{\n\tint cpu = smp_processor_id();\n\n\t/*\n\t * Check if we need to update blocked load\n\t */\n\tnohz_run_idle_balance(cpu);\n\n\t/*\n\t * If the arch has a polling bit, we maintain an invariant:\n\t *\n\t * Our polling bit is clear if we're not scheduled (i.e. if rq->curr !=\n\t * rq->idle). This means that, if rq->idle has the polling bit set,\n\t * then setting need_resched is guaranteed to cause the CPU to\n\t * reschedule.\n\t */\n\n\t__current_set_polling();\n\ttick_nohz_idle_enter();\n\n\twhile (!need_resched()) {\n\t\trmb();\n\n\t\tlocal_irq_disable();\n\n\t\tif (cpu_is_offline(cpu)) {\n\t\t\ttick_nohz_idle_stop_tick();\n\t\t\tcpuhp_report_idle_dead();\n\t\t\tarch_cpu_idle_dead();\n\t\t}\n\n\t\tarch_cpu_idle_enter();\n\t\trcu_nocb_flush_deferred_wakeup();\n\n\t\t/*\n\t\t * In poll mode we reenable interrupts and spin. Also if we\n\t\t * detected in the wakeup from idle path that the tick\n\t\t * broadcast device expired for us, we don't want to go deep\n\t\t * idle as we know that the IPI is going to arrive right away.\n\t\t */\n\t\tif (cpu_idle_force_poll || tick_check_broadcast_expired()) {\n\t\t\ttick_nohz_idle_restart_tick();\n\t\t\tcpu_idle_poll();\n\t\t} else {\n\t\t\tcpuidle_idle_call();\n\t\t}\n\t\tarch_cpu_idle_exit();\n\t}\n\n\t/*\n\t * Since we fell out of the loop above, we know TIF_NEED_RESCHED must\n\t * be set, propagate it into PREEMPT_NEED_RESCHED.\n\t *\n\t * This is required because for polling idle loops we will not have had\n\t * an IPI to fold the state for us.\n\t */\n\tpreempt_set_need_resched();\n\ttick_nohz_idle_exit();\n\t__current_clr_polling();\n\n\t/*\n\t * We promise to call sched_ttwu_pending() and reschedule if\n\t * need_resched() is set while polling is set. That means that clearing\n\t * polling needs to be visible before doing these things.\n\t */\n\tsmp_mb__after_atomic();\n\n\t/*\n\t * RCU relies on this call to be done outside of an RCU read-side\n\t * critical section.\n\t */\n\tflush_smp_call_function_from_idle();\n\tschedule_idle();\n\n\tif (unlikely(klp_patch_pending(current)))\n\t\tklp_update_patch_state(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "it.done"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&it.timer",
            "ns_to_ktime(duration_ns)",
            "HRTIMER_MODE_REL_PINNED_HARD"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "duration_ns"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init_on_stack",
          "args": [
            "&it.timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_REL_HARD"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "431-436",
          "snippet": "void hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidle_use_deepest_state",
          "args": [
            "latency_ns"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_sleep_check",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "current->mm"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!duration_ns"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(current->flags & PF_NO_SETAFFINITY)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(current->flags & PF_KTHREAD)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "current->nr_cpus_allowed != 1"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "current->policy != SCHED_FIFO"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid play_idle_precise(u64 duration_ns, u64 latency_ns)\n{\n\tstruct idle_timer it;\n\n\t/*\n\t * Only FIFO tasks can disable the tick since they don't need the forced\n\t * preemption.\n\t */\n\tWARN_ON_ONCE(current->policy != SCHED_FIFO);\n\tWARN_ON_ONCE(current->nr_cpus_allowed != 1);\n\tWARN_ON_ONCE(!(current->flags & PF_KTHREAD));\n\tWARN_ON_ONCE(!(current->flags & PF_NO_SETAFFINITY));\n\tWARN_ON_ONCE(!duration_ns);\n\tWARN_ON_ONCE(current->mm);\n\n\trcu_sleep_check();\n\tpreempt_disable();\n\tcurrent->flags |= PF_IDLE;\n\tcpuidle_use_deepest_state(latency_ns);\n\n\tit.done = 0;\n\thrtimer_init_on_stack(&it.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\tit.timer.function = idle_inject_timer_fn;\n\thrtimer_start(&it.timer, ns_to_ktime(duration_ns),\n\t\t      HRTIMER_MODE_REL_PINNED_HARD);\n\n\twhile (!READ_ONCE(it.done))\n\t\tdo_idle();\n\n\tcpuidle_use_deepest_state(0);\n\tcurrent->flags &= ~PF_IDLE;\n\n\tpreempt_fold_need_resched();\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "idle_inject_timer_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "351-359",
    "snippet": "static enum hrtimer_restart idle_inject_timer_fn(struct hrtimer *timer)\n{\n\tstruct idle_timer *it = container_of(timer, struct idle_timer, timer);\n\n\tWRITE_ONCE(it->done, 1);\n\tset_tsk_need_resched(current);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "current"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "it->done",
            "1"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structidle_timer",
            "timer"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic enum hrtimer_restart idle_inject_timer_fn(struct hrtimer *timer)\n{\n\tstruct idle_timer *it = container_of(timer, struct idle_timer, timer);\n\n\tWRITE_ONCE(it->done, 1);\n\tset_tsk_need_resched(current);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "cpu_in_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "340-344",
    "snippet": "bool cpu_in_idle(unsigned long pc)\n{\n\treturn pc >= (unsigned long)__cpuidle_text_start &&\n\t\tpc < (unsigned long)__cpuidle_text_end;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char __cpuidle_text_start[], __cpuidle_text_end[];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nextern char __cpuidle_text_start[], __cpuidle_text_end[];\n\nbool cpu_in_idle(unsigned long pc)\n{\n\treturn pc >= (unsigned long)__cpuidle_text_start &&\n\t\tpc < (unsigned long)__cpuidle_text_end;\n}"
  },
  {
    "function_name": "do_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "261-338",
    "snippet": "static void do_idle(void)\n{\n\tint cpu = smp_processor_id();\n\n\t/*\n\t * Check if we need to update blocked load\n\t */\n\tnohz_run_idle_balance(cpu);\n\n\t/*\n\t * If the arch has a polling bit, we maintain an invariant:\n\t *\n\t * Our polling bit is clear if we're not scheduled (i.e. if rq->curr !=\n\t * rq->idle). This means that, if rq->idle has the polling bit set,\n\t * then setting need_resched is guaranteed to cause the CPU to\n\t * reschedule.\n\t */\n\n\t__current_set_polling();\n\ttick_nohz_idle_enter();\n\n\twhile (!need_resched()) {\n\t\trmb();\n\n\t\tlocal_irq_disable();\n\n\t\tif (cpu_is_offline(cpu)) {\n\t\t\ttick_nohz_idle_stop_tick();\n\t\t\tcpuhp_report_idle_dead();\n\t\t\tarch_cpu_idle_dead();\n\t\t}\n\n\t\tarch_cpu_idle_enter();\n\t\trcu_nocb_flush_deferred_wakeup();\n\n\t\t/*\n\t\t * In poll mode we reenable interrupts and spin. Also if we\n\t\t * detected in the wakeup from idle path that the tick\n\t\t * broadcast device expired for us, we don't want to go deep\n\t\t * idle as we know that the IPI is going to arrive right away.\n\t\t */\n\t\tif (cpu_idle_force_poll || tick_check_broadcast_expired()) {\n\t\t\ttick_nohz_idle_restart_tick();\n\t\t\tcpu_idle_poll();\n\t\t} else {\n\t\t\tcpuidle_idle_call();\n\t\t}\n\t\tarch_cpu_idle_exit();\n\t}\n\n\t/*\n\t * Since we fell out of the loop above, we know TIF_NEED_RESCHED must\n\t * be set, propagate it into PREEMPT_NEED_RESCHED.\n\t *\n\t * This is required because for polling idle loops we will not have had\n\t * an IPI to fold the state for us.\n\t */\n\tpreempt_set_need_resched();\n\ttick_nohz_idle_exit();\n\t__current_clr_polling();\n\n\t/*\n\t * We promise to call sched_ttwu_pending() and reschedule if\n\t * need_resched() is set while polling is set. That means that clearing\n\t * polling needs to be visible before doing these things.\n\t */\n\tsmp_mb__after_atomic();\n\n\t/*\n\t * RCU relies on this call to be done outside of an RCU read-side\n\t * critical section.\n\t */\n\tflush_smp_call_function_from_idle();\n\tschedule_idle();\n\n\tif (unlikely(klp_patch_pending(current)))\n\t\tklp_update_patch_state(current);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_update_patch_state",
          "args": [
            "current"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "klp_update_patch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
          "lines": "162-186",
          "snippet": "void klp_update_patch_state(struct task_struct *task)\n{\n\t/*\n\t * A variant of synchronize_rcu() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\t/*\n\t * This test_and_clear_tsk_thread_flag() call also serves as a read\n\t * barrier (smp_rmb) for two cases:\n\t *\n\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the\n\t *    klp_target_state read.  The corresponding write barrier is in\n\t *    klp_init_transition().\n\t *\n\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read\n\t *    of func->transition, if klp_ftrace_handler() is called later on\n\t *    the same CPU.  See __klp_disable_patch().\n\t */\n\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))\n\t\ttask->patch_state = READ_ONCE(klp_target_state);\n\n\tpreempt_enable_notrace();\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_update_patch_state(struct task_struct *task)\n{\n\t/*\n\t * A variant of synchronize_rcu() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\t/*\n\t * This test_and_clear_tsk_thread_flag() call also serves as a read\n\t * barrier (smp_rmb) for two cases:\n\t *\n\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the\n\t *    klp_target_state read.  The corresponding write barrier is in\n\t *    klp_init_transition().\n\t *\n\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read\n\t *    of func->transition, if klp_ftrace_handler() is called later on\n\t *    the same CPU.  See __klp_disable_patch().\n\t */\n\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))\n\t\ttask->patch_state = READ_ONCE(klp_target_state);\n\n\tpreempt_enable_notrace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "klp_patch_pending(current)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_patch_pending",
          "args": [
            "current"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_idle",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6386-6399",
          "snippet": "void __sched schedule_idle(void)\n{\n\t/*\n\t * As this skips calling sched_submit_work(), which the idle task does\n\t * regardless because that function is a nop when the task is in a\n\t * TASK_RUNNING state, make sure this isn't used someplace that the\n\t * current task can be in any other state. Note, idle is always in the\n\t * TASK_RUNNING state.\n\t */\n\tWARN_ON_ONCE(current->__state);\n\tdo {\n\t\t__schedule(SM_NONE);\n\t} while (need_resched());\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [
            "#define SM_NONE\t\t\t0x0"
          ],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\n#define SM_NONE\t\t\t0x0\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_idle(void)\n{\n\t/*\n\t * As this skips calling sched_submit_work(), which the idle task does\n\t * regardless because that function is a nop when the task is in a\n\t * TASK_RUNNING state, make sure this isn't used someplace that the\n\t * current task can be in any other state. Note, idle is always in the\n\t * TASK_RUNNING state.\n\t */\n\tWARN_ON_ONCE(current->__state);\n\tdo {\n\t\t__schedule(SM_NONE);\n\t} while (need_resched());\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_smp_call_function_from_idle",
          "args": [],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "flush_smp_call_function_from_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1853-1853",
          "snippet": "static inline void flush_smp_call_function_from_idle(void) { }",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline void flush_smp_call_function_from_idle(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__current_clr_polling",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_idle_exit",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_idle_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1281-1306",
          "snippet": "void tick_nohz_idle_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tbool idle_active, tick_stopped;\n\tktime_t now;\n\n\tlocal_irq_disable();\n\n\tWARN_ON_ONCE(!ts->inidle);\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 0;\n\tidle_active = ts->idle_active;\n\ttick_stopped = ts->tick_stopped;\n\n\tif (idle_active || tick_stopped)\n\t\tnow = ktime_get();\n\n\tif (idle_active)\n\t\ttick_nohz_stop_idle(ts, now);\n\n\tif (tick_stopped)\n\t\ttick_nohz_idle_update_tick(ts, now);\n\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tbool idle_active, tick_stopped;\n\tktime_t now;\n\n\tlocal_irq_disable();\n\n\tWARN_ON_ONCE(!ts->inidle);\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 0;\n\tidle_active = ts->idle_active;\n\ttick_stopped = ts->tick_stopped;\n\n\tif (idle_active || tick_stopped)\n\t\tnow = ktime_get();\n\n\tif (idle_active)\n\t\ttick_nohz_stop_idle(ts, now);\n\n\tif (tick_stopped)\n\t\ttick_nohz_idle_update_tick(ts, now);\n\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_set_need_resched",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_cpu_idle_exit",
          "args": [],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "arch_cpu_idle_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
          "lines": "76-76",
          "snippet": "void __weak arch_cpu_idle_exit(void) { }",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_exit(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpuidle_idle_call",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidle_idle_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
          "lines": "170-254",
          "snippet": "static void cpuidle_idle_call(void)\n{\n\tstruct cpuidle_device *dev = cpuidle_get_device();\n\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);\n\tint next_state, entered_state;\n\n\t/*\n\t * Check if the idle task must be rescheduled. If it is the\n\t * case, exit the function after re-enabling the local irq.\n\t */\n\tif (need_resched()) {\n\t\tlocal_irq_enable();\n\t\treturn;\n\t}\n\n\t/*\n\t * The RCU framework needs to be told that we are entering an idle\n\t * section, so no more rcu read side critical sections and one more\n\t * step to the grace period\n\t */\n\n\tif (cpuidle_not_available(drv, dev)) {\n\t\ttick_nohz_idle_stop_tick();\n\n\t\tdefault_idle_call();\n\t\tgoto exit_idle;\n\t}\n\n\t/*\n\t * Suspend-to-idle (\"s2idle\") is a system state in which all user space\n\t * has been frozen, all I/O devices have been suspended and the only\n\t * activity happens here and in interrupts (if any). In that case bypass\n\t * the cpuidle governor and go straight for the deepest idle state\n\t * available.  Possibly also suspend the local tick and the entire\n\t * timekeeping to prevent timer interrupts from kicking us out of idle\n\t * until a proper wakeup interrupt happens.\n\t */\n\n\tif (idle_should_enter_s2idle() || dev->forced_idle_latency_limit_ns) {\n\t\tu64 max_latency_ns;\n\n\t\tif (idle_should_enter_s2idle()) {\n\n\t\t\tentered_state = call_cpuidle_s2idle(drv, dev);\n\t\t\tif (entered_state > 0)\n\t\t\t\tgoto exit_idle;\n\n\t\t\tmax_latency_ns = U64_MAX;\n\t\t} else {\n\t\t\tmax_latency_ns = dev->forced_idle_latency_limit_ns;\n\t\t}\n\n\t\ttick_nohz_idle_stop_tick();\n\n\t\tnext_state = cpuidle_find_deepest_state(drv, dev, max_latency_ns);\n\t\tcall_cpuidle(drv, dev, next_state);\n\t} else {\n\t\tbool stop_tick = true;\n\n\t\t/*\n\t\t * Ask the cpuidle framework to choose a convenient idle state.\n\t\t */\n\t\tnext_state = cpuidle_select(drv, dev, &stop_tick);\n\n\t\tif (stop_tick || tick_nohz_tick_stopped())\n\t\t\ttick_nohz_idle_stop_tick();\n\t\telse\n\t\t\ttick_nohz_idle_retain_tick();\n\n\t\tentered_state = call_cpuidle(drv, dev, next_state);\n\t\t/*\n\t\t * Give the governor an opportunity to reflect on the outcome\n\t\t */\n\t\tcpuidle_reflect(dev, entered_state);\n\t}\n\nexit_idle:\n\t__current_set_polling();\n\n\t/*\n\t * It is up to the idle functions to reenable local interrupts\n\t */\n\tif (WARN_ON_ONCE(irqs_disabled()))\n\t\tlocal_irq_enable();\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};\n\nstatic void cpuidle_idle_call(void)\n{\n\tstruct cpuidle_device *dev = cpuidle_get_device();\n\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);\n\tint next_state, entered_state;\n\n\t/*\n\t * Check if the idle task must be rescheduled. If it is the\n\t * case, exit the function after re-enabling the local irq.\n\t */\n\tif (need_resched()) {\n\t\tlocal_irq_enable();\n\t\treturn;\n\t}\n\n\t/*\n\t * The RCU framework needs to be told that we are entering an idle\n\t * section, so no more rcu read side critical sections and one more\n\t * step to the grace period\n\t */\n\n\tif (cpuidle_not_available(drv, dev)) {\n\t\ttick_nohz_idle_stop_tick();\n\n\t\tdefault_idle_call();\n\t\tgoto exit_idle;\n\t}\n\n\t/*\n\t * Suspend-to-idle (\"s2idle\") is a system state in which all user space\n\t * has been frozen, all I/O devices have been suspended and the only\n\t * activity happens here and in interrupts (if any). In that case bypass\n\t * the cpuidle governor and go straight for the deepest idle state\n\t * available.  Possibly also suspend the local tick and the entire\n\t * timekeeping to prevent timer interrupts from kicking us out of idle\n\t * until a proper wakeup interrupt happens.\n\t */\n\n\tif (idle_should_enter_s2idle() || dev->forced_idle_latency_limit_ns) {\n\t\tu64 max_latency_ns;\n\n\t\tif (idle_should_enter_s2idle()) {\n\n\t\t\tentered_state = call_cpuidle_s2idle(drv, dev);\n\t\t\tif (entered_state > 0)\n\t\t\t\tgoto exit_idle;\n\n\t\t\tmax_latency_ns = U64_MAX;\n\t\t} else {\n\t\t\tmax_latency_ns = dev->forced_idle_latency_limit_ns;\n\t\t}\n\n\t\ttick_nohz_idle_stop_tick();\n\n\t\tnext_state = cpuidle_find_deepest_state(drv, dev, max_latency_ns);\n\t\tcall_cpuidle(drv, dev, next_state);\n\t} else {\n\t\tbool stop_tick = true;\n\n\t\t/*\n\t\t * Ask the cpuidle framework to choose a convenient idle state.\n\t\t */\n\t\tnext_state = cpuidle_select(drv, dev, &stop_tick);\n\n\t\tif (stop_tick || tick_nohz_tick_stopped())\n\t\t\ttick_nohz_idle_stop_tick();\n\t\telse\n\t\t\ttick_nohz_idle_retain_tick();\n\n\t\tentered_state = call_cpuidle(drv, dev, next_state);\n\t\t/*\n\t\t * Give the governor an opportunity to reflect on the outcome\n\t\t */\n\t\tcpuidle_reflect(dev, entered_state);\n\t}\n\nexit_idle:\n\t__current_set_polling();\n\n\t/*\n\t * It is up to the idle functions to reenable local interrupts\n\t */\n\tif (WARN_ON_ONCE(irqs_disabled()))\n\t\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_idle_poll",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_idle_poll",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
          "lines": "55-71",
          "snippet": "__cpuidle cpu_idle_poll(void)\n{\n\ttrace_cpu_idle(0, smp_processor_id());\n\tstop_critical_timings();\n\trcu_idle_enter();\n\tlocal_irq_enable();\n\n\twhile (!tif_need_resched() &&\n\t       (cpu_idle_force_poll || tick_check_broadcast_expired()))\n\t\tcpu_relax();\n\n\trcu_idle_exit();\n\tstart_critical_timings();\n\ttrace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());\n\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\n__cpuidle cpu_idle_poll(void)\n{\n\ttrace_cpu_idle(0, smp_processor_id());\n\tstop_critical_timings();\n\trcu_idle_enter();\n\tlocal_irq_enable();\n\n\twhile (!tif_need_resched() &&\n\t       (cpu_idle_force_poll || tick_check_broadcast_expired()))\n\t\tcpu_relax();\n\n\trcu_idle_exit();\n\tstart_critical_timings();\n\ttrace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_idle_restart_tick",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_idle_restart_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1253-1262",
          "snippet": "void tick_nohz_idle_restart_tick(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->tick_stopped) {\n\t\tktime_t now = ktime_get();\n\t\ttick_nohz_restart_sched_tick(ts, now);\n\t\ttick_nohz_account_idle_time(ts, now);\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_restart_tick(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->tick_stopped) {\n\t\tktime_t now = ktime_get();\n\t\ttick_nohz_restart_sched_tick(ts, now);\n\t\ttick_nohz_account_idle_time(ts, now);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_broadcast_expired",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_broadcast_expired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "625-628",
          "snippet": "int tick_check_broadcast_expired(void)\n{\n\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_force_mask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_check_broadcast_expired(void)\n{\n\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_force_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nocb_flush_deferred_wakeup",
          "args": [],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_flush_deferred_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "953-956",
          "snippet": "void rcu_nocb_flush_deferred_wakeup(void)\n{\n\tdo_nocb_deferred_wakeup(this_cpu_ptr(&rcu_data));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "void rcu_nocb_flush_deferred_wakeup(void)\n{\n\tdo_nocb_deferred_wakeup(this_cpu_ptr(&rcu_data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_cpu_idle_enter",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "arch_cpu_idle_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
          "lines": "75-75",
          "snippet": "void __weak arch_cpu_idle_enter(void) { }",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_enter(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "arch_cpu_idle_dead",
          "args": [],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "arch_cpu_idle_dead",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
          "lines": "77-77",
          "snippet": "void __weak arch_cpu_idle_dead(void) { }",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_dead(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_report_idle_dead",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_report_idle_dead",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1082-1095",
          "snippet": "void cpuhp_report_idle_dead(void)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\tBUG_ON(st->state != CPUHP_AP_OFFLINE);\n\trcu_report_dead(smp_processor_id());\n\tst->state = CPUHP_AP_IDLE_DEAD;\n\t/*\n\t * We cannot call complete after rcu_report_dead() so we delegate it\n\t * to an online cpu.\n\t */\n\tsmp_call_function_single(cpumask_first(cpu_online_mask),\n\t\t\t\t cpuhp_complete_idle_dead, st, 0);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid cpuhp_report_idle_dead(void)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\tBUG_ON(st->state != CPUHP_AP_OFFLINE);\n\trcu_report_dead(smp_processor_id());\n\tst->state = CPUHP_AP_IDLE_DEAD;\n\t/*\n\t * We cannot call complete after rcu_report_dead() so we delegate it\n\t * to an online cpu.\n\t */\n\tsmp_call_function_single(cpumask_first(cpu_online_mask),\n\t\t\t\t cpuhp_complete_idle_dead, st, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_idle_stop_tick",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_idle_stop_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1081-1084",
          "snippet": "void tick_nohz_idle_stop_tick(void)\n{\n\t__tick_nohz_idle_stop_tick(this_cpu_ptr(&tick_cpu_sched));\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_stop_tick(void)\n{\n\t__tick_nohz_idle_stop_tick(this_cpu_ptr(&tick_cpu_sched));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "cpu"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmb",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_idle_enter",
          "args": [],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_idle_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1101-1117",
          "snippet": "void tick_nohz_idle_enter(void)\n{\n\tstruct tick_sched *ts;\n\n\tlockdep_assert_irqs_enabled();\n\n\tlocal_irq_disable();\n\n\tts = this_cpu_ptr(&tick_cpu_sched);\n\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 1;\n\ttick_nohz_start_idle(ts);\n\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_enter(void)\n{\n\tstruct tick_sched *ts;\n\n\tlockdep_assert_irqs_enabled();\n\n\tlocal_irq_disable();\n\n\tts = this_cpu_ptr(&tick_cpu_sched);\n\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 1;\n\ttick_nohz_start_idle(ts);\n\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__current_set_polling",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nohz_run_idle_balance",
          "args": [
            "cpu"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "nohz_run_idle_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2747-2747",
          "snippet": "static inline void nohz_run_idle_balance(int cpu) { }",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic inline void nohz_run_idle_balance(int cpu) { }"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};\n\nstatic void do_idle(void)\n{\n\tint cpu = smp_processor_id();\n\n\t/*\n\t * Check if we need to update blocked load\n\t */\n\tnohz_run_idle_balance(cpu);\n\n\t/*\n\t * If the arch has a polling bit, we maintain an invariant:\n\t *\n\t * Our polling bit is clear if we're not scheduled (i.e. if rq->curr !=\n\t * rq->idle). This means that, if rq->idle has the polling bit set,\n\t * then setting need_resched is guaranteed to cause the CPU to\n\t * reschedule.\n\t */\n\n\t__current_set_polling();\n\ttick_nohz_idle_enter();\n\n\twhile (!need_resched()) {\n\t\trmb();\n\n\t\tlocal_irq_disable();\n\n\t\tif (cpu_is_offline(cpu)) {\n\t\t\ttick_nohz_idle_stop_tick();\n\t\t\tcpuhp_report_idle_dead();\n\t\t\tarch_cpu_idle_dead();\n\t\t}\n\n\t\tarch_cpu_idle_enter();\n\t\trcu_nocb_flush_deferred_wakeup();\n\n\t\t/*\n\t\t * In poll mode we reenable interrupts and spin. Also if we\n\t\t * detected in the wakeup from idle path that the tick\n\t\t * broadcast device expired for us, we don't want to go deep\n\t\t * idle as we know that the IPI is going to arrive right away.\n\t\t */\n\t\tif (cpu_idle_force_poll || tick_check_broadcast_expired()) {\n\t\t\ttick_nohz_idle_restart_tick();\n\t\t\tcpu_idle_poll();\n\t\t} else {\n\t\t\tcpuidle_idle_call();\n\t\t}\n\t\tarch_cpu_idle_exit();\n\t}\n\n\t/*\n\t * Since we fell out of the loop above, we know TIF_NEED_RESCHED must\n\t * be set, propagate it into PREEMPT_NEED_RESCHED.\n\t *\n\t * This is required because for polling idle loops we will not have had\n\t * an IPI to fold the state for us.\n\t */\n\tpreempt_set_need_resched();\n\ttick_nohz_idle_exit();\n\t__current_clr_polling();\n\n\t/*\n\t * We promise to call sched_ttwu_pending() and reschedule if\n\t * need_resched() is set while polling is set. That means that clearing\n\t * polling needs to be visible before doing these things.\n\t */\n\tsmp_mb__after_atomic();\n\n\t/*\n\t * RCU relies on this call to be done outside of an RCU read-side\n\t * critical section.\n\t */\n\tflush_smp_call_function_from_idle();\n\tschedule_idle();\n\n\tif (unlikely(klp_patch_pending(current)))\n\t\tklp_update_patch_state(current);\n}"
  },
  {
    "function_name": "cpuidle_idle_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "170-254",
    "snippet": "static void cpuidle_idle_call(void)\n{\n\tstruct cpuidle_device *dev = cpuidle_get_device();\n\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);\n\tint next_state, entered_state;\n\n\t/*\n\t * Check if the idle task must be rescheduled. If it is the\n\t * case, exit the function after re-enabling the local irq.\n\t */\n\tif (need_resched()) {\n\t\tlocal_irq_enable();\n\t\treturn;\n\t}\n\n\t/*\n\t * The RCU framework needs to be told that we are entering an idle\n\t * section, so no more rcu read side critical sections and one more\n\t * step to the grace period\n\t */\n\n\tif (cpuidle_not_available(drv, dev)) {\n\t\ttick_nohz_idle_stop_tick();\n\n\t\tdefault_idle_call();\n\t\tgoto exit_idle;\n\t}\n\n\t/*\n\t * Suspend-to-idle (\"s2idle\") is a system state in which all user space\n\t * has been frozen, all I/O devices have been suspended and the only\n\t * activity happens here and in interrupts (if any). In that case bypass\n\t * the cpuidle governor and go straight for the deepest idle state\n\t * available.  Possibly also suspend the local tick and the entire\n\t * timekeeping to prevent timer interrupts from kicking us out of idle\n\t * until a proper wakeup interrupt happens.\n\t */\n\n\tif (idle_should_enter_s2idle() || dev->forced_idle_latency_limit_ns) {\n\t\tu64 max_latency_ns;\n\n\t\tif (idle_should_enter_s2idle()) {\n\n\t\t\tentered_state = call_cpuidle_s2idle(drv, dev);\n\t\t\tif (entered_state > 0)\n\t\t\t\tgoto exit_idle;\n\n\t\t\tmax_latency_ns = U64_MAX;\n\t\t} else {\n\t\t\tmax_latency_ns = dev->forced_idle_latency_limit_ns;\n\t\t}\n\n\t\ttick_nohz_idle_stop_tick();\n\n\t\tnext_state = cpuidle_find_deepest_state(drv, dev, max_latency_ns);\n\t\tcall_cpuidle(drv, dev, next_state);\n\t} else {\n\t\tbool stop_tick = true;\n\n\t\t/*\n\t\t * Ask the cpuidle framework to choose a convenient idle state.\n\t\t */\n\t\tnext_state = cpuidle_select(drv, dev, &stop_tick);\n\n\t\tif (stop_tick || tick_nohz_tick_stopped())\n\t\t\ttick_nohz_idle_stop_tick();\n\t\telse\n\t\t\ttick_nohz_idle_retain_tick();\n\n\t\tentered_state = call_cpuidle(drv, dev, next_state);\n\t\t/*\n\t\t * Give the governor an opportunity to reflect on the outcome\n\t\t */\n\t\tcpuidle_reflect(dev, entered_state);\n\t}\n\nexit_idle:\n\t__current_set_polling();\n\n\t/*\n\t * It is up to the idle functions to reenable local interrupts\n\t */\n\tif (WARN_ON_ONCE(irqs_disabled()))\n\t\tlocal_irq_enable();\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "irqs_disabled()"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__current_set_polling",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuidle_reflect",
          "args": [
            "dev",
            "entered_state"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_cpuidle",
          "args": [
            "drv",
            "dev",
            "next_state"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "call_cpuidle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
          "lines": "140-159",
          "snippet": "static int call_cpuidle(struct cpuidle_driver *drv, struct cpuidle_device *dev,\n\t\t      int next_state)\n{\n\t/*\n\t * The idle task must be scheduled, it is pointless to go to idle, just\n\t * update no idle residency and return.\n\t */\n\tif (current_clr_polling_and_test()) {\n\t\tdev->last_residency_ns = 0;\n\t\tlocal_irq_enable();\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * Enter the idle state previously returned by the governor decision.\n\t * This function will block until an interrupt occurs and will take\n\t * care of re-enabling the local interrupts\n\t */\n\treturn cpuidle_enter(drv, dev, next_state);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};\n\nstatic int call_cpuidle(struct cpuidle_driver *drv, struct cpuidle_device *dev,\n\t\t      int next_state)\n{\n\t/*\n\t * The idle task must be scheduled, it is pointless to go to idle, just\n\t * update no idle residency and return.\n\t */\n\tif (current_clr_polling_and_test()) {\n\t\tdev->last_residency_ns = 0;\n\t\tlocal_irq_enable();\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * Enter the idle state previously returned by the governor decision.\n\t * This function will block until an interrupt occurs and will take\n\t * care of re-enabling the local interrupts\n\t */\n\treturn cpuidle_enter(drv, dev, next_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_idle_retain_tick",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_idle_retain_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1086-1094",
          "snippet": "void tick_nohz_idle_retain_tick(void)\n{\n\ttick_nohz_retain_tick(this_cpu_ptr(&tick_cpu_sched));\n\t/*\n\t * Undo the effect of get_next_timer_interrupt() called from\n\t * tick_nohz_next_event().\n\t */\n\ttimer_clear_idle();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_retain_tick(void)\n{\n\ttick_nohz_retain_tick(this_cpu_ptr(&tick_cpu_sched));\n\t/*\n\t * Undo the effect of get_next_timer_interrupt() called from\n\t * tick_nohz_next_event().\n\t */\n\ttimer_clear_idle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_idle_stop_tick",
          "args": [],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_idle_stop_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1081-1084",
          "snippet": "void tick_nohz_idle_stop_tick(void)\n{\n\t__tick_nohz_idle_stop_tick(this_cpu_ptr(&tick_cpu_sched));\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_stop_tick(void)\n{\n\t__tick_nohz_idle_stop_tick(this_cpu_ptr(&tick_cpu_sched));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_tick_stopped",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_tick_stopped",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "587-592",
          "snippet": "bool tick_nohz_tick_stopped(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->tick_stopped;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nbool tick_nohz_tick_stopped(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->tick_stopped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidle_select",
          "args": [
            "drv",
            "dev",
            "&stop_tick"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuidle_find_deepest_state",
          "args": [
            "drv",
            "dev",
            "max_latency_ns"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_cpuidle_s2idle",
          "args": [
            "drv",
            "dev"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "call_cpuidle_s2idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
          "lines": "131-138",
          "snippet": "static int call_cpuidle_s2idle(struct cpuidle_driver *drv,\n\t\t\t       struct cpuidle_device *dev)\n{\n\tif (current_clr_polling_and_test())\n\t\treturn -EBUSY;\n\n\treturn cpuidle_enter_s2idle(drv, dev);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic int call_cpuidle_s2idle(struct cpuidle_driver *drv,\n\t\t\t       struct cpuidle_device *dev)\n{\n\tif (current_clr_polling_and_test())\n\t\treturn -EBUSY;\n\n\treturn cpuidle_enter_s2idle(drv, dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idle_should_enter_s2idle",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_should_enter_s2idle",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_idle_call",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "default_idle_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
          "lines": "89-129",
          "snippet": "void __cpuidle default_idle_call(void)\n{\n\tif (current_clr_polling_and_test()) {\n\t\tlocal_irq_enable();\n\t} else {\n\n\t\ttrace_cpu_idle(1, smp_processor_id());\n\t\tstop_critical_timings();\n\n\t\t/*\n\t\t * arch_cpu_idle() is supposed to enable IRQs, however\n\t\t * we can't do that because of RCU and tracing.\n\t\t *\n\t\t * Trace IRQs enable here, then switch off RCU, and have\n\t\t * arch_cpu_idle() use raw_local_irq_enable(). Note that\n\t\t * rcu_idle_enter() relies on lockdep IRQ state, so switch that\n\t\t * last -- this is very similar to the entry code.\n\t\t */\n\t\ttrace_hardirqs_on_prepare();\n\t\tlockdep_hardirqs_on_prepare(_THIS_IP_);\n\t\trcu_idle_enter();\n\t\tlockdep_hardirqs_on(_THIS_IP_);\n\n\t\tarch_cpu_idle();\n\n\t\t/*\n\t\t * OK, so IRQs are enabled here, but RCU needs them disabled to\n\t\t * turn itself back on.. funny thing is that disabling IRQs\n\t\t * will cause tracing, which needs RCU. Jump through hoops to\n\t\t * make it 'work'.\n\t\t */\n\t\traw_local_irq_disable();\n\t\tlockdep_hardirqs_off(_THIS_IP_);\n\t\trcu_idle_exit();\n\t\tlockdep_hardirqs_on(_THIS_IP_);\n\t\traw_local_irq_enable();\n\n\t\tstart_critical_timings();\n\t\ttrace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());\n\t}\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __cpuidle default_idle_call(void)\n{\n\tif (current_clr_polling_and_test()) {\n\t\tlocal_irq_enable();\n\t} else {\n\n\t\ttrace_cpu_idle(1, smp_processor_id());\n\t\tstop_critical_timings();\n\n\t\t/*\n\t\t * arch_cpu_idle() is supposed to enable IRQs, however\n\t\t * we can't do that because of RCU and tracing.\n\t\t *\n\t\t * Trace IRQs enable here, then switch off RCU, and have\n\t\t * arch_cpu_idle() use raw_local_irq_enable(). Note that\n\t\t * rcu_idle_enter() relies on lockdep IRQ state, so switch that\n\t\t * last -- this is very similar to the entry code.\n\t\t */\n\t\ttrace_hardirqs_on_prepare();\n\t\tlockdep_hardirqs_on_prepare(_THIS_IP_);\n\t\trcu_idle_enter();\n\t\tlockdep_hardirqs_on(_THIS_IP_);\n\n\t\tarch_cpu_idle();\n\n\t\t/*\n\t\t * OK, so IRQs are enabled here, but RCU needs them disabled to\n\t\t * turn itself back on.. funny thing is that disabling IRQs\n\t\t * will cause tracing, which needs RCU. Jump through hoops to\n\t\t * make it 'work'.\n\t\t */\n\t\traw_local_irq_disable();\n\t\tlockdep_hardirqs_off(_THIS_IP_);\n\t\trcu_idle_exit();\n\t\tlockdep_hardirqs_on(_THIS_IP_);\n\t\traw_local_irq_enable();\n\n\t\tstart_critical_timings();\n\t\ttrace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidle_not_available",
          "args": [
            "drv",
            "dev"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuidle_get_cpu_driver",
          "args": [
            "dev"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuidle_get_device",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};\n\nstatic void cpuidle_idle_call(void)\n{\n\tstruct cpuidle_device *dev = cpuidle_get_device();\n\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);\n\tint next_state, entered_state;\n\n\t/*\n\t * Check if the idle task must be rescheduled. If it is the\n\t * case, exit the function after re-enabling the local irq.\n\t */\n\tif (need_resched()) {\n\t\tlocal_irq_enable();\n\t\treturn;\n\t}\n\n\t/*\n\t * The RCU framework needs to be told that we are entering an idle\n\t * section, so no more rcu read side critical sections and one more\n\t * step to the grace period\n\t */\n\n\tif (cpuidle_not_available(drv, dev)) {\n\t\ttick_nohz_idle_stop_tick();\n\n\t\tdefault_idle_call();\n\t\tgoto exit_idle;\n\t}\n\n\t/*\n\t * Suspend-to-idle (\"s2idle\") is a system state in which all user space\n\t * has been frozen, all I/O devices have been suspended and the only\n\t * activity happens here and in interrupts (if any). In that case bypass\n\t * the cpuidle governor and go straight for the deepest idle state\n\t * available.  Possibly also suspend the local tick and the entire\n\t * timekeeping to prevent timer interrupts from kicking us out of idle\n\t * until a proper wakeup interrupt happens.\n\t */\n\n\tif (idle_should_enter_s2idle() || dev->forced_idle_latency_limit_ns) {\n\t\tu64 max_latency_ns;\n\n\t\tif (idle_should_enter_s2idle()) {\n\n\t\t\tentered_state = call_cpuidle_s2idle(drv, dev);\n\t\t\tif (entered_state > 0)\n\t\t\t\tgoto exit_idle;\n\n\t\t\tmax_latency_ns = U64_MAX;\n\t\t} else {\n\t\t\tmax_latency_ns = dev->forced_idle_latency_limit_ns;\n\t\t}\n\n\t\ttick_nohz_idle_stop_tick();\n\n\t\tnext_state = cpuidle_find_deepest_state(drv, dev, max_latency_ns);\n\t\tcall_cpuidle(drv, dev, next_state);\n\t} else {\n\t\tbool stop_tick = true;\n\n\t\t/*\n\t\t * Ask the cpuidle framework to choose a convenient idle state.\n\t\t */\n\t\tnext_state = cpuidle_select(drv, dev, &stop_tick);\n\n\t\tif (stop_tick || tick_nohz_tick_stopped())\n\t\t\ttick_nohz_idle_stop_tick();\n\t\telse\n\t\t\ttick_nohz_idle_retain_tick();\n\n\t\tentered_state = call_cpuidle(drv, dev, next_state);\n\t\t/*\n\t\t * Give the governor an opportunity to reflect on the outcome\n\t\t */\n\t\tcpuidle_reflect(dev, entered_state);\n\t}\n\nexit_idle:\n\t__current_set_polling();\n\n\t/*\n\t * It is up to the idle functions to reenable local interrupts\n\t */\n\tif (WARN_ON_ONCE(irqs_disabled()))\n\t\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "call_cpuidle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "140-159",
    "snippet": "static int call_cpuidle(struct cpuidle_driver *drv, struct cpuidle_device *dev,\n\t\t      int next_state)\n{\n\t/*\n\t * The idle task must be scheduled, it is pointless to go to idle, just\n\t * update no idle residency and return.\n\t */\n\tif (current_clr_polling_and_test()) {\n\t\tdev->last_residency_ns = 0;\n\t\tlocal_irq_enable();\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * Enter the idle state previously returned by the governor decision.\n\t * This function will block until an interrupt occurs and will take\n\t * care of re-enabling the local interrupts\n\t */\n\treturn cpuidle_enter(drv, dev, next_state);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuidle_enter",
          "args": [
            "drv",
            "dev",
            "next_state"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_clr_polling_and_test",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(idle) = {\n\n\t/* no enqueue/yield_task for idle tasks */\n\n\t/* dequeue is not valid, we print a debug message there: */\n\t.dequeue_task\t\t= dequeue_task_idle,\n\n\t.check_preempt_curr\t= check_preempt_curr_idle,\n\n\t.pick_next_task\t\t= pick_next_task_idle,\n\t.put_prev_task\t\t= put_prev_task_idle,\n\t.set_next_task          = set_next_task_idle,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_idle,\n\t.pick_task\t\t= pick_task_idle,\n\t.select_task_rq\t\t= select_task_rq_idle,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_idle,\n\n\t.prio_changed\t\t= prio_changed_idle,\n\t.switched_to\t\t= switched_to_idle,\n\t.update_curr\t\t= update_curr_idle,\n};\n\nstatic int call_cpuidle(struct cpuidle_driver *drv, struct cpuidle_device *dev,\n\t\t      int next_state)\n{\n\t/*\n\t * The idle task must be scheduled, it is pointless to go to idle, just\n\t * update no idle residency and return.\n\t */\n\tif (current_clr_polling_and_test()) {\n\t\tdev->last_residency_ns = 0;\n\t\tlocal_irq_enable();\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * Enter the idle state previously returned by the governor decision.\n\t * This function will block until an interrupt occurs and will take\n\t * care of re-enabling the local interrupts\n\t */\n\treturn cpuidle_enter(drv, dev, next_state);\n}"
  },
  {
    "function_name": "call_cpuidle_s2idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "131-138",
    "snippet": "static int call_cpuidle_s2idle(struct cpuidle_driver *drv,\n\t\t\t       struct cpuidle_device *dev)\n{\n\tif (current_clr_polling_and_test())\n\t\treturn -EBUSY;\n\n\treturn cpuidle_enter_s2idle(drv, dev);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuidle_enter_s2idle",
          "args": [
            "drv",
            "dev"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_clr_polling_and_test",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic int call_cpuidle_s2idle(struct cpuidle_driver *drv,\n\t\t\t       struct cpuidle_device *dev)\n{\n\tif (current_clr_polling_and_test())\n\t\treturn -EBUSY;\n\n\treturn cpuidle_enter_s2idle(drv, dev);\n}"
  },
  {
    "function_name": "default_idle_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "89-129",
    "snippet": "void __cpuidle default_idle_call(void)\n{\n\tif (current_clr_polling_and_test()) {\n\t\tlocal_irq_enable();\n\t} else {\n\n\t\ttrace_cpu_idle(1, smp_processor_id());\n\t\tstop_critical_timings();\n\n\t\t/*\n\t\t * arch_cpu_idle() is supposed to enable IRQs, however\n\t\t * we can't do that because of RCU and tracing.\n\t\t *\n\t\t * Trace IRQs enable here, then switch off RCU, and have\n\t\t * arch_cpu_idle() use raw_local_irq_enable(). Note that\n\t\t * rcu_idle_enter() relies on lockdep IRQ state, so switch that\n\t\t * last -- this is very similar to the entry code.\n\t\t */\n\t\ttrace_hardirqs_on_prepare();\n\t\tlockdep_hardirqs_on_prepare(_THIS_IP_);\n\t\trcu_idle_enter();\n\t\tlockdep_hardirqs_on(_THIS_IP_);\n\n\t\tarch_cpu_idle();\n\n\t\t/*\n\t\t * OK, so IRQs are enabled here, but RCU needs them disabled to\n\t\t * turn itself back on.. funny thing is that disabling IRQs\n\t\t * will cause tracing, which needs RCU. Jump through hoops to\n\t\t * make it 'work'.\n\t\t */\n\t\traw_local_irq_disable();\n\t\tlockdep_hardirqs_off(_THIS_IP_);\n\t\trcu_idle_exit();\n\t\tlockdep_hardirqs_on(_THIS_IP_);\n\t\traw_local_irq_enable();\n\n\t\tstart_critical_timings();\n\t\ttrace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());\n\t}\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_cpu_idle",
          "args": [
            "PWR_EVENT_EXIT",
            "smp_processor_id()"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_critical_timings",
          "args": [],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "start_critical_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "437-441",
          "snippet": "void start_critical_timings(void)\n{\n\tif (preempt_trace(preempt_count()) || irq_trace())\n\t\tstart_critical_timing(CALLER_ADDR0, CALLER_ADDR1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid start_critical_timings(void)\n{\n\tif (preempt_trace(preempt_count()) || irq_trace())\n\t\tstart_critical_timing(CALLER_ADDR0, CALLER_ADDR1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_enable",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_on",
          "args": [
            "_THIS_IP_"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4297-4358",
          "snippet": "void noinstr lockdep_hardirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs can happen in the middle of local_irq_{en,dis}able() where the\n\t * tracking state and hardware state are out of sync.\n\t *\n\t * NMIs must save lockdep_hardirqs_enabled() to restore IRQ state from,\n\t * and not rely on hardware state like normal interrupts.\n\t */\n\tif (unlikely(in_nmi())) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Skip:\n\t\t *  - recursion check, because NMI can hit lockdep;\n\t\t *  - hardware state check, because above;\n\t\t *  - chain_key check, see lockdep_hardirqs_on_prepare().\n\t\t */\n\t\tgoto skip_checks;\n\t}\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * Ensure the lock stack remained unchanged between\n\t * lockdep_hardirqs_on_prepare() and lockdep_hardirqs_on().\n\t */\n\tDEBUG_LOCKS_WARN_ON(current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key);\n\nskip_checks:\n\t/* we'll do an OFF -> ON transition: */\n\t__this_cpu_write(hardirqs_enabled, 1);\n\ttrace->hardirq_enable_ip = ip;\n\ttrace->hardirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid noinstr lockdep_hardirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs can happen in the middle of local_irq_{en,dis}able() where the\n\t * tracking state and hardware state are out of sync.\n\t *\n\t * NMIs must save lockdep_hardirqs_enabled() to restore IRQ state from,\n\t * and not rely on hardware state like normal interrupts.\n\t */\n\tif (unlikely(in_nmi())) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Skip:\n\t\t *  - recursion check, because NMI can hit lockdep;\n\t\t *  - hardware state check, because above;\n\t\t *  - chain_key check, see lockdep_hardirqs_on_prepare().\n\t\t */\n\t\tgoto skip_checks;\n\t}\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * Ensure the lock stack remained unchanged between\n\t * lockdep_hardirqs_on_prepare() and lockdep_hardirqs_on().\n\t */\n\tDEBUG_LOCKS_WARN_ON(current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key);\n\nskip_checks:\n\t/* we'll do an OFF -> ON transition: */\n\t__this_cpu_write(hardirqs_enabled, 1);\n\ttrace->hardirq_enable_ip = ip;\n\ttrace->hardirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_idle_exit",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_idle_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "888-895",
          "snippet": "void rcu_idle_exit(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_eqs_exit(false);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcu_idle_exit(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_eqs_exit(false);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_off",
          "args": [
            "_THIS_IP_"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4364-4400",
          "snippet": "void noinstr lockdep_hardirqs_off(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * Matching lockdep_hardirqs_on(), allow NMIs in the middle of lockdep;\n\t * they will restore the software state. This ensures the software\n\t * state is consistent inside NMIs as well.\n\t */\n\tif (in_nmi()) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\t} else if (__this_cpu_read(lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\t__this_cpu_write(hardirqs_enabled, 0);\n\t\ttrace->hardirq_disable_ip = ip;\n\t\ttrace->hardirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else {\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid noinstr lockdep_hardirqs_off(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * Matching lockdep_hardirqs_on(), allow NMIs in the middle of lockdep;\n\t * they will restore the software state. This ensures the software\n\t * state is consistent inside NMIs as well.\n\t */\n\tif (in_nmi()) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\t} else if (__this_cpu_read(lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\t__this_cpu_write(hardirqs_enabled, 0);\n\t\ttrace->hardirq_disable_ip = ip;\n\t\ttrace->hardirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else {\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_local_irq_disable",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_cpu_idle",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "arch_cpu_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
          "lines": "78-82",
          "snippet": "void __weak arch_cpu_idle(void)\n{\n\tcpu_idle_force_poll = 1;\n\traw_local_irq_enable();\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle(void)\n{\n\tcpu_idle_force_poll = 1;\n\traw_local_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_idle_enter",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_idle_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "651-655",
          "snippet": "void rcu_idle_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(false);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_idle_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_on_prepare",
          "args": [
            "_THIS_IP_"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_on_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4244-4294",
          "snippet": "void lockdep_hardirqs_on_prepare(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs do not (and cannot) track lock dependencies, nothing to do.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (unlikely(lockdep_hardirqs_enabled())) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(early_boot_irqs_disabled))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirq_context()))\n\t\treturn;\n\n\tcurrent->hardirq_chain_key = current->curr_chain_key;\n\n\tlockdep_recursion_inc();\n\t__trace_hardirqs_on_caller();\n\tlockdep_recursion_finish();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_hardirqs_on_prepare(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs do not (and cannot) track lock dependencies, nothing to do.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (unlikely(lockdep_hardirqs_enabled())) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(early_boot_irqs_disabled))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirq_context()))\n\t\treturn;\n\n\tcurrent->hardirq_chain_key = current->curr_chain_key;\n\n\tlockdep_recursion_inc();\n\t__trace_hardirqs_on_caller();\n\tlockdep_recursion_finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_on_prepare",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "trace_hardirqs_on_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
          "lines": "28-36",
          "snippet": "void trace_hardirqs_on_prepare(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_hardirqs_on_prepare(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_critical_timings",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "stop_critical_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "445-449",
          "snippet": "void stop_critical_timings(void)\n{\n\tif (preempt_trace(preempt_count()) || irq_trace())\n\t\tstop_critical_timing(CALLER_ADDR0, CALLER_ADDR1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid stop_critical_timings(void)\n{\n\tif (preempt_trace(preempt_count()) || irq_trace())\n\t\tstop_critical_timing(CALLER_ADDR0, CALLER_ADDR1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_cpu_idle",
          "args": [
            "1",
            "smp_processor_id()"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_clr_polling_and_test",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __cpuidle default_idle_call(void)\n{\n\tif (current_clr_polling_and_test()) {\n\t\tlocal_irq_enable();\n\t} else {\n\n\t\ttrace_cpu_idle(1, smp_processor_id());\n\t\tstop_critical_timings();\n\n\t\t/*\n\t\t * arch_cpu_idle() is supposed to enable IRQs, however\n\t\t * we can't do that because of RCU and tracing.\n\t\t *\n\t\t * Trace IRQs enable here, then switch off RCU, and have\n\t\t * arch_cpu_idle() use raw_local_irq_enable(). Note that\n\t\t * rcu_idle_enter() relies on lockdep IRQ state, so switch that\n\t\t * last -- this is very similar to the entry code.\n\t\t */\n\t\ttrace_hardirqs_on_prepare();\n\t\tlockdep_hardirqs_on_prepare(_THIS_IP_);\n\t\trcu_idle_enter();\n\t\tlockdep_hardirqs_on(_THIS_IP_);\n\n\t\tarch_cpu_idle();\n\n\t\t/*\n\t\t * OK, so IRQs are enabled here, but RCU needs them disabled to\n\t\t * turn itself back on.. funny thing is that disabling IRQs\n\t\t * will cause tracing, which needs RCU. Jump through hoops to\n\t\t * make it 'work'.\n\t\t */\n\t\traw_local_irq_disable();\n\t\tlockdep_hardirqs_off(_THIS_IP_);\n\t\trcu_idle_exit();\n\t\tlockdep_hardirqs_on(_THIS_IP_);\n\t\traw_local_irq_enable();\n\n\t\tstart_critical_timings();\n\t\ttrace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());\n\t}\n}"
  },
  {
    "function_name": "arch_cpu_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "78-82",
    "snippet": "void __weak arch_cpu_idle(void)\n{\n\tcpu_idle_force_poll = 1;\n\traw_local_irq_enable();\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_enable",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle(void)\n{\n\tcpu_idle_force_poll = 1;\n\traw_local_irq_enable();\n}"
  },
  {
    "function_name": "arch_cpu_idle_dead",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "77-77",
    "snippet": "void __weak arch_cpu_idle_dead(void) { }",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_dead(void) { }"
  },
  {
    "function_name": "arch_cpu_idle_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "76-76",
    "snippet": "void __weak arch_cpu_idle_exit(void) { }",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_exit(void) { }"
  },
  {
    "function_name": "arch_cpu_idle_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "75-75",
    "snippet": "void __weak arch_cpu_idle_enter(void) { }",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_enter(void) { }"
  },
  {
    "function_name": "arch_cpu_idle_prepare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "74-74",
    "snippet": "void __weak arch_cpu_idle_prepare(void) { }",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_prepare(void) { }"
  },
  {
    "function_name": "cpu_idle_poll",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "55-71",
    "snippet": "__cpuidle cpu_idle_poll(void)\n{\n\ttrace_cpu_idle(0, smp_processor_id());\n\tstop_critical_timings();\n\trcu_idle_enter();\n\tlocal_irq_enable();\n\n\twhile (!tif_need_resched() &&\n\t       (cpu_idle_force_poll || tick_check_broadcast_expired()))\n\t\tcpu_relax();\n\n\trcu_idle_exit();\n\tstart_critical_timings();\n\ttrace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());\n\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_cpu_idle",
          "args": [
            "PWR_EVENT_EXIT",
            "smp_processor_id()"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_critical_timings",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "start_critical_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "437-441",
          "snippet": "void start_critical_timings(void)\n{\n\tif (preempt_trace(preempt_count()) || irq_trace())\n\t\tstart_critical_timing(CALLER_ADDR0, CALLER_ADDR1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid start_critical_timings(void)\n{\n\tif (preempt_trace(preempt_count()) || irq_trace())\n\t\tstart_critical_timing(CALLER_ADDR0, CALLER_ADDR1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_idle_exit",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_idle_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "888-895",
          "snippet": "void rcu_idle_exit(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_eqs_exit(false);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcu_idle_exit(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_eqs_exit(false);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_check_broadcast_expired",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_broadcast_expired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "625-628",
          "snippet": "int tick_check_broadcast_expired(void)\n{\n\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_force_mask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_check_broadcast_expired(void)\n{\n\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_force_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tif_need_resched",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_idle_enter",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_idle_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "651-655",
          "snippet": "void rcu_idle_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(false);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_idle_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_critical_timings",
          "args": [],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "stop_critical_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "445-449",
          "snippet": "void stop_critical_timings(void)\n{\n\tif (preempt_trace(preempt_count()) || irq_trace())\n\t\tstop_critical_timing(CALLER_ADDR0, CALLER_ADDR1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid stop_critical_timings(void)\n{\n\tif (preempt_trace(preempt_count()) || irq_trace())\n\t\tstop_critical_timing(CALLER_ADDR0, CALLER_ADDR1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_cpu_idle",
          "args": [
            "0",
            "smp_processor_id()"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\n__cpuidle cpu_idle_poll(void)\n{\n\ttrace_cpu_idle(0, smp_processor_id());\n\tstop_critical_timings();\n\trcu_idle_enter();\n\tlocal_irq_enable();\n\n\twhile (!tif_need_resched() &&\n\t       (cpu_idle_force_poll || tick_check_broadcast_expired()))\n\t\tcpu_relax();\n\n\trcu_idle_exit();\n\tstart_critical_timings();\n\ttrace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());\n\n\treturn 1;\n}"
  },
  {
    "function_name": "cpu_idle_nopoll_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "46-51",
    "snippet": "static int __init cpu_idle_nopoll_setup(char *__unused)\n{\n\tcpu_idle_force_poll = 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic int __init cpu_idle_nopoll_setup(char *__unused)\n{\n\tcpu_idle_force_poll = 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "cpu_idle_poll_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "38-43",
    "snippet": "static int __init cpu_idle_poll_setup(char *__unused)\n{\n\tcpu_idle_force_poll = 1;\n\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic int __init cpu_idle_poll_setup(char *__unused)\n{\n\tcpu_idle_force_poll = 1;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "cpu_idle_poll_ctrl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "27-35",
    "snippet": "void cpu_idle_poll_ctrl(bool enable)\n{\n\tif (enable) {\n\t\tcpu_idle_force_poll++;\n\t} else {\n\t\tcpu_idle_force_poll--;\n\t\tWARN_ON_ONCE(cpu_idle_force_poll < 0);\n\t}\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu_idle_force_poll < 0"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid cpu_idle_poll_ctrl(bool enable)\n{\n\tif (enable) {\n\t\tcpu_idle_force_poll++;\n\t} else {\n\t\tcpu_idle_force_poll--;\n\t\tWARN_ON_ONCE(cpu_idle_force_poll < 0);\n\t}\n}"
  },
  {
    "function_name": "sched_idle_set_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/idle.c",
    "lines": "20-23",
    "snippet": "void sched_idle_set_state(struct cpuidle_state *idle_state)\n{\n\tidle_set_state(this_rq(), idle_state);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "idle_set_state",
          "args": [
            "this_rq()",
            "idle_state"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "idle_set_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2305-2308",
          "snippet": "static inline void idle_set_state(struct rq *rq,\n\t\t\t\t  struct cpuidle_state *idle_state)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void idle_set_state(struct rq *rq,\n\t\t\t\t  struct cpuidle_state *idle_state)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid sched_idle_set_state(struct cpuidle_state *idle_state)\n{\n\tidle_set_state(this_rq(), idle_state);\n}"
  }
]