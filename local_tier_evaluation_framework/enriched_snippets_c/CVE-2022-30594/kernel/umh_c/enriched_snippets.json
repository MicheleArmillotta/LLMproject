[
  {
    "function_name": "proc_cap_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "488-546",
    "snippet": "static int proc_cap_handler(struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tunsigned long cap_array[_KERNEL_CAPABILITY_U32S];\n\tkernel_cap_t new_cap;\n\tint err, i;\n\n\tif (write && (!capable(CAP_SETPCAP) ||\n\t\t      !capable(CAP_SYS_MODULE)))\n\t\treturn -EPERM;\n\n\t/*\n\t * convert from the global kernel_cap_t to the ulong array to print to\n\t * userspace if this is a read.\n\t */\n\tspin_lock(&umh_sysctl_lock);\n\tfor (i = 0; i < _KERNEL_CAPABILITY_U32S; i++)  {\n\t\tif (table->data == CAP_BSET)\n\t\t\tcap_array[i] = usermodehelper_bset.cap[i];\n\t\telse if (table->data == CAP_PI)\n\t\t\tcap_array[i] = usermodehelper_inheritable.cap[i];\n\t\telse\n\t\t\tBUG();\n\t}\n\tspin_unlock(&umh_sysctl_lock);\n\n\tt = *table;\n\tt.data = &cap_array;\n\n\t/*\n\t * actually read or write and array of ulongs from userspace.  Remember\n\t * these are least significant 32 bits first\n\t */\n\terr = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * convert from the sysctl array of ulongs to the kernel_cap_t\n\t * internal representation\n\t */\n\tfor (i = 0; i < _KERNEL_CAPABILITY_U32S; i++)\n\t\tnew_cap.cap[i] = cap_array[i];\n\n\t/*\n\t * Drop everything not in the new_cap (but don't add things)\n\t */\n\tif (write) {\n\t\tspin_lock(&umh_sysctl_lock);\n\t\tif (table->data == CAP_BSET)\n\t\t\tusermodehelper_bset = cap_intersect(usermodehelper_bset, new_cap);\n\t\tif (table->data == CAP_PI)\n\t\t\tusermodehelper_inheritable = cap_intersect(usermodehelper_inheritable, new_cap);\n\t\tspin_unlock(&umh_sysctl_lock);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define CAP_PI\t\t(void *)2",
      "#define CAP_BSET\t(void *)1"
    ],
    "globals_used": [
      "static kernel_cap_t usermodehelper_bset = CAP_FULL_SET;",
      "static kernel_cap_t usermodehelper_inheritable = CAP_FULL_SET;",
      "static DEFINE_SPINLOCK(umh_sysctl_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&umh_sysctl_lock"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_intersect",
          "args": [
            "usermodehelper_inheritable",
            "new_cap"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_intersect",
          "args": [
            "usermodehelper_bset",
            "new_cap"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&umh_sysctl_lock"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_doulongvec_minmax",
          "args": [
            "&t",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "proc_doulongvec_minmax",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "1603-1607",
          "snippet": "int proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nint proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_MODULE"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CAP_PI\t\t(void *)2\n#define CAP_BSET\t(void *)1\n\nstatic kernel_cap_t usermodehelper_bset = CAP_FULL_SET;\nstatic kernel_cap_t usermodehelper_inheritable = CAP_FULL_SET;\nstatic DEFINE_SPINLOCK(umh_sysctl_lock);\n\nstatic int proc_cap_handler(struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tunsigned long cap_array[_KERNEL_CAPABILITY_U32S];\n\tkernel_cap_t new_cap;\n\tint err, i;\n\n\tif (write && (!capable(CAP_SETPCAP) ||\n\t\t      !capable(CAP_SYS_MODULE)))\n\t\treturn -EPERM;\n\n\t/*\n\t * convert from the global kernel_cap_t to the ulong array to print to\n\t * userspace if this is a read.\n\t */\n\tspin_lock(&umh_sysctl_lock);\n\tfor (i = 0; i < _KERNEL_CAPABILITY_U32S; i++)  {\n\t\tif (table->data == CAP_BSET)\n\t\t\tcap_array[i] = usermodehelper_bset.cap[i];\n\t\telse if (table->data == CAP_PI)\n\t\t\tcap_array[i] = usermodehelper_inheritable.cap[i];\n\t\telse\n\t\t\tBUG();\n\t}\n\tspin_unlock(&umh_sysctl_lock);\n\n\tt = *table;\n\tt.data = &cap_array;\n\n\t/*\n\t * actually read or write and array of ulongs from userspace.  Remember\n\t * these are least significant 32 bits first\n\t */\n\terr = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * convert from the sysctl array of ulongs to the kernel_cap_t\n\t * internal representation\n\t */\n\tfor (i = 0; i < _KERNEL_CAPABILITY_U32S; i++)\n\t\tnew_cap.cap[i] = cap_array[i];\n\n\t/*\n\t * Drop everything not in the new_cap (but don't add things)\n\t */\n\tif (write) {\n\t\tspin_lock(&umh_sysctl_lock);\n\t\tif (table->data == CAP_BSET)\n\t\t\tusermodehelper_bset = cap_intersect(usermodehelper_bset, new_cap);\n\t\tif (table->data == CAP_PI)\n\t\t\tusermodehelper_inheritable = cap_intersect(usermodehelper_inheritable, new_cap);\n\t\tspin_unlock(&umh_sysctl_lock);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "call_usermodehelper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "474-485",
    "snippet": "int call_usermodehelper(const char *path, char **argv, char **envp, int wait)\n{\n\tstruct subprocess_info *info;\n\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask,\n\t\t\t\t\t NULL, NULL, NULL);\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\n\treturn call_usermodehelper_exec(info, wait);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_usermodehelper_exec",
          "args": [
            "info",
            "wait"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_exec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "404-458",
          "snippet": "int call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is no binary for us to call, then just return and get out of\n\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and\n\t * disable all call_usermodehelper() calls.\n\t */\n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t/*\n\t * Set the completion pointer only if there is a waiter.\n\t * This makes it possible to use umh_complete to free\n\t * the data structure in case of UMH_NO_WAIT.\n\t */\n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_killable(&done);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t/* umh_complete() will see NULL and free sub_info */\n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\t\t/* fallthrough, umh_complete() was already called */\n\t}\n\n\twait_for_completion(&done);\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\n\nint call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is no binary for us to call, then just return and get out of\n\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and\n\t * disable all call_usermodehelper() calls.\n\t */\n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t/*\n\t * Set the completion pointer only if there is a waiter.\n\t * This makes it possible to use umh_complete to free\n\t * the data structure in case of UMH_NO_WAIT.\n\t */\n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_killable(&done);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t/* umh_complete() will see NULL and free sub_info */\n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\t\t/* fallthrough, umh_complete() was already called */\n\t}\n\n\twait_for_completion(&done);\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_usermodehelper_setup",
          "args": [
            "path",
            "argv",
            "envp",
            "gfp_mask",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "358-384",
          "snippet": "struct subprocess_info *call_usermodehelper_setup(const char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\n#ifdef CONFIG_STATIC_USERMODEHELPER\n\tsub_info->path = CONFIG_STATIC_USERMODEHELPER_PATH;\n#else\n\tsub_info->path = path;\n#endif\n\tsub_info->argv = argv;\n\tsub_info->envp = envp;\n\n\tsub_info->cleanup = cleanup;\n\tsub_info->init = init;\n\tsub_info->data = data;\n  out:\n\treturn sub_info;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct subprocess_info *call_usermodehelper_setup(const char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\n#ifdef CONFIG_STATIC_USERMODEHELPER\n\tsub_info->path = CONFIG_STATIC_USERMODEHELPER_PATH;\n#else\n\tsub_info->path = path;\n#endif\n\tsub_info->argv = argv;\n\tsub_info->envp = envp;\n\n\tsub_info->cleanup = cleanup;\n\tsub_info->init = init;\n\tsub_info->data = data;\n  out:\n\treturn sub_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nint call_usermodehelper(const char *path, char **argv, char **envp, int wait)\n{\n\tstruct subprocess_info *info;\n\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask,\n\t\t\t\t\t NULL, NULL, NULL);\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\n\treturn call_usermodehelper_exec(info, wait);\n}"
  },
  {
    "function_name": "call_usermodehelper_exec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "404-458",
    "snippet": "int call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is no binary for us to call, then just return and get out of\n\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and\n\t * disable all call_usermodehelper() calls.\n\t */\n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t/*\n\t * Set the completion pointer only if there is a waiter.\n\t * This makes it possible to use umh_complete to free\n\t * the data structure in case of UMH_NO_WAIT.\n\t */\n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_killable(&done);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t/* umh_complete() will see NULL and free sub_info */\n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\t\t/* fallthrough, umh_complete() was already called */\n\t}\n\n\twait_for_completion(&done);\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "helper_unlock",
          "args": [],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "helper_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "329-333",
          "snippet": "static void helper_unlock(void)\n{\n\tif (atomic_dec_and_test(&running_helpers))\n\t\twake_up(&running_helpers_waitq);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t running_helpers = ATOMIC_INIT(0);",
            "static DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic atomic_t running_helpers = ATOMIC_INIT(0);\nstatic DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);\n\nstatic void helper_unlock(void)\n{\n\tif (atomic_dec_and_test(&running_helpers))\n\t\twake_up(&running_helpers_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_usermodehelper_freeinfo",
          "args": [
            "sub_info"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_freeinfo",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "42-47",
          "snippet": "static void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&done"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&sub_info->complete",
            "NULL"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion_killable",
          "args": [
            "&done"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_completion_killable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "241-247",
          "snippet": "int __sched wait_for_completion_killable(struct completion *x)\n{\n\tlong t = wait_for_common(x, MAX_SCHEDULE_TIMEOUT, TASK_KILLABLE);\n\tif (t == -ERESTARTSYS)\n\t\treturn t;\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint __sched wait_for_completion_killable(struct completion *x)\n{\n\tlong t = wait_for_common(x, MAX_SCHEDULE_TIMEOUT, TASK_KILLABLE);\n\tif (t == -ERESTARTSYS)\n\t\treturn t;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "system_unbound_wq",
            "&sub_info->work"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sub_info->path"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "helper_lock",
          "args": [],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "helper_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "323-327",
          "snippet": "static void helper_lock(void)\n{\n\tatomic_inc(&running_helpers);\n\tsmp_mb__after_atomic();\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t running_helpers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic atomic_t running_helpers = ATOMIC_INIT(0);\n\nstatic void helper_lock(void)\n{\n\tatomic_inc(&running_helpers);\n\tsmp_mb__after_atomic();\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_COMPLETION_ONSTACK",
          "args": [
            "done"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\n\nint call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is no binary for us to call, then just return and get out of\n\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and\n\t * disable all call_usermodehelper() calls.\n\t */\n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t/*\n\t * Set the completion pointer only if there is a waiter.\n\t * This makes it possible to use umh_complete to free\n\t * the data structure in case of UMH_NO_WAIT.\n\t */\n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_killable(&done);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t/* umh_complete() will see NULL and free sub_info */\n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\t\t/* fallthrough, umh_complete() was already called */\n\t}\n\n\twait_for_completion(&done);\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}"
  },
  {
    "function_name": "call_usermodehelper_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "358-384",
    "snippet": "struct subprocess_info *call_usermodehelper_setup(const char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\n#ifdef CONFIG_STATIC_USERMODEHELPER\n\tsub_info->path = CONFIG_STATIC_USERMODEHELPER_PATH;\n#else\n\tsub_info->path = path;\n#endif\n\tsub_info->argv = argv;\n\tsub_info->envp = envp;\n\n\tsub_info->cleanup = cleanup;\n\tsub_info->init = init;\n\tsub_info->data = data;\n  out:\n\treturn sub_info;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&sub_info->work",
            "call_usermodehelper_exec_work"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct subprocess_info)",
            "gfp_mask"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct subprocess_info *call_usermodehelper_setup(const char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\n#ifdef CONFIG_STATIC_USERMODEHELPER\n\tsub_info->path = CONFIG_STATIC_USERMODEHELPER_PATH;\n#else\n\tsub_info->path = path;\n#endif\n\tsub_info->argv = argv;\n\tsub_info->envp = envp;\n\n\tsub_info->cleanup = cleanup;\n\tsub_info->init = init;\n\tsub_info->data = data;\n  out:\n\treturn sub_info;\n}"
  },
  {
    "function_name": "helper_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "329-333",
    "snippet": "static void helper_unlock(void)\n{\n\tif (atomic_dec_and_test(&running_helpers))\n\t\twake_up(&running_helpers_waitq);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t running_helpers = ATOMIC_INIT(0);",
      "static DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&running_helpers_waitq"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&running_helpers"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic atomic_t running_helpers = ATOMIC_INIT(0);\nstatic DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);\n\nstatic void helper_unlock(void)\n{\n\tif (atomic_dec_and_test(&running_helpers))\n\t\twake_up(&running_helpers_waitq);\n}"
  },
  {
    "function_name": "helper_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "323-327",
    "snippet": "static void helper_lock(void)\n{\n\tatomic_inc(&running_helpers);\n\tsmp_mb__after_atomic();\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t running_helpers = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&running_helpers"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic atomic_t running_helpers = ATOMIC_INIT(0);\n\nstatic void helper_lock(void)\n{\n\tatomic_inc(&running_helpers);\n\tsmp_mb__after_atomic();\n}"
  },
  {
    "function_name": "__usermodehelper_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "296-321",
    "snippet": "int __usermodehelper_disable(enum umh_disable_depth depth)\n{\n\tlong retval;\n\n\tif (!depth)\n\t\treturn -EINVAL;\n\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\tup_write(&umhelper_sem);\n\n\t/*\n\t * From now on call_usermodehelper_exec() won't start any new\n\t * helpers, so it is sufficient if running_helpers turns out to\n\t * be zero at one point (it may be increased later, but that\n\t * doesn't matter).\n\t */\n\tretval = wait_event_timeout(running_helpers_waitq,\n\t\t\t\t\tatomic_read(&running_helpers) == 0,\n\t\t\t\t\tRUNNING_HELPERS_TIMEOUT);\n\tif (retval)\n\t\treturn 0;\n\n\t__usermodehelper_set_disable_depth(UMH_ENABLED);\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RUNNING_HELPERS_TIMEOUT\t(5 * HZ)"
    ],
    "globals_used": [
      "static DECLARE_RWSEM(umhelper_sem);",
      "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
      "static atomic_t running_helpers = ATOMIC_INIT(0);",
      "static DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__usermodehelper_set_disable_depth",
          "args": [
            "UMH_ENABLED"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "__usermodehelper_set_disable_depth",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "282-288",
          "snippet": "void __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nvoid __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_timeout",
          "args": [
            "running_helpers_waitq",
            "atomic_read(&running_helpers) == 0",
            "RUNNING_HELPERS_TIMEOUT"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&running_helpers"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&umhelper_sem"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&umhelper_sem"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define RUNNING_HELPERS_TIMEOUT\t(5 * HZ)\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic atomic_t running_helpers = ATOMIC_INIT(0);\nstatic DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);\n\nint __usermodehelper_disable(enum umh_disable_depth depth)\n{\n\tlong retval;\n\n\tif (!depth)\n\t\treturn -EINVAL;\n\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\tup_write(&umhelper_sem);\n\n\t/*\n\t * From now on call_usermodehelper_exec() won't start any new\n\t * helpers, so it is sufficient if running_helpers turns out to\n\t * be zero at one point (it may be increased later, but that\n\t * doesn't matter).\n\t */\n\tretval = wait_event_timeout(running_helpers_waitq,\n\t\t\t\t\tatomic_read(&running_helpers) == 0,\n\t\t\t\t\tRUNNING_HELPERS_TIMEOUT);\n\tif (retval)\n\t\treturn 0;\n\n\t__usermodehelper_set_disable_depth(UMH_ENABLED);\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "__usermodehelper_set_disable_depth",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "282-288",
    "snippet": "void __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(umhelper_sem);",
      "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
      "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&umhelper_sem"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&usermodehelper_disabled_waitq"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&umhelper_sem"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nvoid __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}"
  },
  {
    "function_name": "usermodehelper_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "269-272",
    "snippet": "void usermodehelper_read_unlock(void)\n{\n\tup_read(&umhelper_sem);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(umhelper_sem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&umhelper_sem"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\n\nvoid usermodehelper_read_unlock(void)\n{\n\tup_read(&umhelper_sem);\n}"
  },
  {
    "function_name": "usermodehelper_read_lock_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "242-266",
    "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(umhelper_sem);",
      "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
      "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&usermodehelper_disabled_waitq",
            "&wait"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "finish_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "388-411",
          "snippet": "void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&umhelper_sem"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "timeout"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_timeout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8396-8406",
          "snippet": "long __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nlong __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&umhelper_sem"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&usermodehelper_disabled_waitq",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_to_wait_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "302-335",
          "snippet": "long prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (signal_pending_state(state, current)) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nlong prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (signal_pending_state(state, current)) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
  },
  {
    "function_name": "usermodehelper_read_trylock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "212-239",
    "snippet": "int usermodehelper_read_trylock(void)\n{\n\tDEFINE_WAIT(wait);\n\tint ret = 0;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tif (usermodehelper_disabled == UMH_DISABLED)\n\t\t\tret = -EAGAIN;\n\n\t\tup_read(&umhelper_sem);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tschedule();\n\t\ttry_to_freeze();\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(umhelper_sem);",
      "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
      "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&usermodehelper_disabled_waitq",
            "&wait"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "finish_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "388-411",
          "snippet": "void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&umhelper_sem"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&umhelper_sem"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&usermodehelper_disabled_waitq",
            "&wait",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_to_wait_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "302-335",
          "snippet": "long prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (signal_pending_state(state, current)) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nlong prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (signal_pending_state(state, current)) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nint usermodehelper_read_trylock(void)\n{\n\tDEFINE_WAIT(wait);\n\tint ret = 0;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tif (usermodehelper_disabled == UMH_DISABLED)\n\t\t\tret = -EAGAIN;\n\n\t\tup_read(&umhelper_sem);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tschedule();\n\t\ttry_to_freeze();\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn ret;\n}"
  },
  {
    "function_name": "call_usermodehelper_exec_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "160-181",
    "snippet": "static void call_usermodehelper_exec_work(struct work_struct *work)\n{\n\tstruct subprocess_info *sub_info =\n\t\tcontainer_of(work, struct subprocess_info, work);\n\n\tif (sub_info->wait & UMH_WAIT_PROC) {\n\t\tcall_usermodehelper_exec_sync(sub_info);\n\t} else {\n\t\tpid_t pid;\n\t\t/*\n\t\t * Use CLONE_PARENT to reparent it to kthreadd; we do not\n\t\t * want to pollute current->children, and we need a parent\n\t\t * that always ignores SIGCHLD to ensure auto-reaping.\n\t\t */\n\t\tpid = kernel_thread(call_usermodehelper_exec_async, sub_info,\n\t\t\t\t    CLONE_PARENT | SIGCHLD);\n\t\tif (pid < 0) {\n\t\t\tsub_info->retval = pid;\n\t\t\tumh_complete(sub_info);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umh_complete",
          "args": [
            "sub_info"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "umh_complete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "49-61",
          "snippet": "static void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_thread",
          "args": [
            "call_usermodehelper_exec_async",
            "sub_info",
            "CLONE_PARENT | SIGCHLD"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "2597-2608",
          "snippet": "pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |\n\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),\n\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),\n\t\t.stack\t\t= (unsigned long)fn,\n\t\t.stack_size\t= (unsigned long)arg,\n\t};\n\n\treturn kernel_clone(&args);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\npid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |\n\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),\n\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),\n\t\t.stack\t\t= (unsigned long)fn,\n\t\t.stack_size\t= (unsigned long)arg,\n\t};\n\n\treturn kernel_clone(&args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_usermodehelper_exec_sync",
          "args": [
            "sub_info"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_exec_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "129-144",
          "snippet": "static void call_usermodehelper_exec_sync(struct subprocess_info *sub_info)\n{\n\tpid_t pid;\n\n\t/* If SIGCLD is ignored do_wait won't populate the status. */\n\tkernel_sigaction(SIGCHLD, SIG_DFL);\n\tpid = kernel_thread(call_usermodehelper_exec_async, sub_info, SIGCHLD);\n\tif (pid < 0)\n\t\tsub_info->retval = pid;\n\telse\n\t\tkernel_wait(pid, &sub_info->retval);\n\n\t/* Restore default kernel sig handler */\n\tkernel_sigaction(SIGCHLD, SIG_IGN);\n\tumh_complete(sub_info);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void call_usermodehelper_exec_sync(struct subprocess_info *sub_info)\n{\n\tpid_t pid;\n\n\t/* If SIGCLD is ignored do_wait won't populate the status. */\n\tkernel_sigaction(SIGCHLD, SIG_DFL);\n\tpid = kernel_thread(call_usermodehelper_exec_async, sub_info, SIGCHLD);\n\tif (pid < 0)\n\t\tsub_info->retval = pid;\n\telse\n\t\tkernel_wait(pid, &sub_info->retval);\n\n\t/* Restore default kernel sig handler */\n\tkernel_sigaction(SIGCHLD, SIG_IGN);\n\tumh_complete(sub_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structsubprocess_info",
            "work"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void call_usermodehelper_exec_work(struct work_struct *work)\n{\n\tstruct subprocess_info *sub_info =\n\t\tcontainer_of(work, struct subprocess_info, work);\n\n\tif (sub_info->wait & UMH_WAIT_PROC) {\n\t\tcall_usermodehelper_exec_sync(sub_info);\n\t} else {\n\t\tpid_t pid;\n\t\t/*\n\t\t * Use CLONE_PARENT to reparent it to kthreadd; we do not\n\t\t * want to pollute current->children, and we need a parent\n\t\t * that always ignores SIGCHLD to ensure auto-reaping.\n\t\t */\n\t\tpid = kernel_thread(call_usermodehelper_exec_async, sub_info,\n\t\t\t\t    CLONE_PARENT | SIGCHLD);\n\t\tif (pid < 0) {\n\t\t\tsub_info->retval = pid;\n\t\t\tumh_complete(sub_info);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "call_usermodehelper_exec_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "129-144",
    "snippet": "static void call_usermodehelper_exec_sync(struct subprocess_info *sub_info)\n{\n\tpid_t pid;\n\n\t/* If SIGCLD is ignored do_wait won't populate the status. */\n\tkernel_sigaction(SIGCHLD, SIG_DFL);\n\tpid = kernel_thread(call_usermodehelper_exec_async, sub_info, SIGCHLD);\n\tif (pid < 0)\n\t\tsub_info->retval = pid;\n\telse\n\t\tkernel_wait(pid, &sub_info->retval);\n\n\t/* Restore default kernel sig handler */\n\tkernel_sigaction(SIGCHLD, SIG_IGN);\n\tumh_complete(sub_info);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umh_complete",
          "args": [
            "sub_info"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "umh_complete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "49-61",
          "snippet": "static void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_sigaction",
          "args": [
            "SIGCHLD",
            "SIG_IGN"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_sigaction",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "4067-4082",
          "snippet": "void kernel_sigaction(int sig, __sighandler_t action)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->sighand->action[sig - 1].sa.sa_handler = action;\n\tif (action == SIG_IGN) {\n\t\tsigset_t mask;\n\n\t\tsigemptyset(&mask);\n\t\tsigaddset(&mask, sig);\n\n\t\tflush_sigqueue_mask(&mask, &current->signal->shared_pending);\n\t\tflush_sigqueue_mask(&mask, &current->pending);\n\t\trecalc_sigpending();\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid kernel_sigaction(int sig, __sighandler_t action)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->sighand->action[sig - 1].sa.sa_handler = action;\n\tif (action == SIG_IGN) {\n\t\tsigset_t mask;\n\n\t\tsigemptyset(&mask);\n\t\tsigaddset(&mask, sig);\n\n\t\tflush_sigqueue_mask(&mask, &current->signal->shared_pending);\n\t\tflush_sigqueue_mask(&mask, &current->pending);\n\t\trecalc_sigpending();\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_wait",
          "args": [
            "pid",
            "&sub_info->retval"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_thread",
          "args": [
            "call_usermodehelper_exec_async",
            "sub_info",
            "SIGCHLD"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "2597-2608",
          "snippet": "pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |\n\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),\n\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),\n\t\t.stack\t\t= (unsigned long)fn,\n\t\t.stack_size\t= (unsigned long)arg,\n\t};\n\n\treturn kernel_clone(&args);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\npid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |\n\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),\n\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),\n\t\t.stack\t\t= (unsigned long)fn,\n\t\t.stack_size\t= (unsigned long)arg,\n\t};\n\n\treturn kernel_clone(&args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void call_usermodehelper_exec_sync(struct subprocess_info *sub_info)\n{\n\tpid_t pid;\n\n\t/* If SIGCLD is ignored do_wait won't populate the status. */\n\tkernel_sigaction(SIGCHLD, SIG_DFL);\n\tpid = kernel_thread(call_usermodehelper_exec_async, sub_info, SIGCHLD);\n\tif (pid < 0)\n\t\tsub_info->retval = pid;\n\telse\n\t\tkernel_wait(pid, &sub_info->retval);\n\n\t/* Restore default kernel sig handler */\n\tkernel_sigaction(SIGCHLD, SIG_IGN);\n\tumh_complete(sub_info);\n}"
  },
  {
    "function_name": "call_usermodehelper_exec_async",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "66-126",
    "snippet": "static int call_usermodehelper_exec_async(void *data)\n{\n\tstruct subprocess_info *sub_info = data;\n\tstruct cred *new;\n\tint retval;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tflush_signal_handlers(current, 1);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t/*\n\t * Initial kernel threads share ther FS with init, in order to\n\t * get the init root directory. But we've now created a new\n\t * thread that is going to execve a user process and has its own\n\t * 'struct fs_struct'. Reset umask to the default.\n\t */\n\tcurrent->fs->umask = 0022;\n\n\t/*\n\t * Our parent (unbound workqueue) runs with elevated scheduling\n\t * priority. Avoid propagating that into the userspace child.\n\t */\n\tset_user_nice(current, 0);\n\n\tretval = -ENOMEM;\n\tnew = prepare_kernel_cred(current);\n\tif (!new)\n\t\tgoto out;\n\n\tspin_lock(&umh_sysctl_lock);\n\tnew->cap_bset = cap_intersect(usermodehelper_bset, new->cap_bset);\n\tnew->cap_inheritable = cap_intersect(usermodehelper_inheritable,\n\t\t\t\t\t     new->cap_inheritable);\n\tspin_unlock(&umh_sysctl_lock);\n\n\tif (sub_info->init) {\n\t\tretval = sub_info->init(sub_info, new);\n\t\tif (retval) {\n\t\t\tabort_creds(new);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcommit_creds(new);\n\n\twait_for_initramfs();\n\tretval = kernel_execve(sub_info->path,\n\t\t\t       (const char *const *)sub_info->argv,\n\t\t\t       (const char *const *)sub_info->envp);\nout:\n\tsub_info->retval = retval;\n\t/*\n\t * call_usermodehelper_exec_sync() will call umh_complete\n\t * if UHM_WAIT_PROC.\n\t */\n\tif (!(sub_info->wait & UMH_WAIT_PROC))\n\t\tumh_complete(sub_info);\n\tif (!retval)\n\t\treturn 0;\n\tdo_exit(0);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static kernel_cap_t usermodehelper_bset = CAP_FULL_SET;",
      "static kernel_cap_t usermodehelper_inheritable = CAP_FULL_SET;",
      "static DEFINE_SPINLOCK(umh_sysctl_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "0"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "do_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "734-859",
          "snippet": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\t/*\n\t * If do_dead is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t *\n\t * On uptodate architectures force_uaccess_begin is a noop.  On\n\t * architectures that still have set_fs/get_fs in addition to handling\n\t * oopses handles kernel threads that run as set_fs(KERNEL_DS) by\n\t * default.\n\t */\n\tforce_uaccess_begin();\n\n\tkcov_task_exit(tsk);\n\n\tcoredump_task_exit(tsk);\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tio_uring_files_cancel();\n\texit_signals(tsk);  /* sets PF_EXITING */\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\t/*\n\t\t * If the last thread of global init has exited, panic\n\t\t * immediately to get a useable coredump.\n\t\t */\n\t\tif (unlikely(is_global_init(tsk)))\n\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\t\ttsk->signal->group_exit_code ?: (int)code);\n\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\t/*\n\t * If do_dead is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t *\n\t * On uptodate architectures force_uaccess_begin is a noop.  On\n\t * architectures that still have set_fs/get_fs in addition to handling\n\t * oopses handles kernel threads that run as set_fs(KERNEL_DS) by\n\t * default.\n\t */\n\tforce_uaccess_begin();\n\n\tkcov_task_exit(tsk);\n\n\tcoredump_task_exit(tsk);\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tio_uring_files_cancel();\n\texit_signals(tsk);  /* sets PF_EXITING */\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\t/*\n\t\t * If the last thread of global init has exited, panic\n\t\t * immediately to get a useable coredump.\n\t\t */\n\t\tif (unlikely(is_global_init(tsk)))\n\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\t\ttsk->signal->group_exit_code ?: (int)code);\n\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}"
        }
      },
      {
        "call_info": {
          "callee": "umh_complete",
          "args": [
            "sub_info"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "umh_complete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "49-61",
          "snippet": "static void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_execve",
          "args": [
            "sub_info->path",
            "(const char *const *)sub_info->argv",
            "(const char *const *)sub_info->envp"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_initramfs",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "commit_creds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "447-523",
          "snippet": "int commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\t/*\n\t\t * If a task drops privileges and becomes nondumpable,\n\t\t * the dumpability change must become visible before\n\t\t * the credential change; otherwise, a __ptrace_may_access()\n\t\t * racing with this change may be able to attach to a task it\n\t\t * shouldn't be able to attach to (as if the task had dropped\n\t\t * privileges without becoming nondumpable).\n\t\t * Pairs with a read barrier in __ptrace_may_access().\n\t\t */\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(new);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(new);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tinc_rlimit_ucounts(new->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tdec_rlimit_ucounts(old->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\t/*\n\t\t * If a task drops privileges and becomes nondumpable,\n\t\t * the dumpability change must become visible before\n\t\t * the credential change; otherwise, a __ptrace_may_access()\n\t\t * racing with this change may be able to attach to a task it\n\t\t * shouldn't be able to attach to (as if the task had dropped\n\t\t * privileges without becoming nondumpable).\n\t\t * Pairs with a read barrier in __ptrace_may_access().\n\t\t */\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(new);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(new);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tinc_rlimit_ucounts(new->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tdec_rlimit_ucounts(old->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "new"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "abort_creds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "533-544",
          "snippet": "void abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_info->init",
          "args": [
            "sub_info",
            "new"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&umh_sysctl_lock"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_intersect",
          "args": [
            "usermodehelper_inheritable",
            "new->cap_inheritable"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_intersect",
          "args": [
            "usermodehelper_bset",
            "new->cap_bset"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&umh_sysctl_lock"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_kernel_cred",
          "args": [
            "current"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_kernel_cred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "717-769",
          "snippet": "struct cred *prepare_kernel_cred(struct task_struct *daemon)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_kernel_cred() alloc %p\", new);\n\n\tif (daemon)\n\t\told = get_task_cred(daemon);\n\telse\n\t\told = get_cred(&init_cred);\n\n\tvalidate_creds(old);\n\n\t*new = *old;\n\tnew->non_rcu = 0;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\tget_group_info(new->group_info);\n\n#ifdef CONFIG_KEYS\n\tnew->session_keyring = NULL;\n\tnew->process_keyring = NULL;\n\tnew->thread_keyring = NULL;\n\tnew->request_key_auth = NULL;\n\tnew->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tput_cred(old);\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tput_cred(new);\n\tput_cred(old);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *cred_jar;",
            "struct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n\t.ucounts\t\t= &init_ucounts,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\nstruct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n\t.ucounts\t\t= &init_ucounts,\n};\n\nstruct cred *prepare_kernel_cred(struct task_struct *daemon)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_kernel_cred() alloc %p\", new);\n\n\tif (daemon)\n\t\told = get_task_cred(daemon);\n\telse\n\t\told = get_cred(&init_cred);\n\n\tvalidate_creds(old);\n\n\t*new = *old;\n\tnew->non_rcu = 0;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\tget_group_info(new->group_info);\n\n#ifdef CONFIG_KEYS\n\tnew->session_keyring = NULL;\n\tnew->process_keyring = NULL;\n\tnew->thread_keyring = NULL;\n\tnew->request_key_auth = NULL;\n\tnew->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tput_cred(old);\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tput_cred(new);\n\tput_cred(old);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "0"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_signal_handlers",
          "args": [
            "current",
            "1"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "flush_signal_handlers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "538-553",
          "snippet": "void\nflush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tka->sa.sa_restorer = NULL;\n#endif\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid\nflush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tka->sa.sa_restorer = NULL;\n#endif\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic kernel_cap_t usermodehelper_bset = CAP_FULL_SET;\nstatic kernel_cap_t usermodehelper_inheritable = CAP_FULL_SET;\nstatic DEFINE_SPINLOCK(umh_sysctl_lock);\n\nstatic int call_usermodehelper_exec_async(void *data)\n{\n\tstruct subprocess_info *sub_info = data;\n\tstruct cred *new;\n\tint retval;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tflush_signal_handlers(current, 1);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t/*\n\t * Initial kernel threads share ther FS with init, in order to\n\t * get the init root directory. But we've now created a new\n\t * thread that is going to execve a user process and has its own\n\t * 'struct fs_struct'. Reset umask to the default.\n\t */\n\tcurrent->fs->umask = 0022;\n\n\t/*\n\t * Our parent (unbound workqueue) runs with elevated scheduling\n\t * priority. Avoid propagating that into the userspace child.\n\t */\n\tset_user_nice(current, 0);\n\n\tretval = -ENOMEM;\n\tnew = prepare_kernel_cred(current);\n\tif (!new)\n\t\tgoto out;\n\n\tspin_lock(&umh_sysctl_lock);\n\tnew->cap_bset = cap_intersect(usermodehelper_bset, new->cap_bset);\n\tnew->cap_inheritable = cap_intersect(usermodehelper_inheritable,\n\t\t\t\t\t     new->cap_inheritable);\n\tspin_unlock(&umh_sysctl_lock);\n\n\tif (sub_info->init) {\n\t\tretval = sub_info->init(sub_info, new);\n\t\tif (retval) {\n\t\t\tabort_creds(new);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcommit_creds(new);\n\n\twait_for_initramfs();\n\tretval = kernel_execve(sub_info->path,\n\t\t\t       (const char *const *)sub_info->argv,\n\t\t\t       (const char *const *)sub_info->envp);\nout:\n\tsub_info->retval = retval;\n\t/*\n\t * call_usermodehelper_exec_sync() will call umh_complete\n\t * if UHM_WAIT_PROC.\n\t */\n\tif (!(sub_info->wait & UMH_WAIT_PROC))\n\t\tumh_complete(sub_info);\n\tif (!retval)\n\t\treturn 0;\n\tdo_exit(0);\n}"
  },
  {
    "function_name": "umh_complete",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "49-61",
    "snippet": "static void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_usermodehelper_freeinfo",
          "args": [
            "sub_info"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_freeinfo",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "42-47",
          "snippet": "static void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "comp"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "umh_complete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "49-61",
          "snippet": "static void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&sub_info->complete",
            "NULL"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t/*\n\t * See call_usermodehelper_exec(). If xchg() returns NULL\n\t * we own sub_info, the UMH_KILLABLE caller has gone away\n\t * or the caller used UMH_NO_WAIT.\n\t */\n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}"
  },
  {
    "function_name": "call_usermodehelper_freeinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
    "lines": "42-47",
    "snippet": "static void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/initrd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "info"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}"
  }
]