[
  {
    "function_name": "kdb_gdb_state_pass",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_debugger.c",
    "lines": "173-176",
    "snippet": "void kdb_gdb_state_pass(char *buf)\n{\n\tgdbstub_state(kdb_ks, buf);\n}",
    "includes": [
      "#include \"../debug_core.h\"",
      "#include \"kdb_private.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/export.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_state *kdb_ks;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gdbstub_state",
          "args": [
            "kdb_ks",
            "buf"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "gdbstub_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "1092-1118",
          "snippet": "int gdbstub_state(struct kgdb_state *ks, char *cmd)\n{\n\tint error;\n\n\tswitch (cmd[0]) {\n\tcase 'e':\n\t\terror = kgdb_arch_handle_exception(ks->ex_vector,\n\t\t\t\t\t\t   ks->signo,\n\t\t\t\t\t\t   ks->err_code,\n\t\t\t\t\t\t   remcom_in_buffer,\n\t\t\t\t\t\t   remcom_out_buffer,\n\t\t\t\t\t\t   ks->linux_regs);\n\t\treturn error;\n\tcase 's':\n\tcase 'c':\n\t\tstrscpy(remcom_in_buffer, cmd, sizeof(remcom_in_buffer));\n\t\treturn 0;\n\tcase '$':\n\t\tstrscpy(remcom_in_buffer, cmd, sizeof(remcom_in_buffer));\n\t\tgdbstub_use_prev_in_buf = strlen(remcom_in_buffer);\n\t\tgdbstub_prev_in_buf_pos = 0;\n\t\treturn 0;\n\t}\n\tdbg_io_ops->write_char('+');\n\tput_packet(remcom_out_buffer);\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];",
            "static char\t\t\tremcom_out_buffer[BUFMAX];",
            "static int\t\t\tgdbstub_use_prev_in_buf;",
            "static int\t\t\tgdbstub_prev_in_buf_pos;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\nstatic int\t\t\tgdbstub_use_prev_in_buf;\nstatic int\t\t\tgdbstub_prev_in_buf_pos;\n\nint gdbstub_state(struct kgdb_state *ks, char *cmd)\n{\n\tint error;\n\n\tswitch (cmd[0]) {\n\tcase 'e':\n\t\terror = kgdb_arch_handle_exception(ks->ex_vector,\n\t\t\t\t\t\t   ks->signo,\n\t\t\t\t\t\t   ks->err_code,\n\t\t\t\t\t\t   remcom_in_buffer,\n\t\t\t\t\t\t   remcom_out_buffer,\n\t\t\t\t\t\t   ks->linux_regs);\n\t\treturn error;\n\tcase 's':\n\tcase 'c':\n\t\tstrscpy(remcom_in_buffer, cmd, sizeof(remcom_in_buffer));\n\t\treturn 0;\n\tcase '$':\n\t\tstrscpy(remcom_in_buffer, cmd, sizeof(remcom_in_buffer));\n\t\tgdbstub_use_prev_in_buf = strlen(remcom_in_buffer);\n\t\tgdbstub_prev_in_buf_pos = 0;\n\t\treturn 0;\n\t}\n\tdbg_io_ops->write_char('+');\n\tput_packet(remcom_out_buffer);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../debug_core.h\"\n#include \"kdb_private.h\"\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/kdebug.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n\nstatic struct kgdb_state *kdb_ks;\n\nvoid kdb_gdb_state_pass(char *buf)\n{\n\tgdbstub_state(kdb_ks, buf);\n}"
  },
  {
    "function_name": "kdb_stub",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_debugger.c",
    "lines": "53-171",
    "snippet": "int kdb_stub(struct kgdb_state *ks)\n{\n\tint error = 0;\n\tkdb_bp_t *bp;\n\tunsigned long addr = kgdb_arch_pc(ks->ex_vector, ks->linux_regs);\n\tkdb_reason_t reason = KDB_REASON_OOPS;\n\tkdb_dbtrap_t db_result = KDB_DB_NOBPT;\n\tint i;\n\n\tkdb_ks = ks;\n\tif (KDB_STATE(REENTRY)) {\n\t\treason = KDB_REASON_SWITCH;\n\t\tKDB_STATE_CLEAR(REENTRY);\n\t\taddr = instruction_pointer(ks->linux_regs);\n\t}\n\tks->pass_exception = 0;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treason = KDB_REASON_KEYBOARD;\n\n\tif (ks->err_code == KDB_REASON_SYSTEM_NMI && ks->signo == SIGTRAP)\n\t\treason = KDB_REASON_SYSTEM_NMI;\n\n\telse if (in_nmi())\n\t\treason = KDB_REASON_NMI;\n\n\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++) {\n\t\tif ((bp->bp_enabled) && (bp->bp_addr == addr)) {\n\t\t\treason = KDB_REASON_BREAK;\n\t\t\tdb_result = KDB_DB_BPT;\n\t\t\tif (addr != instruction_pointer(ks->linux_regs))\n\t\t\t\tkgdb_arch_set_pc(ks->linux_regs, addr);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (reason == KDB_REASON_BREAK || reason == KDB_REASON_SWITCH) {\n\t\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++) {\n\t\t\tif (bp->bp_free)\n\t\t\t\tcontinue;\n\t\t\tif (bp->bp_addr == addr) {\n\t\t\t\tbp->bp_delay = 1;\n\t\t\t\tbp->bp_delayed = 1;\n\t/*\n\t * SSBPT is set when the kernel debugger must single step a\n\t * task in order to re-establish an instruction breakpoint\n\t * which uses the instruction replacement mechanism.  It is\n\t * cleared by any action that removes the need to single-step\n\t * the breakpoint.\n\t */\n\t\t\t\treason = KDB_REASON_BREAK;\n\t\t\t\tdb_result = KDB_DB_BPT;\n\t\t\t\tKDB_STATE_SET(SSBPT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (reason != KDB_REASON_BREAK && ks->ex_vector == 0 &&\n\t\tks->signo == SIGTRAP) {\n\t\treason = KDB_REASON_SSTEP;\n\t\tdb_result = KDB_DB_BPT;\n\t}\n\t/* Set initial kdb state variables */\n\tKDB_STATE_CLEAR(KGDB_TRANS);\n\tkdb_common_init_state(ks);\n\t/* Remove any breakpoints as needed by kdb and clear single step */\n\tkdb_bp_remove();\n\tKDB_STATE_CLEAR(DOING_SS);\n\tKDB_STATE_SET(PAGER);\n\tif (ks->err_code == DIE_OOPS || reason == KDB_REASON_OOPS) {\n\t\tks->pass_exception = 1;\n\t\tKDB_FLAG_SET(CATASTROPHIC);\n\t}\n\t/* set CATASTROPHIC if the system contains unresponsive processors */\n\tfor_each_online_cpu(i)\n\t\tif (!kgdb_info[i].enter_kgdb)\n\t\t\tKDB_FLAG_SET(CATASTROPHIC);\n\tif (KDB_STATE(SSBPT) && reason == KDB_REASON_SSTEP) {\n\t\tKDB_STATE_CLEAR(SSBPT);\n\t\tKDB_STATE_CLEAR(DOING_SS);\n\t} else {\n\t\t/* Start kdb main loop */\n\t\terror = kdb_main_loop(KDB_REASON_ENTER, reason,\n\t\t\t\t      ks->err_code, db_result, ks->linux_regs);\n\t}\n\t/*\n\t * Upon exit from the kdb main loop setup break points and restart\n\t * the system based on the requested continue state\n\t */\n\tkdb_common_deinit_state();\n\tKDB_STATE_CLEAR(PAGER);\n\tif (error == KDB_CMD_KGDB) {\n\t\tif (KDB_STATE(DOING_KGDB))\n\t\t\tKDB_STATE_CLEAR(DOING_KGDB);\n\t\treturn DBG_PASS_EVENT;\n\t}\n\tkdb_bp_install(ks->linux_regs);\n\t/* Set the exit state to a single step or a continue */\n\tif (KDB_STATE(DOING_SS))\n\t\tgdbstub_state(ks, \"s\");\n\telse\n\t\tgdbstub_state(ks, \"c\");\n\n\tKDB_FLAG_CLEAR(CATASTROPHIC);\n\n\t/* Invoke arch specific exception handling prior to system resume */\n\tkgdb_info[ks->cpu].ret_state = gdbstub_state(ks, \"e\");\n\tif (ks->pass_exception)\n\t\tkgdb_info[ks->cpu].ret_state = 1;\n\tif (error == KDB_CMD_CPU) {\n\t\tKDB_STATE_SET(REENTRY);\n\t\t/*\n\t\t * Force clear the single step bit because kdb emulates this\n\t\t * differently vs the gdbstub\n\t\t */\n\t\tkgdb_single_step = 0;\n\t\treturn DBG_SWITCH_CPU_EVENT;\n\t}\n\treturn kgdb_info[ks->cpu].ret_state;\n}",
    "includes": [
      "#include \"../debug_core.h\"",
      "#include \"kdb_private.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/export.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_state *kdb_ks;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "REENTRY"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdbstub_state",
          "args": [
            "ks",
            "\"e\""
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "gdbstub_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "1092-1118",
          "snippet": "int gdbstub_state(struct kgdb_state *ks, char *cmd)\n{\n\tint error;\n\n\tswitch (cmd[0]) {\n\tcase 'e':\n\t\terror = kgdb_arch_handle_exception(ks->ex_vector,\n\t\t\t\t\t\t   ks->signo,\n\t\t\t\t\t\t   ks->err_code,\n\t\t\t\t\t\t   remcom_in_buffer,\n\t\t\t\t\t\t   remcom_out_buffer,\n\t\t\t\t\t\t   ks->linux_regs);\n\t\treturn error;\n\tcase 's':\n\tcase 'c':\n\t\tstrscpy(remcom_in_buffer, cmd, sizeof(remcom_in_buffer));\n\t\treturn 0;\n\tcase '$':\n\t\tstrscpy(remcom_in_buffer, cmd, sizeof(remcom_in_buffer));\n\t\tgdbstub_use_prev_in_buf = strlen(remcom_in_buffer);\n\t\tgdbstub_prev_in_buf_pos = 0;\n\t\treturn 0;\n\t}\n\tdbg_io_ops->write_char('+');\n\tput_packet(remcom_out_buffer);\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];",
            "static char\t\t\tremcom_out_buffer[BUFMAX];",
            "static int\t\t\tgdbstub_use_prev_in_buf;",
            "static int\t\t\tgdbstub_prev_in_buf_pos;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\nstatic int\t\t\tgdbstub_use_prev_in_buf;\nstatic int\t\t\tgdbstub_prev_in_buf_pos;\n\nint gdbstub_state(struct kgdb_state *ks, char *cmd)\n{\n\tint error;\n\n\tswitch (cmd[0]) {\n\tcase 'e':\n\t\terror = kgdb_arch_handle_exception(ks->ex_vector,\n\t\t\t\t\t\t   ks->signo,\n\t\t\t\t\t\t   ks->err_code,\n\t\t\t\t\t\t   remcom_in_buffer,\n\t\t\t\t\t\t   remcom_out_buffer,\n\t\t\t\t\t\t   ks->linux_regs);\n\t\treturn error;\n\tcase 's':\n\tcase 'c':\n\t\tstrscpy(remcom_in_buffer, cmd, sizeof(remcom_in_buffer));\n\t\treturn 0;\n\tcase '$':\n\t\tstrscpy(remcom_in_buffer, cmd, sizeof(remcom_in_buffer));\n\t\tgdbstub_use_prev_in_buf = strlen(remcom_in_buffer);\n\t\tgdbstub_prev_in_buf_pos = 0;\n\t\treturn 0;\n\t}\n\tdbg_io_ops->write_char('+');\n\tput_packet(remcom_out_buffer);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG_CLEAR",
          "args": [
            "CATASTROPHIC"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "DOING_SS"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_bp_install",
          "args": [
            "ks->linux_regs"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_bp_install",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_bp.c",
          "lines": "174-188",
          "snippet": "void kdb_bp_install(struct pt_regs *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < KDB_MAXBPT; i++) {\n\t\tkdb_bp_t *bp = &kdb_breakpoints[i];\n\n\t\tif (KDB_DEBUG(BP)) {\n\t\t\tkdb_printf(\"%s: bp %d bp_enabled %d\\n\",\n\t\t\t\t   __func__, i, bp->bp_enabled);\n\t\t}\n\t\tif (bp->bp_enabled)\n\t\t\t_kdb_bp_install(regs, bp);\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kdb.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kdb_bp_t kdb_breakpoints[KDB_MAXBPT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nkdb_bp_t kdb_breakpoints[KDB_MAXBPT];\n\nvoid kdb_bp_install(struct pt_regs *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < KDB_MAXBPT; i++) {\n\t\tkdb_bp_t *bp = &kdb_breakpoints[i];\n\n\t\tif (KDB_DEBUG(BP)) {\n\t\t\tkdb_printf(\"%s: bp %d bp_enabled %d\\n\",\n\t\t\t\t   __func__, i, bp->bp_enabled);\n\t\t}\n\t\tif (bp->bp_enabled)\n\t\t\t_kdb_bp_install(regs, bp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "DOING_KGDB"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "DOING_KGDB"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "PAGER"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_common_deinit_state",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_common_deinit_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_debugger.c",
          "lines": "45-51",
          "snippet": "int kdb_common_deinit_state(void)\n{\n\tkdb_initial_cpu = -1;\n\tkdb_current_task = NULL;\n\tkdb_current_regs = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"../debug_core.h\"",
            "#include \"kdb_private.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../debug_core.h\"\n#include \"kdb_private.h\"\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/kdebug.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n\nint kdb_common_deinit_state(void)\n{\n\tkdb_initial_cpu = -1;\n\tkdb_current_task = NULL;\n\tkdb_current_regs = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_main_loop",
          "args": [
            "KDB_REASON_ENTER",
            "reason",
            "ks->err_code",
            "db_result",
            "ks->linux_regs"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_main_loop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1386-1441",
          "snippet": "int kdb_main_loop(kdb_reason_t reason, kdb_reason_t reason2, int error,\n\t      kdb_dbtrap_t db_result, struct pt_regs *regs)\n{\n\tint result = 1;\n\t/* Stay in kdb() until 'go', 'ss[b]' or an error */\n\twhile (1) {\n\t\t/*\n\t\t * All processors except the one that is in control\n\t\t * will spin here.\n\t\t */\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 1\", reason);\n\t\twhile (KDB_STATE(HOLD_CPU)) {\n\t\t\t/* state KDB is turned off by kdb_cpu to see if the\n\t\t\t * other cpus are still live, each cpu in this loop\n\t\t\t * turns it back on.\n\t\t\t */\n\t\t\tif (!KDB_STATE(KDB))\n\t\t\t\tKDB_STATE_SET(KDB);\n\t\t}\n\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 2\", reason);\n\t\tif (KDB_STATE(LEAVING))\n\t\t\tbreak;\t/* Another cpu said 'go' */\n\t\t/* Still using kdb, this processor is in control */\n\t\tresult = kdb_local(reason2, error, regs, db_result);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 3\", result);\n\n\t\tif (result == KDB_CMD_CPU)\n\t\t\tbreak;\n\n\t\tif (result == KDB_CMD_SS) {\n\t\t\tKDB_STATE_SET(DOING_SS);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result == KDB_CMD_KGDB) {\n\t\t\tif (!KDB_STATE(DOING_KGDB))\n\t\t\t\tkdb_printf(\"Entering please attach debugger \"\n\t\t\t\t\t   \"or use $D#44+ or $3#33\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (result && result != 1 && result != KDB_CMD_GO)\n\t\t\tkdb_printf(\"\\nUnexpected kdb_local return code %d\\n\",\n\t\t\t\t   result);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 4\", reason);\n\t\tbreak;\n\t}\n\tif (KDB_STATE(DOING_SS))\n\t\tKDB_STATE_CLEAR(SSBPT);\n\n\t/* Clean up any keyboard devices before leaving */\n\tkdb_kbd_cleanup_state();\n\n\treturn result;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdb_main_loop(kdb_reason_t reason, kdb_reason_t reason2, int error,\n\t      kdb_dbtrap_t db_result, struct pt_regs *regs)\n{\n\tint result = 1;\n\t/* Stay in kdb() until 'go', 'ss[b]' or an error */\n\twhile (1) {\n\t\t/*\n\t\t * All processors except the one that is in control\n\t\t * will spin here.\n\t\t */\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 1\", reason);\n\t\twhile (KDB_STATE(HOLD_CPU)) {\n\t\t\t/* state KDB is turned off by kdb_cpu to see if the\n\t\t\t * other cpus are still live, each cpu in this loop\n\t\t\t * turns it back on.\n\t\t\t */\n\t\t\tif (!KDB_STATE(KDB))\n\t\t\t\tKDB_STATE_SET(KDB);\n\t\t}\n\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 2\", reason);\n\t\tif (KDB_STATE(LEAVING))\n\t\t\tbreak;\t/* Another cpu said 'go' */\n\t\t/* Still using kdb, this processor is in control */\n\t\tresult = kdb_local(reason2, error, regs, db_result);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 3\", result);\n\n\t\tif (result == KDB_CMD_CPU)\n\t\t\tbreak;\n\n\t\tif (result == KDB_CMD_SS) {\n\t\t\tKDB_STATE_SET(DOING_SS);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result == KDB_CMD_KGDB) {\n\t\t\tif (!KDB_STATE(DOING_KGDB))\n\t\t\t\tkdb_printf(\"Entering please attach debugger \"\n\t\t\t\t\t   \"or use $D#44+ or $3#33\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (result && result != 1 && result != KDB_CMD_GO)\n\t\t\tkdb_printf(\"\\nUnexpected kdb_local return code %d\\n\",\n\t\t\t\t   result);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 4\", reason);\n\t\tbreak;\n\t}\n\tif (KDB_STATE(DOING_SS))\n\t\tKDB_STATE_CLEAR(SSBPT);\n\n\t/* Clean up any keyboard devices before leaving */\n\tkdb_kbd_cleanup_state();\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "DOING_SS"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "SSBPT"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "SSBPT"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_FLAG_SET",
          "args": [
            "CATASTROPHIC"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_FLAG_SET",
          "args": [
            "CATASTROPHIC"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "PAGER"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "DOING_SS"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_bp_remove",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_bp_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_bp.c",
          "lines": "205-219",
          "snippet": "void kdb_bp_remove(void)\n{\n\tint i;\n\n\tfor (i = KDB_MAXBPT - 1; i >= 0; i--) {\n\t\tkdb_bp_t *bp = &kdb_breakpoints[i];\n\n\t\tif (KDB_DEBUG(BP)) {\n\t\t\tkdb_printf(\"%s: bp %d bp_enabled %d\\n\",\n\t\t\t\t   __func__, i, bp->bp_enabled);\n\t\t}\n\t\tif (bp->bp_enabled)\n\t\t\t_kdb_bp_remove(bp);\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kdb.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kdb_bp_t kdb_breakpoints[KDB_MAXBPT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nkdb_bp_t kdb_breakpoints[KDB_MAXBPT];\n\nvoid kdb_bp_remove(void)\n{\n\tint i;\n\n\tfor (i = KDB_MAXBPT - 1; i >= 0; i--) {\n\t\tkdb_bp_t *bp = &kdb_breakpoints[i];\n\n\t\tif (KDB_DEBUG(BP)) {\n\t\t\tkdb_printf(\"%s: bp %d bp_enabled %d\\n\",\n\t\t\t\t   __func__, i, bp->bp_enabled);\n\t\t}\n\t\tif (bp->bp_enabled)\n\t\t\t_kdb_bp_remove(bp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_common_init_state",
          "args": [
            "ks"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_common_init_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_debugger.c",
          "lines": "37-43",
          "snippet": "int kdb_common_init_state(struct kgdb_state *ks)\n{\n\tkdb_initial_cpu = atomic_read(&kgdb_active);\n\tkdb_current_task = kgdb_info[ks->cpu].task;\n\tkdb_current_regs = kgdb_info[ks->cpu].debuggerinfo;\n\treturn 0;\n}",
          "includes": [
            "#include \"../debug_core.h\"",
            "#include \"kdb_private.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../debug_core.h\"\n#include \"kdb_private.h\"\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/kdebug.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n\nint kdb_common_init_state(struct kgdb_state *ks)\n{\n\tkdb_initial_cpu = atomic_read(&kgdb_active);\n\tkdb_current_task = kgdb_info[ks->cpu].task;\n\tkdb_current_regs = kgdb_info[ks->cpu].debuggerinfo;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "KGDB_TRANS"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "SSBPT"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_arch_set_pc",
          "args": [
            "ks->linux_regs",
            "addr"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "ks->linux_regs"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_setting_breakpoint"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "ks->linux_regs"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "REENTRY"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "REENTRY"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_arch_pc",
          "args": [
            "ks->ex_vector",
            "ks->linux_regs"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_pc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "201-204",
          "snippet": "unsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nunsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../debug_core.h\"\n#include \"kdb_private.h\"\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/kdebug.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n\nstatic struct kgdb_state *kdb_ks;\n\nint kdb_stub(struct kgdb_state *ks)\n{\n\tint error = 0;\n\tkdb_bp_t *bp;\n\tunsigned long addr = kgdb_arch_pc(ks->ex_vector, ks->linux_regs);\n\tkdb_reason_t reason = KDB_REASON_OOPS;\n\tkdb_dbtrap_t db_result = KDB_DB_NOBPT;\n\tint i;\n\n\tkdb_ks = ks;\n\tif (KDB_STATE(REENTRY)) {\n\t\treason = KDB_REASON_SWITCH;\n\t\tKDB_STATE_CLEAR(REENTRY);\n\t\taddr = instruction_pointer(ks->linux_regs);\n\t}\n\tks->pass_exception = 0;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treason = KDB_REASON_KEYBOARD;\n\n\tif (ks->err_code == KDB_REASON_SYSTEM_NMI && ks->signo == SIGTRAP)\n\t\treason = KDB_REASON_SYSTEM_NMI;\n\n\telse if (in_nmi())\n\t\treason = KDB_REASON_NMI;\n\n\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++) {\n\t\tif ((bp->bp_enabled) && (bp->bp_addr == addr)) {\n\t\t\treason = KDB_REASON_BREAK;\n\t\t\tdb_result = KDB_DB_BPT;\n\t\t\tif (addr != instruction_pointer(ks->linux_regs))\n\t\t\t\tkgdb_arch_set_pc(ks->linux_regs, addr);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (reason == KDB_REASON_BREAK || reason == KDB_REASON_SWITCH) {\n\t\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++) {\n\t\t\tif (bp->bp_free)\n\t\t\t\tcontinue;\n\t\t\tif (bp->bp_addr == addr) {\n\t\t\t\tbp->bp_delay = 1;\n\t\t\t\tbp->bp_delayed = 1;\n\t/*\n\t * SSBPT is set when the kernel debugger must single step a\n\t * task in order to re-establish an instruction breakpoint\n\t * which uses the instruction replacement mechanism.  It is\n\t * cleared by any action that removes the need to single-step\n\t * the breakpoint.\n\t */\n\t\t\t\treason = KDB_REASON_BREAK;\n\t\t\t\tdb_result = KDB_DB_BPT;\n\t\t\t\tKDB_STATE_SET(SSBPT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (reason != KDB_REASON_BREAK && ks->ex_vector == 0 &&\n\t\tks->signo == SIGTRAP) {\n\t\treason = KDB_REASON_SSTEP;\n\t\tdb_result = KDB_DB_BPT;\n\t}\n\t/* Set initial kdb state variables */\n\tKDB_STATE_CLEAR(KGDB_TRANS);\n\tkdb_common_init_state(ks);\n\t/* Remove any breakpoints as needed by kdb and clear single step */\n\tkdb_bp_remove();\n\tKDB_STATE_CLEAR(DOING_SS);\n\tKDB_STATE_SET(PAGER);\n\tif (ks->err_code == DIE_OOPS || reason == KDB_REASON_OOPS) {\n\t\tks->pass_exception = 1;\n\t\tKDB_FLAG_SET(CATASTROPHIC);\n\t}\n\t/* set CATASTROPHIC if the system contains unresponsive processors */\n\tfor_each_online_cpu(i)\n\t\tif (!kgdb_info[i].enter_kgdb)\n\t\t\tKDB_FLAG_SET(CATASTROPHIC);\n\tif (KDB_STATE(SSBPT) && reason == KDB_REASON_SSTEP) {\n\t\tKDB_STATE_CLEAR(SSBPT);\n\t\tKDB_STATE_CLEAR(DOING_SS);\n\t} else {\n\t\t/* Start kdb main loop */\n\t\terror = kdb_main_loop(KDB_REASON_ENTER, reason,\n\t\t\t\t      ks->err_code, db_result, ks->linux_regs);\n\t}\n\t/*\n\t * Upon exit from the kdb main loop setup break points and restart\n\t * the system based on the requested continue state\n\t */\n\tkdb_common_deinit_state();\n\tKDB_STATE_CLEAR(PAGER);\n\tif (error == KDB_CMD_KGDB) {\n\t\tif (KDB_STATE(DOING_KGDB))\n\t\t\tKDB_STATE_CLEAR(DOING_KGDB);\n\t\treturn DBG_PASS_EVENT;\n\t}\n\tkdb_bp_install(ks->linux_regs);\n\t/* Set the exit state to a single step or a continue */\n\tif (KDB_STATE(DOING_SS))\n\t\tgdbstub_state(ks, \"s\");\n\telse\n\t\tgdbstub_state(ks, \"c\");\n\n\tKDB_FLAG_CLEAR(CATASTROPHIC);\n\n\t/* Invoke arch specific exception handling prior to system resume */\n\tkgdb_info[ks->cpu].ret_state = gdbstub_state(ks, \"e\");\n\tif (ks->pass_exception)\n\t\tkgdb_info[ks->cpu].ret_state = 1;\n\tif (error == KDB_CMD_CPU) {\n\t\tKDB_STATE_SET(REENTRY);\n\t\t/*\n\t\t * Force clear the single step bit because kdb emulates this\n\t\t * differently vs the gdbstub\n\t\t */\n\t\tkgdb_single_step = 0;\n\t\treturn DBG_SWITCH_CPU_EVENT;\n\t}\n\treturn kgdb_info[ks->cpu].ret_state;\n}"
  },
  {
    "function_name": "kdb_common_deinit_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_debugger.c",
    "lines": "45-51",
    "snippet": "int kdb_common_deinit_state(void)\n{\n\tkdb_initial_cpu = -1;\n\tkdb_current_task = NULL;\n\tkdb_current_regs = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include \"../debug_core.h\"",
      "#include \"kdb_private.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/export.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../debug_core.h\"\n#include \"kdb_private.h\"\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/kdebug.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n\nint kdb_common_deinit_state(void)\n{\n\tkdb_initial_cpu = -1;\n\tkdb_current_task = NULL;\n\tkdb_current_regs = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_common_init_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_debugger.c",
    "lines": "37-43",
    "snippet": "int kdb_common_init_state(struct kgdb_state *ks)\n{\n\tkdb_initial_cpu = atomic_read(&kgdb_active);\n\tkdb_current_task = kgdb_info[ks->cpu].task;\n\tkdb_current_regs = kgdb_info[ks->cpu].debuggerinfo;\n\treturn 0;\n}",
    "includes": [
      "#include \"../debug_core.h\"",
      "#include \"kdb_private.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/export.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_active"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../debug_core.h\"\n#include \"kdb_private.h\"\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/kdebug.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n\nint kdb_common_init_state(struct kgdb_state *ks)\n{\n\tkdb_initial_cpu = atomic_read(&kgdb_active);\n\tkdb_current_task = kgdb_info[ks->cpu].task;\n\tkdb_current_regs = kgdb_info[ks->cpu].debuggerinfo;\n\treturn 0;\n}"
  }
]