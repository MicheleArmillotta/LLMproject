[
  {
    "function_name": "put_old_itimerspec32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "901-908",
    "snippet": "int put_old_itimerspec32(const struct itimerspec64 *its,\n\t\t\tstruct old_itimerspec32 __user *uits)\n{\n\tif (__put_old_timespec32(&its->it_interval, &uits->it_interval) ||\n\t    __put_old_timespec32(&its->it_value, &uits->it_value))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_old_timespec32",
          "args": [
            "&its->it_value",
            "&uits->it_value"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "__put_old_timespec32",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "832-840",
          "snippet": "static int __put_old_timespec32(const struct timespec64 *ts64,\n\t\t\t\t   struct old_timespec32 __user *cts)\n{\n\tstruct old_timespec32 ts = {\n\t\t.tv_sec = ts64->tv_sec,\n\t\t.tv_nsec = ts64->tv_nsec\n\t};\n\treturn copy_to_user(cts, &ts, sizeof(ts)) ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int __put_old_timespec32(const struct timespec64 *ts64,\n\t\t\t\t   struct old_timespec32 __user *cts)\n{\n\tstruct old_timespec32 ts = {\n\t\t.tv_sec = ts64->tv_sec,\n\t\t.tv_nsec = ts64->tv_nsec\n\t};\n\treturn copy_to_user(cts, &ts, sizeof(ts)) ? -EFAULT : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint put_old_itimerspec32(const struct itimerspec64 *its,\n\t\t\tstruct old_itimerspec32 __user *uits)\n{\n\tif (__put_old_timespec32(&its->it_interval, &uits->it_interval) ||\n\t    __put_old_timespec32(&its->it_value, &uits->it_value))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_old_itimerspec32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "890-898",
    "snippet": "int get_old_itimerspec32(struct itimerspec64 *its,\n\t\t\tconst struct old_itimerspec32 __user *uits)\n{\n\n\tif (__get_old_timespec32(&its->it_interval, &uits->it_interval) ||\n\t    __get_old_timespec32(&its->it_value, &uits->it_value))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_old_timespec32",
          "args": [
            "&its->it_value",
            "&uits->it_value"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "__get_old_timespec32",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "816-830",
          "snippet": "static int __get_old_timespec32(struct timespec64 *ts64,\n\t\t\t\t   const struct old_timespec32 __user *cts)\n{\n\tstruct old_timespec32 ts;\n\tint ret;\n\n\tret = copy_from_user(&ts, cts, sizeof(ts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tts64->tv_sec = ts.tv_sec;\n\tts64->tv_nsec = ts.tv_nsec;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int __get_old_timespec32(struct timespec64 *ts64,\n\t\t\t\t   const struct old_timespec32 __user *cts)\n{\n\tstruct old_timespec32 ts;\n\tint ret;\n\n\tret = copy_from_user(&ts, cts, sizeof(ts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tts64->tv_sec = ts.tv_sec;\n\tts64->tv_nsec = ts.tv_nsec;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint get_old_itimerspec32(struct itimerspec64 *its,\n\t\t\tconst struct old_itimerspec32 __user *uits)\n{\n\n\tif (__get_old_timespec32(&its->it_interval, &uits->it_interval) ||\n\t    __get_old_timespec32(&its->it_value, &uits->it_value))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "put_itimerspec64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "875-887",
    "snippet": "int put_itimerspec64(const struct itimerspec64 *it,\n\t\t\tstruct __kernel_itimerspec __user *uit)\n{\n\tint ret;\n\n\tret = put_timespec64(&it->it_interval, &uit->it_interval);\n\tif (ret)\n\t\treturn ret;\n\n\tret = put_timespec64(&it->it_value, &uit->it_value);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_timespec64",
          "args": [
            "&it->it_value",
            "&uit->it_value"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "put_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "804-813",
          "snippet": "int put_timespec64(const struct timespec64 *ts,\n\t\t   struct __kernel_timespec __user *uts)\n{\n\tstruct __kernel_timespec kts = {\n\t\t.tv_sec = ts->tv_sec,\n\t\t.tv_nsec = ts->tv_nsec\n\t};\n\n\treturn copy_to_user(uts, &kts, sizeof(kts)) ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint put_timespec64(const struct timespec64 *ts,\n\t\t   struct __kernel_timespec __user *uts)\n{\n\tstruct __kernel_timespec kts = {\n\t\t.tv_sec = ts->tv_sec,\n\t\t.tv_nsec = ts->tv_nsec\n\t};\n\n\treturn copy_to_user(uts, &kts, sizeof(kts)) ? -EFAULT : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint put_itimerspec64(const struct itimerspec64 *it,\n\t\t\tstruct __kernel_itimerspec __user *uit)\n{\n\tint ret;\n\n\tret = put_timespec64(&it->it_interval, &uit->it_interval);\n\tif (ret)\n\t\treturn ret;\n\n\tret = put_timespec64(&it->it_value, &uit->it_value);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "get_itimerspec64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "860-872",
    "snippet": "int get_itimerspec64(struct itimerspec64 *it,\n\t\t\tconst struct __kernel_itimerspec __user *uit)\n{\n\tint ret;\n\n\tret = get_timespec64(&it->it_interval, &uit->it_interval);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_timespec64(&it->it_value, &uit->it_value);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_timespec64",
          "args": [
            "&it->it_value",
            "&uit->it_value"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "get_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "781-801",
          "snippet": "int get_timespec64(struct timespec64 *ts,\n\t\t   const struct __kernel_timespec __user *uts)\n{\n\tstruct __kernel_timespec kts;\n\tint ret;\n\n\tret = copy_from_user(&kts, uts, sizeof(kts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tts->tv_sec = kts.tv_sec;\n\n\t/* Zero out the padding in compat mode */\n\tif (in_compat_syscall())\n\t\tkts.tv_nsec &= 0xFFFFFFFFUL;\n\n\t/* In 32-bit mode, this drops the padding */\n\tts->tv_nsec = kts.tv_nsec;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint get_timespec64(struct timespec64 *ts,\n\t\t   const struct __kernel_timespec __user *uts)\n{\n\tstruct __kernel_timespec kts;\n\tint ret;\n\n\tret = copy_from_user(&kts, uts, sizeof(kts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tts->tv_sec = kts.tv_sec;\n\n\t/* Zero out the padding in compat mode */\n\tif (in_compat_syscall())\n\t\tkts.tv_nsec &= 0xFFFFFFFFUL;\n\n\t/* In 32-bit mode, this drops the padding */\n\tts->tv_nsec = kts.tv_nsec;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint get_itimerspec64(struct itimerspec64 *it,\n\t\t\tconst struct __kernel_itimerspec __user *uit)\n{\n\tint ret;\n\n\tret = get_timespec64(&it->it_interval, &uit->it_interval);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_timespec64(&it->it_value, &uit->it_value);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "put_old_timespec32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "851-857",
    "snippet": "int put_old_timespec32(const struct timespec64 *ts, void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __put_old_timespec32(ts, uts);\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_old_timespec32",
          "args": [
            "ts",
            "uts"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "__put_old_timespec32",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "832-840",
          "snippet": "static int __put_old_timespec32(const struct timespec64 *ts64,\n\t\t\t\t   struct old_timespec32 __user *cts)\n{\n\tstruct old_timespec32 ts = {\n\t\t.tv_sec = ts64->tv_sec,\n\t\t.tv_nsec = ts64->tv_nsec\n\t};\n\treturn copy_to_user(cts, &ts, sizeof(ts)) ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int __put_old_timespec32(const struct timespec64 *ts64,\n\t\t\t\t   struct old_timespec32 __user *cts)\n{\n\tstruct old_timespec32 ts = {\n\t\t.tv_sec = ts64->tv_sec,\n\t\t.tv_nsec = ts64->tv_nsec\n\t};\n\treturn copy_to_user(cts, &ts, sizeof(ts)) ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uts",
            "ts",
            "sizeof(*ts)"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint put_old_timespec32(const struct timespec64 *ts, void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __put_old_timespec32(ts, uts);\n}"
  },
  {
    "function_name": "get_old_timespec32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "842-848",
    "snippet": "int get_old_timespec32(struct timespec64 *ts, const void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_from_user(ts, uts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __get_old_timespec32(ts, uts);\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_old_timespec32",
          "args": [
            "ts",
            "uts"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "__get_old_timespec32",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "816-830",
          "snippet": "static int __get_old_timespec32(struct timespec64 *ts64,\n\t\t\t\t   const struct old_timespec32 __user *cts)\n{\n\tstruct old_timespec32 ts;\n\tint ret;\n\n\tret = copy_from_user(&ts, cts, sizeof(ts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tts64->tv_sec = ts.tv_sec;\n\tts64->tv_nsec = ts.tv_nsec;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int __get_old_timespec32(struct timespec64 *ts64,\n\t\t\t\t   const struct old_timespec32 __user *cts)\n{\n\tstruct old_timespec32 ts;\n\tint ret;\n\n\tret = copy_from_user(&ts, cts, sizeof(ts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tts64->tv_sec = ts.tv_sec;\n\tts64->tv_nsec = ts.tv_nsec;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "ts",
            "uts",
            "sizeof(*ts)"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint get_old_timespec32(struct timespec64 *ts, const void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_from_user(ts, uts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __get_old_timespec32(ts, uts);\n}"
  },
  {
    "function_name": "__put_old_timespec32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "832-840",
    "snippet": "static int __put_old_timespec32(const struct timespec64 *ts64,\n\t\t\t\t   struct old_timespec32 __user *cts)\n{\n\tstruct old_timespec32 ts = {\n\t\t.tv_sec = ts64->tv_sec,\n\t\t.tv_nsec = ts64->tv_nsec\n\t};\n\treturn copy_to_user(cts, &ts, sizeof(ts)) ? -EFAULT : 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "cts",
            "&ts",
            "sizeof(ts)"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int __put_old_timespec32(const struct timespec64 *ts64,\n\t\t\t\t   struct old_timespec32 __user *cts)\n{\n\tstruct old_timespec32 ts = {\n\t\t.tv_sec = ts64->tv_sec,\n\t\t.tv_nsec = ts64->tv_nsec\n\t};\n\treturn copy_to_user(cts, &ts, sizeof(ts)) ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "__get_old_timespec32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "816-830",
    "snippet": "static int __get_old_timespec32(struct timespec64 *ts64,\n\t\t\t\t   const struct old_timespec32 __user *cts)\n{\n\tstruct old_timespec32 ts;\n\tint ret;\n\n\tret = copy_from_user(&ts, cts, sizeof(ts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tts64->tv_sec = ts.tv_sec;\n\tts64->tv_nsec = ts.tv_nsec;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&ts",
            "cts",
            "sizeof(ts)"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int __get_old_timespec32(struct timespec64 *ts64,\n\t\t\t\t   const struct old_timespec32 __user *cts)\n{\n\tstruct old_timespec32 ts;\n\tint ret;\n\n\tret = copy_from_user(&ts, cts, sizeof(ts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tts64->tv_sec = ts.tv_sec;\n\tts64->tv_nsec = ts.tv_nsec;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "put_timespec64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "804-813",
    "snippet": "int put_timespec64(const struct timespec64 *ts,\n\t\t   struct __kernel_timespec __user *uts)\n{\n\tstruct __kernel_timespec kts = {\n\t\t.tv_sec = ts->tv_sec,\n\t\t.tv_nsec = ts->tv_nsec\n\t};\n\n\treturn copy_to_user(uts, &kts, sizeof(kts)) ? -EFAULT : 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uts",
            "&kts",
            "sizeof(kts)"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint put_timespec64(const struct timespec64 *ts,\n\t\t   struct __kernel_timespec __user *uts)\n{\n\tstruct __kernel_timespec kts = {\n\t\t.tv_sec = ts->tv_sec,\n\t\t.tv_nsec = ts->tv_nsec\n\t};\n\n\treturn copy_to_user(uts, &kts, sizeof(kts)) ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "get_timespec64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "781-801",
    "snippet": "int get_timespec64(struct timespec64 *ts,\n\t\t   const struct __kernel_timespec __user *uts)\n{\n\tstruct __kernel_timespec kts;\n\tint ret;\n\n\tret = copy_from_user(&kts, uts, sizeof(kts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tts->tv_sec = kts.tv_sec;\n\n\t/* Zero out the padding in compat mode */\n\tif (in_compat_syscall())\n\t\tkts.tv_nsec &= 0xFFFFFFFFUL;\n\n\t/* In 32-bit mode, this drops the padding */\n\tts->tv_nsec = kts.tv_nsec;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_compat_syscall",
          "args": [],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&kts",
            "uts",
            "sizeof(kts)"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint get_timespec64(struct timespec64 *ts,\n\t\t   const struct __kernel_timespec __user *uts)\n{\n\tstruct __kernel_timespec kts;\n\tint ret;\n\n\tret = copy_from_user(&kts, uts, sizeof(kts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tts->tv_sec = kts.tv_sec;\n\n\t/* Zero out the padding in compat mode */\n\tif (in_compat_syscall())\n\t\tkts.tv_nsec &= 0xFFFFFFFFUL;\n\n\t/* In 32-bit mode, this drops the padding */\n\tts->tv_nsec = kts.tv_nsec;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "timespec64_add_safe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "765-779",
    "snippet": "struct timespec64 timespec64_add_safe(const struct timespec64 lhs,\n\t\t\t\tconst struct timespec64 rhs)\n{\n\tstruct timespec64 res;\n\n\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,\n\t\t\tlhs.tv_nsec + rhs.tv_nsec);\n\n\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {\n\t\tres.tv_sec = TIME64_MAX;\n\t\tres.tv_nsec = 0;\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_normalized_timespec64",
          "args": [
            "&res",
            "(timeu64_t) lhs.tv_sec + rhs.tv_sec",
            "lhs.tv_nsec + rhs.tv_nsec"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "set_normalized_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "478-497",
          "snippet": "void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >= NSEC_PER_SEC) {\n\t\t/*\n\t\t * The following asm() prevents the compiler from\n\t\t * optimising this loop into a modulo operation. See\n\t\t * also __iter_div_u64_rem() in include/linux/time.h\n\t\t */\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec -= NSEC_PER_SEC;\n\t\t++sec;\n\t}\n\twhile (nsec < 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += NSEC_PER_SEC;\n\t\t--sec;\n\t}\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >= NSEC_PER_SEC) {\n\t\t/*\n\t\t * The following asm() prevents the compiler from\n\t\t * optimising this loop into a modulo operation. See\n\t\t * also __iter_div_u64_rem() in include/linux/time.h\n\t\t */\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec -= NSEC_PER_SEC;\n\t\t++sec;\n\t}\n\twhile (nsec < 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += NSEC_PER_SEC;\n\t\t--sec;\n\t}\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 timespec64_add_safe(const struct timespec64 lhs,\n\t\t\t\tconst struct timespec64 rhs)\n{\n\tstruct timespec64 res;\n\n\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,\n\t\t\tlhs.tv_nsec + rhs.tv_nsec);\n\n\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {\n\t\tres.tv_sec = TIME64_MAX;\n\t\tres.tv_nsec = 0;\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "nsecs_to_jiffies",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "754-757",
    "snippet": "unsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nsecs_to_jiffies64",
          "args": [
            "n"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "nsecs_to_jiffies64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "723-738",
          "snippet": "u64 nsecs_to_jiffies64(u64 n)\n{\n#if (NSEC_PER_SEC % HZ) == 0\n\t/* Common case, HZ = 100, 128, 200, 250, 256, 500, 512, 1000 etc. */\n\treturn div_u64(n, NSEC_PER_SEC / HZ);\n#elif (HZ % 512) == 0\n\t/* overflow after 292 years if HZ = 1024 */\n\treturn div_u64(n * HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n\t * Generic case - optimized for cases where HZ is a multiple of 3.\n\t * overflow after 64.99 years, exact for HZ = 60, 72, 90, 120 etc.\n\t */\n\treturn div_u64(n * 9, (9ull * NSEC_PER_SEC + HZ / 2) / HZ);\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nu64 nsecs_to_jiffies64(u64 n)\n{\n#if (NSEC_PER_SEC % HZ) == 0\n\t/* Common case, HZ = 100, 128, 200, 250, 256, 500, 512, 1000 etc. */\n\treturn div_u64(n, NSEC_PER_SEC / HZ);\n#elif (HZ % 512) == 0\n\t/* overflow after 292 years if HZ = 1024 */\n\treturn div_u64(n * HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n\t * Generic case - optimized for cases where HZ is a multiple of 3.\n\t * overflow after 64.99 years, exact for HZ = 60, 72, 90, 120 etc.\n\t */\n\treturn div_u64(n * 9, (9ull * NSEC_PER_SEC + HZ / 2) / HZ);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}"
  },
  {
    "function_name": "nsecs_to_jiffies64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "723-738",
    "snippet": "u64 nsecs_to_jiffies64(u64 n)\n{\n#if (NSEC_PER_SEC % HZ) == 0\n\t/* Common case, HZ = 100, 128, 200, 250, 256, 500, 512, 1000 etc. */\n\treturn div_u64(n, NSEC_PER_SEC / HZ);\n#elif (HZ % 512) == 0\n\t/* overflow after 292 years if HZ = 1024 */\n\treturn div_u64(n * HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n\t * Generic case - optimized for cases where HZ is a multiple of 3.\n\t * overflow after 64.99 years, exact for HZ = 60, 72, 90, 120 etc.\n\t */\n\treturn div_u64(n * 9, (9ull * NSEC_PER_SEC + HZ / 2) / HZ);\n#endif\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "n * 9",
            "(9ull * NSEC_PER_SEC + HZ / 2) / HZ"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "n * HZ / 512",
            "NSEC_PER_SEC / 512"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "n",
            "NSEC_PER_SEC / HZ"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nu64 nsecs_to_jiffies64(u64 n)\n{\n#if (NSEC_PER_SEC % HZ) == 0\n\t/* Common case, HZ = 100, 128, 200, 250, 256, 500, 512, 1000 etc. */\n\treturn div_u64(n, NSEC_PER_SEC / HZ);\n#elif (HZ % 512) == 0\n\t/* overflow after 292 years if HZ = 1024 */\n\treturn div_u64(n * HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n\t * Generic case - optimized for cases where HZ is a multiple of 3.\n\t * overflow after 64.99 years, exact for HZ = 60, 72, 90, 120 etc.\n\t */\n\treturn div_u64(n * 9, (9ull * NSEC_PER_SEC + HZ / 2) / HZ);\n#endif\n}"
  },
  {
    "function_name": "jiffies64_to_msecs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "700-707",
    "snippet": "u64 jiffies64_to_msecs(const u64 j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#else\n\treturn div_u64(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n#endif\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "j * HZ_TO_MSEC_NUM",
            "HZ_TO_MSEC_DEN"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nu64 jiffies64_to_msecs(const u64 j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#else\n\treturn div_u64(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n#endif\n}"
  },
  {
    "function_name": "jiffies64_to_nsecs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "690-697",
    "snippet": "u64 jiffies64_to_nsecs(u64 j)\n{\n#if !(NSEC_PER_SEC % HZ)\n\treturn (NSEC_PER_SEC / HZ) * j;\n# else\n\treturn div_u64(j * HZ_TO_NSEC_NUM, HZ_TO_NSEC_DEN);\n#endif\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "j * HZ_TO_NSEC_NUM",
            "HZ_TO_NSEC_DEN"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nu64 jiffies64_to_nsecs(u64 j)\n{\n#if !(NSEC_PER_SEC % HZ)\n\treturn (NSEC_PER_SEC / HZ) * j;\n# else\n\treturn div_u64(j * HZ_TO_NSEC_NUM, HZ_TO_NSEC_DEN);\n#endif\n}"
  },
  {
    "function_name": "nsec_to_clock_t",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "674-688",
    "snippet": "u64 nsec_to_clock_t(u64 x)\n{\n#if (NSEC_PER_SEC % USER_HZ) == 0\n\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);\n#elif (USER_HZ % 512) == 0\n\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,\n         * overflow after 64.99 years.\n         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...\n         */\n\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);\n#endif\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "x * 9",
            "(9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "x * USER_HZ / 512",
            "NSEC_PER_SEC / 512"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "x",
            "NSEC_PER_SEC / USER_HZ"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nu64 nsec_to_clock_t(u64 x)\n{\n#if (NSEC_PER_SEC % USER_HZ) == 0\n\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);\n#elif (USER_HZ % 512) == 0\n\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,\n         * overflow after 64.99 years.\n         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...\n         */\n\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);\n#endif\n}"
  },
  {
    "function_name": "jiffies_64_to_clock_t",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "652-671",
    "snippet": "u64 jiffies_64_to_clock_t(u64 x)\n{\n#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0\n# if HZ < USER_HZ\n\tx = div_u64(x * USER_HZ, HZ);\n# elif HZ > USER_HZ\n\tx = div_u64(x, HZ / USER_HZ);\n# else\n\t/* Nothing to do */\n# endif\n#else\n\t/*\n\t * There are better ways that don't overflow early,\n\t * but even this doesn't overflow in hundreds of years\n\t * in 64 bits, so..\n\t */\n\tx = div_u64(x * TICK_NSEC, (NSEC_PER_SEC / USER_HZ));\n#endif\n\treturn x;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "x * TICK_NSEC",
            "(NSEC_PER_SEC / USER_HZ)"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "x",
            "HZ / USER_HZ"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "x * USER_HZ",
            "HZ"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nu64 jiffies_64_to_clock_t(u64 x)\n{\n#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0\n# if HZ < USER_HZ\n\tx = div_u64(x * USER_HZ, HZ);\n# elif HZ > USER_HZ\n\tx = div_u64(x, HZ / USER_HZ);\n# else\n\t/* Nothing to do */\n# endif\n#else\n\t/*\n\t * There are better ways that don't overflow early,\n\t * but even this doesn't overflow in hundreds of years\n\t * in 64 bits, so..\n\t */\n\tx = div_u64(x * TICK_NSEC, (NSEC_PER_SEC / USER_HZ));\n#endif\n\treturn x;\n}"
  },
  {
    "function_name": "clock_t_to_jiffies",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "635-649",
    "snippet": "unsigned long clock_t_to_jiffies(unsigned long x)\n{\n#if (HZ % USER_HZ)==0\n\tif (x >= ~0UL / (HZ / USER_HZ))\n\t\treturn ~0UL;\n\treturn x * (HZ / USER_HZ);\n#else\n\t/* Don't worry about loss of precision here .. */\n\tif (x >= ~0UL / HZ * USER_HZ)\n\t\treturn ~0UL;\n\n\t/* .. but do try to contain it here */\n\treturn div_u64((u64)x * HZ, USER_HZ);\n#endif\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "(u64)x * HZ",
            "USER_HZ"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long clock_t_to_jiffies(unsigned long x)\n{\n#if (HZ % USER_HZ)==0\n\tif (x >= ~0UL / (HZ / USER_HZ))\n\t\treturn ~0UL;\n\treturn x * (HZ / USER_HZ);\n#else\n\t/* Don't worry about loss of precision here .. */\n\tif (x >= ~0UL / HZ * USER_HZ)\n\t\treturn ~0UL;\n\n\t/* .. but do try to contain it here */\n\treturn div_u64((u64)x * HZ, USER_HZ);\n#endif\n}"
  },
  {
    "function_name": "jiffies_to_clock_t",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "621-632",
    "snippet": "clock_t jiffies_to_clock_t(unsigned long x)\n{\n#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0\n# if HZ < USER_HZ\n\treturn x * (USER_HZ / HZ);\n# else\n\treturn x / (HZ / USER_HZ);\n# endif\n#else\n\treturn div_u64((u64)x * TICK_NSEC, NSEC_PER_SEC / USER_HZ);\n#endif\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "(u64)x * TICK_NSEC",
            "NSEC_PER_SEC / USER_HZ"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nclock_t jiffies_to_clock_t(unsigned long x)\n{\n#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0\n# if HZ < USER_HZ\n\treturn x * (USER_HZ / HZ);\n# else\n\treturn x / (HZ / USER_HZ);\n# endif\n#else\n\treturn div_u64((u64)x * TICK_NSEC, NSEC_PER_SEC / USER_HZ);\n#endif\n}"
  },
  {
    "function_name": "jiffies_to_timespec64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "604-615",
    "snippet": "void\njiffies_to_timespec64(const unsigned long jiffies, struct timespec64 *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu32 rem;\n\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n\t\t\t\t    NSEC_PER_SEC, &rem);\n\tvalue->tv_nsec = rem;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64_rem",
          "args": [
            "(u64)jiffies * TICK_NSEC",
            "NSEC_PER_SEC",
            "&rem"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid\njiffies_to_timespec64(const unsigned long jiffies, struct timespec64 *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu32 rem;\n\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n\t\t\t\t    NSEC_PER_SEC, &rem);\n\tvalue->tv_nsec = rem;\n}"
  },
  {
    "function_name": "timespec64_to_jiffies",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "587-601",
    "snippet": "unsigned long\ntimespec64_to_jiffies(const struct timespec64 *value)\n{\n\tu64 sec = value->tv_sec;\n\tlong nsec = value->tv_nsec + TICK_NSEC - 1;\n\n\tif (sec >= MAX_SEC_IN_JIFFIES){\n\t\tsec = MAX_SEC_IN_JIFFIES;\n\t\tnsec = 0;\n\t}\n\treturn ((sec * SEC_CONVERSION) +\n\t\t(((u64)nsec * NSEC_CONVERSION) >>\n\t\t (NSEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;\n\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long\ntimespec64_to_jiffies(const struct timespec64 *value)\n{\n\tu64 sec = value->tv_sec;\n\tlong nsec = value->tv_nsec + TICK_NSEC - 1;\n\n\tif (sec >= MAX_SEC_IN_JIFFIES){\n\t\tsec = MAX_SEC_IN_JIFFIES;\n\t\tnsec = 0;\n\t}\n\treturn ((sec * SEC_CONVERSION) +\n\t\t(((u64)nsec * NSEC_CONVERSION) >>\n\t\t (NSEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;\n\n}"
  },
  {
    "function_name": "__usecs_to_jiffies",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "563-568",
    "snippet": "unsigned long __usecs_to_jiffies(const unsigned int u)\n{\n\tif (u > jiffies_to_usecs(MAX_JIFFY_OFFSET))\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _usecs_to_jiffies(u);\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_usecs_to_jiffies",
          "args": [
            "u"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "__usecs_to_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "563-568",
          "snippet": "unsigned long __usecs_to_jiffies(const unsigned int u)\n{\n\tif (u > jiffies_to_usecs(MAX_JIFFY_OFFSET))\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _usecs_to_jiffies(u);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "jiffies_to_usecs",
          "args": [
            "MAX_JIFFY_OFFSET"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "jiffies_to_usecs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "391-408",
          "snippet": "unsigned int jiffies_to_usecs(const unsigned long j)\n{\n\t/*\n\t * Hz usually doesn't go much further MSEC_PER_SEC.\n\t * jiffies_to_usecs() and usecs_to_jiffies() depend on that.\n\t */\n\tBUILD_BUG_ON(HZ > USEC_PER_SEC);\n\n#if !(USEC_PER_SEC % HZ)\n\treturn (USEC_PER_SEC / HZ) * j;\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_USEC_MUL32 * j) >> HZ_TO_USEC_SHR32;\n# else\n\treturn (j * HZ_TO_USEC_NUM) / HZ_TO_USEC_DEN;\n# endif\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned int jiffies_to_usecs(const unsigned long j)\n{\n\t/*\n\t * Hz usually doesn't go much further MSEC_PER_SEC.\n\t * jiffies_to_usecs() and usecs_to_jiffies() depend on that.\n\t */\n\tBUILD_BUG_ON(HZ > USEC_PER_SEC);\n\n#if !(USEC_PER_SEC % HZ)\n\treturn (USEC_PER_SEC / HZ) * j;\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_USEC_MUL32 * j) >> HZ_TO_USEC_SHR32;\n# else\n\treturn (j * HZ_TO_USEC_NUM) / HZ_TO_USEC_DEN;\n# endif\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long __usecs_to_jiffies(const unsigned int u)\n{\n\tif (u > jiffies_to_usecs(MAX_JIFFY_OFFSET))\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _usecs_to_jiffies(u);\n}"
  },
  {
    "function_name": "__msecs_to_jiffies",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "552-560",
    "snippet": "unsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_msecs_to_jiffies",
          "args": [
            "m"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "__msecs_to_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "552-560",
          "snippet": "unsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}"
  },
  {
    "function_name": "ns_to_timespec64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "506-525",
    "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64_rem",
          "args": [
            "-nsec - 1",
            "NSEC_PER_SEC",
            "&rem"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64_rem",
          "args": [
            "nsec",
            "NSEC_PER_SEC",
            "&rem"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "nsec > 0"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}"
  },
  {
    "function_name": "set_normalized_timespec64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "478-497",
    "snippet": "void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >= NSEC_PER_SEC) {\n\t\t/*\n\t\t * The following asm() prevents the compiler from\n\t\t * optimising this loop into a modulo operation. See\n\t\t * also __iter_div_u64_rem() in include/linux/time.h\n\t\t */\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec -= NSEC_PER_SEC;\n\t\t++sec;\n\t}\n\twhile (nsec < 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += NSEC_PER_SEC;\n\t\t--sec;\n\t}\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >= NSEC_PER_SEC) {\n\t\t/*\n\t\t * The following asm() prevents the compiler from\n\t\t * optimising this loop into a modulo operation. See\n\t\t * also __iter_div_u64_rem() in include/linux/time.h\n\t\t */\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec -= NSEC_PER_SEC;\n\t\t++sec;\n\t}\n\twhile (nsec < 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += NSEC_PER_SEC;\n\t\t--sec;\n\t}\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}"
  },
  {
    "function_name": "ns_to_kernel_old_timeval",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "452-461",
    "snippet": "struct __kernel_old_timeval ns_to_kernel_old_timeval(const s64 nsec)\n{\n\tstruct timespec64 ts = ns_to_timespec64(nsec);\n\tstruct __kernel_old_timeval tv;\n\n\ttv.tv_sec = ts.tv_sec;\n\ttv.tv_usec = (suseconds_t)ts.tv_nsec / 1000;\n\n\treturn tv;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "nsec"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "506-525",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct __kernel_old_timeval ns_to_kernel_old_timeval(const s64 nsec)\n{\n\tstruct timespec64 ts = ns_to_timespec64(nsec);\n\tstruct __kernel_old_timeval tv;\n\n\ttv.tv_sec = ts.tv_sec;\n\ttv.tv_usec = (suseconds_t)ts.tv_nsec / 1000;\n\n\treturn tv;\n}"
  },
  {
    "function_name": "mktime64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "431-449",
    "snippet": "time64_t mktime64(const unsigned int year0, const unsigned int mon0,\n\t\tconst unsigned int day, const unsigned int hour,\n\t\tconst unsigned int min, const unsigned int sec)\n{\n\tunsigned int mon = mon0, year = year0;\n\n\t/* 1..12 -> 11,12,1..10 */\n\tif (0 >= (int) (mon -= 2)) {\n\t\tmon += 12;\t/* Puts Feb last since it has leap day */\n\t\tyear -= 1;\n\t}\n\n\treturn ((((time64_t)\n\t\t  (year/4 - year/100 + year/400 + 367*mon/12 + day) +\n\t\t  year*365 - 719499\n\t    )*24 + hour /* now have hours - midnight tomorrow handled here */\n\t  )*60 + min /* now have minutes */\n\t)*60 + sec; /* finally seconds */\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "year/4 - year/100 + year/400 + 367*mon/12 + day"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\ntime64_t mktime64(const unsigned int year0, const unsigned int mon0,\n\t\tconst unsigned int day, const unsigned int hour,\n\t\tconst unsigned int min, const unsigned int sec)\n{\n\tunsigned int mon = mon0, year = year0;\n\n\t/* 1..12 -> 11,12,1..10 */\n\tif (0 >= (int) (mon -= 2)) {\n\t\tmon += 12;\t/* Puts Feb last since it has leap day */\n\t\tyear -= 1;\n\t}\n\n\treturn ((((time64_t)\n\t\t  (year/4 - year/100 + year/400 + 367*mon/12 + day) +\n\t\t  year*365 - 719499\n\t    )*24 + hour /* now have hours - midnight tomorrow handled here */\n\t  )*60 + min /* now have minutes */\n\t)*60 + sec; /* finally seconds */\n}"
  },
  {
    "function_name": "jiffies_to_usecs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "391-408",
    "snippet": "unsigned int jiffies_to_usecs(const unsigned long j)\n{\n\t/*\n\t * Hz usually doesn't go much further MSEC_PER_SEC.\n\t * jiffies_to_usecs() and usecs_to_jiffies() depend on that.\n\t */\n\tBUILD_BUG_ON(HZ > USEC_PER_SEC);\n\n#if !(USEC_PER_SEC % HZ)\n\treturn (USEC_PER_SEC / HZ) * j;\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_USEC_MUL32 * j) >> HZ_TO_USEC_SHR32;\n# else\n\treturn (j * HZ_TO_USEC_NUM) / HZ_TO_USEC_DEN;\n# endif\n#endif\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "HZ > USEC_PER_SEC"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned int jiffies_to_usecs(const unsigned long j)\n{\n\t/*\n\t * Hz usually doesn't go much further MSEC_PER_SEC.\n\t * jiffies_to_usecs() and usecs_to_jiffies() depend on that.\n\t */\n\tBUILD_BUG_ON(HZ > USEC_PER_SEC);\n\n#if !(USEC_PER_SEC % HZ)\n\treturn (USEC_PER_SEC / HZ) * j;\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_USEC_MUL32 * j) >> HZ_TO_USEC_SHR32;\n# else\n\treturn (j * HZ_TO_USEC_NUM) / HZ_TO_USEC_DEN;\n# endif\n#endif\n}"
  },
  {
    "function_name": "jiffies_to_msecs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "374-388",
    "snippet": "unsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "j * HZ_TO_MSEC_NUM",
            "HZ_TO_MSEC_DEN"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}"
  },
  {
    "function_name": "put_old_timex32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "318-347",
    "snippet": "int put_old_timex32(struct old_timex32 __user *utp, const struct __kernel_timex *txc)\n{\n\tstruct old_timex32 tx32;\n\n\tmemset(&tx32, 0, sizeof(struct old_timex32));\n\ttx32.modes = txc->modes;\n\ttx32.offset = txc->offset;\n\ttx32.freq = txc->freq;\n\ttx32.maxerror = txc->maxerror;\n\ttx32.esterror = txc->esterror;\n\ttx32.status = txc->status;\n\ttx32.constant = txc->constant;\n\ttx32.precision = txc->precision;\n\ttx32.tolerance = txc->tolerance;\n\ttx32.time.tv_sec = txc->time.tv_sec;\n\ttx32.time.tv_usec = txc->time.tv_usec;\n\ttx32.tick = txc->tick;\n\ttx32.ppsfreq = txc->ppsfreq;\n\ttx32.jitter = txc->jitter;\n\ttx32.shift = txc->shift;\n\ttx32.stabil = txc->stabil;\n\ttx32.jitcnt = txc->jitcnt;\n\ttx32.calcnt = txc->calcnt;\n\ttx32.errcnt = txc->errcnt;\n\ttx32.stbcnt = txc->stbcnt;\n\ttx32.tai = txc->tai;\n\tif (copy_to_user(utp, &tx32, sizeof(struct old_timex32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "utp",
            "&tx32",
            "sizeof(struct old_timex32)"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tx32",
            "0",
            "sizeof(struct old_timex32)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint put_old_timex32(struct old_timex32 __user *utp, const struct __kernel_timex *txc)\n{\n\tstruct old_timex32 tx32;\n\n\tmemset(&tx32, 0, sizeof(struct old_timex32));\n\ttx32.modes = txc->modes;\n\ttx32.offset = txc->offset;\n\ttx32.freq = txc->freq;\n\ttx32.maxerror = txc->maxerror;\n\ttx32.esterror = txc->esterror;\n\ttx32.status = txc->status;\n\ttx32.constant = txc->constant;\n\ttx32.precision = txc->precision;\n\ttx32.tolerance = txc->tolerance;\n\ttx32.time.tv_sec = txc->time.tv_sec;\n\ttx32.time.tv_usec = txc->time.tv_usec;\n\ttx32.tick = txc->tick;\n\ttx32.ppsfreq = txc->ppsfreq;\n\ttx32.jitter = txc->jitter;\n\ttx32.shift = txc->shift;\n\ttx32.stabil = txc->stabil;\n\ttx32.jitcnt = txc->jitcnt;\n\ttx32.calcnt = txc->calcnt;\n\ttx32.errcnt = txc->errcnt;\n\ttx32.stbcnt = txc->stbcnt;\n\ttx32.tai = txc->tai;\n\tif (copy_to_user(utp, &tx32, sizeof(struct old_timex32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_old_timex32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "286-316",
    "snippet": "int get_old_timex32(struct __kernel_timex *txc, const struct old_timex32 __user *utp)\n{\n\tstruct old_timex32 tx32;\n\n\tmemset(txc, 0, sizeof(struct __kernel_timex));\n\tif (copy_from_user(&tx32, utp, sizeof(struct old_timex32)))\n\t\treturn -EFAULT;\n\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&tx32",
            "utp",
            "sizeof(struct old_timex32)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "txc",
            "0",
            "sizeof(struct __kernel_timex)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint get_old_timex32(struct __kernel_timex *txc, const struct old_timex32 __user *utp)\n{\n\tstruct old_timex32 tx32;\n\n\tmemset(txc, 0, sizeof(struct __kernel_timex));\n\tif (copy_from_user(&tx32, utp, sizeof(struct old_timex32)))\n\t\treturn -EFAULT;\n\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_sys_settimeofday64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "169-197",
    "snippet": "int do_sys_settimeofday64(const struct timespec64 *tv, const struct timezone *tz)\n{\n\tstatic int firsttime = 1;\n\tint error = 0;\n\n\tif (tv && !timespec64_valid_settod(tv))\n\t\treturn -EINVAL;\n\n\terror = security_settime64(tv, tz);\n\tif (error)\n\t\treturn error;\n\n\tif (tz) {\n\t\t/* Verify we're within the +-15 hrs range */\n\t\tif (tz->tz_minuteswest > 15*60 || tz->tz_minuteswest < -15*60)\n\t\t\treturn -EINVAL;\n\n\t\tsys_tz = *tz;\n\t\tupdate_vsyscall_tz();\n\t\tif (firsttime) {\n\t\t\tfirsttime = 0;\n\t\t\tif (!tv)\n\t\t\t\ttimekeeping_warp_clock();\n\t\t}\n\t}\n\tif (tv)\n\t\treturn do_settimeofday64(tv);\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct timezone sys_tz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_settimeofday64",
          "args": [
            "tv"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "do_settimeofday64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1293-1332",
          "snippet": "int do_settimeofday64(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 ts_delta, xt;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!timespec64_valid_settod(ts))\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\txt = tk_xtime(tk);\n\tts_delta = timespec64_sub(*ts, xt);\n\n\tif (timespec64_compare(&tk->wall_to_monotonic, &ts_delta) > 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, ts_delta));\n\n\ttk_set_xtime(tk, ts);\nout:\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Signal hrtimers about time change */\n\tclock_was_set(CLOCK_SET_WALL);\n\n\tif (!ret)\n\t\taudit_tk_injoffset(ts_delta);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nint do_settimeofday64(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 ts_delta, xt;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!timespec64_valid_settod(ts))\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\txt = tk_xtime(tk);\n\tts_delta = timespec64_sub(*ts, xt);\n\n\tif (timespec64_compare(&tk->wall_to_monotonic, &ts_delta) > 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, ts_delta));\n\n\ttk_set_xtime(tk, ts);\nout:\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Signal hrtimers about time change */\n\tclock_was_set(CLOCK_SET_WALL);\n\n\tif (!ret)\n\t\taudit_tk_injoffset(ts_delta);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_warp_clock",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_warp_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1401-1411",
          "snippet": "void timekeeping_warp_clock(void)\n{\n\tif (sys_tz.tz_minuteswest != 0) {\n\t\tstruct timespec64 adjust;\n\n\t\tpersistent_clock_is_local = 1;\n\t\tadjust.tv_sec = sys_tz.tz_minuteswest * 60;\n\t\tadjust.tv_nsec = 0;\n\t\ttimekeeping_inject_offset(&adjust);\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int persistent_clock_is_local;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint persistent_clock_is_local;\n\nvoid timekeeping_warp_clock(void)\n{\n\tif (sys_tz.tz_minuteswest != 0) {\n\t\tstruct timespec64 adjust;\n\n\t\tpersistent_clock_is_local = 1;\n\t\tadjust.tv_sec = sys_tz.tz_minuteswest * 60;\n\t\tadjust.tv_nsec = 0;\n\t\ttimekeeping_inject_offset(&adjust);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_vsyscall_tz",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "update_vsyscall_tz",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/vsyscall.c",
          "lines": "123-131",
          "snippet": "void update_vsyscall_tz(void)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\n\tvdata[CS_HRES_COARSE].tz_minuteswest = sys_tz.tz_minuteswest;\n\tvdata[CS_HRES_COARSE].tz_dsttime = sys_tz.tz_dsttime;\n\n\t__arch_sync_vdso_data(vdata);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include <vdso/vsyscall.h>",
            "#include <vdso/helpers.h>",
            "#include <vdso/datapage.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include <vdso/vsyscall.h>\n#include <vdso/helpers.h>\n#include <vdso/datapage.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/hrtimer.h>\n\nvoid update_vsyscall_tz(void)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\n\tvdata[CS_HRES_COARSE].tz_minuteswest = sys_tz.tz_minuteswest;\n\tvdata[CS_HRES_COARSE].tz_dsttime = sys_tz.tz_dsttime;\n\n\t__arch_sync_vdso_data(vdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_settime64",
          "args": [
            "tv",
            "tz"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_valid_settod",
          "args": [
            "tv"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timezone sys_tz;\n\nint do_sys_settimeofday64(const struct timespec64 *tv, const struct timezone *tz)\n{\n\tstatic int firsttime = 1;\n\tint error = 0;\n\n\tif (tv && !timespec64_valid_settod(tv))\n\t\treturn -EINVAL;\n\n\terror = security_settime64(tv, tz);\n\tif (error)\n\t\treturn error;\n\n\tif (tz) {\n\t\t/* Verify we're within the +-15 hrs range */\n\t\tif (tz->tz_minuteswest > 15*60 || tz->tz_minuteswest < -15*60)\n\t\t\treturn -EINVAL;\n\n\t\tsys_tz = *tz;\n\t\tupdate_vsyscall_tz();\n\t\tif (firsttime) {\n\t\t\tfirsttime = 0;\n\t\t\tif (!tv)\n\t\t\t\ttimekeeping_warp_clock();\n\t\t}\n\t}\n\tif (tv)\n\t\treturn do_settimeofday64(tv);\n\treturn 0;\n}"
  },
  {
    "function_name": "time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "62-72",
    "snippet": "SYSCALL_DEFINE1(time, __kernel_old_time_t __user *, tloc)\n{\n\t__kernel_old_time_t i = (__kernel_old_time_t)ktime_get_real_seconds();\n\n\tif (tloc) {\n\t\tif (put_user(i,tloc))\n\t\t\treturn -EFAULT;\n\t}\n\tforce_successful_syscall_return();\n\treturn i;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nSYSCALL_DEFINE1(time, __kernel_old_time_t __user *, tloc)\n{\n\t__kernel_old_time_t i = (__kernel_old_time_t)ktime_get_real_seconds();\n\n\tif (tloc) {\n\t\tif (put_user(i,tloc))\n\t\t\treturn -EFAULT;\n\t}\n\tforce_successful_syscall_return();\n\treturn i;\n}"
  },
  {
    "function_name": "stime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "81-97",
    "snippet": "SYSCALL_DEFINE1(stime, __kernel_old_time_t __user *, tptr)\n{\n\tstruct timespec64 tv;\n\tint err;\n\n\tif (get_user(tv.tv_sec, tptr))\n\t\treturn -EFAULT;\n\n\ttv.tv_nsec = 0;\n\n\terr = security_settime64(&tv, NULL);\n\tif (err)\n\t\treturn err;\n\n\tdo_settimeofday64(&tv);\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nSYSCALL_DEFINE1(stime, __kernel_old_time_t __user *, tptr)\n{\n\tstruct timespec64 tv;\n\tint err;\n\n\tif (get_user(tv.tv_sec, tptr))\n\t\treturn -EFAULT;\n\n\ttv.tv_nsec = 0;\n\n\terr = security_settime64(&tv, NULL);\n\tif (err)\n\t\treturn err;\n\n\tdo_settimeofday64(&tv);\n\treturn 0;\n}"
  },
  {
    "function_name": "time32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "105-117",
    "snippet": "SYSCALL_DEFINE1(time32, old_time32_t __user *, tloc)\n{\n\told_time32_t i;\n\n\ti = (old_time32_t)ktime_get_real_seconds();\n\n\tif (tloc) {\n\t\tif (put_user(i,tloc))\n\t\t\treturn -EFAULT;\n\t}\n\tforce_successful_syscall_return();\n\treturn i;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nSYSCALL_DEFINE1(time32, old_time32_t __user *, tloc)\n{\n\told_time32_t i;\n\n\ti = (old_time32_t)ktime_get_real_seconds();\n\n\tif (tloc) {\n\t\tif (put_user(i,tloc))\n\t\t\treturn -EFAULT;\n\t}\n\tforce_successful_syscall_return();\n\treturn i;\n}"
  },
  {
    "function_name": "stime32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "119-135",
    "snippet": "SYSCALL_DEFINE1(stime32, old_time32_t __user *, tptr)\n{\n\tstruct timespec64 tv;\n\tint err;\n\n\tif (get_user(tv.tv_sec, tptr))\n\t\treturn -EFAULT;\n\n\ttv.tv_nsec = 0;\n\n\terr = security_settime64(&tv, NULL);\n\tif (err)\n\t\treturn err;\n\n\tdo_settimeofday64(&tv);\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nSYSCALL_DEFINE1(stime32, old_time32_t __user *, tptr)\n{\n\tstruct timespec64 tv;\n\tint err;\n\n\tif (get_user(tv.tv_sec, tptr))\n\t\treturn -EFAULT;\n\n\ttv.tv_nsec = 0;\n\n\terr = security_settime64(&tv, NULL);\n\tif (err)\n\t\treturn err;\n\n\tdo_settimeofday64(&tv);\n\treturn 0;\n}"
  },
  {
    "function_name": "gettimeofday",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "140-156",
    "snippet": "SYSCALL_DEFINE2(gettimeofday, struct __kernel_old_timeval __user *, tv,\n\t\tstruct timezone __user *, tz)\n{\n\tif (likely(tv != NULL)) {\n\t\tstruct timespec64 ts;\n\n\t\tktime_get_real_ts64(&ts);\n\t\tif (put_user(ts.tv_sec, &tv->tv_sec) ||\n\t\t    put_user(ts.tv_nsec / 1000, &tv->tv_usec))\n\t\t\treturn -EFAULT;\n\t}\n\tif (unlikely(tz != NULL)) {\n\t\tif (copy_to_user(tz, &sys_tz, sizeof(sys_tz)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct timezone sys_tz;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timezone sys_tz;\n\nSYSCALL_DEFINE2(gettimeofday, struct __kernel_old_timeval __user *, tv,\n\t\tstruct timezone __user *, tz)\n{\n\tif (likely(tv != NULL)) {\n\t\tstruct timespec64 ts;\n\n\t\tktime_get_real_ts64(&ts);\n\t\tif (put_user(ts.tv_sec, &tv->tv_sec) ||\n\t\t    put_user(ts.tv_nsec / 1000, &tv->tv_usec))\n\t\t\treturn -EFAULT;\n\t}\n\tif (unlikely(tz != NULL)) {\n\t\tif (copy_to_user(tz, &sys_tz, sizeof(sys_tz)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "settimeofday",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "199-221",
    "snippet": "SYSCALL_DEFINE2(settimeofday, struct __kernel_old_timeval __user *, tv,\n\t\tstruct timezone __user *, tz)\n{\n\tstruct timespec64 new_ts;\n\tstruct timezone new_tz;\n\n\tif (tv) {\n\t\tif (get_user(new_ts.tv_sec, &tv->tv_sec) ||\n\t\t    get_user(new_ts.tv_nsec, &tv->tv_usec))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_ts.tv_nsec > USEC_PER_SEC || new_ts.tv_nsec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tnew_ts.tv_nsec *= NSEC_PER_USEC;\n\t}\n\tif (tz) {\n\t\tif (copy_from_user(&new_tz, tz, sizeof(*tz)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn do_sys_settimeofday64(tv ? &new_ts : NULL, tz ? &new_tz : NULL);\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nSYSCALL_DEFINE2(settimeofday, struct __kernel_old_timeval __user *, tv,\n\t\tstruct timezone __user *, tz)\n{\n\tstruct timespec64 new_ts;\n\tstruct timezone new_tz;\n\n\tif (tv) {\n\t\tif (get_user(new_ts.tv_sec, &tv->tv_sec) ||\n\t\t    get_user(new_ts.tv_nsec, &tv->tv_usec))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_ts.tv_nsec > USEC_PER_SEC || new_ts.tv_nsec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tnew_ts.tv_nsec *= NSEC_PER_USEC;\n\t}\n\tif (tz) {\n\t\tif (copy_from_user(&new_tz, tz, sizeof(*tz)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn do_sys_settimeofday64(tv ? &new_ts : NULL, tz ? &new_tz : NULL);\n}"
  },
  {
    "function_name": "gettimeofday",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "224-241",
    "snippet": "SYSCALL_DEFINE2(gettimeofday, struct old_timeval32 __user *, tv,\n\t\t       struct timezone __user *, tz)\n{\n\tif (tv) {\n\t\tstruct timespec64 ts;\n\n\t\tktime_get_real_ts64(&ts);\n\t\tif (put_user(ts.tv_sec, &tv->tv_sec) ||\n\t\t    put_user(ts.tv_nsec / 1000, &tv->tv_usec))\n\t\t\treturn -EFAULT;\n\t}\n\tif (tz) {\n\t\tif (copy_to_user(tz, &sys_tz, sizeof(sys_tz)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct timezone sys_tz;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timezone sys_tz;\n\nSYSCALL_DEFINE2(gettimeofday, struct old_timeval32 __user *, tv,\n\t\t       struct timezone __user *, tz)\n{\n\tif (tv) {\n\t\tstruct timespec64 ts;\n\n\t\tktime_get_real_ts64(&ts);\n\t\tif (put_user(ts.tv_sec, &tv->tv_sec) ||\n\t\t    put_user(ts.tv_nsec / 1000, &tv->tv_usec))\n\t\t\treturn -EFAULT;\n\t}\n\tif (tz) {\n\t\tif (copy_to_user(tz, &sys_tz, sizeof(sys_tz)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "settimeofday",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "243-265",
    "snippet": "SYSCALL_DEFINE2(settimeofday, struct old_timeval32 __user *, tv,\n\t\t       struct timezone __user *, tz)\n{\n\tstruct timespec64 new_ts;\n\tstruct timezone new_tz;\n\n\tif (tv) {\n\t\tif (get_user(new_ts.tv_sec, &tv->tv_sec) ||\n\t\t    get_user(new_ts.tv_nsec, &tv->tv_usec))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_ts.tv_nsec > USEC_PER_SEC || new_ts.tv_nsec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tnew_ts.tv_nsec *= NSEC_PER_USEC;\n\t}\n\tif (tz) {\n\t\tif (copy_from_user(&new_tz, tz, sizeof(*tz)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn do_sys_settimeofday64(tv ? &new_ts : NULL, tz ? &new_tz : NULL);\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nSYSCALL_DEFINE2(settimeofday, struct old_timeval32 __user *, tv,\n\t\t       struct timezone __user *, tz)\n{\n\tstruct timespec64 new_ts;\n\tstruct timezone new_tz;\n\n\tif (tv) {\n\t\tif (get_user(new_ts.tv_sec, &tv->tv_sec) ||\n\t\t    get_user(new_ts.tv_nsec, &tv->tv_usec))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_ts.tv_nsec > USEC_PER_SEC || new_ts.tv_nsec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tnew_ts.tv_nsec *= NSEC_PER_USEC;\n\t}\n\tif (tz) {\n\t\tif (copy_from_user(&new_tz, tz, sizeof(*tz)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn do_sys_settimeofday64(tv ? &new_ts : NULL, tz ? &new_tz : NULL);\n}"
  },
  {
    "function_name": "adjtimex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "269-282",
    "snippet": "SYSCALL_DEFINE1(adjtimex, struct __kernel_timex __user *, txc_p)\n{\n\tstruct __kernel_timex txc;\t\t/* Local copy of parameter */\n\tint ret;\n\n\t/* Copy the user data space into the kernel copy\n\t * structure. But bear in mind that the structures\n\t * may change\n\t */\n\tif (copy_from_user(&txc, txc_p, sizeof(struct __kernel_timex)))\n\t\treturn -EFAULT;\n\tret = do_adjtimex(&txc);\n\treturn copy_to_user(txc_p, &txc, sizeof(struct __kernel_timex)) ? -EFAULT : ret;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nSYSCALL_DEFINE1(adjtimex, struct __kernel_timex __user *, txc_p)\n{\n\tstruct __kernel_timex txc;\t\t/* Local copy of parameter */\n\tint ret;\n\n\t/* Copy the user data space into the kernel copy\n\t * structure. But bear in mind that the structures\n\t * may change\n\t */\n\tif (copy_from_user(&txc, txc_p, sizeof(struct __kernel_timex)))\n\t\treturn -EFAULT;\n\tret = do_adjtimex(&txc);\n\treturn copy_to_user(txc_p, &txc, sizeof(struct __kernel_timex)) ? -EFAULT : ret;\n}"
  },
  {
    "function_name": "adjtimex_time32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
    "lines": "349-365",
    "snippet": "SYSCALL_DEFINE1(adjtimex_time32, struct old_timex32 __user *, utp)\n{\n\tstruct __kernel_timex txc;\n\tint err, ret;\n\n\terr = get_old_timex32(&txc, utp);\n\tif (err)\n\t\treturn err;\n\n\tret = do_adjtimex(&txc);\n\n\terr = put_old_timex32(utp, &txc);\n\tif (err)\n\t\treturn err;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <generated/timeconst.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/math64.h>",
      "#include <linux/fs.h>",
      "#include <linux/security.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/errno.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/capability.h>",
      "#include <linux/timex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nSYSCALL_DEFINE1(adjtimex_time32, struct old_timex32 __user *, utp)\n{\n\tstruct __kernel_timex txc;\n\tint err, ret;\n\n\terr = get_old_timex32(&txc, utp);\n\tif (err)\n\t\treturn err;\n\n\tret = do_adjtimex(&txc);\n\n\terr = put_old_timex32(utp, &txc);\n\tif (err)\n\t\treturn err;\n\n\treturn ret;\n}"
  }
]