[
  {
    "function_name": "rmem_cma_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/contiguous.c",
    "lines": "245-280",
    "snippet": "static int __init rmem_cma_setup(struct reserved_mem *rmem)\n{\n\tphys_addr_t align = PAGE_SIZE << max(MAX_ORDER - 1, pageblock_order);\n\tphys_addr_t mask = align - 1;\n\tunsigned long node = rmem->fdt_node;\n\tstruct cma *cma;\n\tint err;\n\n\tif (!of_get_flat_dt_prop(node, \"reusable\", NULL) ||\n\t    of_get_flat_dt_prop(node, \"no-map\", NULL))\n\t\treturn -EINVAL;\n\n\tif ((rmem->base & mask) || (rmem->size & mask)) {\n\t\tpr_err(\"Reserved memory: incorrect alignment of CMA region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = cma_init_reserved_mem(rmem->base, rmem->size, 0, rmem->name, &cma);\n\tif (err) {\n\t\tpr_err(\"Reserved memory: unable to setup CMA region\\n\");\n\t\treturn err;\n\t}\n\t/* Architecture specific contiguous memory fixup. */\n\tdma_contiguous_early_fixup(rmem->base, rmem->size);\n\n\tif (of_get_flat_dt_prop(node, \"linux,cma-default\", NULL))\n\t\tdma_contiguous_set_default(cma);\n\n\trmem->ops = &rmem_cma_ops;\n\trmem->priv = cma;\n\n\tpr_info(\"Reserved memory: created CMA memory pool at %pa, size %ld MiB\\n\",\n\t\t&rmem->base, (unsigned long)rmem->size / SZ_1M);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/cma.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/sizes.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <asm/dma-contiguous.h>",
      "#include <asm/page.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Reserved memory: created CMA memory pool at %pa, size %ld MiB\\n\"",
            "&rmem->base",
            "(unsigned long)rmem->size / SZ_1M"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_contiguous_set_default",
          "args": [
            "cma"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,cma-default\"",
            "NULL"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_contiguous_early_fixup",
          "args": [
            "rmem->base",
            "rmem->size"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Reserved memory: unable to setup CMA region\\n\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_init_reserved_mem",
          "args": [
            "rmem->base",
            "rmem->size",
            "0",
            "rmem->name",
            "&cma"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Reserved memory: incorrect alignment of CMA region\\n\""
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"no-map\"",
            "NULL"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"reusable\"",
            "NULL"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "MAX_ORDER - 1",
            "pageblock_order"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-contiguous.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/dma-contiguous.h>\n#include <asm/page.h>\n\nstatic int __init rmem_cma_setup(struct reserved_mem *rmem)\n{\n\tphys_addr_t align = PAGE_SIZE << max(MAX_ORDER - 1, pageblock_order);\n\tphys_addr_t mask = align - 1;\n\tunsigned long node = rmem->fdt_node;\n\tstruct cma *cma;\n\tint err;\n\n\tif (!of_get_flat_dt_prop(node, \"reusable\", NULL) ||\n\t    of_get_flat_dt_prop(node, \"no-map\", NULL))\n\t\treturn -EINVAL;\n\n\tif ((rmem->base & mask) || (rmem->size & mask)) {\n\t\tpr_err(\"Reserved memory: incorrect alignment of CMA region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = cma_init_reserved_mem(rmem->base, rmem->size, 0, rmem->name, &cma);\n\tif (err) {\n\t\tpr_err(\"Reserved memory: unable to setup CMA region\\n\");\n\t\treturn err;\n\t}\n\t/* Architecture specific contiguous memory fixup. */\n\tdma_contiguous_early_fixup(rmem->base, rmem->size);\n\n\tif (of_get_flat_dt_prop(node, \"linux,cma-default\", NULL))\n\t\tdma_contiguous_set_default(cma);\n\n\trmem->ops = &rmem_cma_ops;\n\trmem->priv = cma;\n\n\tpr_info(\"Reserved memory: created CMA memory pool at %pa, size %ld MiB\\n\",\n\t\t&rmem->base, (unsigned long)rmem->size / SZ_1M);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rmem_cma_device_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/contiguous.c",
    "lines": "234-238",
    "snippet": "static void rmem_cma_device_release(struct reserved_mem *rmem,\n\t\t\t\t    struct device *dev)\n{\n\tdev_set_cma_area(dev, NULL);\n}",
    "includes": [
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/cma.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/sizes.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <asm/dma-contiguous.h>",
      "#include <asm/page.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_set_cma_area",
          "args": [
            "dev",
            "NULL"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-contiguous.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/dma-contiguous.h>\n#include <asm/page.h>\n\nstatic void rmem_cma_device_release(struct reserved_mem *rmem,\n\t\t\t\t    struct device *dev)\n{\n\tdev_set_cma_area(dev, NULL);\n}"
  },
  {
    "function_name": "rmem_cma_device_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/contiguous.c",
    "lines": "228-232",
    "snippet": "static int rmem_cma_device_init(struct reserved_mem *rmem, struct device *dev)\n{\n\tdev_set_cma_area(dev, rmem->priv);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/cma.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/sizes.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <asm/dma-contiguous.h>",
      "#include <asm/page.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_set_cma_area",
          "args": [
            "dev",
            "rmem->priv"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-contiguous.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/dma-contiguous.h>\n#include <asm/page.h>\n\nstatic int rmem_cma_device_init(struct reserved_mem *rmem, struct device *dev)\n{\n\tdev_set_cma_area(dev, rmem->priv);\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_release_from_contiguous",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/contiguous.c",
    "lines": "211-215",
    "snippet": "bool dma_release_from_contiguous(struct device *dev, struct page *pages,\n\t\t\t\t int count)\n{\n\treturn cma_release(dev_get_cma_area(dev), pages, count);\n}",
    "includes": [
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/cma.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/sizes.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <asm/dma-contiguous.h>",
      "#include <asm/page.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cma_release",
          "args": [
            "dev_get_cma_area(dev)",
            "pages",
            "count"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_get_cma_area",
          "args": [
            "dev"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-contiguous.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/dma-contiguous.h>\n#include <asm/page.h>\n\nbool dma_release_from_contiguous(struct device *dev, struct page *pages,\n\t\t\t\t int count)\n{\n\treturn cma_release(dev_get_cma_area(dev), pages, count);\n}"
  },
  {
    "function_name": "dma_alloc_from_contiguous",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/contiguous.c",
    "lines": "192-199",
    "snippet": "struct page *dma_alloc_from_contiguous(struct device *dev, size_t count,\n\t\t\t\t       unsigned int align, bool no_warn)\n{\n\tif (align > CONFIG_CMA_ALIGNMENT)\n\t\talign = CONFIG_CMA_ALIGNMENT;\n\n\treturn cma_alloc(dev_get_cma_area(dev), count, align, no_warn);\n}",
    "includes": [
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/cma.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/sizes.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <asm/dma-contiguous.h>",
      "#include <asm/page.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cma_alloc",
          "args": [
            "dev_get_cma_area(dev)",
            "count",
            "align",
            "no_warn"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_get_cma_area",
          "args": [
            "dev"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-contiguous.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/dma-contiguous.h>\n#include <asm/page.h>\n\nstruct page *dma_alloc_from_contiguous(struct device *dev, size_t count,\n\t\t\t\t       unsigned int align, bool no_warn)\n{\n\tif (align > CONFIG_CMA_ALIGNMENT)\n\t\talign = CONFIG_CMA_ALIGNMENT;\n\n\treturn cma_alloc(dev_get_cma_area(dev), count, align, no_warn);\n}"
  },
  {
    "function_name": "dma_contiguous_reserve_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/contiguous.c",
    "lines": "162-178",
    "snippet": "int __init dma_contiguous_reserve_area(phys_addr_t size, phys_addr_t base,\n\t\t\t\t       phys_addr_t limit, struct cma **res_cma,\n\t\t\t\t       bool fixed)\n{\n\tint ret;\n\n\tret = cma_declare_contiguous(base, size, limit, 0, 0, fixed,\n\t\t\t\t\t\"reserved\", res_cma);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Architecture specific contiguous memory fixup. */\n\tdma_contiguous_early_fixup(cma_get_base(*res_cma),\n\t\t\t\tcma_get_size(*res_cma));\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/cma.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/sizes.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <asm/dma-contiguous.h>",
      "#include <asm/page.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_contiguous_early_fixup",
          "args": [
            "cma_get_base(*res_cma)",
            "cma_get_size(*res_cma)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_get_size",
          "args": [
            "*res_cma"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_get_base",
          "args": [
            "*res_cma"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_declare_contiguous",
          "args": [
            "base",
            "size",
            "limit",
            "0",
            "0",
            "fixed",
            "\"reserved\"",
            "res_cma"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-contiguous.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/dma-contiguous.h>\n#include <asm/page.h>\n\nint __init dma_contiguous_reserve_area(phys_addr_t size, phys_addr_t base,\n\t\t\t\t       phys_addr_t limit, struct cma **res_cma,\n\t\t\t\t       bool fixed)\n{\n\tint ret;\n\n\tret = cma_declare_contiguous(base, size, limit, 0, 0, fixed,\n\t\t\t\t\t\"reserved\", res_cma);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Architecture specific contiguous memory fixup. */\n\tdma_contiguous_early_fixup(cma_get_base(*res_cma),\n\t\t\t\tcma_get_size(*res_cma));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_contiguous_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/contiguous.c",
    "lines": "107-143",
    "snippet": "void __init dma_contiguous_reserve(phys_addr_t limit)\n{\n\tphys_addr_t selected_size = 0;\n\tphys_addr_t selected_base = 0;\n\tphys_addr_t selected_limit = limit;\n\tbool fixed = false;\n\n\tpr_debug(\"%s(limit %08lx)\\n\", __func__, (unsigned long)limit);\n\n\tif (size_cmdline != -1) {\n\t\tselected_size = size_cmdline;\n\t\tselected_base = base_cmdline;\n\t\tselected_limit = min_not_zero(limit_cmdline, limit);\n\t\tif (base_cmdline + size_cmdline == limit_cmdline)\n\t\t\tfixed = true;\n\t} else {\n#ifdef CONFIG_CMA_SIZE_SEL_MBYTES\n\t\tselected_size = size_bytes;\n#elif defined(CONFIG_CMA_SIZE_SEL_PERCENTAGE)\n\t\tselected_size = cma_early_percent_memory();\n#elif defined(CONFIG_CMA_SIZE_SEL_MIN)\n\t\tselected_size = min(size_bytes, cma_early_percent_memory());\n#elif defined(CONFIG_CMA_SIZE_SEL_MAX)\n\t\tselected_size = max(size_bytes, cma_early_percent_memory());\n#endif\n\t}\n\n\tif (selected_size && !dma_contiguous_default_area) {\n\t\tpr_debug(\"%s: reserving %ld MiB for global area\\n\", __func__,\n\t\t\t (unsigned long)selected_size / SZ_1M);\n\n\t\tdma_contiguous_reserve_area(selected_size, selected_base,\n\t\t\t\t\t    selected_limit,\n\t\t\t\t\t    &dma_contiguous_default_area,\n\t\t\t\t\t    fixed);\n\t}\n}",
    "includes": [
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/cma.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/sizes.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <asm/dma-contiguous.h>",
      "#include <asm/page.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cma *dma_contiguous_default_area;",
      "static const phys_addr_t size_bytes = (phys_addr_t)CMA_SIZE_MBYTES * SZ_1M;",
      "static phys_addr_t size_cmdline = -1;",
      "static phys_addr_t base_cmdline;",
      "static phys_addr_t limit_cmdline;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_contiguous_reserve_area",
          "args": [
            "selected_size",
            "selected_base",
            "selected_limit",
            "&dma_contiguous_default_area",
            "fixed"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "dma_contiguous_reserve_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/contiguous.c",
          "lines": "162-178",
          "snippet": "int __init dma_contiguous_reserve_area(phys_addr_t size, phys_addr_t base,\n\t\t\t\t       phys_addr_t limit, struct cma **res_cma,\n\t\t\t\t       bool fixed)\n{\n\tint ret;\n\n\tret = cma_declare_contiguous(base, size, limit, 0, 0, fixed,\n\t\t\t\t\t\"reserved\", res_cma);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Architecture specific contiguous memory fixup. */\n\tdma_contiguous_early_fixup(cma_get_base(*res_cma),\n\t\t\t\tcma_get_size(*res_cma));\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/cma.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/sizes.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <asm/dma-contiguous.h>",
            "#include <asm/page.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-contiguous.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/dma-contiguous.h>\n#include <asm/page.h>\n\nint __init dma_contiguous_reserve_area(phys_addr_t size, phys_addr_t base,\n\t\t\t\t       phys_addr_t limit, struct cma **res_cma,\n\t\t\t\t       bool fixed)\n{\n\tint ret;\n\n\tret = cma_declare_contiguous(base, size, limit, 0, 0, fixed,\n\t\t\t\t\t\"reserved\", res_cma);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Architecture specific contiguous memory fixup. */\n\tdma_contiguous_early_fixup(cma_get_base(*res_cma),\n\t\t\t\tcma_get_size(*res_cma));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: reserving %ld MiB for global area\\n\"",
            "__func__",
            "(unsigned long)selected_size / SZ_1M"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "size_bytes",
            "cma_early_percent_memory()"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cma_early_percent_memory",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "cma_early_percent_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/contiguous.c",
          "lines": "73-87",
          "snippet": "__maybe_unused cma_early_percent_memory(void)\n{\n\tstruct memblock_region *reg;\n\tunsigned long total_pages = 0;\n\n\t/*\n\t * We cannot use memblock_phys_mem_size() here, because\n\t * memblock_analyze() has not been called yet.\n\t */\n\tfor_each_memblock(memory, reg)\n\t\ttotal_pages += memblock_region_memory_end_pfn(reg) -\n\t\t\t       memblock_region_memory_base_pfn(reg);\n\n\treturn (total_pages * CONFIG_CMA_SIZE_PERCENTAGE / 100) << PAGE_SHIFT;\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/cma.h>",
            "#include <linux/dma-contiguous.h>",
            "#include <linux/sizes.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <asm/dma-contiguous.h>",
            "#include <asm/page.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-contiguous.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/dma-contiguous.h>\n#include <asm/page.h>\n\n__maybe_unused cma_early_percent_memory(void)\n{\n\tstruct memblock_region *reg;\n\tunsigned long total_pages = 0;\n\n\t/*\n\t * We cannot use memblock_phys_mem_size() here, because\n\t * memblock_analyze() has not been called yet.\n\t */\n\tfor_each_memblock(memory, reg)\n\t\ttotal_pages += memblock_region_memory_end_pfn(reg) -\n\t\t\t       memblock_region_memory_base_pfn(reg);\n\n\treturn (total_pages * CONFIG_CMA_SIZE_PERCENTAGE / 100) << PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "size_bytes",
            "cma_early_percent_memory()"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "min_not_zero",
          "args": [
            "limit_cmdline",
            "limit"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(limit %08lx)\\n\"",
            "__func__",
            "(unsigned long)limit"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-contiguous.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/dma-contiguous.h>\n#include <asm/page.h>\n\nstruct cma *dma_contiguous_default_area;\nstatic const phys_addr_t size_bytes = (phys_addr_t)CMA_SIZE_MBYTES * SZ_1M;\nstatic phys_addr_t size_cmdline = -1;\nstatic phys_addr_t base_cmdline;\nstatic phys_addr_t limit_cmdline;\n\nvoid __init dma_contiguous_reserve(phys_addr_t limit)\n{\n\tphys_addr_t selected_size = 0;\n\tphys_addr_t selected_base = 0;\n\tphys_addr_t selected_limit = limit;\n\tbool fixed = false;\n\n\tpr_debug(\"%s(limit %08lx)\\n\", __func__, (unsigned long)limit);\n\n\tif (size_cmdline != -1) {\n\t\tselected_size = size_cmdline;\n\t\tselected_base = base_cmdline;\n\t\tselected_limit = min_not_zero(limit_cmdline, limit);\n\t\tif (base_cmdline + size_cmdline == limit_cmdline)\n\t\t\tfixed = true;\n\t} else {\n#ifdef CONFIG_CMA_SIZE_SEL_MBYTES\n\t\tselected_size = size_bytes;\n#elif defined(CONFIG_CMA_SIZE_SEL_PERCENTAGE)\n\t\tselected_size = cma_early_percent_memory();\n#elif defined(CONFIG_CMA_SIZE_SEL_MIN)\n\t\tselected_size = min(size_bytes, cma_early_percent_memory());\n#elif defined(CONFIG_CMA_SIZE_SEL_MAX)\n\t\tselected_size = max(size_bytes, cma_early_percent_memory());\n#endif\n\t}\n\n\tif (selected_size && !dma_contiguous_default_area) {\n\t\tpr_debug(\"%s: reserving %ld MiB for global area\\n\", __func__,\n\t\t\t (unsigned long)selected_size / SZ_1M);\n\n\t\tdma_contiguous_reserve_area(selected_size, selected_base,\n\t\t\t\t\t    selected_limit,\n\t\t\t\t\t    &dma_contiguous_default_area,\n\t\t\t\t\t    fixed);\n\t}\n}"
  },
  {
    "function_name": "cma_early_percent_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/contiguous.c",
    "lines": "73-87",
    "snippet": "__maybe_unused cma_early_percent_memory(void)\n{\n\tstruct memblock_region *reg;\n\tunsigned long total_pages = 0;\n\n\t/*\n\t * We cannot use memblock_phys_mem_size() here, because\n\t * memblock_analyze() has not been called yet.\n\t */\n\tfor_each_memblock(memory, reg)\n\t\ttotal_pages += memblock_region_memory_end_pfn(reg) -\n\t\t\t       memblock_region_memory_base_pfn(reg);\n\n\treturn (total_pages * CONFIG_CMA_SIZE_PERCENTAGE / 100) << PAGE_SHIFT;\n}",
    "includes": [
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/cma.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/sizes.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <asm/dma-contiguous.h>",
      "#include <asm/page.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_region_memory_base_pfn",
          "args": [
            "reg"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_region_memory_end_pfn",
          "args": [
            "reg"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memblock",
          "args": [
            "memory",
            "reg"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-contiguous.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/dma-contiguous.h>\n#include <asm/page.h>\n\n__maybe_unused cma_early_percent_memory(void)\n{\n\tstruct memblock_region *reg;\n\tunsigned long total_pages = 0;\n\n\t/*\n\t * We cannot use memblock_phys_mem_size() here, because\n\t * memblock_analyze() has not been called yet.\n\t */\n\tfor_each_memblock(memory, reg)\n\t\ttotal_pages += memblock_region_memory_end_pfn(reg) -\n\t\t\t       memblock_region_memory_base_pfn(reg);\n\n\treturn (total_pages * CONFIG_CMA_SIZE_PERCENTAGE / 100) << PAGE_SHIFT;\n}"
  },
  {
    "function_name": "early_cma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/contiguous.c",
    "lines": "50-68",
    "snippet": "static int __init early_cma(char *p)\n{\n\tif (!p) {\n\t\tpr_err(\"Config string not provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsize_cmdline = memparse(p, &p);\n\tif (*p != '@')\n\t\treturn 0;\n\tbase_cmdline = memparse(p + 1, &p);\n\tif (*p != '-') {\n\t\tlimit_cmdline = base_cmdline + size_cmdline;\n\t\treturn 0;\n\t}\n\tlimit_cmdline = memparse(p + 1, &p);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/of_reserved_mem.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/cma.h>",
      "#include <linux/dma-contiguous.h>",
      "#include <linux/sizes.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>",
      "#include <asm/dma-contiguous.h>",
      "#include <asm/page.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static phys_addr_t size_cmdline = -1;",
      "static phys_addr_t base_cmdline;",
      "static phys_addr_t limit_cmdline;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "p + 1",
            "&p"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "p + 1",
            "&p"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "p",
            "&p"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Config string not provided\\n\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-contiguous.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/dma-contiguous.h>\n#include <asm/page.h>\n\nstatic phys_addr_t size_cmdline = -1;\nstatic phys_addr_t base_cmdline;\nstatic phys_addr_t limit_cmdline;\n\nstatic int __init early_cma(char *p)\n{\n\tif (!p) {\n\t\tpr_err(\"Config string not provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsize_cmdline = memparse(p, &p);\n\tif (*p != '@')\n\t\treturn 0;\n\tbase_cmdline = memparse(p + 1, &p);\n\tif (*p != '-') {\n\t\tlimit_cmdline = base_cmdline + size_cmdline;\n\t\treturn 0;\n\t}\n\tlimit_cmdline = memparse(p + 1, &p);\n\n\treturn 0;\n}"
  }
]