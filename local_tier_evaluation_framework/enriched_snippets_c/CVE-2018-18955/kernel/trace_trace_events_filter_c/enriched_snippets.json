[
  {
    "function_name": "ftrace_test_event_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "2181-2239",
    "snippet": "static __init int ftrace_test_event_filter(void)\n{\n\tint i;\n\n\tprintk(KERN_INFO \"Testing ftrace filter: \");\n\n\tfor (i = 0; i < DATA_CNT; i++) {\n\t\tstruct event_filter *filter = NULL;\n\t\tstruct test_filter_data_t *d = &test_filter_data[i];\n\t\tint err;\n\n\t\terr = create_filter(&event_ftrace_test_filter, d->filter,\n\t\t\t\t    false, &filter);\n\t\tif (err) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to get filter for '%s', err %d\\n\",\n\t\t\t       d->filter, err);\n\t\t\t__free_filter(filter);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Needed to dereference filter->prog */\n\t\tmutex_lock(&event_mutex);\n\t\t/*\n\t\t * The preemption disabling is not really needed for self\n\t\t * tests, but the rcu dereference will complain without it.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (*d->not_visited)\n\t\t\tupdate_pred_fn(filter, d->not_visited);\n\n\t\ttest_pred_visited = 0;\n\t\terr = filter_match_preds(filter, &d->rec);\n\t\tpreempt_enable();\n\n\t\tmutex_unlock(&event_mutex);\n\n\t\t__free_filter(filter);\n\n\t\tif (test_pred_visited) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed, unwanted pred visited for filter %s\\n\",\n\t\t\t       d->filter);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err != d->match) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to match filter '%s', expected %d\\n\",\n\t\t\t       d->filter, d->match);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == DATA_CNT)\n\t\tprintk(KERN_CONT \"OK\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DATA_CNT ARRAY_SIZE(test_filter_data)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"OK\\n\""
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8231-8252",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"Failed to match filter '%s', expected %d\\n\"",
            "d->filter",
            "d->match"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_printk.c",
          "lines": "229-241",
          "snippet": "int __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nint __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"Failed, unwanted pred visited for filter %s\\n\"",
            "d->filter"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "filter"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1007-1015",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter_match_preds",
          "args": [
            "filter",
            "&d->rec"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "filter_match_preds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "880-901",
          "snippet": "int filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t/* no filter is considered a match */\n\tif (!filter)\n\t\treturn 1;\n\n\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */\n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t/* no filter is considered a match */\n\tif (!filter)\n\t\treturn 1;\n\n\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */\n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pred_fn",
          "args": [
            "filter",
            "d->not_visited"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "update_pred_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "2157-2179",
          "snippet": "static void update_pred_fn(struct event_filter *filter, char *fields)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tstruct ftrace_event_field *field = pred->field;\n\n\t\tWARN_ON_ONCE(!pred->fn);\n\n\t\tif (!field) {\n\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strchr(fields, *field->name))\n\t\t\tcontinue;\n\n\t\tpred->fn = test_pred_visited_fn;\n\t}\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void update_pred_fn(struct event_filter *filter, char *fields)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tstruct ftrace_event_field *field = pred->field;\n\n\t\tWARN_ON_ONCE(!pred->fn);\n\n\t\tif (!field) {\n\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strchr(fields, *field->name))\n\t\t\tcontinue;\n\n\t\tpred->fn = test_pred_visited_fn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_filter",
          "args": [
            "&event_ftrace_test_filter",
            "d->filter",
            "false",
            "&filter"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1703-1723",
          "snippet": "static int create_filter(struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(pe, *filterp);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int create_filter(struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(pe, *filterp);\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\n#define DATA_CNT ARRAY_SIZE(test_filter_data)\n\nstatic __init int ftrace_test_event_filter(void)\n{\n\tint i;\n\n\tprintk(KERN_INFO \"Testing ftrace filter: \");\n\n\tfor (i = 0; i < DATA_CNT; i++) {\n\t\tstruct event_filter *filter = NULL;\n\t\tstruct test_filter_data_t *d = &test_filter_data[i];\n\t\tint err;\n\n\t\terr = create_filter(&event_ftrace_test_filter, d->filter,\n\t\t\t\t    false, &filter);\n\t\tif (err) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to get filter for '%s', err %d\\n\",\n\t\t\t       d->filter, err);\n\t\t\t__free_filter(filter);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Needed to dereference filter->prog */\n\t\tmutex_lock(&event_mutex);\n\t\t/*\n\t\t * The preemption disabling is not really needed for self\n\t\t * tests, but the rcu dereference will complain without it.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (*d->not_visited)\n\t\t\tupdate_pred_fn(filter, d->not_visited);\n\n\t\ttest_pred_visited = 0;\n\t\terr = filter_match_preds(filter, &d->rec);\n\t\tpreempt_enable();\n\n\t\tmutex_unlock(&event_mutex);\n\n\t\t__free_filter(filter);\n\n\t\tif (test_pred_visited) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed, unwanted pred visited for filter %s\\n\",\n\t\t\t       d->filter);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err != d->match) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to match filter '%s', expected %d\\n\",\n\t\t\t       d->filter, d->match);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == DATA_CNT)\n\t\tprintk(KERN_CONT \"OK\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "update_pred_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "2157-2179",
    "snippet": "static void update_pred_fn(struct event_filter *filter, char *fields)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tstruct ftrace_event_field *field = pred->field;\n\n\t\tWARN_ON_ONCE(!pred->fn);\n\n\t\tif (!field) {\n\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strchr(fields, *field->name))\n\t\t\tcontinue;\n\n\t\tpred->fn = test_pred_visited_fn;\n\t}\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fields",
            "*field->name"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"all leafs should have field defined %d\"",
            "i"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!pred->fn"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "filter->prog",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&event_mutex"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void update_pred_fn(struct event_filter *filter, char *fields)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tstruct ftrace_event_field *field = pred->field;\n\n\t\tWARN_ON_ONCE(!pred->fn);\n\n\t\tif (!field) {\n\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strchr(fields, *field->name))\n\t\t\tcontinue;\n\n\t\tpred->fn = test_pred_visited_fn;\n\t}\n}"
  },
  {
    "function_name": "test_pred_visited_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "2148-2155",
    "snippet": "static int test_pred_visited_fn(struct filter_pred *pred, void *event)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\ttest_pred_visited = 1;\n\tprintk(KERN_INFO \"\\npred visited %s\\n\", field->name);\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"\\npred visited %s\\n\"",
            "field->name"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int test_pred_visited_fn(struct filter_pred *pred, void *event)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\ttest_pred_visited = 1;\n\tprintk(KERN_INFO \"\\npred visited %s\\n\", field->name);\n\treturn 1;\n}"
  },
  {
    "function_name": "ftrace_profile_set_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "2024-2060",
    "snippet": "int ftrace_profile_set_filter(struct perf_event *event, int event_id,\n\t\t\t      char *filter_str)\n{\n\tint err;\n\tstruct event_filter *filter = NULL;\n\tstruct trace_event_call *call;\n\n\tmutex_lock(&event_mutex);\n\n\tcall = event->tp_event;\n\n\terr = -EINVAL;\n\tif (!call)\n\t\tgoto out_unlock;\n\n\terr = -EEXIST;\n\tif (event->filter)\n\t\tgoto out_unlock;\n\n\terr = create_filter(call, filter_str, false, &filter);\n\tif (err)\n\t\tgoto free_filter;\n\n\tif (ftrace_event_is_function(call))\n\t\terr = ftrace_function_set_filter(event, filter);\n\telse\n\t\tevent->filter = filter;\n\nfree_filter:\n\tif (err || ftrace_event_is_function(call))\n\t\t__free_filter(filter);\n\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "filter"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1007-1015",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_event_is_function",
          "args": [
            "call"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_is_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_export.c",
          "lines": "198-201",
          "snippet": "bool ftrace_event_is_function(struct trace_event_call *call)\n{\n\treturn call == &event_function;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include \"trace_output.h\"",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/stringify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include \"trace_output.h\"\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stringify.h>\n\nbool ftrace_event_is_function(struct trace_event_call *call)\n{\n\treturn call == &event_function;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_function_set_filter",
          "args": [
            "event",
            "filter"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_function_set_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "2017-2021",
          "snippet": "static int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\treturn -ENODEV;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\treturn -ENODEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_filter",
          "args": [
            "call",
            "filter_str",
            "false",
            "&filter"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1703-1723",
          "snippet": "static int create_filter(struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(pe, *filterp);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int create_filter(struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(pe, *filterp);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint ftrace_profile_set_filter(struct perf_event *event, int event_id,\n\t\t\t      char *filter_str)\n{\n\tint err;\n\tstruct event_filter *filter = NULL;\n\tstruct trace_event_call *call;\n\n\tmutex_lock(&event_mutex);\n\n\tcall = event->tp_event;\n\n\terr = -EINVAL;\n\tif (!call)\n\t\tgoto out_unlock;\n\n\terr = -EEXIST;\n\tif (event->filter)\n\t\tgoto out_unlock;\n\n\terr = create_filter(call, filter_str, false, &filter);\n\tif (err)\n\t\tgoto free_filter;\n\n\tif (ftrace_event_is_function(call))\n\t\terr = ftrace_function_set_filter(event, filter);\n\telse\n\t\tevent->filter = filter;\n\nfree_filter:\n\tif (err || ftrace_event_is_function(call))\n\t\t__free_filter(filter);\n\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ftrace_function_set_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "2017-2021",
    "snippet": "static int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\treturn -ENODEV;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\treturn -ENODEV;\n}"
  },
  {
    "function_name": "ftrace_function_set_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1993-2015",
    "snippet": "static int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tstruct function_filter_data data = {\n\t\t.first_filter  = 1,\n\t\t.first_notrace = 1,\n\t\t.ops           = &event->ftrace_ops,\n\t};\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\n\t\tif (!is_or(prog, i))\n\t\t\treturn -EINVAL;\n\n\t\tif (ftrace_function_set_filter_pred(pred, &data) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * ops[] = { OPS };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_function_set_filter_pred",
          "args": [
            "pred",
            "&data"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_function_set_filter_pred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1959-1973",
          "snippet": "static int ftrace_function_set_filter_pred(struct filter_pred *pred,\n\t\t\t\t\t   struct function_filter_data *data)\n{\n\tint ret;\n\n\t/* Checking the node is valid for function trace. */\n\tret = ftrace_function_check_pred(pred);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __ftrace_function_set_filter(pred->op == OP_EQ,\n\t\t\t\t\t    pred->regex.pattern,\n\t\t\t\t\t    pred->regex.len,\n\t\t\t\t\t    data);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int ftrace_function_set_filter_pred(struct filter_pred *pred,\n\t\t\t\t\t   struct function_filter_data *data)\n{\n\tint ret;\n\n\t/* Checking the node is valid for function trace. */\n\tret = ftrace_function_check_pred(pred);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __ftrace_function_set_filter(pred->op == OP_EQ,\n\t\t\t\t\t    pred->regex.pattern,\n\t\t\t\t\t    pred->regex.len,\n\t\t\t\t\t    data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_or",
          "args": [
            "prog",
            "i"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "is_or",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1975-1991",
          "snippet": "static bool is_or(struct prog_entry *prog, int i)\n{\n\tint target;\n\n\t/*\n\t * Only \"||\" is allowed for function events, thus,\n\t * all true branches should jump to true, and any\n\t * false branch should jump to false.\n\t */\n\ttarget = prog[i].target + 1;\n\t/* True and false have NULL preds (all prog entries should jump to one */\n\tif (prog[target].pred)\n\t\treturn false;\n\n\t/* prog[target].target is 1 for TRUE, 0 for FALSE */\n\treturn prog[i].when_to_branch == prog[target].target;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic bool is_or(struct prog_entry *prog, int i)\n{\n\tint target;\n\n\t/*\n\t * Only \"||\" is allowed for function events, thus,\n\t * all true branches should jump to true, and any\n\t * false branch should jump to false.\n\t */\n\ttarget = prog[i].target + 1;\n\t/* True and false have NULL preds (all prog entries should jump to one */\n\tif (prog[target].pred)\n\t\treturn false;\n\n\t/* prog[target].target is 1 for TRUE, 0 for FALSE */\n\treturn prog[i].when_to_branch == prog[target].target;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "filter->prog",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&event_mutex"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic const char * ops[] = { OPS };\n\nstatic int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tstruct function_filter_data data = {\n\t\t.first_filter  = 1,\n\t\t.first_notrace = 1,\n\t\t.ops           = &event->ftrace_ops,\n\t};\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\n\t\tif (!is_or(prog, i))\n\t\t\treturn -EINVAL;\n\n\t\tif (ftrace_function_set_filter_pred(pred, &data) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "is_or",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1975-1991",
    "snippet": "static bool is_or(struct prog_entry *prog, int i)\n{\n\tint target;\n\n\t/*\n\t * Only \"||\" is allowed for function events, thus,\n\t * all true branches should jump to true, and any\n\t * false branch should jump to false.\n\t */\n\ttarget = prog[i].target + 1;\n\t/* True and false have NULL preds (all prog entries should jump to one */\n\tif (prog[target].pred)\n\t\treturn false;\n\n\t/* prog[target].target is 1 for TRUE, 0 for FALSE */\n\treturn prog[i].when_to_branch == prog[target].target;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic bool is_or(struct prog_entry *prog, int i)\n{\n\tint target;\n\n\t/*\n\t * Only \"||\" is allowed for function events, thus,\n\t * all true branches should jump to true, and any\n\t * false branch should jump to false.\n\t */\n\ttarget = prog[i].target + 1;\n\t/* True and false have NULL preds (all prog entries should jump to one */\n\tif (prog[target].pred)\n\t\treturn false;\n\n\t/* prog[target].target is 1 for TRUE, 0 for FALSE */\n\treturn prog[i].when_to_branch == prog[target].target;\n}"
  },
  {
    "function_name": "ftrace_function_set_filter_pred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1959-1973",
    "snippet": "static int ftrace_function_set_filter_pred(struct filter_pred *pred,\n\t\t\t\t\t   struct function_filter_data *data)\n{\n\tint ret;\n\n\t/* Checking the node is valid for function trace. */\n\tret = ftrace_function_check_pred(pred);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __ftrace_function_set_filter(pred->op == OP_EQ,\n\t\t\t\t\t    pred->regex.pattern,\n\t\t\t\t\t    pred->regex.len,\n\t\t\t\t\t    data);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_function_set_filter",
          "args": [
            "pred->op == OP_EQ",
            "pred->regex.pattern",
            "pred->regex.len",
            "data"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_function_set_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1909-1939",
          "snippet": "static int __ftrace_function_set_filter(int filter, char *buf, int len,\n\t\t\t\t\tstruct function_filter_data *data)\n{\n\tint i, re_cnt, ret = -EINVAL;\n\tint *reset;\n\tchar **re;\n\n\treset = filter ? &data->first_filter : &data->first_notrace;\n\n\t/*\n\t * The 'ip' field could have multiple filters set, separated\n\t * either by space or comma. We first cut the filter and apply\n\t * all pieces separatelly.\n\t */\n\tre = ftrace_function_filter_re(buf, len, &re_cnt);\n\tif (!re)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < re_cnt; i++) {\n\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,\n\t\t\t\t\t\t re[i], strlen(re[i]));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (*reset)\n\t\t\t*reset = 0;\n\t}\n\n\targv_free(re);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * ops[] = { OPS };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic const char * ops[] = { OPS };\n\nstatic int __ftrace_function_set_filter(int filter, char *buf, int len,\n\t\t\t\t\tstruct function_filter_data *data)\n{\n\tint i, re_cnt, ret = -EINVAL;\n\tint *reset;\n\tchar **re;\n\n\treset = filter ? &data->first_filter : &data->first_notrace;\n\n\t/*\n\t * The 'ip' field could have multiple filters set, separated\n\t * either by space or comma. We first cut the filter and apply\n\t * all pieces separatelly.\n\t */\n\tre = ftrace_function_filter_re(buf, len, &re_cnt);\n\tif (!re)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < re_cnt; i++) {\n\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,\n\t\t\t\t\t\t re[i], strlen(re[i]));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (*reset)\n\t\t\t*reset = 0;\n\t}\n\n\targv_free(re);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_function_check_pred",
          "args": [
            "pred"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_function_check_pred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1941-1957",
          "snippet": "static int ftrace_function_check_pred(struct filter_pred *pred)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\t/*\n\t * Check the predicate for function trace, verify:\n\t *  - only '==' and '!=' is used\n\t *  - the 'ip' field is used\n\t */\n\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))\n\t\treturn -EINVAL;\n\n\tif (strcmp(field->name, \"ip\"))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int ftrace_function_check_pred(struct filter_pred *pred)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\t/*\n\t * Check the predicate for function trace, verify:\n\t *  - only '==' and '!=' is used\n\t *  - the 'ip' field is used\n\t */\n\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))\n\t\treturn -EINVAL;\n\n\tif (strcmp(field->name, \"ip\"))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int ftrace_function_set_filter_pred(struct filter_pred *pred,\n\t\t\t\t\t   struct function_filter_data *data)\n{\n\tint ret;\n\n\t/* Checking the node is valid for function trace. */\n\tret = ftrace_function_check_pred(pred);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __ftrace_function_set_filter(pred->op == OP_EQ,\n\t\t\t\t\t    pred->regex.pattern,\n\t\t\t\t\t    pred->regex.len,\n\t\t\t\t\t    data);\n}"
  },
  {
    "function_name": "ftrace_function_check_pred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1941-1957",
    "snippet": "static int ftrace_function_check_pred(struct filter_pred *pred)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\t/*\n\t * Check the predicate for function trace, verify:\n\t *  - only '==' and '!=' is used\n\t *  - the 'ip' field is used\n\t */\n\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))\n\t\treturn -EINVAL;\n\n\tif (strcmp(field->name, \"ip\"))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field->name",
            "\"ip\""
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int ftrace_function_check_pred(struct filter_pred *pred)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\t/*\n\t * Check the predicate for function trace, verify:\n\t *  - only '==' and '!=' is used\n\t *  - the 'ip' field is used\n\t */\n\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))\n\t\treturn -EINVAL;\n\n\tif (strcmp(field->name, \"ip\"))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ftrace_function_set_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1909-1939",
    "snippet": "static int __ftrace_function_set_filter(int filter, char *buf, int len,\n\t\t\t\t\tstruct function_filter_data *data)\n{\n\tint i, re_cnt, ret = -EINVAL;\n\tint *reset;\n\tchar **re;\n\n\treset = filter ? &data->first_filter : &data->first_notrace;\n\n\t/*\n\t * The 'ip' field could have multiple filters set, separated\n\t * either by space or comma. We first cut the filter and apply\n\t * all pieces separatelly.\n\t */\n\tre = ftrace_function_filter_re(buf, len, &re_cnt);\n\tif (!re)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < re_cnt; i++) {\n\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,\n\t\t\t\t\t\t re[i], strlen(re[i]));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (*reset)\n\t\t\t*reset = 0;\n\t}\n\n\targv_free(re);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * ops[] = { OPS };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "argv_free",
          "args": [
            "re"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_function_set_regexp",
          "args": [
            "data->ops",
            "filter",
            "*reset",
            "re[i]",
            "strlen(re[i])"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_function_set_regexp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1896-1907",
          "snippet": "static int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,\n\t\t\t\t      int reset, char *re, int len)\n{\n\tint ret;\n\n\tif (filter)\n\t\tret = ftrace_set_filter(ops, re, len, reset);\n\telse\n\t\tret = ftrace_set_notrace(ops, re, len, reset);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * ops[] = { OPS };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic const char * ops[] = { OPS };\n\nstatic int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,\n\t\t\t\t      int reset, char *re, int len)\n{\n\tint ret;\n\n\tif (filter)\n\t\tret = ftrace_set_filter(ops, re, len, reset);\n\telse\n\t\tret = ftrace_set_notrace(ops, re, len, reset);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "re[i]"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_function_filter_re",
          "args": [
            "buf",
            "len",
            "&re_cnt"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_function_filter_re",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1876-1894",
          "snippet": "static char **\nftrace_function_filter_re(char *buf, int len, int *count)\n{\n\tchar *str, **re;\n\n\tstr = kstrndup(buf, len, GFP_KERNEL);\n\tif (!str)\n\t\treturn NULL;\n\n\t/*\n\t * The argv_split function takes white space\n\t * as a separator, so convert ',' into spaces.\n\t */\n\tstrreplace(str, ',', ' ');\n\n\tre = argv_split(GFP_KERNEL, str, count);\n\tkfree(str);\n\treturn re;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic char **\nftrace_function_filter_re(char *buf, int len, int *count)\n{\n\tchar *str, **re;\n\n\tstr = kstrndup(buf, len, GFP_KERNEL);\n\tif (!str)\n\t\treturn NULL;\n\n\t/*\n\t * The argv_split function takes white space\n\t * as a separator, so convert ',' into spaces.\n\t */\n\tstrreplace(str, ',', ' ');\n\n\tre = argv_split(GFP_KERNEL, str, count);\n\tkfree(str);\n\treturn re;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic const char * ops[] = { OPS };\n\nstatic int __ftrace_function_set_filter(int filter, char *buf, int len,\n\t\t\t\t\tstruct function_filter_data *data)\n{\n\tint i, re_cnt, ret = -EINVAL;\n\tint *reset;\n\tchar **re;\n\n\treset = filter ? &data->first_filter : &data->first_notrace;\n\n\t/*\n\t * The 'ip' field could have multiple filters set, separated\n\t * either by space or comma. We first cut the filter and apply\n\t * all pieces separatelly.\n\t */\n\tre = ftrace_function_filter_re(buf, len, &re_cnt);\n\tif (!re)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < re_cnt; i++) {\n\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,\n\t\t\t\t\t\t re[i], strlen(re[i]));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (*reset)\n\t\t\t*reset = 0;\n\t}\n\n\targv_free(re);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_function_set_regexp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1896-1907",
    "snippet": "static int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,\n\t\t\t\t      int reset, char *re, int len)\n{\n\tint ret;\n\n\tif (filter)\n\t\tret = ftrace_set_filter(ops, re, len, reset);\n\telse\n\t\tret = ftrace_set_notrace(ops, re, len, reset);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * ops[] = { OPS };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_notrace",
          "args": [
            "ops",
            "re",
            "len",
            "reset"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_notrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4815-4820",
          "snippet": "int ftrace_set_notrace(struct ftrace_ops *ops, unsigned char *buf,\n\t\t\tint len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 0);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_notrace(struct ftrace_ops *ops, unsigned char *buf,\n\t\t\tint len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter",
          "args": [
            "ops",
            "re",
            "len",
            "reset"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4796-4801",
          "snippet": "int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic const char * ops[] = { OPS };\n\nstatic int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,\n\t\t\t\t      int reset, char *re, int len)\n{\n\tint ret;\n\n\tif (filter)\n\t\tret = ftrace_set_filter(ops, re, len, reset);\n\telse\n\t\tret = ftrace_set_notrace(ops, re, len, reset);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_function_filter_re",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1876-1894",
    "snippet": "static char **\nftrace_function_filter_re(char *buf, int len, int *count)\n{\n\tchar *str, **re;\n\n\tstr = kstrndup(buf, len, GFP_KERNEL);\n\tif (!str)\n\t\treturn NULL;\n\n\t/*\n\t * The argv_split function takes white space\n\t * as a separator, so convert ',' into spaces.\n\t */\n\tstrreplace(str, ',', ' ');\n\n\tre = argv_split(GFP_KERNEL, str, count);\n\tkfree(str);\n\treturn re;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "str"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv_split",
          "args": [
            "GFP_KERNEL",
            "str",
            "count"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strreplace",
          "args": [
            "str",
            "','",
            "' '"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "buf",
            "len",
            "GFP_KERNEL"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic char **\nftrace_function_filter_re(char *buf, int len, int *count)\n{\n\tchar *str, **re;\n\n\tstr = kstrndup(buf, len, GFP_KERNEL);\n\tif (!str)\n\t\treturn NULL;\n\n\t/*\n\t * The argv_split function takes white space\n\t * as a separator, so convert ',' into spaces.\n\t */\n\tstrreplace(str, ',', ' ');\n\n\tre = argv_split(GFP_KERNEL, str, count);\n\tkfree(str);\n\treturn re;\n}"
  },
  {
    "function_name": "ftrace_profile_free_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1861-1867",
    "snippet": "void ftrace_profile_free_filter(struct perf_event *event)\n{\n\tstruct event_filter *filter = event->filter;\n\n\tevent->filter = NULL;\n\t__free_filter(filter);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "filter"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1007-1015",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid ftrace_profile_free_filter(struct perf_event *event)\n{\n\tstruct event_filter *filter = event->filter;\n\n\tevent->filter = NULL;\n\t__free_filter(filter);\n}"
  },
  {
    "function_name": "apply_subsystem_event_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1816-1857",
    "snippet": "int apply_subsystem_event_filter(struct trace_subsystem_dir *dir,\n\t\t\t\t char *filter_string)\n{\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_array *tr = dir->tr;\n\tstruct event_filter *filter = NULL;\n\tint err = 0;\n\n\tmutex_lock(&event_mutex);\n\n\t/* Make sure the system still has events */\n\tif (!dir->nr_events) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_free_subsystem_preds(dir, tr);\n\t\tremove_filter_string(system->filter);\n\t\tfilter = system->filter;\n\t\tsystem->filter = NULL;\n\t\t/* Ensure all filters are no longer used */\n\t\ttracepoint_synchronize_unregister();\n\t\tfilter_free_subsystem_filters(dir, tr);\n\t\t__free_filter(filter);\n\t\tgoto out_unlock;\n\t}\n\n\terr = create_system_filter(dir, tr, filter_string, &filter);\n\tif (filter) {\n\t\t/*\n\t\t * No event actually uses the system filter\n\t\t * we can free it without synchronize_sched().\n\t\t */\n\t\t__free_filter(system->filter);\n\t\tsystem->filter = filter;\n\t}\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "system->filter"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1007-1015",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_system_filter",
          "args": [
            "dir",
            "tr",
            "filter_string",
            "&filter"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "create_system_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1741-1762",
          "snippet": "static int create_system_filter(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tchar *filter_str, struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\terr = create_filter_start(filter_str, true, &pe, filterp);\n\tif (!err) {\n\t\terr = process_system_preds(dir, tr, pe, filter_str);\n\t\tif (!err) {\n\t\t\t/* System filters just show a default message */\n\t\t\tkfree((*filterp)->filter_string);\n\t\t\t(*filterp)->filter_string = NULL;\n\t\t} else {\n\t\t\tappend_filter_err(pe, *filterp);\n\t\t}\n\t}\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int create_system_filter(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tchar *filter_str, struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\terr = create_filter_start(filter_str, true, &pe, filterp);\n\tif (!err) {\n\t\terr = process_system_preds(dir, tr, pe, filter_str);\n\t\tif (!err) {\n\t\t\t/* System filters just show a default message */\n\t\t\tkfree((*filterp)->filter_string);\n\t\t\t(*filterp)->filter_string = NULL;\n\t\t} else {\n\t\t\tappend_filter_err(pe, *filterp);\n\t\t}\n\t}\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_free_subsystem_filters",
          "args": [
            "dir",
            "tr"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "filter_free_subsystem_filters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1046-1056",
          "snippet": "static void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,\n\t\t\t\t\t  struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__free_subsystem_filter(file);\n\t}\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,\n\t\t\t\t\t  struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__free_subsystem_filter(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_filter_string",
          "args": [
            "system->filter"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "remove_filter_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "904-911",
          "snippet": "static void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_free_subsystem_preds",
          "args": [
            "dir",
            "tr"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "filter_free_subsystem_preds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1028-1038",
          "snippet": "static void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__remove_filter(file);\n\t}\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__remove_filter(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strstrip(filter_string)",
            "\"0\""
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "filter_string"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint apply_subsystem_event_filter(struct trace_subsystem_dir *dir,\n\t\t\t\t char *filter_string)\n{\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_array *tr = dir->tr;\n\tstruct event_filter *filter = NULL;\n\tint err = 0;\n\n\tmutex_lock(&event_mutex);\n\n\t/* Make sure the system still has events */\n\tif (!dir->nr_events) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_free_subsystem_preds(dir, tr);\n\t\tremove_filter_string(system->filter);\n\t\tfilter = system->filter;\n\t\tsystem->filter = NULL;\n\t\t/* Ensure all filters are no longer used */\n\t\ttracepoint_synchronize_unregister();\n\t\tfilter_free_subsystem_filters(dir, tr);\n\t\t__free_filter(filter);\n\t\tgoto out_unlock;\n\t}\n\n\terr = create_system_filter(dir, tr, filter_string, &filter);\n\tif (filter) {\n\t\t/*\n\t\t * No event actually uses the system filter\n\t\t * we can free it without synchronize_sched().\n\t\t */\n\t\t__free_filter(system->filter);\n\t\tsystem->filter = filter;\n\t}\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "apply_event_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1765-1814",
    "snippet": "int apply_event_filter(struct trace_event_file *file, char *filter_string)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct event_filter *filter = NULL;\n\tint err;\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_disable(file);\n\t\tfilter = event_filter(file);\n\n\t\tif (!filter)\n\t\t\treturn 0;\n\n\t\tevent_clear_filter(file);\n\n\t\t/* Make sure the filter is not being used */\n\t\ttracepoint_synchronize_unregister();\n\t\t__free_filter(filter);\n\n\t\treturn 0;\n\t}\n\n\terr = create_filter(call, filter_string, true, &filter);\n\n\t/*\n\t * Always swap the call filter with the new filter\n\t * even if there was an error. If there was an error\n\t * in the filter, we disable the filter and show the error\n\t * string\n\t */\n\tif (filter) {\n\t\tstruct event_filter *tmp;\n\n\t\ttmp = event_filter(file);\n\t\tif (!err)\n\t\t\tevent_set_filtered_flag(file);\n\t\telse\n\t\t\tfilter_disable(file);\n\n\t\tevent_set_filter(file, filter);\n\n\t\tif (tmp) {\n\t\t\t/* Make sure the call is done with the filter */\n\t\t\ttracepoint_synchronize_unregister();\n\t\t\t__free_filter(tmp);\n\t\t}\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "tmp"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1007-1015",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_set_filter",
          "args": [
            "file",
            "filter"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "event_set_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1524-1528",
          "snippet": "static inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_disable",
          "args": [
            "file"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "filter_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "997-1005",
          "snippet": "static void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_set_filtered_flag",
          "args": [
            "file"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "event_set_filtered_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1514-1522",
          "snippet": "static inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_filter",
          "args": [
            "file"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "free_event_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1017-1020",
          "snippet": "void free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_filter",
          "args": [
            "call",
            "filter_string",
            "true",
            "&filter"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1703-1723",
          "snippet": "static int create_filter(struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(pe, *filterp);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int create_filter(struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(pe, *filterp);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_clear_filter",
          "args": [
            "file"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "event_clear_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1530-1533",
          "snippet": "static inline void event_clear_filter(struct trace_event_file *file)\n{\n\tRCU_INIT_POINTER(file->filter, NULL);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline void event_clear_filter(struct trace_event_file *file)\n{\n\tRCU_INIT_POINTER(file->filter, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strstrip(filter_string)",
            "\"0\""
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "filter_string"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint apply_event_filter(struct trace_event_file *file, char *filter_string)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct event_filter *filter = NULL;\n\tint err;\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_disable(file);\n\t\tfilter = event_filter(file);\n\n\t\tif (!filter)\n\t\t\treturn 0;\n\n\t\tevent_clear_filter(file);\n\n\t\t/* Make sure the filter is not being used */\n\t\ttracepoint_synchronize_unregister();\n\t\t__free_filter(filter);\n\n\t\treturn 0;\n\t}\n\n\terr = create_filter(call, filter_string, true, &filter);\n\n\t/*\n\t * Always swap the call filter with the new filter\n\t * even if there was an error. If there was an error\n\t * in the filter, we disable the filter and show the error\n\t * string\n\t */\n\tif (filter) {\n\t\tstruct event_filter *tmp;\n\n\t\ttmp = event_filter(file);\n\t\tif (!err)\n\t\t\tevent_set_filtered_flag(file);\n\t\telse\n\t\t\tfilter_disable(file);\n\n\t\tevent_set_filter(file, filter);\n\n\t\tif (tmp) {\n\t\t\t/* Make sure the call is done with the filter */\n\t\t\ttracepoint_synchronize_unregister();\n\t\t\t__free_filter(tmp);\n\t\t}\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "create_system_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1741-1762",
    "snippet": "static int create_system_filter(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tchar *filter_str, struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\terr = create_filter_start(filter_str, true, &pe, filterp);\n\tif (!err) {\n\t\terr = process_system_preds(dir, tr, pe, filter_str);\n\t\tif (!err) {\n\t\t\t/* System filters just show a default message */\n\t\t\tkfree((*filterp)->filter_string);\n\t\t\t(*filterp)->filter_string = NULL;\n\t\t} else {\n\t\t\tappend_filter_err(pe, *filterp);\n\t\t}\n\t}\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_filter_finish",
          "args": [
            "pe"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1681-1684",
          "snippet": "static void create_filter_finish(struct filter_parse_error *pe)\n{\n\tkfree(pe);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void create_filter_finish(struct filter_parse_error *pe)\n{\n\tkfree(pe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_filter_err",
          "args": [
            "pe",
            "*filterp"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "append_filter_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "913-951",
          "snippet": "static void append_filter_err(struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *err_text[] = { ERRORS };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic char *err_text[] = { ERRORS };\n\nstatic void append_filter_err(struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "(*filterp)->filter_string"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_system_preds",
          "args": [
            "dir",
            "tr",
            "pe",
            "filter_str"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "process_system_preds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1561-1646",
          "snippet": "static int process_system_preds(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tstruct filter_parse_error *pe,\n\t\t\t\tchar *filter_string)\n{\n\tstruct trace_event_file *file;\n\tstruct filter_list *filter_item;\n\tstruct event_filter *filter = NULL;\n\tstruct filter_list *tmp;\n\tLIST_HEAD(filter_list);\n\tbool fail = true;\n\tint err;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\n\t\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (!filter)\n\t\t\tgoto fail_mem;\n\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\tgoto fail_mem;\n\n\t\terr = process_preds(file->event_call, filter_string, filter, pe);\n\t\tif (err) {\n\t\t\tfilter_disable(file);\n\t\t\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\t\t\tappend_filter_err(pe, filter);\n\t\t} else\n\t\t\tevent_set_filtered_flag(file);\n\n\n\t\tfilter_item = kzalloc(sizeof(*filter_item), GFP_KERNEL);\n\t\tif (!filter_item)\n\t\t\tgoto fail_mem;\n\n\t\tlist_add_tail(&filter_item->list, &filter_list);\n\t\t/*\n\t\t * Regardless of if this returned an error, we still\n\t\t * replace the filter for the call.\n\t\t */\n\t\tfilter_item->filter = event_filter(file);\n\t\tevent_set_filter(file, filter);\n\t\tfilter = NULL;\n\n\t\tfail = false;\n\t}\n\n\tif (fail)\n\t\tgoto fail;\n\n\t/*\n\t * The calls can still be using the old filters.\n\t * Do a synchronize_sched() and to ensure all calls are\n\t * done with them before we free them.\n\t */\n\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn 0;\n fail:\n\t/* No call succeeded */\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\treturn -EINVAL;\n fail_mem:\n\tkfree(filter);\n\t/* If any call succeeded, we still need to sync */\n\tif (!fail)\n\t\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int process_system_preds(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tstruct filter_parse_error *pe,\n\t\t\t\tchar *filter_string)\n{\n\tstruct trace_event_file *file;\n\tstruct filter_list *filter_item;\n\tstruct event_filter *filter = NULL;\n\tstruct filter_list *tmp;\n\tLIST_HEAD(filter_list);\n\tbool fail = true;\n\tint err;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\n\t\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (!filter)\n\t\t\tgoto fail_mem;\n\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\tgoto fail_mem;\n\n\t\terr = process_preds(file->event_call, filter_string, filter, pe);\n\t\tif (err) {\n\t\t\tfilter_disable(file);\n\t\t\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\t\t\tappend_filter_err(pe, filter);\n\t\t} else\n\t\t\tevent_set_filtered_flag(file);\n\n\n\t\tfilter_item = kzalloc(sizeof(*filter_item), GFP_KERNEL);\n\t\tif (!filter_item)\n\t\t\tgoto fail_mem;\n\n\t\tlist_add_tail(&filter_item->list, &filter_list);\n\t\t/*\n\t\t * Regardless of if this returned an error, we still\n\t\t * replace the filter for the call.\n\t\t */\n\t\tfilter_item->filter = event_filter(file);\n\t\tevent_set_filter(file, filter);\n\t\tfilter = NULL;\n\n\t\tfail = false;\n\t}\n\n\tif (fail)\n\t\tgoto fail;\n\n\t/*\n\t * The calls can still be using the old filters.\n\t * Do a synchronize_sched() and to ensure all calls are\n\t * done with them before we free them.\n\t */\n\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn 0;\n fail:\n\t/* No call succeeded */\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\treturn -EINVAL;\n fail_mem:\n\tkfree(filter);\n\t/* If any call succeeded, we still need to sync */\n\tif (!fail)\n\t\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_filter_start",
          "args": [
            "filter_str",
            "true",
            "&pe",
            "filterp"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1648-1679",
          "snippet": "static int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* we're committed to creating a new filter */\n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* we're committed to creating a new filter */\n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int create_system_filter(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tchar *filter_str, struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\terr = create_filter_start(filter_str, true, &pe, filterp);\n\tif (!err) {\n\t\terr = process_system_preds(dir, tr, pe, filter_str);\n\t\tif (!err) {\n\t\t\t/* System filters just show a default message */\n\t\t\tkfree((*filterp)->filter_string);\n\t\t\t(*filterp)->filter_string = NULL;\n\t\t} else {\n\t\t\tappend_filter_err(pe, *filterp);\n\t\t}\n\t}\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}"
  },
  {
    "function_name": "create_event_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1725-1730",
    "snippet": "int create_event_filter(struct trace_event_call *call,\n\t\t\tchar *filter_str, bool set_str,\n\t\t\tstruct event_filter **filterp)\n{\n\treturn create_filter(call, filter_str, set_str, filterp);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_filter",
          "args": [
            "call",
            "filter_str",
            "set_str",
            "filterp"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1703-1723",
          "snippet": "static int create_filter(struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(pe, *filterp);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int create_filter(struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(pe, *filterp);\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint create_event_filter(struct trace_event_call *call,\n\t\t\tchar *filter_str, bool set_str,\n\t\t\tstruct event_filter **filterp)\n{\n\treturn create_filter(call, filter_str, set_str, filterp);\n}"
  },
  {
    "function_name": "create_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1703-1723",
    "snippet": "static int create_filter(struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(pe, *filterp);\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "append_filter_err",
          "args": [
            "pe",
            "*filterp"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "append_filter_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "913-951",
          "snippet": "static void append_filter_err(struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *err_text[] = { ERRORS };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic char *err_text[] = { ERRORS };\n\nstatic void append_filter_err(struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_preds",
          "args": [
            "call",
            "filter_string",
            "*filterp",
            "pe"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "process_preds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1476-1512",
          "snippet": "static int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_filter_start",
          "args": [
            "filter_string",
            "set_str",
            "&pe",
            "filterp"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "create_filter_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1648-1679",
          "snippet": "static int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* we're committed to creating a new filter */\n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* we're committed to creating a new filter */\n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "*filterp"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int create_filter(struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(pe, *filterp);\n\n\treturn err;\n}"
  },
  {
    "function_name": "create_filter_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1681-1684",
    "snippet": "static void create_filter_finish(struct filter_parse_error *pe)\n{\n\tkfree(pe);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pe"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void create_filter_finish(struct filter_parse_error *pe)\n{\n\tkfree(pe);\n}"
  },
  {
    "function_name": "create_filter_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1648-1679",
    "snippet": "static int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* we're committed to creating a new filter */\n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "filter"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1007-1015",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pe"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pe)",
            "GFP_KERNEL"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "filter_string",
            "GFP_KERNEL"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*filter)",
            "GFP_KERNEL"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "*pse || *filterp"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* we're committed to creating a new filter */\n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "process_system_preds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1561-1646",
    "snippet": "static int process_system_preds(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tstruct filter_parse_error *pe,\n\t\t\t\tchar *filter_string)\n{\n\tstruct trace_event_file *file;\n\tstruct filter_list *filter_item;\n\tstruct event_filter *filter = NULL;\n\tstruct filter_list *tmp;\n\tLIST_HEAD(filter_list);\n\tbool fail = true;\n\tint err;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\n\t\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (!filter)\n\t\t\tgoto fail_mem;\n\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\tgoto fail_mem;\n\n\t\terr = process_preds(file->event_call, filter_string, filter, pe);\n\t\tif (err) {\n\t\t\tfilter_disable(file);\n\t\t\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\t\t\tappend_filter_err(pe, filter);\n\t\t} else\n\t\t\tevent_set_filtered_flag(file);\n\n\n\t\tfilter_item = kzalloc(sizeof(*filter_item), GFP_KERNEL);\n\t\tif (!filter_item)\n\t\t\tgoto fail_mem;\n\n\t\tlist_add_tail(&filter_item->list, &filter_list);\n\t\t/*\n\t\t * Regardless of if this returned an error, we still\n\t\t * replace the filter for the call.\n\t\t */\n\t\tfilter_item->filter = event_filter(file);\n\t\tevent_set_filter(file, filter);\n\t\tfilter = NULL;\n\n\t\tfail = false;\n\t}\n\n\tif (fail)\n\t\tgoto fail;\n\n\t/*\n\t * The calls can still be using the old filters.\n\t * Do a synchronize_sched() and to ensure all calls are\n\t * done with them before we free them.\n\t */\n\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn 0;\n fail:\n\t/* No call succeeded */\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\treturn -EINVAL;\n fail_mem:\n\tkfree(filter);\n\t/* If any call succeeded, we still need to sync */\n\tif (!fail)\n\t\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filter_item"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&filter_item->list"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "filter_item->filter"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1007-1015",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "filter_item",
            "tmp",
            "&filter_list",
            "list"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_error",
          "args": [
            "pe",
            "FILT_ERR_BAD_SUBSYS_FILTER",
            "0"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "parse_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "132-136",
          "snippet": "static void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "filter_item",
            "tmp",
            "&filter_list",
            "list"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "filter_item",
            "tmp",
            "&filter_list",
            "list"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_set_filter",
          "args": [
            "file",
            "filter"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "event_set_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1524-1528",
          "snippet": "static inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_filter",
          "args": [
            "file"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "free_event_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1017-1020",
          "snippet": "void free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&filter_item->list",
            "&filter_list"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*filter_item)",
            "GFP_KERNEL"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_set_filtered_flag",
          "args": [
            "file"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "event_set_filtered_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1514-1522",
          "snippet": "static inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_filter_err",
          "args": [
            "pe",
            "filter"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "append_filter_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "913-951",
          "snippet": "static void append_filter_err(struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *err_text[] = { ERRORS };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic char *err_text[] = { ERRORS };\n\nstatic void append_filter_err(struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_disable",
          "args": [
            "file"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "filter_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "997-1005",
          "snippet": "static void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_preds",
          "args": [
            "file->event_call",
            "filter_string",
            "filter",
            "pe"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "process_preds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1476-1512",
          "snippet": "static int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "filter_string",
            "GFP_KERNEL"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*filter)",
            "GFP_KERNEL"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "filter_list"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int process_system_preds(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tstruct filter_parse_error *pe,\n\t\t\t\tchar *filter_string)\n{\n\tstruct trace_event_file *file;\n\tstruct filter_list *filter_item;\n\tstruct event_filter *filter = NULL;\n\tstruct filter_list *tmp;\n\tLIST_HEAD(filter_list);\n\tbool fail = true;\n\tint err;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\n\t\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (!filter)\n\t\t\tgoto fail_mem;\n\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\tgoto fail_mem;\n\n\t\terr = process_preds(file->event_call, filter_string, filter, pe);\n\t\tif (err) {\n\t\t\tfilter_disable(file);\n\t\t\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\t\t\tappend_filter_err(pe, filter);\n\t\t} else\n\t\t\tevent_set_filtered_flag(file);\n\n\n\t\tfilter_item = kzalloc(sizeof(*filter_item), GFP_KERNEL);\n\t\tif (!filter_item)\n\t\t\tgoto fail_mem;\n\n\t\tlist_add_tail(&filter_item->list, &filter_list);\n\t\t/*\n\t\t * Regardless of if this returned an error, we still\n\t\t * replace the filter for the call.\n\t\t */\n\t\tfilter_item->filter = event_filter(file);\n\t\tevent_set_filter(file, filter);\n\t\tfilter = NULL;\n\n\t\tfail = false;\n\t}\n\n\tif (fail)\n\t\tgoto fail;\n\n\t/*\n\t * The calls can still be using the old filters.\n\t * Do a synchronize_sched() and to ensure all calls are\n\t * done with them before we free them.\n\t */\n\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn 0;\n fail:\n\t/* No call succeeded */\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\treturn -EINVAL;\n fail_mem:\n\tkfree(filter);\n\t/* If any call succeeded, we still need to sync */\n\tif (!fail)\n\t\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "event_no_set_filter_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1547-1554",
    "snippet": "static inline bool\nevent_no_set_filter_flag(struct trace_event_file *file)\n{\n\tif (file->flags & EVENT_FILE_FL_NO_SET_FILTER)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline bool\nevent_no_set_filter_flag(struct trace_event_file *file)\n{\n\tif (file->flags & EVENT_FILE_FL_NO_SET_FILTER)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "event_clear_no_set_filter_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1541-1545",
    "snippet": "static inline void\nevent_clear_no_set_filter_flag(struct trace_event_file *file)\n{\n\tfile->flags &= ~EVENT_FILE_FL_NO_SET_FILTER;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline void\nevent_clear_no_set_filter_flag(struct trace_event_file *file)\n{\n\tfile->flags &= ~EVENT_FILE_FL_NO_SET_FILTER;\n}"
  },
  {
    "function_name": "event_set_no_set_filter_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1535-1539",
    "snippet": "static inline void\nevent_set_no_set_filter_flag(struct trace_event_file *file)\n{\n\tfile->flags |= EVENT_FILE_FL_NO_SET_FILTER;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline void\nevent_set_no_set_filter_flag(struct trace_event_file *file)\n{\n\tfile->flags |= EVENT_FILE_FL_NO_SET_FILTER;\n}"
  },
  {
    "function_name": "event_clear_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1530-1533",
    "snippet": "static inline void event_clear_filter(struct trace_event_file *file)\n{\n\tRCU_INIT_POINTER(file->filter, NULL);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "file->filter",
            "NULL"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline void event_clear_filter(struct trace_event_file *file)\n{\n\tRCU_INIT_POINTER(file->filter, NULL);\n}"
  },
  {
    "function_name": "event_set_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1524-1528",
    "snippet": "static inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "file->filter",
            "filter"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}"
  },
  {
    "function_name": "event_set_filtered_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1514-1522",
    "snippet": "static inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffered_event_enable",
          "args": [],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffered_event_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2179-2212",
          "snippet": "void trace_buffered_event_enable(void)\n{\n\tstruct ring_buffer_event *event;\n\tstruct page *page;\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (trace_buffered_event_ref++)\n\t\treturn;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\t\tif (!page)\n\t\t\tgoto failed;\n\n\t\tevent = page_address(page);\n\t\tmemset(event, 0, sizeof(*event));\n\n\t\tper_cpu(trace_buffered_event, cpu) = event;\n\n\t\tpreempt_disable();\n\t\tif (cpu == smp_processor_id() &&\n\t\t    this_cpu_read(trace_buffered_event) !=\n\t\t    per_cpu(trace_buffered_event, cpu))\n\t\t\tWARN_ON_ONCE(1);\n\t\tpreempt_enable();\n\t}\n\n\treturn;\n failed:\n\ttrace_buffered_event_disable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static int trace_buffered_event_ref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic int trace_buffered_event_ref;\n\nvoid trace_buffered_event_enable(void)\n{\n\tstruct ring_buffer_event *event;\n\tstruct page *page;\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (trace_buffered_event_ref++)\n\t\treturn;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\t\tif (!page)\n\t\t\tgoto failed;\n\n\t\tevent = page_address(page);\n\t\tmemset(event, 0, sizeof(*event));\n\n\t\tper_cpu(trace_buffered_event, cpu) = event;\n\n\t\tpreempt_disable();\n\t\tif (cpu == smp_processor_id() &&\n\t\t    this_cpu_read(trace_buffered_event) !=\n\t\t    per_cpu(trace_buffered_event, cpu))\n\t\t\tWARN_ON_ONCE(1);\n\t\tpreempt_enable();\n\t}\n\n\treturn;\n failed:\n\ttrace_buffered_event_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}"
  },
  {
    "function_name": "process_preds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1476-1512",
    "snippet": "static int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "filter->prog",
            "prog"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prog"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "predicate_parse",
          "args": [
            "filter_string",
            "nr_parens",
            "nr_preds",
            "parse_pred",
            "call",
            "pe"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "predicate_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "408-579",
          "snippet": "static struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kmalloc_array(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tif (!N) {\n\t\t/* No program? */\n\t\tret = -EINVAL;\n\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n\tprog[N].target = 1;\t\t/* TRUE */\n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(prog_stack);\n\tkfree(inverts);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kmalloc_array(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tif (!N) {\n\t\t/* No program? */\n\t\tret = -EINVAL;\n\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n\tprog[N].target = 1;\t\t/* TRUE */\n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(prog_stack);\n\tkfree(inverts);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_error",
          "args": [
            "pe",
            "FILT_ERR_TOO_MANY_CLOSE",
            "index"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "parse_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "132-136",
          "snippet": "static void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_stack",
          "args": [
            "filter_string",
            "&nr_parens",
            "&nr_preds",
            "&index"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "calc_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1379-1474",
          "snippet": "static int calc_stack(const char *str, int *parens, int *preds, int *err)\n{\n\tbool is_pred = false;\n\tint nr_preds = 0;\n\tint open = 1; /* Count the expression as \"(E)\" */\n\tint last_quote = 0;\n\tint max_open = 1;\n\tint quote = 0;\n\tint i;\n\n\t*err = 0;\n\n\tfor (i = 0; str[i]; i++) {\n\t\tif (isspace(str[i]))\n\t\t\tcontinue;\n\t\tif (quote) {\n\t\t\tif (str[i] == quote)\n\t\t\t       quote = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[i]) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tquote = str[i];\n\t\t\tlast_quote = i;\n\t\t\tbreak;\n\t\tcase '|':\n\t\tcase '&':\n\t\t\tif (str[i+1] != str[i])\n\t\t\t\tbreak;\n\t\t\tis_pred = false;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tis_pred = false;\n\t\t\topen++;\n\t\t\tif (open > max_open)\n\t\t\t\tmax_open = open;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tis_pred = false;\n\t\t\tif (open == 1) {\n\t\t\t\t*err = i;\n\t\t\t\treturn TOO_MANY_CLOSE;\n\t\t\t}\n\t\t\topen--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!is_pred) {\n\t\t\tnr_preds++;\n\t\t\tis_pred = true;\n\t\t}\n\t}\n\n\tif (quote) {\n\t\t*err = last_quote;\n\t\treturn MISSING_QUOTE;\n\t}\n\n\tif (open != 1) {\n\t\tint level = open;\n\n\t\t/* find the bad open */\n\t\tfor (i--; i; i--) {\n\t\t\tif (quote) {\n\t\t\t\tif (str[i] == quote)\n\t\t\t\t\tquote = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (str[i]) {\n\t\t\tcase '(':\n\t\t\t\tif (level == open) {\n\t\t\t\t\t*err = i;\n\t\t\t\t\treturn TOO_MANY_OPEN;\n\t\t\t\t}\n\t\t\t\tlevel--;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tquote = str[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* First character is the '(' with missing ')' */\n\t\t*err = 0;\n\t\treturn TOO_MANY_OPEN;\n\t}\n\n\t/* Set the size of the required stacks */\n\t*parens = max_open;\n\t*preds = nr_preds;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int calc_stack(const char *str, int *parens, int *preds, int *err)\n{\n\tbool is_pred = false;\n\tint nr_preds = 0;\n\tint open = 1; /* Count the expression as \"(E)\" */\n\tint last_quote = 0;\n\tint max_open = 1;\n\tint quote = 0;\n\tint i;\n\n\t*err = 0;\n\n\tfor (i = 0; str[i]; i++) {\n\t\tif (isspace(str[i]))\n\t\t\tcontinue;\n\t\tif (quote) {\n\t\t\tif (str[i] == quote)\n\t\t\t       quote = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[i]) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tquote = str[i];\n\t\t\tlast_quote = i;\n\t\t\tbreak;\n\t\tcase '|':\n\t\tcase '&':\n\t\t\tif (str[i+1] != str[i])\n\t\t\t\tbreak;\n\t\t\tis_pred = false;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tis_pred = false;\n\t\t\topen++;\n\t\t\tif (open > max_open)\n\t\t\t\tmax_open = open;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tis_pred = false;\n\t\t\tif (open == 1) {\n\t\t\t\t*err = i;\n\t\t\t\treturn TOO_MANY_CLOSE;\n\t\t\t}\n\t\t\topen--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!is_pred) {\n\t\t\tnr_preds++;\n\t\t\tis_pred = true;\n\t\t}\n\t}\n\n\tif (quote) {\n\t\t*err = last_quote;\n\t\treturn MISSING_QUOTE;\n\t}\n\n\tif (open != 1) {\n\t\tint level = open;\n\n\t\t/* find the bad open */\n\t\tfor (i--; i; i--) {\n\t\t\tif (quote) {\n\t\t\t\tif (str[i] == quote)\n\t\t\t\t\tquote = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (str[i]) {\n\t\t\tcase '(':\n\t\t\t\tif (level == open) {\n\t\t\t\t\t*err = i;\n\t\t\t\t\treturn TOO_MANY_OPEN;\n\t\t\t\t}\n\t\t\t\tlevel--;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tquote = str[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* First character is the '(' with missing ')' */\n\t\t*err = 0;\n\t\treturn TOO_MANY_OPEN;\n\t}\n\n\t/* Set the size of the required stacks */\n\t*parens = max_open;\n\t*preds = nr_preds;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}"
  },
  {
    "function_name": "calc_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1379-1474",
    "snippet": "static int calc_stack(const char *str, int *parens, int *preds, int *err)\n{\n\tbool is_pred = false;\n\tint nr_preds = 0;\n\tint open = 1; /* Count the expression as \"(E)\" */\n\tint last_quote = 0;\n\tint max_open = 1;\n\tint quote = 0;\n\tint i;\n\n\t*err = 0;\n\n\tfor (i = 0; str[i]; i++) {\n\t\tif (isspace(str[i]))\n\t\t\tcontinue;\n\t\tif (quote) {\n\t\t\tif (str[i] == quote)\n\t\t\t       quote = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[i]) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tquote = str[i];\n\t\t\tlast_quote = i;\n\t\t\tbreak;\n\t\tcase '|':\n\t\tcase '&':\n\t\t\tif (str[i+1] != str[i])\n\t\t\t\tbreak;\n\t\t\tis_pred = false;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tis_pred = false;\n\t\t\topen++;\n\t\t\tif (open > max_open)\n\t\t\t\tmax_open = open;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tis_pred = false;\n\t\t\tif (open == 1) {\n\t\t\t\t*err = i;\n\t\t\t\treturn TOO_MANY_CLOSE;\n\t\t\t}\n\t\t\topen--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!is_pred) {\n\t\t\tnr_preds++;\n\t\t\tis_pred = true;\n\t\t}\n\t}\n\n\tif (quote) {\n\t\t*err = last_quote;\n\t\treturn MISSING_QUOTE;\n\t}\n\n\tif (open != 1) {\n\t\tint level = open;\n\n\t\t/* find the bad open */\n\t\tfor (i--; i; i--) {\n\t\t\tif (quote) {\n\t\t\t\tif (str[i] == quote)\n\t\t\t\t\tquote = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (str[i]) {\n\t\t\tcase '(':\n\t\t\t\tif (level == open) {\n\t\t\t\t\t*err = i;\n\t\t\t\t\treturn TOO_MANY_OPEN;\n\t\t\t\t}\n\t\t\t\tlevel--;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tquote = str[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* First character is the '(' with missing ')' */\n\t\t*err = 0;\n\t\treturn TOO_MANY_OPEN;\n\t}\n\n\t/* Set the size of the required stacks */\n\t*parens = max_open;\n\t*preds = nr_preds;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "str[i]"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int calc_stack(const char *str, int *parens, int *preds, int *err)\n{\n\tbool is_pred = false;\n\tint nr_preds = 0;\n\tint open = 1; /* Count the expression as \"(E)\" */\n\tint last_quote = 0;\n\tint max_open = 1;\n\tint quote = 0;\n\tint i;\n\n\t*err = 0;\n\n\tfor (i = 0; str[i]; i++) {\n\t\tif (isspace(str[i]))\n\t\t\tcontinue;\n\t\tif (quote) {\n\t\t\tif (str[i] == quote)\n\t\t\t       quote = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[i]) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tquote = str[i];\n\t\t\tlast_quote = i;\n\t\t\tbreak;\n\t\tcase '|':\n\t\tcase '&':\n\t\t\tif (str[i+1] != str[i])\n\t\t\t\tbreak;\n\t\t\tis_pred = false;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tis_pred = false;\n\t\t\topen++;\n\t\t\tif (open > max_open)\n\t\t\t\tmax_open = open;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tis_pred = false;\n\t\t\tif (open == 1) {\n\t\t\t\t*err = i;\n\t\t\t\treturn TOO_MANY_CLOSE;\n\t\t\t}\n\t\t\topen--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!is_pred) {\n\t\t\tnr_preds++;\n\t\t\tis_pred = true;\n\t\t}\n\t}\n\n\tif (quote) {\n\t\t*err = last_quote;\n\t\treturn MISSING_QUOTE;\n\t}\n\n\tif (open != 1) {\n\t\tint level = open;\n\n\t\t/* find the bad open */\n\t\tfor (i--; i; i--) {\n\t\t\tif (quote) {\n\t\t\t\tif (str[i] == quote)\n\t\t\t\t\tquote = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (str[i]) {\n\t\t\tcase '(':\n\t\t\t\tif (level == open) {\n\t\t\t\t\t*err = i;\n\t\t\t\t\treturn TOO_MANY_OPEN;\n\t\t\t\t}\n\t\t\t\tlevel--;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tquote = str[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* First character is the '(' with missing ')' */\n\t\t*err = 0;\n\t\treturn TOO_MANY_OPEN;\n\t}\n\n\t/* Set the size of the required stacks */\n\t*parens = max_open;\n\t*preds = nr_preds;\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_pred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1126-1361",
    "snippet": "static int parse_pred(const char *str, void *data,\n\t\t      int pos, struct filter_parse_error *pe,\n\t\t      struct filter_pred **pred_ptr)\n{\n\tstruct trace_event_call *call = data;\n\tstruct ftrace_event_field *field;\n\tstruct filter_pred *pred = NULL;\n\tchar num_buf[24];\t/* Big enough to hold an address */\n\tchar *field_name;\n\tchar q;\n\tu64 val;\n\tint len;\n\tint ret;\n\tint op;\n\tint s;\n\tint i = 0;\n\n\t/* First find the field to associate to */\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\n\tlen = i - s;\n\n\tif (!len)\n\t\treturn -1;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\n\t/* Make sure that the field exists */\n\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field) {\n\t\tparse_error(pe, FILT_ERR_FIELD_NOT_FOUND, pos + i);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\t/* Make sure this op is supported */\n\tfor (op = 0; ops[op]; op++) {\n\t\t/* This is why '<=' must come before '<' in ops[] */\n\t\tif (strncmp(str + i, ops[op], strlen(ops[op])) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ops[op]) {\n\t\tparse_error(pe, FILT_ERR_INVALID_OP, pos + i);\n\t\tgoto err_free;\n\t}\n\n\ti += strlen(ops[op]);\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\ts = i;\n\n\tpred = kzalloc(sizeof(*pred), GFP_KERNEL);\n\tif (!pred)\n\t\treturn -ENOMEM;\n\n\tpred->field = field;\n\tpred->offset = field->offset;\n\tpred->op = op;\n\n\tif (ftrace_event_is_function(call)) {\n\t\t/*\n\t\t * Perf does things different with function events.\n\t\t * It only allows an \"ip\" field, and expects a string.\n\t\t * But the string does not need to be surrounded by quotes.\n\t\t * If it is a string, the assigned function as a nop,\n\t\t * (perf doesn't use it) and grab everything.\n\t\t */\n\t\tif (strcmp(field->name, \"ip\") != 0) {\n\t\t\t parse_error(pe, FILT_ERR_IP_FIELD_ONLY, pos + i);\n\t\t\t goto err_free;\n\t\t }\n\t\t pred->fn = filter_pred_none;\n\n\t\t /*\n\t\t  * Quotes are not required, but if they exist then we need\n\t\t  * to read them till we hit a matching one.\n\t\t  */\n\t\t if (str[i] == '\\'' || str[i] == '\"')\n\t\t\t q = str[i];\n\t\t else\n\t\t\t q = 0;\n\n\t\t for (i++; str[i]; i++) {\n\t\t\t if (q && str[i] == q)\n\t\t\t\t break;\n\t\t\t if (!q && (str[i] == ')' || str[i] == '&' ||\n\t\t\t\t    str[i] == '|'))\n\t\t\t\t break;\n\t\t }\n\t\t /* Skip quotes */\n\t\t if (q)\n\t\t\t s++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t/* This is either a string, or an integer */\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t/* Make sure the op is OK for strings */\n\t\tswitch (op) {\n\t\tcase OP_NE:\n\t\t\tpred->not = 1;\n\t\t\t/* Fall through */\n\t\tcase OP_GLOB:\n\t\tcase OP_EQ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Make sure the field is OK for strings */\n\t\tif (!is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_DIGIT, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i]) {\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Skip quotes */\n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t\tfilter_build_regex(pred);\n\n\t\tif (field->filter_type == FILTER_COMM) {\n\t\t\tpred->fn = filter_pred_comm;\n\n\t\t} else if (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\tpred->fn = filter_pred_string;\n\t\t\tpred->regex.field_len = field->size;\n\n\t\t} else if (field->filter_type == FILTER_DYN_STRING)\n\t\t\tpred->fn = filter_pred_strloc;\n\t\telse\n\t\t\tpred->fn = filter_pred_pchar;\n\t\t/* go past the last quote */\n\t\ti++;\n\n\t} else if (isdigit(str[i])) {\n\n\t\t/* Make sure the field is not a string */\n\t\tif (is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_STRING, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (op == OP_GLOB) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* We allow 0xDEADBEEF */\n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\n\t\tlen = i - s;\n\t\t/* 0xfeedfacedeadbeef is 18 chars max */\n\t\tif (len >= sizeof(num_buf)) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tstrncpy(num_buf, str + s, len);\n\t\tnum_buf[len] = 0;\n\n\t\t/* Make sure it is a value */\n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num_buf, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num_buf, 0, &val);\n\t\tif (ret) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_INTVAL, pos + s);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->val = val;\n\n\t\tif (field->filter_type == FILTER_CPU)\n\t\t\tpred->fn = filter_pred_cpu;\n\t\telse {\n\t\t\tpred->fn = select_comparison_fn(pred->op, field->size,\n\t\t\t\t\t\t\tfield->is_signed);\n\t\t\tif (pred->op == OP_NE)\n\t\t\t\tpred->not = 1;\n\t\t}\n\n\t} else {\n\t\tparse_error(pe, FILT_ERR_INVALID_VALUE, pos + i);\n\t\tgoto err_free;\n\t}\n\n\t*pred_ptr = pred;\n\treturn i;\n\nerr_free:\n\tkfree(pred);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * ops[] = { OPS };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pred"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_error",
          "args": [
            "pe",
            "FILT_ERR_INVALID_VALUE",
            "pos + i"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "parse_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "132-136",
          "snippet": "static void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_comparison_fn",
          "args": [
            "pred->op",
            "field->size",
            "field->is_signed"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "select_comparison_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1069-1123",
          "snippet": "static filter_pred_fn_t select_comparison_fn(enum filter_op_ids op,\n\t\t\t\t\t    int field_size, int field_is_signed)\n{\n\tfilter_pred_fn_t fn = NULL;\n\tint pred_func_index = -1;\n\n\tswitch (op) {\n\tcase OP_EQ:\n\tcase OP_NE:\n\t\tbreak;\n\tdefault:\n\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))\n\t\t\treturn NULL;\n\t\tpred_func_index = op - PRED_FUNC_START;\n\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))\n\t\t\treturn NULL;\n\t}\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_64;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s64[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u64[pred_func_index];\n\t\tbreak;\n\tcase 4:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_32;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s32[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u32[pred_func_index];\n\t\tbreak;\n\tcase 2:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_16;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s16[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u16[pred_func_index];\n\t\tbreak;\n\tcase 1:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_8;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s8[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u8[pred_func_index];\n\t\tbreak;\n\t}\n\n\treturn fn;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define PRED_FUNC_MAX\t\t\t(OP_BAND - PRED_FUNC_START)",
            "#define PRED_FUNC_START\t\t\tOP_LE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\n#define PRED_FUNC_MAX\t\t\t(OP_BAND - PRED_FUNC_START)\n#define PRED_FUNC_START\t\t\tOP_LE\n\nstatic filter_pred_fn_t select_comparison_fn(enum filter_op_ids op,\n\t\t\t\t\t    int field_size, int field_is_signed)\n{\n\tfilter_pred_fn_t fn = NULL;\n\tint pred_func_index = -1;\n\n\tswitch (op) {\n\tcase OP_EQ:\n\tcase OP_NE:\n\t\tbreak;\n\tdefault:\n\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))\n\t\t\treturn NULL;\n\t\tpred_func_index = op - PRED_FUNC_START;\n\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))\n\t\t\treturn NULL;\n\t}\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_64;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s64[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u64[pred_func_index];\n\t\tbreak;\n\tcase 4:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_32;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s32[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u32[pred_func_index];\n\t\tbreak;\n\tcase 2:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_16;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s16[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u16[pred_func_index];\n\t\tbreak;\n\tcase 1:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_8;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s8[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u8[pred_func_index];\n\t\tbreak;\n\t}\n\n\treturn fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoull",
          "args": [
            "num_buf",
            "0",
            "&val"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoll",
          "args": [
            "num_buf",
            "0",
            "&val"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "num_buf",
            "str + s",
            "len"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "str[i]"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_string_field",
          "args": [
            "field"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "is_string_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1417-1423",
          "snippet": "static inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "str[i]"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter_build_regex",
          "args": [
            "pred"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "filter_build_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "848-877",
          "snippet": "static void filter_build_regex(struct filter_pred *pred)\n{\n\tstruct regex *r = &pred->regex;\n\tchar *search;\n\tenum regex_type type = MATCH_FULL;\n\n\tif (pred->op == OP_GLOB) {\n\t\ttype = filter_parse_regex(r->pattern, r->len, &search, &pred->not);\n\t\tr->len = strlen(search);\n\t\tmemmove(r->pattern, search, r->len+1);\n\t}\n\n\tswitch (type) {\n\tcase MATCH_FULL:\n\t\tr->match = regex_match_full;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tr->match = regex_match_front;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tr->match = regex_match_middle;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tr->match = regex_match_end;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tr->match = regex_match_glob;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void filter_build_regex(struct filter_pred *pred)\n{\n\tstruct regex *r = &pred->regex;\n\tchar *search;\n\tenum regex_type type = MATCH_FULL;\n\n\tif (pred->op == OP_GLOB) {\n\t\ttype = filter_parse_regex(r->pattern, r->len, &search, &pred->not);\n\t\tr->len = strlen(search);\n\t\tmemmove(r->pattern, search, r->len+1);\n\t}\n\n\tswitch (type) {\n\tcase MATCH_FULL:\n\t\tr->match = regex_match_full;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tr->match = regex_match_front;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tr->match = regex_match_middle;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tr->match = regex_match_end;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tr->match = regex_match_glob;\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pred->regex.pattern",
            "str + s",
            "len"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "pred->regex.pattern",
            "str + s",
            "len"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field->name",
            "\"ip\""
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_event_is_function",
          "args": [
            "call"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_is_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_export.c",
          "lines": "198-201",
          "snippet": "bool ftrace_event_is_function(struct trace_event_call *call)\n{\n\treturn call == &event_function;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include \"trace_output.h\"",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/stringify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include \"trace_output.h\"\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stringify.h>\n\nbool ftrace_event_is_function(struct trace_event_call *call)\n{\n\treturn call == &event_function;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pred)",
            "GFP_KERNEL"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "str[i]"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ops[op]"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str + i",
            "ops[op]",
            "strlen(ops[op])"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "str[i]"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_find_event_field",
          "args": [
            "call",
            "field_name"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_event_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "94-110",
          "snippet": "struct ftrace_event_field *\ntrace_find_event_field(struct trace_event_call *call, char *name)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tfield = __find_event_field(head, name);\n\tif (field)\n\t\treturn field;\n\n\tfield = __find_event_field(&ftrace_generic_fields, name);\n\tif (field)\n\t\treturn field;\n\n\treturn __find_event_field(&ftrace_common_fields, name);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ftrace_generic_fields);",
            "static LIST_HEAD(ftrace_common_fields);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(ftrace_generic_fields);\nstatic LIST_HEAD(ftrace_common_fields);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstruct ftrace_event_field *\ntrace_find_event_field(struct trace_event_call *call, char *name)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tfield = __find_event_field(head, name);\n\tif (field)\n\t\treturn field;\n\n\tfield = __find_event_field(&ftrace_generic_fields, name);\n\tif (field)\n\t\treturn field;\n\n\treturn __find_event_field(&ftrace_common_fields, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup_nul",
          "args": [
            "str + s",
            "len",
            "GFP_KERNEL"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "str[i]"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "str[i]"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic const char * ops[] = { OPS };\n\nstatic int parse_pred(const char *str, void *data,\n\t\t      int pos, struct filter_parse_error *pe,\n\t\t      struct filter_pred **pred_ptr)\n{\n\tstruct trace_event_call *call = data;\n\tstruct ftrace_event_field *field;\n\tstruct filter_pred *pred = NULL;\n\tchar num_buf[24];\t/* Big enough to hold an address */\n\tchar *field_name;\n\tchar q;\n\tu64 val;\n\tint len;\n\tint ret;\n\tint op;\n\tint s;\n\tint i = 0;\n\n\t/* First find the field to associate to */\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\n\tlen = i - s;\n\n\tif (!len)\n\t\treturn -1;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\n\t/* Make sure that the field exists */\n\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field) {\n\t\tparse_error(pe, FILT_ERR_FIELD_NOT_FOUND, pos + i);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\t/* Make sure this op is supported */\n\tfor (op = 0; ops[op]; op++) {\n\t\t/* This is why '<=' must come before '<' in ops[] */\n\t\tif (strncmp(str + i, ops[op], strlen(ops[op])) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ops[op]) {\n\t\tparse_error(pe, FILT_ERR_INVALID_OP, pos + i);\n\t\tgoto err_free;\n\t}\n\n\ti += strlen(ops[op]);\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\ts = i;\n\n\tpred = kzalloc(sizeof(*pred), GFP_KERNEL);\n\tif (!pred)\n\t\treturn -ENOMEM;\n\n\tpred->field = field;\n\tpred->offset = field->offset;\n\tpred->op = op;\n\n\tif (ftrace_event_is_function(call)) {\n\t\t/*\n\t\t * Perf does things different with function events.\n\t\t * It only allows an \"ip\" field, and expects a string.\n\t\t * But the string does not need to be surrounded by quotes.\n\t\t * If it is a string, the assigned function as a nop,\n\t\t * (perf doesn't use it) and grab everything.\n\t\t */\n\t\tif (strcmp(field->name, \"ip\") != 0) {\n\t\t\t parse_error(pe, FILT_ERR_IP_FIELD_ONLY, pos + i);\n\t\t\t goto err_free;\n\t\t }\n\t\t pred->fn = filter_pred_none;\n\n\t\t /*\n\t\t  * Quotes are not required, but if they exist then we need\n\t\t  * to read them till we hit a matching one.\n\t\t  */\n\t\t if (str[i] == '\\'' || str[i] == '\"')\n\t\t\t q = str[i];\n\t\t else\n\t\t\t q = 0;\n\n\t\t for (i++; str[i]; i++) {\n\t\t\t if (q && str[i] == q)\n\t\t\t\t break;\n\t\t\t if (!q && (str[i] == ')' || str[i] == '&' ||\n\t\t\t\t    str[i] == '|'))\n\t\t\t\t break;\n\t\t }\n\t\t /* Skip quotes */\n\t\t if (q)\n\t\t\t s++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t/* This is either a string, or an integer */\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t/* Make sure the op is OK for strings */\n\t\tswitch (op) {\n\t\tcase OP_NE:\n\t\t\tpred->not = 1;\n\t\t\t/* Fall through */\n\t\tcase OP_GLOB:\n\t\tcase OP_EQ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Make sure the field is OK for strings */\n\t\tif (!is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_DIGIT, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i]) {\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Skip quotes */\n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t\tfilter_build_regex(pred);\n\n\t\tif (field->filter_type == FILTER_COMM) {\n\t\t\tpred->fn = filter_pred_comm;\n\n\t\t} else if (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\tpred->fn = filter_pred_string;\n\t\t\tpred->regex.field_len = field->size;\n\n\t\t} else if (field->filter_type == FILTER_DYN_STRING)\n\t\t\tpred->fn = filter_pred_strloc;\n\t\telse\n\t\t\tpred->fn = filter_pred_pchar;\n\t\t/* go past the last quote */\n\t\ti++;\n\n\t} else if (isdigit(str[i])) {\n\n\t\t/* Make sure the field is not a string */\n\t\tif (is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_STRING, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (op == OP_GLOB) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* We allow 0xDEADBEEF */\n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\n\t\tlen = i - s;\n\t\t/* 0xfeedfacedeadbeef is 18 chars max */\n\t\tif (len >= sizeof(num_buf)) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tstrncpy(num_buf, str + s, len);\n\t\tnum_buf[len] = 0;\n\n\t\t/* Make sure it is a value */\n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num_buf, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num_buf, 0, &val);\n\t\tif (ret) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_INTVAL, pos + s);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->val = val;\n\n\t\tif (field->filter_type == FILTER_CPU)\n\t\t\tpred->fn = filter_pred_cpu;\n\t\telse {\n\t\t\tpred->fn = select_comparison_fn(pred->op, field->size,\n\t\t\t\t\t\t\tfield->is_signed);\n\t\t\tif (pred->op == OP_NE)\n\t\t\t\tpred->not = 1;\n\t\t}\n\n\t} else {\n\t\tparse_error(pe, FILT_ERR_INVALID_VALUE, pos + i);\n\t\tgoto err_free;\n\t}\n\n\t*pred_ptr = pred;\n\treturn i;\n\nerr_free:\n\tkfree(pred);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "select_comparison_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1069-1123",
    "snippet": "static filter_pred_fn_t select_comparison_fn(enum filter_op_ids op,\n\t\t\t\t\t    int field_size, int field_is_signed)\n{\n\tfilter_pred_fn_t fn = NULL;\n\tint pred_func_index = -1;\n\n\tswitch (op) {\n\tcase OP_EQ:\n\tcase OP_NE:\n\t\tbreak;\n\tdefault:\n\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))\n\t\t\treturn NULL;\n\t\tpred_func_index = op - PRED_FUNC_START;\n\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))\n\t\t\treturn NULL;\n\t}\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_64;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s64[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u64[pred_func_index];\n\t\tbreak;\n\tcase 4:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_32;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s32[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u32[pred_func_index];\n\t\tbreak;\n\tcase 2:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_16;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s16[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u16[pred_func_index];\n\t\tbreak;\n\tcase 1:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_8;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s8[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u8[pred_func_index];\n\t\tbreak;\n\t}\n\n\treturn fn;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define PRED_FUNC_MAX\t\t\t(OP_BAND - PRED_FUNC_START)",
      "#define PRED_FUNC_START\t\t\tOP_LE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pred_func_index > PRED_FUNC_MAX"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "op < PRED_FUNC_START"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\n#define PRED_FUNC_MAX\t\t\t(OP_BAND - PRED_FUNC_START)\n#define PRED_FUNC_START\t\t\tOP_LE\n\nstatic filter_pred_fn_t select_comparison_fn(enum filter_op_ids op,\n\t\t\t\t\t    int field_size, int field_is_signed)\n{\n\tfilter_pred_fn_t fn = NULL;\n\tint pred_func_index = -1;\n\n\tswitch (op) {\n\tcase OP_EQ:\n\tcase OP_NE:\n\t\tbreak;\n\tdefault:\n\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))\n\t\t\treturn NULL;\n\t\tpred_func_index = op - PRED_FUNC_START;\n\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))\n\t\t\treturn NULL;\n\t}\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_64;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s64[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u64[pred_func_index];\n\t\tbreak;\n\tcase 4:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_32;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s32[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u32[pred_func_index];\n\t\tbreak;\n\tcase 2:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_16;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s16[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u16[pred_func_index];\n\t\tbreak;\n\tcase 1:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_8;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s8[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u8[pred_func_index];\n\t\tbreak;\n\t}\n\n\treturn fn;\n}"
  },
  {
    "function_name": "filter_assign_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1058-1067",
    "snippet": "int filter_assign_type(const char *type)\n{\n\tif (strstr(type, \"__data_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_DYN_STRING;\n\n\tif (strchr(type, '[') && strstr(type, \"char\"))\n\t\treturn FILTER_STATIC_STRING;\n\n\treturn FILTER_OTHER;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"char\""
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "type",
            "'['"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"char\""
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"__data_loc\""
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint filter_assign_type(const char *type)\n{\n\tif (strstr(type, \"__data_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_DYN_STRING;\n\n\tif (strchr(type, '[') && strstr(type, \"char\"))\n\t\treturn FILTER_STATIC_STRING;\n\n\treturn FILTER_OTHER;\n}"
  },
  {
    "function_name": "filter_free_subsystem_filters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1046-1056",
    "snippet": "static void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,\n\t\t\t\t\t  struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__free_subsystem_filter(file);\n\t}\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_subsystem_filter",
          "args": [
            "file"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "__free_subsystem_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1040-1044",
          "snippet": "static inline void __free_subsystem_filter(struct trace_event_file *file)\n{\n\t__free_filter(file->filter);\n\tfile->filter = NULL;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline void __free_subsystem_filter(struct trace_event_file *file)\n{\n\t__free_filter(file->filter);\n\tfile->filter = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,\n\t\t\t\t\t  struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__free_subsystem_filter(file);\n\t}\n}"
  },
  {
    "function_name": "__free_subsystem_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1040-1044",
    "snippet": "static inline void __free_subsystem_filter(struct trace_event_file *file)\n{\n\t__free_filter(file->filter);\n\tfile->filter = NULL;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "file->filter"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1007-1015",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline void __free_subsystem_filter(struct trace_event_file *file)\n{\n\t__free_filter(file->filter);\n\tfile->filter = NULL;\n}"
  },
  {
    "function_name": "filter_free_subsystem_preds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1028-1038",
    "snippet": "static void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__remove_filter(file);\n\t}\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__remove_filter",
          "args": [
            "file"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1022-1026",
          "snippet": "static inline void __remove_filter(struct trace_event_file *file)\n{\n\tfilter_disable(file);\n\tremove_filter_string(file->filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline void __remove_filter(struct trace_event_file *file)\n{\n\tfilter_disable(file);\n\tremove_filter_string(file->filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__remove_filter(file);\n\t}\n}"
  },
  {
    "function_name": "__remove_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1022-1026",
    "snippet": "static inline void __remove_filter(struct trace_event_file *file)\n{\n\tfilter_disable(file);\n\tremove_filter_string(file->filter);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_filter_string",
          "args": [
            "file->filter"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "remove_filter_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "904-911",
          "snippet": "static void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_disable",
          "args": [
            "file"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "filter_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "997-1005",
          "snippet": "static void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline void __remove_filter(struct trace_event_file *file)\n{\n\tfilter_disable(file);\n\tremove_filter_string(file->filter);\n}"
  },
  {
    "function_name": "free_event_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1017-1020",
    "snippet": "void free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_filter",
          "args": [
            "filter"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "__free_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1007-1015",
          "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}"
  },
  {
    "function_name": "__free_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "1007-1015",
    "snippet": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filter"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_prog",
          "args": [
            "filter"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "free_prog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "983-995",
          "snippet": "static void free_prog(struct event_filter *filter)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\tprog = rcu_access_pointer(filter->prog);\n\tif (!prog)\n\t\treturn;\n\n\tfor (i = 0; prog[i].pred; i++)\n\t\tkfree(prog[i].pred);\n\tkfree(prog);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void free_prog(struct event_filter *filter)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\tprog = rcu_access_pointer(filter->prog);\n\tif (!prog)\n\t\treturn;\n\n\tfor (i = 0; prog[i].pred; i++)\n\t\tkfree(prog[i].pred);\n\tkfree(prog);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}"
  },
  {
    "function_name": "filter_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "997-1005",
    "snippet": "static void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffered_event_disable",
          "args": [],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffered_event_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2234-2270",
          "snippet": "void trace_buffered_event_disable(void)\n{\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (WARN_ON_ONCE(!trace_buffered_event_ref))\n\t\treturn;\n\n\tif (--trace_buffered_event_ref)\n\t\treturn;\n\n\tpreempt_disable();\n\t/* For each CPU, set the buffer as used. */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       disable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n\n\t/* Wait for all current users to finish */\n\tsynchronize_sched();\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tfree_page((unsigned long)per_cpu(trace_buffered_event, cpu));\n\t\tper_cpu(trace_buffered_event, cpu) = NULL;\n\t}\n\t/*\n\t * Make sure trace_buffered_event is NULL before clearing\n\t * trace_buffered_event_cnt.\n\t */\n\tsmp_wmb();\n\n\tpreempt_disable();\n\t/* Do the work on each cpu */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       enable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_buffered_event_ref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int trace_buffered_event_ref;\n\nvoid trace_buffered_event_disable(void)\n{\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (WARN_ON_ONCE(!trace_buffered_event_ref))\n\t\treturn;\n\n\tif (--trace_buffered_event_ref)\n\t\treturn;\n\n\tpreempt_disable();\n\t/* For each CPU, set the buffer as used. */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       disable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n\n\t/* Wait for all current users to finish */\n\tsynchronize_sched();\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tfree_page((unsigned long)per_cpu(trace_buffered_event, cpu));\n\t\tper_cpu(trace_buffered_event, cpu) = NULL;\n\t}\n\t/*\n\t * Make sure trace_buffered_event is NULL before clearing\n\t * trace_buffered_event_cnt.\n\t */\n\tsmp_wmb();\n\n\tpreempt_disable();\n\t/* Do the work on each cpu */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       enable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}"
  },
  {
    "function_name": "free_prog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "983-995",
    "snippet": "static void free_prog(struct event_filter *filter)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\tprog = rcu_access_pointer(filter->prog);\n\tif (!prog)\n\t\treturn;\n\n\tfor (i = 0; prog[i].pred; i++)\n\t\tkfree(prog[i].pred);\n\tkfree(prog);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "prog"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "filter->prog"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void free_prog(struct event_filter *filter)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\tprog = rcu_access_pointer(filter->prog);\n\tif (!prog)\n\t\treturn;\n\n\tfor (i = 0; prog[i].pred; i++)\n\t\tkfree(prog[i].pred);\n\tkfree(prog);\n}"
  },
  {
    "function_name": "print_subsystem_event_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "969-981",
    "snippet": "void print_subsystem_event_filter(struct event_subsystem *system,\n\t\t\t\t  struct trace_seq *s)\n{\n\tstruct event_filter *filter;\n\n\tmutex_lock(&event_mutex);\n\tfilter = system->filter;\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, DEFAULT_SYS_FILTER_MESSAGE \"\\n\");\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DEFAULT_SYS_FILTER_MESSAGE\t\t\t\t\t\\\n\t\"### global filter ###\\n\"\t\t\t\t\t\\\n\t\"# Use this to set filters for multiple events.\\n\"\t\t\\\n\t\"# Only events with the given fields will be affected.\\n\"\t\\\n\t\"# If no events are modified, an error message will be displayed here\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "DEFAULT_SYS_FILTER_MESSAGE \"\\n\""
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s\\n\"",
            "filter->filter_string"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\n#define DEFAULT_SYS_FILTER_MESSAGE\t\t\t\t\t\\\n\t\"### global filter ###\\n\"\t\t\t\t\t\\\n\t\"# Use this to set filters for multiple events.\\n\"\t\t\\\n\t\"# Only events with the given fields will be affected.\\n\"\t\\\n\t\"# If no events are modified, an error message will be displayed here\"\n\nvoid print_subsystem_event_filter(struct event_subsystem *system,\n\t\t\t\t  struct trace_seq *s)\n{\n\tstruct event_filter *filter;\n\n\tmutex_lock(&event_mutex);\n\tfilter = system->filter;\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, DEFAULT_SYS_FILTER_MESSAGE \"\\n\");\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "print_event_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "959-967",
    "snippet": "void print_event_filter(struct trace_event_file *file, struct trace_seq *s)\n{\n\tstruct event_filter *filter = event_filter(file);\n\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, \"none\\n\");\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"none\\n\""
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s\\n\"",
            "filter->filter_string"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_filter",
          "args": [
            "file"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "free_event_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1017-1020",
          "snippet": "void free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid print_event_filter(struct trace_event_file *file, struct trace_seq *s)\n{\n\tstruct event_filter *filter = event_filter(file);\n\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, \"none\\n\");\n}"
  },
  {
    "function_name": "event_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "953-956",
    "snippet": "static inline struct event_filter *event_filter(struct trace_event_file *file)\n{\n\treturn file->filter;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic inline struct event_filter *event_filter(struct trace_event_file *file)\n{\n\treturn file->filter;\n}"
  },
  {
    "function_name": "append_filter_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "913-951",
    "snippet": "static void append_filter_err(struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *err_text[] = { ERRORS };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup_nul",
          "args": [
            "s->buffer",
            "s->seq.len",
            "GFP_KERNEL"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "0"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"\\nError: (%d)\\n\"",
            "pe->lasterr"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "filter->filter_string"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filter->filter_string"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_init",
          "args": [
            "s"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "39-43",
          "snippet": "static inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nstatic inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*s)",
            "GFP_KERNEL"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!filter->filter_string"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic char *err_text[] = { ERRORS };\n\nstatic void append_filter_err(struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}"
  },
  {
    "function_name": "remove_filter_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "904-911",
    "snippet": "static void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filter->filter_string"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}"
  },
  {
    "function_name": "filter_match_preds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "880-901",
    "snippet": "int filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t/* no filter is considered a match */\n\tif (!filter)\n\t\treturn 1;\n\n\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */\n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pred->fn",
          "args": [
            "pred",
            "rec"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "filter->prog"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t/* no filter is considered a match */\n\tif (!filter)\n\t\treturn 1;\n\n\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */\n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}"
  },
  {
    "function_name": "filter_build_regex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "848-877",
    "snippet": "static void filter_build_regex(struct filter_pred *pred)\n{\n\tstruct regex *r = &pred->regex;\n\tchar *search;\n\tenum regex_type type = MATCH_FULL;\n\n\tif (pred->op == OP_GLOB) {\n\t\ttype = filter_parse_regex(r->pattern, r->len, &search, &pred->not);\n\t\tr->len = strlen(search);\n\t\tmemmove(r->pattern, search, r->len+1);\n\t}\n\n\tswitch (type) {\n\tcase MATCH_FULL:\n\t\tr->match = regex_match_full;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tr->match = regex_match_front;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tr->match = regex_match_middle;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tr->match = regex_match_end;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tr->match = regex_match_glob;\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "r->pattern",
            "search",
            "r->len+1"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "search"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_parse_regex",
          "args": [
            "r->pattern",
            "r->len",
            "&search",
            "&pred->not"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "filter_parse_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "810-846",
          "snippet": "enum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nenum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void filter_build_regex(struct filter_pred *pred)\n{\n\tstruct regex *r = &pred->regex;\n\tchar *search;\n\tenum regex_type type = MATCH_FULL;\n\n\tif (pred->op == OP_GLOB) {\n\t\ttype = filter_parse_regex(r->pattern, r->len, &search, &pred->not);\n\t\tr->len = strlen(search);\n\t\tmemmove(r->pattern, search, r->len+1);\n\t}\n\n\tswitch (type) {\n\tcase MATCH_FULL:\n\t\tr->match = regex_match_full;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tr->match = regex_match_front;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tr->match = regex_match_middle;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tr->match = regex_match_end;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tr->match = regex_match_glob;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "filter_parse_regex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "810-846",
    "snippet": "enum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\"[?\\\\\"",
            "buff[i]"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nenum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}"
  },
  {
    "function_name": "regex_match_glob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "786-791",
    "snippet": "static int regex_match_glob(char *str, struct regex *r, int len __maybe_unused)\n{\n\tif (glob_match(r->pattern, str))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "glob_match",
          "args": [
            "r->pattern",
            "str"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int regex_match_glob(char *str, struct regex *r, int len __maybe_unused)\n{\n\tif (glob_match(r->pattern, str))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "regex_match_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "776-784",
    "snippet": "static int regex_match_end(char *str, struct regex *r, int len)\n{\n\tint strlen = len - 1;\n\n\tif (strlen >= r->len &&\n\t    memcmp(str + strlen - r->len, r->pattern, r->len) == 0)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "str + strlen - r->len",
            "r->pattern",
            "r->len"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int regex_match_end(char *str, struct regex *r, int len)\n{\n\tint strlen = len - 1;\n\n\tif (strlen >= r->len &&\n\t    memcmp(str + strlen - r->len, r->pattern, r->len) == 0)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "regex_match_middle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "768-774",
    "snippet": "static int regex_match_middle(char *str, struct regex *r, int len)\n{\n\tif (!len)\n\t\treturn strstr(str, r->pattern) != NULL;\n\n\treturn strnstr(str, r->pattern, len) != NULL;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strnstr",
          "args": [
            "str",
            "r->pattern",
            "len"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "r->pattern"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int regex_match_middle(char *str, struct regex *r, int len)\n{\n\tif (!len)\n\t\treturn strstr(str, r->pattern) != NULL;\n\n\treturn strnstr(str, r->pattern, len) != NULL;\n}"
  },
  {
    "function_name": "regex_match_front",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "760-766",
    "snippet": "static int regex_match_front(char *str, struct regex *r, int len)\n{\n\tif (len && len < r->len)\n\t\treturn 0;\n\n\treturn strncmp(str, r->pattern, r->len) == 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "r->pattern",
            "r->len"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int regex_match_front(char *str, struct regex *r, int len)\n{\n\tif (len && len < r->len)\n\t\treturn 0;\n\n\treturn strncmp(str, r->pattern, r->len) == 0;\n}"
  },
  {
    "function_name": "regex_match_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "751-758",
    "snippet": "static int regex_match_full(char *str, struct regex *r, int len)\n{\n\t/* len of zero means str is dynamic and ends with '\\0' */\n\tif (!len)\n\t\treturn strcmp(str, r->pattern) == 0;\n\n\treturn strncmp(str, r->pattern, len) == 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "r->pattern",
            "len"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "r->pattern"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int regex_match_full(char *str, struct regex *r, int len)\n{\n\t/* len of zero means str is dynamic and ends with '\\0' */\n\tif (!len)\n\t\treturn strcmp(str, r->pattern) == 0;\n\n\treturn strncmp(str, r->pattern, len) == 0;\n}"
  },
  {
    "function_name": "filter_pred_none",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "734-737",
    "snippet": "static int filter_pred_none(struct filter_pred *pred, void *event)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int filter_pred_none(struct filter_pred *pred, void *event)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "filter_pred_comm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "725-732",
    "snippet": "static int filter_pred_comm(struct filter_pred *pred, void *event)\n{\n\tint cmp;\n\n\tcmp = pred->regex.match(current->comm, &pred->regex,\n\t\t\t\tTASK_COMM_LEN);\n\treturn cmp ^ pred->not;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pred->regex.match",
          "args": [
            "current->comm",
            "&pred->regex",
            "TASK_COMM_LEN"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int filter_pred_comm(struct filter_pred *pred, void *event)\n{\n\tint cmp;\n\n\tcmp = pred->regex.match(current->comm, &pred->regex,\n\t\t\t\tTASK_COMM_LEN);\n\treturn cmp ^ pred->not;\n}"
  },
  {
    "function_name": "filter_pred_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "699-722",
    "snippet": "static int filter_pred_cpu(struct filter_pred *pred, void *event)\n{\n\tint cpu, cmp;\n\n\tcpu = raw_smp_processor_id();\n\tcmp = pred->val;\n\n\tswitch (pred->op) {\n\tcase OP_EQ:\n\t\treturn cpu == cmp;\n\tcase OP_NE:\n\t\treturn cpu != cmp;\n\tcase OP_LT:\n\t\treturn cpu < cmp;\n\tcase OP_LE:\n\t\treturn cpu <= cmp;\n\tcase OP_GT:\n\t\treturn cpu > cmp;\n\tcase OP_GE:\n\t\treturn cpu >= cmp;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int filter_pred_cpu(struct filter_pred *pred, void *event)\n{\n\tint cpu, cmp;\n\n\tcpu = raw_smp_processor_id();\n\tcmp = pred->val;\n\n\tswitch (pred->op) {\n\tcase OP_EQ:\n\t\treturn cpu == cmp;\n\tcase OP_NE:\n\t\treturn cpu != cmp;\n\tcase OP_LT:\n\t\treturn cpu < cmp;\n\tcase OP_LE:\n\t\treturn cpu <= cmp;\n\tcase OP_GT:\n\t\treturn cpu > cmp;\n\tcase OP_GE:\n\t\treturn cpu >= cmp;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "filter_pred_strloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "683-696",
    "snippet": "static int filter_pred_strloc(struct filter_pred *pred, void *event)\n{\n\tu32 str_item = *(u32 *)(event + pred->offset);\n\tint str_loc = str_item & 0xffff;\n\tint str_len = str_item >> 16;\n\tchar *addr = (char *)(event + str_loc);\n\tint cmp, match;\n\n\tcmp = pred->regex.match(addr, &pred->regex, str_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pred->regex.match",
          "args": [
            "addr",
            "&pred->regex",
            "str_len"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int filter_pred_strloc(struct filter_pred *pred, void *event)\n{\n\tu32 str_item = *(u32 *)(event + pred->offset);\n\tint str_loc = str_item & 0xffff;\n\tint str_len = str_item >> 16;\n\tchar *addr = (char *)(event + str_loc);\n\tint cmp, match;\n\n\tcmp = pred->regex.match(addr, &pred->regex, str_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}"
  },
  {
    "function_name": "filter_pred_pchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "660-671",
    "snippet": "static int filter_pred_pchar(struct filter_pred *pred, void *event)\n{\n\tchar **addr = (char **)(event + pred->offset);\n\tint cmp, match;\n\tint len = strlen(*addr) + 1;\t/* including tailing '\\0' */\n\n\tcmp = pred->regex.match(*addr, &pred->regex, len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pred->regex.match",
          "args": [
            "*addr",
            "&pred->regex",
            "len"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*addr"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int filter_pred_pchar(struct filter_pred *pred, void *event)\n{\n\tchar **addr = (char **)(event + pred->offset);\n\tint cmp, match;\n\tint len = strlen(*addr) + 1;\t/* including tailing '\\0' */\n\n\tcmp = pred->regex.match(*addr, &pred->regex, len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}"
  },
  {
    "function_name": "filter_pred_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "647-657",
    "snippet": "static int filter_pred_string(struct filter_pred *pred, void *event)\n{\n\tchar *addr = (char *)(event + pred->offset);\n\tint cmp, match;\n\n\tcmp = pred->regex.match(addr, &pred->regex, pred->regex.field_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pred->regex.match",
          "args": [
            "addr",
            "&pred->regex",
            "pred->regex.field_len"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic int filter_pred_string(struct filter_pred *pred, void *event)\n{\n\tchar *addr = (char *)(event + pred->offset);\n\tint cmp, match;\n\n\tcmp = pred->regex.match(addr, &pred->regex, pred->regex.field_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}"
  },
  {
    "function_name": "predicate_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "408-579",
    "snippet": "static struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kmalloc_array(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tif (!N) {\n\t\t/* No program? */\n\t\tret = -EINVAL;\n\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n\tprog[N].target = 1;\t\t/* TRUE */\n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(prog_stack);\n\tkfree(inverts);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "inverts"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "prog[i].target <= i"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_error",
          "args": [
            "pe",
            "FILT_ERR_NO_FILTER",
            "ptr - str"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "parse_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "132-136",
          "snippet": "static void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_preds",
          "args": [
            "prog",
            "N - 1",
            "!invert"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "update_preds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "116-125",
          "snippet": "static void update_preds(struct prog_entry *prog, int N, int invert)\n{\n\tint t, s;\n\n\tt = prog[N].target;\n\ts = prog[t].target;\n\tprog[t].when_to_branch = invert;\n\tprog[t].target = N;\n\tprog[N].target = s;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void update_preds(struct prog_entry *prog, int N, int invert)\n{\n\tint t, s;\n\n\tt = prog[N].target;\n\ts = prog[t].target;\n\tprog[t].when_to_branch = invert;\n\tprog[t].target = N;\n\tprog[N].target = s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*next"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_pred",
          "args": [
            "next",
            "data",
            "ptr - str",
            "pe",
            "&prog[N].pred"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "parse_pred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1126-1361",
          "snippet": "static int parse_pred(const char *str, void *data,\n\t\t      int pos, struct filter_parse_error *pe,\n\t\t      struct filter_pred **pred_ptr)\n{\n\tstruct trace_event_call *call = data;\n\tstruct ftrace_event_field *field;\n\tstruct filter_pred *pred = NULL;\n\tchar num_buf[24];\t/* Big enough to hold an address */\n\tchar *field_name;\n\tchar q;\n\tu64 val;\n\tint len;\n\tint ret;\n\tint op;\n\tint s;\n\tint i = 0;\n\n\t/* First find the field to associate to */\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\n\tlen = i - s;\n\n\tif (!len)\n\t\treturn -1;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\n\t/* Make sure that the field exists */\n\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field) {\n\t\tparse_error(pe, FILT_ERR_FIELD_NOT_FOUND, pos + i);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\t/* Make sure this op is supported */\n\tfor (op = 0; ops[op]; op++) {\n\t\t/* This is why '<=' must come before '<' in ops[] */\n\t\tif (strncmp(str + i, ops[op], strlen(ops[op])) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ops[op]) {\n\t\tparse_error(pe, FILT_ERR_INVALID_OP, pos + i);\n\t\tgoto err_free;\n\t}\n\n\ti += strlen(ops[op]);\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\ts = i;\n\n\tpred = kzalloc(sizeof(*pred), GFP_KERNEL);\n\tif (!pred)\n\t\treturn -ENOMEM;\n\n\tpred->field = field;\n\tpred->offset = field->offset;\n\tpred->op = op;\n\n\tif (ftrace_event_is_function(call)) {\n\t\t/*\n\t\t * Perf does things different with function events.\n\t\t * It only allows an \"ip\" field, and expects a string.\n\t\t * But the string does not need to be surrounded by quotes.\n\t\t * If it is a string, the assigned function as a nop,\n\t\t * (perf doesn't use it) and grab everything.\n\t\t */\n\t\tif (strcmp(field->name, \"ip\") != 0) {\n\t\t\t parse_error(pe, FILT_ERR_IP_FIELD_ONLY, pos + i);\n\t\t\t goto err_free;\n\t\t }\n\t\t pred->fn = filter_pred_none;\n\n\t\t /*\n\t\t  * Quotes are not required, but if they exist then we need\n\t\t  * to read them till we hit a matching one.\n\t\t  */\n\t\t if (str[i] == '\\'' || str[i] == '\"')\n\t\t\t q = str[i];\n\t\t else\n\t\t\t q = 0;\n\n\t\t for (i++; str[i]; i++) {\n\t\t\t if (q && str[i] == q)\n\t\t\t\t break;\n\t\t\t if (!q && (str[i] == ')' || str[i] == '&' ||\n\t\t\t\t    str[i] == '|'))\n\t\t\t\t break;\n\t\t }\n\t\t /* Skip quotes */\n\t\t if (q)\n\t\t\t s++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t/* This is either a string, or an integer */\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t/* Make sure the op is OK for strings */\n\t\tswitch (op) {\n\t\tcase OP_NE:\n\t\t\tpred->not = 1;\n\t\t\t/* Fall through */\n\t\tcase OP_GLOB:\n\t\tcase OP_EQ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Make sure the field is OK for strings */\n\t\tif (!is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_DIGIT, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i]) {\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Skip quotes */\n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t\tfilter_build_regex(pred);\n\n\t\tif (field->filter_type == FILTER_COMM) {\n\t\t\tpred->fn = filter_pred_comm;\n\n\t\t} else if (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\tpred->fn = filter_pred_string;\n\t\t\tpred->regex.field_len = field->size;\n\n\t\t} else if (field->filter_type == FILTER_DYN_STRING)\n\t\t\tpred->fn = filter_pred_strloc;\n\t\telse\n\t\t\tpred->fn = filter_pred_pchar;\n\t\t/* go past the last quote */\n\t\ti++;\n\n\t} else if (isdigit(str[i])) {\n\n\t\t/* Make sure the field is not a string */\n\t\tif (is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_STRING, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (op == OP_GLOB) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* We allow 0xDEADBEEF */\n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\n\t\tlen = i - s;\n\t\t/* 0xfeedfacedeadbeef is 18 chars max */\n\t\tif (len >= sizeof(num_buf)) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tstrncpy(num_buf, str + s, len);\n\t\tnum_buf[len] = 0;\n\n\t\t/* Make sure it is a value */\n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num_buf, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num_buf, 0, &val);\n\t\tif (ret) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_INTVAL, pos + s);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->val = val;\n\n\t\tif (field->filter_type == FILTER_CPU)\n\t\t\tpred->fn = filter_pred_cpu;\n\t\telse {\n\t\t\tpred->fn = select_comparison_fn(pred->op, field->size,\n\t\t\t\t\t\t\tfield->is_signed);\n\t\t\tif (pred->op == OP_NE)\n\t\t\t\tpred->not = 1;\n\t\t}\n\n\t} else {\n\t\tparse_error(pe, FILT_ERR_INVALID_VALUE, pos + i);\n\t\tgoto err_free;\n\t}\n\n\t*pred_ptr = pred;\n\treturn i;\n\nerr_free:\n\tkfree(pred);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * ops[] = { OPS };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic const char * ops[] = { OPS };\n\nstatic int parse_pred(const char *str, void *data,\n\t\t      int pos, struct filter_parse_error *pe,\n\t\t      struct filter_pred **pred_ptr)\n{\n\tstruct trace_event_call *call = data;\n\tstruct ftrace_event_field *field;\n\tstruct filter_pred *pred = NULL;\n\tchar num_buf[24];\t/* Big enough to hold an address */\n\tchar *field_name;\n\tchar q;\n\tu64 val;\n\tint len;\n\tint ret;\n\tint op;\n\tint s;\n\tint i = 0;\n\n\t/* First find the field to associate to */\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\n\tlen = i - s;\n\n\tif (!len)\n\t\treturn -1;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\n\t/* Make sure that the field exists */\n\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field) {\n\t\tparse_error(pe, FILT_ERR_FIELD_NOT_FOUND, pos + i);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\t/* Make sure this op is supported */\n\tfor (op = 0; ops[op]; op++) {\n\t\t/* This is why '<=' must come before '<' in ops[] */\n\t\tif (strncmp(str + i, ops[op], strlen(ops[op])) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ops[op]) {\n\t\tparse_error(pe, FILT_ERR_INVALID_OP, pos + i);\n\t\tgoto err_free;\n\t}\n\n\ti += strlen(ops[op]);\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\ts = i;\n\n\tpred = kzalloc(sizeof(*pred), GFP_KERNEL);\n\tif (!pred)\n\t\treturn -ENOMEM;\n\n\tpred->field = field;\n\tpred->offset = field->offset;\n\tpred->op = op;\n\n\tif (ftrace_event_is_function(call)) {\n\t\t/*\n\t\t * Perf does things different with function events.\n\t\t * It only allows an \"ip\" field, and expects a string.\n\t\t * But the string does not need to be surrounded by quotes.\n\t\t * If it is a string, the assigned function as a nop,\n\t\t * (perf doesn't use it) and grab everything.\n\t\t */\n\t\tif (strcmp(field->name, \"ip\") != 0) {\n\t\t\t parse_error(pe, FILT_ERR_IP_FIELD_ONLY, pos + i);\n\t\t\t goto err_free;\n\t\t }\n\t\t pred->fn = filter_pred_none;\n\n\t\t /*\n\t\t  * Quotes are not required, but if they exist then we need\n\t\t  * to read them till we hit a matching one.\n\t\t  */\n\t\t if (str[i] == '\\'' || str[i] == '\"')\n\t\t\t q = str[i];\n\t\t else\n\t\t\t q = 0;\n\n\t\t for (i++; str[i]; i++) {\n\t\t\t if (q && str[i] == q)\n\t\t\t\t break;\n\t\t\t if (!q && (str[i] == ')' || str[i] == '&' ||\n\t\t\t\t    str[i] == '|'))\n\t\t\t\t break;\n\t\t }\n\t\t /* Skip quotes */\n\t\t if (q)\n\t\t\t s++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t/* This is either a string, or an integer */\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t/* Make sure the op is OK for strings */\n\t\tswitch (op) {\n\t\tcase OP_NE:\n\t\t\tpred->not = 1;\n\t\t\t/* Fall through */\n\t\tcase OP_GLOB:\n\t\tcase OP_EQ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Make sure the field is OK for strings */\n\t\tif (!is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_DIGIT, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i]) {\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Skip quotes */\n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t\tfilter_build_regex(pred);\n\n\t\tif (field->filter_type == FILTER_COMM) {\n\t\t\tpred->fn = filter_pred_comm;\n\n\t\t} else if (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\tpred->fn = filter_pred_string;\n\t\t\tpred->regex.field_len = field->size;\n\n\t\t} else if (field->filter_type == FILTER_DYN_STRING)\n\t\t\tpred->fn = filter_pred_strloc;\n\t\telse\n\t\t\tpred->fn = filter_pred_pchar;\n\t\t/* go past the last quote */\n\t\ti++;\n\n\t} else if (isdigit(str[i])) {\n\n\t\t/* Make sure the field is not a string */\n\t\tif (is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_STRING, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (op == OP_GLOB) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* We allow 0xDEADBEEF */\n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\n\t\tlen = i - s;\n\t\t/* 0xfeedfacedeadbeef is 18 chars max */\n\t\tif (len >= sizeof(num_buf)) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tstrncpy(num_buf, str + s, len);\n\t\tnum_buf[len] = 0;\n\n\t\t/* Make sure it is a value */\n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num_buf, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num_buf, 0, &val);\n\t\tif (ret) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_INTVAL, pos + s);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->val = val;\n\n\t\tif (field->filter_type == FILTER_CPU)\n\t\t\tpred->fn = filter_pred_cpu;\n\t\telse {\n\t\t\tpred->fn = select_comparison_fn(pred->op, field->size,\n\t\t\t\t\t\t\tfield->is_signed);\n\t\t\tif (pred->op == OP_NE)\n\t\t\t\tpred->not = 1;\n\t\t}\n\n\t} else {\n\t\tparse_error(pe, FILT_ERR_INVALID_VALUE, pos + i);\n\t\tgoto err_free;\n\t}\n\n\t*pred_ptr = pred;\n\treturn i;\n\nerr_free:\n\tkfree(pred);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_not",
          "args": [
            "next"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "is_not",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "82-90",
          "snippet": "static bool is_not(const char *str)\n{\n\tswitch (str[1]) {\n\tcase '=':\n\tcase '~':\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic bool is_not(const char *str)\n{\n\tswitch (str[1]) {\n\tcase '=':\n\tcase '~':\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*next"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nr_preds",
            "sizeof(*inverts)",
            "GFP_KERNEL"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nr_preds",
            "sizeof(*prog_stack)",
            "GFP_KERNEL"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nr_parens",
            "sizeof(*op_stack)",
            "GFP_KERNEL"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kmalloc_array(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tif (!N) {\n\t\t/* No program? */\n\t\tret = -EINVAL;\n\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n\tprog[N].target = 1;\t\t/* TRUE */\n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(prog_stack);\n\tkfree(inverts);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "parse_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "132-136",
    "snippet": "static void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}"
  },
  {
    "function_name": "update_preds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "116-125",
    "snippet": "static void update_preds(struct prog_entry *prog, int N, int invert)\n{\n\tint t, s;\n\n\tt = prog[N].target;\n\ts = prog[t].target;\n\tprog[t].when_to_branch = invert;\n\tprog[t].target = N;\n\tprog[N].target = s;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic void update_preds(struct prog_entry *prog, int N, int invert)\n{\n\tint t, s;\n\n\tt = prog[N].target;\n\ts = prog[t].target;\n\tprog[t].when_to_branch = invert;\n\tprog[t].target = N;\n\tprog[N].target = s;\n}"
  },
  {
    "function_name": "is_not",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
    "lines": "82-90",
    "snippet": "static bool is_not(const char *str)\n{\n\tswitch (str[1]) {\n\tcase '=':\n\tcase '~':\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"trace_events_filter_test.h\"",
      "#include <linux/tracepoint.h>",
      "#include <linux/types.h>",
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic bool is_not(const char *str)\n{\n\tswitch (str[1]) {\n\tcase '=':\n\tcase '~':\n\t\treturn false;\n\t}\n\treturn true;\n}"
  }
]