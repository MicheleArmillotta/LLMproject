[
  {
    "function_name": "audit_update_lsm_rules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "1422-1440",
    "snippet": "int audit_update_lsm_rules(void)\n{\n\tstruct audit_krule *r, *n;\n\tint i, err = 0;\n\n\t/* audit_filter_mutex synchronizes the writers */\n\tmutex_lock(&audit_filter_mutex);\n\n\tfor (i = 0; i < AUDIT_NR_FILTERS; i++) {\n\t\tlist_for_each_entry_safe(r, n, &audit_rules_list[i], list) {\n\t\t\tint res = update_lsm_rule(r);\n\t\t\tif (!err)\n\t\t\t\terr = res;\n\t\t}\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_lsm_rule",
          "args": [
            "r"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "update_lsm_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1385-1415",
          "snippet": "static int update_lsm_rule(struct audit_krule *r)\n{\n\tstruct audit_entry *entry = container_of(r, struct audit_entry, rule);\n\tstruct audit_entry *nentry;\n\tint err = 0;\n\n\tif (!security_audit_rule_known(r))\n\t\treturn 0;\n\n\tnentry = audit_dupe_rule(r);\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe);\n\tif (IS_ERR(nentry)) {\n\t\t/* save the first error encountered for the\n\t\t * return value */\n\t\terr = PTR_ERR(nentry);\n\t\taudit_panic(\"error updating LSM filters\");\n\t\tif (r->watch)\n\t\t\tlist_del(&r->rlist);\n\t\tlist_del_rcu(&entry->list);\n\t\tlist_del(&r->list);\n\t} else {\n\t\tif (r->watch || r->tree)\n\t\t\tlist_replace_init(&r->rlist, &nentry->rule.rlist);\n\t\tlist_replace_rcu(&entry->list, &nentry->list);\n\t\tlist_replace(&r->list, &nentry->rule.list);\n\t}\n\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\n\treturn err;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int update_lsm_rule(struct audit_krule *r)\n{\n\tstruct audit_entry *entry = container_of(r, struct audit_entry, rule);\n\tstruct audit_entry *nentry;\n\tint err = 0;\n\n\tif (!security_audit_rule_known(r))\n\t\treturn 0;\n\n\tnentry = audit_dupe_rule(r);\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe);\n\tif (IS_ERR(nentry)) {\n\t\t/* save the first error encountered for the\n\t\t * return value */\n\t\terr = PTR_ERR(nentry);\n\t\taudit_panic(\"error updating LSM filters\");\n\t\tif (r->watch)\n\t\t\tlist_del(&r->rlist);\n\t\tlist_del_rcu(&entry->list);\n\t\tlist_del(&r->list);\n\t} else {\n\t\tif (r->watch || r->tree)\n\t\t\tlist_replace_init(&r->rlist, &nentry->rule.rlist);\n\t\tlist_replace_rcu(&entry->list, &nentry->list);\n\t\tlist_replace(&r->list, &nentry->rule.list);\n\t}\n\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "r",
            "n",
            "&audit_rules_list[i]",
            "list"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n};\n\nint audit_update_lsm_rules(void)\n{\n\tstruct audit_krule *r, *n;\n\tint i, err = 0;\n\n\t/* audit_filter_mutex synchronizes the writers */\n\tmutex_lock(&audit_filter_mutex);\n\n\tfor (i = 0; i < AUDIT_NR_FILTERS; i++) {\n\t\tlist_for_each_entry_safe(r, n, &audit_rules_list[i], list) {\n\t\t\tint res = update_lsm_rule(r);\n\t\t\tif (!err)\n\t\t\t\terr = res;\n\t\t}\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "update_lsm_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "1385-1415",
    "snippet": "static int update_lsm_rule(struct audit_krule *r)\n{\n\tstruct audit_entry *entry = container_of(r, struct audit_entry, rule);\n\tstruct audit_entry *nentry;\n\tint err = 0;\n\n\tif (!security_audit_rule_known(r))\n\t\treturn 0;\n\n\tnentry = audit_dupe_rule(r);\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe);\n\tif (IS_ERR(nentry)) {\n\t\t/* save the first error encountered for the\n\t\t * return value */\n\t\terr = PTR_ERR(nentry);\n\t\taudit_panic(\"error updating LSM filters\");\n\t\tif (r->watch)\n\t\t\tlist_del(&r->rlist);\n\t\tlist_del_rcu(&entry->list);\n\t\tlist_del(&r->list);\n\t} else {\n\t\tif (r->watch || r->tree)\n\t\t\tlist_replace_init(&r->rlist, &nentry->rule.rlist);\n\t\tlist_replace_rcu(&entry->list, &nentry->list);\n\t\tlist_replace(&r->list, &nentry->rule.list);\n\t}\n\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\n\treturn err;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&entry->rcu",
            "audit_free_rule_rcu"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_replace",
          "args": [
            "&r->list",
            "&nentry->rule.list"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_rcu",
          "args": [
            "&entry->list",
            "&nentry->list"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&r->rlist",
            "&nentry->rule.rlist"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&r->list"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&entry->list"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"error updating LSM filters\""
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "310-323",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "nentry"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nentry"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_remove_mark",
          "args": [
            "entry->rule.exe"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_fsnotify.c",
          "lines": "149-154",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_dupe_rule",
          "args": [
            "r"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "audit_dupe_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "800-876",
          "snippet": "struct audit_entry *audit_dupe_rule(struct audit_krule *old)\n{\n\tu32 fcount = old->field_count;\n\tstruct audit_entry *entry;\n\tstruct audit_krule *new;\n\tchar *fk;\n\tint i, err = 0;\n\n\tentry = audit_init_entry(fcount);\n\tif (unlikely(!entry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = &entry->rule;\n\tnew->flags = old->flags;\n\tnew->pflags = old->pflags;\n\tnew->listnr = old->listnr;\n\tnew->action = old->action;\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tnew->mask[i] = old->mask[i];\n\tnew->prio = old->prio;\n\tnew->buflen = old->buflen;\n\tnew->inode_f = old->inode_f;\n\tnew->field_count = old->field_count;\n\n\t/*\n\t * note that we are OK with not refcounting here; audit_match_tree()\n\t * never dereferences tree and we can't get false positives there\n\t * since we'd have to have rule gone from the list *and* removed\n\t * before the chunks found by lookup had been allocated, i.e. before\n\t * the beginning of list scan.\n\t */\n\tnew->tree = old->tree;\n\tmemcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);\n\n\t/* deep copy this information, updating the lsm_rule fields, because\n\t * the originals will all be freed when the old rule is freed. */\n\tfor (i = 0; i < fcount; i++) {\n\t\tswitch (new->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\terr = audit_dupe_lsm_field(&new->fields[i],\n\t\t\t\t\t\t       &old->fields[i]);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tfk = kstrdup(old->filterkey, GFP_KERNEL);\n\t\t\tif (unlikely(!fk))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse\n\t\t\t\tnew->filterkey = fk;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\terr = audit_dupe_exe(new, old);\n\t\t\tbreak;\n\t\t}\n\t\tif (err) {\n\t\t\tif (new->exe)\n\t\t\t\taudit_remove_mark(new->exe);\n\t\t\taudit_free_rule(entry);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tif (old->watch) {\n\t\taudit_get_watch(old->watch);\n\t\tnew->watch = old->watch;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct audit_entry *audit_dupe_rule(struct audit_krule *old)\n{\n\tu32 fcount = old->field_count;\n\tstruct audit_entry *entry;\n\tstruct audit_krule *new;\n\tchar *fk;\n\tint i, err = 0;\n\n\tentry = audit_init_entry(fcount);\n\tif (unlikely(!entry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = &entry->rule;\n\tnew->flags = old->flags;\n\tnew->pflags = old->pflags;\n\tnew->listnr = old->listnr;\n\tnew->action = old->action;\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tnew->mask[i] = old->mask[i];\n\tnew->prio = old->prio;\n\tnew->buflen = old->buflen;\n\tnew->inode_f = old->inode_f;\n\tnew->field_count = old->field_count;\n\n\t/*\n\t * note that we are OK with not refcounting here; audit_match_tree()\n\t * never dereferences tree and we can't get false positives there\n\t * since we'd have to have rule gone from the list *and* removed\n\t * before the chunks found by lookup had been allocated, i.e. before\n\t * the beginning of list scan.\n\t */\n\tnew->tree = old->tree;\n\tmemcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);\n\n\t/* deep copy this information, updating the lsm_rule fields, because\n\t * the originals will all be freed when the old rule is freed. */\n\tfor (i = 0; i < fcount; i++) {\n\t\tswitch (new->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\terr = audit_dupe_lsm_field(&new->fields[i],\n\t\t\t\t\t\t       &old->fields[i]);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tfk = kstrdup(old->filterkey, GFP_KERNEL);\n\t\t\tif (unlikely(!fk))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse\n\t\t\t\tnew->filterkey = fk;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\terr = audit_dupe_exe(new, old);\n\t\t\tbreak;\n\t\t}\n\t\tif (err) {\n\t\t\tif (new->exe)\n\t\t\t\taudit_remove_mark(new->exe);\n\t\t\taudit_free_rule(entry);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tif (old->watch) {\n\t\taudit_get_watch(old->watch);\n\t\tnew->watch = old->watch;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_audit_rule_known",
          "args": [
            "r"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "r",
            "structaudit_entry",
            "rule"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int update_lsm_rule(struct audit_krule *r)\n{\n\tstruct audit_entry *entry = container_of(r, struct audit_entry, rule);\n\tstruct audit_entry *nentry;\n\tint err = 0;\n\n\tif (!security_audit_rule_known(r))\n\t\treturn 0;\n\n\tnentry = audit_dupe_rule(r);\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe);\n\tif (IS_ERR(nentry)) {\n\t\t/* save the first error encountered for the\n\t\t * return value */\n\t\terr = PTR_ERR(nentry);\n\t\taudit_panic(\"error updating LSM filters\");\n\t\tif (r->watch)\n\t\t\tlist_del(&r->rlist);\n\t\tlist_del_rcu(&entry->list);\n\t\tlist_del(&r->list);\n\t} else {\n\t\tif (r->watch || r->tree)\n\t\t\tlist_replace_init(&r->rlist, &nentry->rule.rlist);\n\t\tlist_replace_rcu(&entry->list, &nentry->list);\n\t\tlist_replace(&r->list, &nentry->rule.list);\n\t}\n\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\n\treturn err;\n}"
  },
  {
    "function_name": "audit_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "1312-1383",
    "snippet": "int audit_filter(int msgtype, unsigned int listtype)\n{\n\tstruct audit_entry *e;\n\tint ret = 1; /* Audit by default */\n\n\trcu_read_lock();\n\tif (list_empty(&audit_filter_list[listtype]))\n\t\tgoto unlock_and_return;\n\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {\n\t\tint i, result = 0;\n\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\t\t\tpid_t pid;\n\t\t\tu32 sid;\n\n\t\t\tswitch (f->type) {\n\t\t\tcase AUDIT_PID:\n\t\t\t\tpid = task_pid_nr(current);\n\t\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_UID:\n\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_GID:\n\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID:\n\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),\n\t\t\t\t\t\t\t      f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID_SET:\n\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_MSGTYPE:\n\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_SUBJ_USER:\n\t\t\tcase AUDIT_SUBJ_ROLE:\n\t\t\tcase AUDIT_SUBJ_TYPE:\n\t\t\tcase AUDIT_SUBJ_SEN:\n\t\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t\tif (f->lsm_rule) {\n\t\t\t\t\tsecurity_task_getsecid(current, &sid);\n\t\t\t\t\tresult = security_audit_rule_match(sid,\n\t\t\t\t\t\t\tf->type, f->op, f->lsm_rule, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_EXE:\n\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t\tif (result < 0) /* error */\n\t\t\t\tgoto unlock_and_return;\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result > 0) {\n\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_and_return:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n#if AUDIT_NR_FILTERS != 7\n#error Fix audit_filter_list initialiser\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_exe_compare",
          "args": [
            "current",
            "e->rule.exe"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "audit_exe_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "556-569",
          "snippet": "int audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)\n{\n\tstruct file *exe_file;\n\tunsigned long ino;\n\tdev_t dev;\n\n\texe_file = get_task_exe_file(tsk);\n\tif (!exe_file)\n\t\treturn 0;\n\tino = file_inode(exe_file)->i_ino;\n\tdev = file_inode(exe_file)->i_sb->s_dev;\n\tfput(exe_file);\n\treturn audit_mark_compare(mark, ino, dev);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)\n{\n\tstruct file *exe_file;\n\tunsigned long ino;\n\tdev_t dev;\n\n\texe_file = get_task_exe_file(tsk);\n\tif (!exe_file)\n\t\treturn 0;\n\tino = file_inode(exe_file)->i_ino;\n\tdev = file_inode(exe_file)->i_sb->s_dev;\n\tfput(exe_file);\n\treturn audit_mark_compare(mark, ino, dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_audit_rule_match",
          "args": [
            "sid",
            "f->type",
            "f->op",
            "f->lsm_rule",
            "NULL"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_task_getsecid",
          "args": [
            "current",
            "&sid"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_comparator",
          "args": [
            "msgtype",
            "f->op",
            "f->val"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "audit_comparator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1184-1207",
          "snippet": "int audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_loginuid_set",
          "args": [
            "current"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_uid_comparator",
          "args": [
            "audit_get_loginuid(current)",
            "f->op",
            "f->uid"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "audit_uid_comparator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1209-1230",
          "snippet": "int audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_gid_comparator",
          "args": [
            "current_gid()",
            "f->op",
            "f->gid"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "audit_gid_comparator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1232-1253",
          "snippet": "int audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_gid",
          "args": [],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "e",
            "&audit_filter_list[listtype]",
            "list"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&audit_filter_list[listtype]"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n#if AUDIT_NR_FILTERS != 7\n#error Fix audit_filter_list initialiser\n#endif\n};\n\nint audit_filter(int msgtype, unsigned int listtype)\n{\n\tstruct audit_entry *e;\n\tint ret = 1; /* Audit by default */\n\n\trcu_read_lock();\n\tif (list_empty(&audit_filter_list[listtype]))\n\t\tgoto unlock_and_return;\n\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {\n\t\tint i, result = 0;\n\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\t\t\tpid_t pid;\n\t\t\tu32 sid;\n\n\t\t\tswitch (f->type) {\n\t\t\tcase AUDIT_PID:\n\t\t\t\tpid = task_pid_nr(current);\n\t\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_UID:\n\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_GID:\n\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID:\n\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),\n\t\t\t\t\t\t\t      f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID_SET:\n\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_MSGTYPE:\n\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_SUBJ_USER:\n\t\t\tcase AUDIT_SUBJ_ROLE:\n\t\t\tcase AUDIT_SUBJ_TYPE:\n\t\t\tcase AUDIT_SUBJ_SEN:\n\t\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t\tif (f->lsm_rule) {\n\t\t\t\t\tsecurity_task_getsecid(current, &sid);\n\t\t\t\t\tresult = security_audit_rule_match(sid,\n\t\t\t\t\t\t\tf->type, f->op, f->lsm_rule, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_EXE:\n\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t\tif (result < 0) /* error */\n\t\t\t\tgoto unlock_and_return;\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result > 0) {\n\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_and_return:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "audit_compare_dname_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "1293-1310",
    "snippet": "int audit_compare_dname_path(const char *dname, const char *path, int parentlen)\n{\n\tint dlen, pathlen;\n\tconst char *p;\n\n\tdlen = strlen(dname);\n\tpathlen = strlen(path);\n\tif (pathlen < dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname, dlen);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "dname",
            "dlen"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_len",
          "args": [
            "path"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "parent_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1259-1283",
          "snippet": "int parent_len(const char *path)\n{\n\tint plen;\n\tconst char *p;\n\n\tplen = strlen(path);\n\n\tif (plen == 0)\n\t\treturn plen;\n\n\t/* disregard trailing slashes */\n\tp = path + plen - 1;\n\twhile ((*p == '/') && (p > path))\n\t\tp--;\n\n\t/* walk backward until we find the next slash or hit beginning */\n\twhile ((*p != '/') && (p > path))\n\t\tp--;\n\n\t/* did we find a slash? Then increment to include it in path */\n\tif (*p == '/')\n\t\tp++;\n\n\treturn p - path;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint parent_len(const char *path)\n{\n\tint plen;\n\tconst char *p;\n\n\tplen = strlen(path);\n\n\tif (plen == 0)\n\t\treturn plen;\n\n\t/* disregard trailing slashes */\n\tp = path + plen - 1;\n\twhile ((*p == '/') && (p > path))\n\t\tp--;\n\n\t/* walk backward until we find the next slash or hit beginning */\n\twhile ((*p != '/') && (p > path))\n\t\tp--;\n\n\t/* did we find a slash? Then increment to include it in path */\n\tif (*p == '/')\n\t\tp++;\n\n\treturn p - path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_compare_dname_path(const char *dname, const char *path, int parentlen)\n{\n\tint dlen, pathlen;\n\tconst char *p;\n\n\tdlen = strlen(dname);\n\tpathlen = strlen(path);\n\tif (pathlen < dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname, dlen);\n}"
  },
  {
    "function_name": "parent_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "1259-1283",
    "snippet": "int parent_len(const char *path)\n{\n\tint plen;\n\tconst char *p;\n\n\tplen = strlen(path);\n\n\tif (plen == 0)\n\t\treturn plen;\n\n\t/* disregard trailing slashes */\n\tp = path + plen - 1;\n\twhile ((*p == '/') && (p > path))\n\t\tp--;\n\n\t/* walk backward until we find the next slash or hit beginning */\n\twhile ((*p != '/') && (p > path))\n\t\tp--;\n\n\t/* did we find a slash? Then increment to include it in path */\n\tif (*p == '/')\n\t\tp++;\n\n\treturn p - path;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint parent_len(const char *path)\n{\n\tint plen;\n\tconst char *p;\n\n\tplen = strlen(path);\n\n\tif (plen == 0)\n\t\treturn plen;\n\n\t/* disregard trailing slashes */\n\tp = path + plen - 1;\n\twhile ((*p == '/') && (p > path))\n\t\tp--;\n\n\t/* walk backward until we find the next slash or hit beginning */\n\twhile ((*p != '/') && (p > path))\n\t\tp--;\n\n\t/* did we find a slash? Then increment to include it in path */\n\tif (*p == '/')\n\t\tp++;\n\n\treturn p - path;\n}"
  },
  {
    "function_name": "audit_gid_comparator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "1232-1253",
    "snippet": "int audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_gte",
          "args": [
            "left",
            "right"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_gt",
          "args": [
            "left",
            "right"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_lte",
          "args": [
            "left",
            "right"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_lt",
          "args": [
            "left",
            "right"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "left",
            "right"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "left",
            "right"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "audit_uid_comparator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "1209-1230",
    "snippet": "int audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_gte",
          "args": [
            "left",
            "right"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_gt",
          "args": [
            "left",
            "right"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_lte",
          "args": [
            "left",
            "right"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_lt",
          "args": [
            "left",
            "right"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "left",
            "right"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "left",
            "right"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "audit_comparator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "1184-1207",
    "snippet": "int audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "audit_list_rules_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "1149-1182",
    "snippet": "int audit_list_rules_send(struct sk_buff *request_skb, int seq)\n{\n\tu32 portid = NETLINK_CB(request_skb).portid;\n\tstruct net *net = sock_net(NETLINK_CB(request_skb).sk);\n\tstruct task_struct *tsk;\n\tstruct audit_netlink_list *dest;\n\tint err = 0;\n\n\t/* We can't just spew out the rules here because we might fill\n\t * the available socket buffer space and deadlock waiting for\n\t * auditctl to read from it... which isn't ever going to\n\t * happen if we're actually running in the context of auditctl\n\t * trying to _send_ the stuff */\n\n\tdest = kmalloc(sizeof(struct audit_netlink_list), GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest->net = get_net(net);\n\tdest->portid = portid;\n\tskb_queue_head_init(&dest->q);\n\n\tmutex_lock(&audit_filter_mutex);\n\taudit_list_rules(seq, &dest->q);\n\tmutex_unlock(&audit_filter_mutex);\n\n\ttsk = kthread_run(audit_send_list, dest, \"audit_send_list\");\n\tif (IS_ERR(tsk)) {\n\t\tskb_queue_purge(&dest->q);\n\t\tkfree(dest);\n\t\terr = PTR_ERR(tsk);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tsk"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dest"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_queue_purge",
          "args": [
            "&dest->q"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tsk"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "audit_send_list",
            "dest",
            "\"audit_send_list\""
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_list_rules",
          "args": [
            "seq",
            "&dest->q"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "audit_list_rules_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1149-1182",
          "snippet": "int audit_list_rules_send(struct sk_buff *request_skb, int seq)\n{\n\tu32 portid = NETLINK_CB(request_skb).portid;\n\tstruct net *net = sock_net(NETLINK_CB(request_skb).sk);\n\tstruct task_struct *tsk;\n\tstruct audit_netlink_list *dest;\n\tint err = 0;\n\n\t/* We can't just spew out the rules here because we might fill\n\t * the available socket buffer space and deadlock waiting for\n\t * auditctl to read from it... which isn't ever going to\n\t * happen if we're actually running in the context of auditctl\n\t * trying to _send_ the stuff */\n\n\tdest = kmalloc(sizeof(struct audit_netlink_list), GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest->net = get_net(net);\n\tdest->portid = portid;\n\tskb_queue_head_init(&dest->q);\n\n\tmutex_lock(&audit_filter_mutex);\n\taudit_list_rules(seq, &dest->q);\n\tmutex_unlock(&audit_filter_mutex);\n\n\ttsk = kthread_run(audit_send_list, dest, \"audit_send_list\");\n\tif (IS_ERR(tsk)) {\n\t\tskb_queue_purge(&dest->q);\n\t\tkfree(dest);\n\t\terr = PTR_ERR(tsk);\n\t}\n\n\treturn err;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_queue_head_init",
          "args": [
            "&dest->q"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_net",
          "args": [
            "net"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct audit_netlink_list)",
            "GFP_KERNEL"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_net",
          "args": [
            "NETLINK_CB(request_skb).sk"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_CB",
          "args": [
            "request_skb"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_CB",
          "args": [
            "request_skb"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_list_rules_send(struct sk_buff *request_skb, int seq)\n{\n\tu32 portid = NETLINK_CB(request_skb).portid;\n\tstruct net *net = sock_net(NETLINK_CB(request_skb).sk);\n\tstruct task_struct *tsk;\n\tstruct audit_netlink_list *dest;\n\tint err = 0;\n\n\t/* We can't just spew out the rules here because we might fill\n\t * the available socket buffer space and deadlock waiting for\n\t * auditctl to read from it... which isn't ever going to\n\t * happen if we're actually running in the context of auditctl\n\t * trying to _send_ the stuff */\n\n\tdest = kmalloc(sizeof(struct audit_netlink_list), GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest->net = get_net(net);\n\tdest->portid = portid;\n\tskb_queue_head_init(&dest->q);\n\n\tmutex_lock(&audit_filter_mutex);\n\taudit_list_rules(seq, &dest->q);\n\tmutex_unlock(&audit_filter_mutex);\n\n\ttsk = kthread_run(audit_send_list, dest, \"audit_send_list\");\n\tif (IS_ERR(tsk)) {\n\t\tskb_queue_purge(&dest->q);\n\t\tkfree(dest);\n\t\terr = PTR_ERR(tsk);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "audit_rule_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "1112-1142",
    "snippet": "int audit_rule_change(int type, int seq, void *data, size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\n\tentry = audit_data_to_entry(data, datasz);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\n\tswitch (type) {\n\tcase AUDIT_ADD_RULE:\n\t\terr = audit_add_rule(entry);\n\t\taudit_log_rule_change(\"add_rule\", &entry->rule, !err);\n\t\tbreak;\n\tcase AUDIT_DEL_RULE:\n\t\terr = audit_del_rule(entry);\n\t\taudit_log_rule_change(\"remove_rule\", &entry->rule, !err);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tWARN_ON(1);\n\t}\n\n\tif (err || type == AUDIT_DEL_RULE) {\n\t\tif (entry->rule.exe)\n\t\t\taudit_remove_mark(entry->rule.exe);\n\t\taudit_free_rule(entry);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_free_rule",
          "args": [
            "entry"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_rule_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "110-114",
          "snippet": "void audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_mark",
          "args": [
            "entry->rule.exe"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_fsnotify.c",
          "lines": "149-154",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_rule_change",
          "args": [
            "\"remove_rule\"",
            "&entry->rule",
            "!err"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_rule_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1087-1103",
          "snippet": "static void audit_log_rule_change(char *action, struct audit_krule *rule, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" op=%s\", action);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=%d\", rule->listnr, res);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic void audit_log_rule_change(char *action, struct audit_krule *rule, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" op=%s\", action);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=%d\", rule->listnr, res);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_del_rule",
          "args": [
            "entry"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "audit_del_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1002-1055",
          "snippet": "int audit_del_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry  *e;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint ret = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (!e) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (e->rule.watch)\n\t\taudit_remove_watch_rule(&e->rule);\n\n\tif (e->rule.tree)\n\t\taudit_remove_tree_rule(&e->rule);\n\n\tif (e->rule.exe)\n\t\taudit_remove_mark_rule(&e->rule);\n\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules--;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals--;\n#endif\n\n\tlist_del_rcu(&e->list);\n\tlist_del(&e->rule.list);\n\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\nout:\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (tree)\n\t\taudit_put_tree(tree);\t/* that's the temporary one */\n\n\treturn ret;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_del_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry  *e;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint ret = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (!e) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (e->rule.watch)\n\t\taudit_remove_watch_rule(&e->rule);\n\n\tif (e->rule.tree)\n\t\taudit_remove_tree_rule(&e->rule);\n\n\tif (e->rule.exe)\n\t\taudit_remove_mark_rule(&e->rule);\n\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules--;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals--;\n#endif\n\n\tlist_del_rcu(&e->list);\n\tlist_del(&e->rule.list);\n\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\nout:\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (tree)\n\t\taudit_put_tree(tree);\t/* that's the temporary one */\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_add_rule",
          "args": [
            "entry"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "audit_add_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "919-999",
          "snippet": "static inline int audit_add_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry *e;\n\tstruct audit_watch *watch = entry->rule.watch;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint err = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (e) {\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\terr = -EEXIST;\n\t\t/* normally audit_add_tree_rule() will free it on failure */\n\t\tif (tree)\n\t\t\taudit_put_tree(tree);\n\t\treturn err;\n\t}\n\n\tif (watch) {\n\t\t/* audit_filter_mutex is dropped and re-taken during this call */\n\t\terr = audit_add_watch(&entry->rule, &list);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\t/*\n\t\t\t * normally audit_add_tree_rule() will free it\n\t\t\t * on failure\n\t\t\t */\n\t\t\tif (tree)\n\t\t\t\taudit_put_tree(tree);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (tree) {\n\t\terr = audit_add_tree_rule(&entry->rule);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tentry->rule.prio = ~0ULL;\n\tif (entry->rule.listnr == AUDIT_FILTER_EXIT) {\n\t\tif (entry->rule.flags & AUDIT_FILTER_PREPEND)\n\t\t\tentry->rule.prio = ++prio_high;\n\t\telse\n\t\t\tentry->rule.prio = --prio_low;\n\t}\n\n\tif (entry->rule.flags & AUDIT_FILTER_PREPEND) {\n\t\tlist_add(&entry->rule.list,\n\t\t\t &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_rcu(&entry->list, list);\n\t\tentry->rule.flags &= ~AUDIT_FILTER_PREPEND;\n\t} else {\n\t\tlist_add_tail(&entry->rule.list,\n\t\t\t      &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_tail_rcu(&entry->list, list);\n\t}\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules++;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals++;\n#endif\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n};",
            "static u64 prio_low = ~0ULL/2;",
            "static u64 prio_high = ~0ULL/2 - 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n};\nstatic u64 prio_low = ~0ULL/2;\nstatic u64 prio_high = ~0ULL/2 - 1;\n\nstatic inline int audit_add_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry *e;\n\tstruct audit_watch *watch = entry->rule.watch;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint err = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (e) {\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\terr = -EEXIST;\n\t\t/* normally audit_add_tree_rule() will free it on failure */\n\t\tif (tree)\n\t\t\taudit_put_tree(tree);\n\t\treturn err;\n\t}\n\n\tif (watch) {\n\t\t/* audit_filter_mutex is dropped and re-taken during this call */\n\t\terr = audit_add_watch(&entry->rule, &list);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\t/*\n\t\t\t * normally audit_add_tree_rule() will free it\n\t\t\t * on failure\n\t\t\t */\n\t\t\tif (tree)\n\t\t\t\taudit_put_tree(tree);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (tree) {\n\t\terr = audit_add_tree_rule(&entry->rule);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tentry->rule.prio = ~0ULL;\n\tif (entry->rule.listnr == AUDIT_FILTER_EXIT) {\n\t\tif (entry->rule.flags & AUDIT_FILTER_PREPEND)\n\t\t\tentry->rule.prio = ++prio_high;\n\t\telse\n\t\t\tentry->rule.prio = --prio_low;\n\t}\n\n\tif (entry->rule.flags & AUDIT_FILTER_PREPEND) {\n\t\tlist_add(&entry->rule.list,\n\t\t\t &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_rcu(&entry->list, list);\n\t\tentry->rule.flags &= ~AUDIT_FILTER_PREPEND;\n\t} else {\n\t\tlist_add_tail(&entry->rule.list,\n\t\t\t      &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_tail_rcu(&entry->list, list);\n\t}\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules++;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals++;\n#endif\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "entry"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "entry"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_data_to_entry",
          "args": [
            "data",
            "datasz"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "audit_data_to_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "437-601",
          "snippet": "static struct audit_entry *audit_data_to_entry(struct audit_rule_data *data,\n\t\t\t\t\t       size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\tvoid *bufp;\n\tsize_t remain = datasz - sizeof(struct audit_rule_data);\n\tint i;\n\tchar *str;\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\tentry = audit_to_entry_common(data);\n\tif (IS_ERR(entry))\n\t\tgoto exit_nofree;\n\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &entry->rule.fields[i];\n\n\t\terr = -EINVAL;\n\n\t\tf->op = audit_to_op(data->fieldflags[i]);\n\t\tif (f->op == Audit_bad)\n\t\t\tgoto exit_free;\n\n\t\tf->type = data->fields[i];\n\t\tf->val = data->values[i];\n\n\t\t/* Support legacy tests for a valid loginuid */\n\t\tif ((f->type == AUDIT_LOGINUID) && (f->val == AUDIT_UID_UNSET)) {\n\t\t\tf->type = AUDIT_LOGINUID_SET;\n\t\t\tf->val = 0;\n\t\t\tentry->rule.pflags |= AUDIT_LOGINUID_LEGACY;\n\t\t}\n\n\t\terr = audit_field_valid(entry, f);\n\t\tif (err)\n\t\t\tgoto exit_free;\n\n\t\terr = -EINVAL;\n\t\tswitch (f->type) {\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tf->uid = make_kuid(current_user_ns(), f->val);\n\t\t\tif (!uid_valid(f->uid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tf->gid = make_kgid(current_user_ns(), f->val);\n\t\t\tif (!gid_valid(f->gid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tentry->rule.arch_f = f;\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\terr = security_audit_rule_init(f->type, f->op, str,\n\t\t\t\t\t\t       (void **)&f->lsm_rule);\n\t\t\t/* Keep currently invalid fields around in case they\n\t\t\t * become valid after a policy reload. */\n\t\t\tif (err == -EINVAL) {\n\t\t\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\t\t\tstr);\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t\tif (err) {\n\t\t\t\tkfree(str);\n\t\t\t\tgoto exit_free;\n\t\t\t} else\n\t\t\t\tf->lsm_str = str;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\terr = audit_to_watch(&entry->rule, str, f->val, f->op);\n\t\t\tif (err) {\n\t\t\t\tkfree(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\terr = audit_make_tree(&entry->rule, str, f->op);\n\t\t\tkfree(str);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\terr = audit_to_inode(&entry->rule, f);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tif (entry->rule.filterkey || f->val > AUDIT_MAX_KEY_LEN)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\t\t\tentry->rule.filterkey = str;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tif (entry->rule.exe || f->val > PATH_MAX)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\taudit_mark = audit_alloc_mark(&entry->rule, str, f->val);\n\t\t\tif (IS_ERR(audit_mark)) {\n\t\t\t\tkfree(str);\n\t\t\t\terr = PTR_ERR(audit_mark);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.exe = audit_mark;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (entry->rule.inode_f && entry->rule.inode_f->op == Audit_not_equal)\n\t\tentry->rule.inode_f = NULL;\n\nexit_nofree:\n\treturn entry;\n\nexit_free:\n\tif (entry->rule.tree)\n\t\taudit_put_tree(entry->rule.tree); /* that's the temporary one */\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe); /* that's the template one */\n\taudit_free_rule(entry);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic struct audit_entry *audit_data_to_entry(struct audit_rule_data *data,\n\t\t\t\t\t       size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\tvoid *bufp;\n\tsize_t remain = datasz - sizeof(struct audit_rule_data);\n\tint i;\n\tchar *str;\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\tentry = audit_to_entry_common(data);\n\tif (IS_ERR(entry))\n\t\tgoto exit_nofree;\n\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &entry->rule.fields[i];\n\n\t\terr = -EINVAL;\n\n\t\tf->op = audit_to_op(data->fieldflags[i]);\n\t\tif (f->op == Audit_bad)\n\t\t\tgoto exit_free;\n\n\t\tf->type = data->fields[i];\n\t\tf->val = data->values[i];\n\n\t\t/* Support legacy tests for a valid loginuid */\n\t\tif ((f->type == AUDIT_LOGINUID) && (f->val == AUDIT_UID_UNSET)) {\n\t\t\tf->type = AUDIT_LOGINUID_SET;\n\t\t\tf->val = 0;\n\t\t\tentry->rule.pflags |= AUDIT_LOGINUID_LEGACY;\n\t\t}\n\n\t\terr = audit_field_valid(entry, f);\n\t\tif (err)\n\t\t\tgoto exit_free;\n\n\t\terr = -EINVAL;\n\t\tswitch (f->type) {\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tf->uid = make_kuid(current_user_ns(), f->val);\n\t\t\tif (!uid_valid(f->uid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tf->gid = make_kgid(current_user_ns(), f->val);\n\t\t\tif (!gid_valid(f->gid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tentry->rule.arch_f = f;\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\terr = security_audit_rule_init(f->type, f->op, str,\n\t\t\t\t\t\t       (void **)&f->lsm_rule);\n\t\t\t/* Keep currently invalid fields around in case they\n\t\t\t * become valid after a policy reload. */\n\t\t\tif (err == -EINVAL) {\n\t\t\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\t\t\tstr);\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t\tif (err) {\n\t\t\t\tkfree(str);\n\t\t\t\tgoto exit_free;\n\t\t\t} else\n\t\t\t\tf->lsm_str = str;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\terr = audit_to_watch(&entry->rule, str, f->val, f->op);\n\t\t\tif (err) {\n\t\t\t\tkfree(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\terr = audit_make_tree(&entry->rule, str, f->op);\n\t\t\tkfree(str);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\terr = audit_to_inode(&entry->rule, f);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tif (entry->rule.filterkey || f->val > AUDIT_MAX_KEY_LEN)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\t\t\tentry->rule.filterkey = str;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tif (entry->rule.exe || f->val > PATH_MAX)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\taudit_mark = audit_alloc_mark(&entry->rule, str, f->val);\n\t\t\tif (IS_ERR(audit_mark)) {\n\t\t\t\tkfree(str);\n\t\t\t\terr = PTR_ERR(audit_mark);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.exe = audit_mark;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (entry->rule.inode_f && entry->rule.inode_f->op == Audit_not_equal)\n\t\tentry->rule.inode_f = NULL;\n\nexit_nofree:\n\treturn entry;\n\nexit_free:\n\tif (entry->rule.tree)\n\t\taudit_put_tree(entry->rule.tree); /* that's the temporary one */\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe); /* that's the template one */\n\taudit_free_rule(entry);\n\treturn ERR_PTR(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_rule_change(int type, int seq, void *data, size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\n\tentry = audit_data_to_entry(data, datasz);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\n\tswitch (type) {\n\tcase AUDIT_ADD_RULE:\n\t\terr = audit_add_rule(entry);\n\t\taudit_log_rule_change(\"add_rule\", &entry->rule, !err);\n\t\tbreak;\n\tcase AUDIT_DEL_RULE:\n\t\terr = audit_del_rule(entry);\n\t\taudit_log_rule_change(\"remove_rule\", &entry->rule, !err);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tWARN_ON(1);\n\t}\n\n\tif (err || type == AUDIT_DEL_RULE) {\n\t\tif (entry->rule.exe)\n\t\t\taudit_remove_mark(entry->rule.exe);\n\t\taudit_free_rule(entry);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "audit_log_rule_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "1087-1103",
    "snippet": "static void audit_log_rule_change(char *action, struct audit_krule *rule, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" op=%s\", action);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=%d\", rule->listnr, res);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" list=%d res=%d\"",
            "rule->listnr",
            "res"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_key",
          "args": [
            "ab",
            "rule->filterkey"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2048-2055",
          "snippet": "void audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "ab"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2203-2228",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_task_getsecid(current, &sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_task_getsecid(current, &sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_session_info",
          "args": [
            "ab"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_session_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2040-2046",
          "snippet": "void audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \" auid=%u ses=%u\", auid, sessionid);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \" auid=%u ses=%u\", auid, sessionid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "NULL",
            "GFP_KERNEL",
            "AUDIT_CONFIG_CHANGE"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic void audit_log_rule_change(char *action, struct audit_krule *rule, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" op=%s\", action);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=%d\", rule->listnr, res);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_list_rules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "1058-1084",
    "snippet": "static void audit_list_rules(int seq, struct sk_buff_head *q)\n{\n\tstruct sk_buff *skb;\n\tstruct audit_krule *r;\n\tint i;\n\n\t/* This is a blocking read, so use audit_filter_mutex instead of rcu\n\t * iterator to sync with list writers. */\n\tfor (i=0; i<AUDIT_NR_FILTERS; i++) {\n\t\tlist_for_each_entry(r, &audit_rules_list[i], list) {\n\t\t\tstruct audit_rule_data *data;\n\n\t\t\tdata = audit_krule_to_data(r);\n\t\t\tif (unlikely(!data))\n\t\t\t\tbreak;\n\t\t\tskb = audit_make_reply(seq, AUDIT_LIST_RULES, 0, 1,\n\t\t\t\t\t       data,\n\t\t\t\t\t       sizeof(*data) + data->buflen);\n\t\t\tif (skb)\n\t\t\t\tskb_queue_tail(q, skb);\n\t\t\tkfree(data);\n\t\t}\n\t}\n\tskb = audit_make_reply(seq, AUDIT_LIST_RULES, 1, 1, NULL, 0);\n\tif (skb)\n\t\tskb_queue_tail(q, skb);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skb_queue_tail",
          "args": [
            "q",
            "skb"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_make_reply",
          "args": [
            "seq",
            "AUDIT_LIST_RULES",
            "1",
            "1",
            "NULL",
            "0"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "audit_make_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "915-938",
          "snippet": "struct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_queue_tail",
          "args": [
            "q",
            "skb"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!data"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_krule_to_data",
          "args": [
            "r"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "audit_krule_to_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "615-681",
          "snippet": "static struct audit_rule_data *audit_krule_to_data(struct audit_krule *krule)\n{\n\tstruct audit_rule_data *data;\n\tvoid *bufp;\n\tint i;\n\n\tdata = kmalloc(sizeof(*data) + krule->buflen, GFP_KERNEL);\n\tif (unlikely(!data))\n\t\treturn NULL;\n\tmemset(data, 0, sizeof(*data));\n\n\tdata->flags = krule->flags | krule->listnr;\n\tdata->action = krule->action;\n\tdata->field_count = krule->field_count;\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &krule->fields[i];\n\n\t\tdata->fields[i] = f->type;\n\t\tdata->fieldflags[i] = audit_ops[f->op];\n\t\tswitch(f->type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, f->lsm_str);\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_watch_path(krule->watch));\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_tree_path(krule->tree));\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, krule->filterkey);\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, audit_mark_path(krule->exe));\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tif (krule->pflags & AUDIT_LOGINUID_LEGACY && !f->val) {\n\t\t\t\tdata->fields[i] = AUDIT_LOGINUID;\n\t\t\t\tdata->values[i] = AUDIT_UID_UNSET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough if set */\n\t\tdefault:\n\t\t\tdata->values[i] = f->val;\n\t\t}\n\t}\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++) data->mask[i] = krule->mask[i];\n\n\treturn data;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};\n\nstatic struct audit_rule_data *audit_krule_to_data(struct audit_krule *krule)\n{\n\tstruct audit_rule_data *data;\n\tvoid *bufp;\n\tint i;\n\n\tdata = kmalloc(sizeof(*data) + krule->buflen, GFP_KERNEL);\n\tif (unlikely(!data))\n\t\treturn NULL;\n\tmemset(data, 0, sizeof(*data));\n\n\tdata->flags = krule->flags | krule->listnr;\n\tdata->action = krule->action;\n\tdata->field_count = krule->field_count;\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &krule->fields[i];\n\n\t\tdata->fields[i] = f->type;\n\t\tdata->fieldflags[i] = audit_ops[f->op];\n\t\tswitch(f->type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, f->lsm_str);\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_watch_path(krule->watch));\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_tree_path(krule->tree));\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, krule->filterkey);\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, audit_mark_path(krule->exe));\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tif (krule->pflags & AUDIT_LOGINUID_LEGACY && !f->val) {\n\t\t\t\tdata->fields[i] = AUDIT_LOGINUID;\n\t\t\t\tdata->values[i] = AUDIT_UID_UNSET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough if set */\n\t\tdefault:\n\t\t\tdata->values[i] = f->val;\n\t\t}\n\t}\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++) data->mask[i] = krule->mask[i];\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "r",
            "&audit_rules_list[i]",
            "list"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n};\n\nstatic void audit_list_rules(int seq, struct sk_buff_head *q)\n{\n\tstruct sk_buff *skb;\n\tstruct audit_krule *r;\n\tint i;\n\n\t/* This is a blocking read, so use audit_filter_mutex instead of rcu\n\t * iterator to sync with list writers. */\n\tfor (i=0; i<AUDIT_NR_FILTERS; i++) {\n\t\tlist_for_each_entry(r, &audit_rules_list[i], list) {\n\t\t\tstruct audit_rule_data *data;\n\n\t\t\tdata = audit_krule_to_data(r);\n\t\t\tif (unlikely(!data))\n\t\t\t\tbreak;\n\t\t\tskb = audit_make_reply(seq, AUDIT_LIST_RULES, 0, 1,\n\t\t\t\t\t       data,\n\t\t\t\t\t       sizeof(*data) + data->buflen);\n\t\t\tif (skb)\n\t\t\t\tskb_queue_tail(q, skb);\n\t\t\tkfree(data);\n\t\t}\n\t}\n\tskb = audit_make_reply(seq, AUDIT_LIST_RULES, 1, 1, NULL, 0);\n\tif (skb)\n\t\tskb_queue_tail(q, skb);\n}"
  },
  {
    "function_name": "audit_del_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "1002-1055",
    "snippet": "int audit_del_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry  *e;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint ret = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (!e) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (e->rule.watch)\n\t\taudit_remove_watch_rule(&e->rule);\n\n\tif (e->rule.tree)\n\t\taudit_remove_tree_rule(&e->rule);\n\n\tif (e->rule.exe)\n\t\taudit_remove_mark_rule(&e->rule);\n\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules--;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals--;\n#endif\n\n\tlist_del_rcu(&e->list);\n\tlist_del(&e->rule.list);\n\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\nout:\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (tree)\n\t\taudit_put_tree(tree);\t/* that's the temporary one */\n\n\treturn ret;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_put_tree",
          "args": [
            "tree"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "693-696",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&e->rcu",
            "audit_free_rule_rcu"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&e->rule.list"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&e->list"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_match_signal",
          "args": [
            "entry"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "audit_match_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "221-244",
          "snippet": "static int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->rule.arch_f;\n\n\tif (!arch) {\n\t\t/* When arch is unspecified, we must check both masks on biarch\n\t\t * as syscall number alone is ambiguous. */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask) &&\n\t\t\taudit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\t}\n\n\tswitch(audit_classify_arch(arch->val)) {\n\tcase 0: /* native */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask));\n\tcase 1: /* 32bit on biarch */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\tdefault:\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->rule.arch_f;\n\n\tif (!arch) {\n\t\t/* When arch is unspecified, we must check both masks on biarch\n\t\t * as syscall number alone is ambiguous. */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask) &&\n\t\t\taudit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\t}\n\n\tswitch(audit_classify_arch(arch->val)) {\n\tcase 0: /* native */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask));\n\tcase 1: /* 32bit on biarch */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\tdefault:\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_mark_rule",
          "args": [
            "&e->rule"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_fsnotify.c",
          "lines": "149-154",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_tree_rule",
          "args": [
            "&e->rule"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_tree_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "600-622",
          "snippet": "int audit_remove_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *tree;\n\ttree = rule->tree;\n\tif (tree) {\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&rule->rlist);\n\t\tif (list_empty(&tree->rules) && !tree->goner) {\n\t\t\ttree->root = NULL;\n\t\t\tlist_del_init(&tree->same_root);\n\t\t\ttree->goner = 1;\n\t\t\tlist_move(&tree->list, &prune_list);\n\t\t\trule->tree = NULL;\n\t\t\tspin_unlock(&hash_lock);\n\t\t\taudit_schedule_prune();\n\t\t\treturn 1;\n\t\t}\n\t\trule->tree = NULL;\n\t\tspin_unlock(&hash_lock);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(prune_list);",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(prune_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\nstatic void audit_schedule_prune(void);\n\nint audit_remove_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *tree;\n\ttree = rule->tree;\n\tif (tree) {\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&rule->rlist);\n\t\tif (list_empty(&tree->rules) && !tree->goner) {\n\t\t\ttree->root = NULL;\n\t\t\tlist_del_init(&tree->same_root);\n\t\t\ttree->goner = 1;\n\t\t\tlist_move(&tree->list, &prune_list);\n\t\t\trule->tree = NULL;\n\t\t\tspin_unlock(&hash_lock);\n\t\t\taudit_schedule_prune();\n\t\t\treturn 1;\n\t\t}\n\t\trule->tree = NULL;\n\t\tspin_unlock(&hash_lock);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_watch_rule",
          "args": [
            "&e->rule"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_watch_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "463-481",
          "snippet": "void audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_watch_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nvoid audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_find_rule",
          "args": [
            "entry",
            "&list"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "audit_find_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "880-913",
          "snippet": "static struct audit_entry *audit_find_rule(struct audit_entry *entry,\n\t\t\t\t\t   struct list_head **p)\n{\n\tstruct audit_entry *e, *found = NULL;\n\tstruct list_head *list;\n\tint h;\n\n\tif (entry->rule.inode_f) {\n\t\th = audit_hash_ino(entry->rule.inode_f->val);\n\t\t*p = list = &audit_inode_hash[h];\n\t} else if (entry->rule.watch) {\n\t\t/* we don't know the inode number, so must walk entire hash */\n\t\tfor (h = 0; h < AUDIT_INODE_BUCKETS; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\t\t\tfound = e;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\t*p = list = &audit_filter_list[entry->rule.listnr];\n\t}\n\n\tlist_for_each_entry(e, list, list)\n\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\tfound = e;\n\t\t\tgoto out;\n\t\t}\n\nout:\n\treturn found;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n#if AUDIT_NR_FILTERS != 7\n#error Fix audit_filter_list initialiser\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n#if AUDIT_NR_FILTERS != 7\n#error Fix audit_filter_list initialiser\n#endif\n};\n\nstatic struct audit_entry *audit_find_rule(struct audit_entry *entry,\n\t\t\t\t\t   struct list_head **p)\n{\n\tstruct audit_entry *e, *found = NULL;\n\tstruct list_head *list;\n\tint h;\n\n\tif (entry->rule.inode_f) {\n\t\th = audit_hash_ino(entry->rule.inode_f->val);\n\t\t*p = list = &audit_inode_hash[h];\n\t} else if (entry->rule.watch) {\n\t\t/* we don't know the inode number, so must walk entire hash */\n\t\tfor (h = 0; h < AUDIT_INODE_BUCKETS; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\t\t\tfound = e;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\t*p = list = &audit_filter_list[entry->rule.listnr];\n\t}\n\n\tlist_for_each_entry(e, list, list)\n\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\tfound = e;\n\t\t\tgoto out;\n\t\t}\n\nout:\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_del_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry  *e;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint ret = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (!e) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (e->rule.watch)\n\t\taudit_remove_watch_rule(&e->rule);\n\n\tif (e->rule.tree)\n\t\taudit_remove_tree_rule(&e->rule);\n\n\tif (e->rule.exe)\n\t\taudit_remove_mark_rule(&e->rule);\n\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules--;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals--;\n#endif\n\n\tlist_del_rcu(&e->list);\n\tlist_del(&e->rule.list);\n\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\nout:\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (tree)\n\t\taudit_put_tree(tree);\t/* that's the temporary one */\n\n\treturn ret;\n}"
  },
  {
    "function_name": "audit_add_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "919-999",
    "snippet": "static inline int audit_add_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry *e;\n\tstruct audit_watch *watch = entry->rule.watch;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint err = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (e) {\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\terr = -EEXIST;\n\t\t/* normally audit_add_tree_rule() will free it on failure */\n\t\tif (tree)\n\t\t\taudit_put_tree(tree);\n\t\treturn err;\n\t}\n\n\tif (watch) {\n\t\t/* audit_filter_mutex is dropped and re-taken during this call */\n\t\terr = audit_add_watch(&entry->rule, &list);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\t/*\n\t\t\t * normally audit_add_tree_rule() will free it\n\t\t\t * on failure\n\t\t\t */\n\t\t\tif (tree)\n\t\t\t\taudit_put_tree(tree);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (tree) {\n\t\terr = audit_add_tree_rule(&entry->rule);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tentry->rule.prio = ~0ULL;\n\tif (entry->rule.listnr == AUDIT_FILTER_EXIT) {\n\t\tif (entry->rule.flags & AUDIT_FILTER_PREPEND)\n\t\t\tentry->rule.prio = ++prio_high;\n\t\telse\n\t\t\tentry->rule.prio = --prio_low;\n\t}\n\n\tif (entry->rule.flags & AUDIT_FILTER_PREPEND) {\n\t\tlist_add(&entry->rule.list,\n\t\t\t &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_rcu(&entry->list, list);\n\t\tentry->rule.flags &= ~AUDIT_FILTER_PREPEND;\n\t} else {\n\t\tlist_add_tail(&entry->rule.list,\n\t\t\t      &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_tail_rcu(&entry->list, list);\n\t}\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules++;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals++;\n#endif\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n};",
      "static u64 prio_low = ~0ULL/2;",
      "static u64 prio_high = ~0ULL/2 - 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_match_signal",
          "args": [
            "entry"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "audit_match_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "221-244",
          "snippet": "static int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->rule.arch_f;\n\n\tif (!arch) {\n\t\t/* When arch is unspecified, we must check both masks on biarch\n\t\t * as syscall number alone is ambiguous. */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask) &&\n\t\t\taudit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\t}\n\n\tswitch(audit_classify_arch(arch->val)) {\n\tcase 0: /* native */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask));\n\tcase 1: /* 32bit on biarch */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\tdefault:\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->rule.arch_f;\n\n\tif (!arch) {\n\t\t/* When arch is unspecified, we must check both masks on biarch\n\t\t * as syscall number alone is ambiguous. */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask) &&\n\t\t\taudit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\t}\n\n\tswitch(audit_classify_arch(arch->val)) {\n\tcase 0: /* native */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask));\n\tcase 1: /* 32bit on biarch */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\tdefault:\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&entry->list",
            "list"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->rule.list",
            "&audit_rules_list[entry->rule.listnr]"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&entry->list",
            "list"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&entry->rule.list",
            "&audit_rules_list[entry->rule.listnr]"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_add_tree_rule",
          "args": [
            "&entry->rule"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "audit_add_tree_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "753-821",
          "snippet": "int audit_add_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *seed = rule->tree, *tree;\n\tstruct path path;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\trule->tree = NULL;\n\tlist_for_each_entry(tree, &tree_list, list) {\n\t\tif (!strcmp(seed->pathname, tree->pathname)) {\n\t\t\tput_tree(seed);\n\t\t\trule->tree = tree;\n\t\t\tlist_add(&rule->rlist, &tree->rules);\n\t\t\treturn 0;\n\t\t}\n\t}\n\ttree = seed;\n\tlist_add(&tree->list, &tree_list);\n\tlist_add(&rule->rlist, &tree->rules);\n\t/* do not set rule->tree yet */\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (unlikely(!prune_thread)) {\n\t\terr = audit_launch_prune();\n\t\tif (err)\n\t\t\tgoto Err;\n\t}\n\n\terr = kern_path(tree->pathname, 0, &path);\n\tif (err)\n\t\tgoto Err;\n\tmnt = collect_mounts(&path);\n\tpath_put(&path);\n\tif (IS_ERR(mnt)) {\n\t\terr = PTR_ERR(mnt);\n\t\tgoto Err;\n\t}\n\n\tget_tree(tree);\n\terr = iterate_mounts(tag_mount, tree, mnt);\n\tdrop_collected_mounts(mnt);\n\n\tif (!err) {\n\t\tstruct node *node;\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\tnode->index &= ~(1U<<31);\n\t\tspin_unlock(&hash_lock);\n\t} else {\n\t\ttrim_marked(tree);\n\t\tgoto Err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tif (list_empty(&rule->rlist)) {\n\t\tput_tree(tree);\n\t\treturn -ENOENT;\n\t}\n\trule->tree = tree;\n\tput_tree(tree);\n\n\treturn 0;\nErr:\n\tmutex_lock(&audit_filter_mutex);\n\tlist_del_init(&tree->list);\n\tlist_del_init(&tree->rules);\n\tput_tree(tree);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(tree_list);",
            "static struct task_struct *prune_thread;",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(tree_list);\nstatic struct task_struct *prune_thread;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nint audit_add_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *seed = rule->tree, *tree;\n\tstruct path path;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\trule->tree = NULL;\n\tlist_for_each_entry(tree, &tree_list, list) {\n\t\tif (!strcmp(seed->pathname, tree->pathname)) {\n\t\t\tput_tree(seed);\n\t\t\trule->tree = tree;\n\t\t\tlist_add(&rule->rlist, &tree->rules);\n\t\t\treturn 0;\n\t\t}\n\t}\n\ttree = seed;\n\tlist_add(&tree->list, &tree_list);\n\tlist_add(&rule->rlist, &tree->rules);\n\t/* do not set rule->tree yet */\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (unlikely(!prune_thread)) {\n\t\terr = audit_launch_prune();\n\t\tif (err)\n\t\t\tgoto Err;\n\t}\n\n\terr = kern_path(tree->pathname, 0, &path);\n\tif (err)\n\t\tgoto Err;\n\tmnt = collect_mounts(&path);\n\tpath_put(&path);\n\tif (IS_ERR(mnt)) {\n\t\terr = PTR_ERR(mnt);\n\t\tgoto Err;\n\t}\n\n\tget_tree(tree);\n\terr = iterate_mounts(tag_mount, tree, mnt);\n\tdrop_collected_mounts(mnt);\n\n\tif (!err) {\n\t\tstruct node *node;\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\tnode->index &= ~(1U<<31);\n\t\tspin_unlock(&hash_lock);\n\t} else {\n\t\ttrim_marked(tree);\n\t\tgoto Err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tif (list_empty(&rule->rlist)) {\n\t\tput_tree(tree);\n\t\treturn -ENOENT;\n\t}\n\trule->tree = tree;\n\tput_tree(tree);\n\n\treturn 0;\nErr:\n\tmutex_lock(&audit_filter_mutex);\n\tlist_del_init(&tree->list);\n\tlist_del_init(&tree->rules);\n\tput_tree(tree);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_tree",
          "args": [
            "tree"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "693-696",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_add_watch",
          "args": [
            "&entry->rule",
            "&list"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "audit_add_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "416-461",
          "snippet": "int audit_add_watch(struct audit_krule *krule, struct list_head **list)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent;\n\tstruct path parent_path;\n\tint h, ret = 0;\n\n\t/*\n\t * When we will be calling audit_add_to_parent, krule->watch might have\n\t * been updated and watch might have been freed.\n\t * So we need to keep a reference of watch.\n\t */\n\taudit_get_watch(watch);\n\n\tmutex_unlock(&audit_filter_mutex);\n\n\t/* Avoid calling path_lookup under audit_filter_mutex. */\n\tret = audit_get_nd(watch, &parent_path);\n\n\t/* caller expects mutex locked */\n\tmutex_lock(&audit_filter_mutex);\n\n\tif (ret) {\n\t\taudit_put_watch(watch);\n\t\treturn ret;\n\t}\n\n\t/* either find an old parent or attach a new one */\n\tparent = audit_find_parent(d_backing_inode(parent_path.dentry));\n\tif (!parent) {\n\t\tparent = audit_init_parent(&parent_path);\n\t\tif (IS_ERR(parent)) {\n\t\t\tret = PTR_ERR(parent);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\taudit_add_to_parent(krule, parent);\n\n\th = audit_hash_ino((u32)watch->ino);\n\t*list = &audit_inode_hash[h];\nerror:\n\tpath_put(&parent_path);\n\taudit_put_watch(watch);\n\treturn ret;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_add_watch(struct audit_krule *krule, struct list_head **list)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent;\n\tstruct path parent_path;\n\tint h, ret = 0;\n\n\t/*\n\t * When we will be calling audit_add_to_parent, krule->watch might have\n\t * been updated and watch might have been freed.\n\t * So we need to keep a reference of watch.\n\t */\n\taudit_get_watch(watch);\n\n\tmutex_unlock(&audit_filter_mutex);\n\n\t/* Avoid calling path_lookup under audit_filter_mutex. */\n\tret = audit_get_nd(watch, &parent_path);\n\n\t/* caller expects mutex locked */\n\tmutex_lock(&audit_filter_mutex);\n\n\tif (ret) {\n\t\taudit_put_watch(watch);\n\t\treturn ret;\n\t}\n\n\t/* either find an old parent or attach a new one */\n\tparent = audit_find_parent(d_backing_inode(parent_path.dentry));\n\tif (!parent) {\n\t\tparent = audit_init_parent(&parent_path);\n\t\tif (IS_ERR(parent)) {\n\t\t\tret = PTR_ERR(parent);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\taudit_add_to_parent(krule, parent);\n\n\th = audit_hash_ino((u32)watch->ino);\n\t*list = &audit_inode_hash[h];\nerror:\n\tpath_put(&parent_path);\n\taudit_put_watch(watch);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_find_rule",
          "args": [
            "entry",
            "&list"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "audit_find_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "880-913",
          "snippet": "static struct audit_entry *audit_find_rule(struct audit_entry *entry,\n\t\t\t\t\t   struct list_head **p)\n{\n\tstruct audit_entry *e, *found = NULL;\n\tstruct list_head *list;\n\tint h;\n\n\tif (entry->rule.inode_f) {\n\t\th = audit_hash_ino(entry->rule.inode_f->val);\n\t\t*p = list = &audit_inode_hash[h];\n\t} else if (entry->rule.watch) {\n\t\t/* we don't know the inode number, so must walk entire hash */\n\t\tfor (h = 0; h < AUDIT_INODE_BUCKETS; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\t\t\tfound = e;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\t*p = list = &audit_filter_list[entry->rule.listnr];\n\t}\n\n\tlist_for_each_entry(e, list, list)\n\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\tfound = e;\n\t\t\tgoto out;\n\t\t}\n\nout:\n\treturn found;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n#if AUDIT_NR_FILTERS != 7\n#error Fix audit_filter_list initialiser\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n#if AUDIT_NR_FILTERS != 7\n#error Fix audit_filter_list initialiser\n#endif\n};\n\nstatic struct audit_entry *audit_find_rule(struct audit_entry *entry,\n\t\t\t\t\t   struct list_head **p)\n{\n\tstruct audit_entry *e, *found = NULL;\n\tstruct list_head *list;\n\tint h;\n\n\tif (entry->rule.inode_f) {\n\t\th = audit_hash_ino(entry->rule.inode_f->val);\n\t\t*p = list = &audit_inode_hash[h];\n\t} else if (entry->rule.watch) {\n\t\t/* we don't know the inode number, so must walk entire hash */\n\t\tfor (h = 0; h < AUDIT_INODE_BUCKETS; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\t\t\tfound = e;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\t*p = list = &audit_filter_list[entry->rule.listnr];\n\t}\n\n\tlist_for_each_entry(e, list, list)\n\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\tfound = e;\n\t\t\tgoto out;\n\t\t}\n\nout:\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n};\nstatic u64 prio_low = ~0ULL/2;\nstatic u64 prio_high = ~0ULL/2 - 1;\n\nstatic inline int audit_add_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry *e;\n\tstruct audit_watch *watch = entry->rule.watch;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint err = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (e) {\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\terr = -EEXIST;\n\t\t/* normally audit_add_tree_rule() will free it on failure */\n\t\tif (tree)\n\t\t\taudit_put_tree(tree);\n\t\treturn err;\n\t}\n\n\tif (watch) {\n\t\t/* audit_filter_mutex is dropped and re-taken during this call */\n\t\terr = audit_add_watch(&entry->rule, &list);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\t/*\n\t\t\t * normally audit_add_tree_rule() will free it\n\t\t\t * on failure\n\t\t\t */\n\t\t\tif (tree)\n\t\t\t\taudit_put_tree(tree);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (tree) {\n\t\terr = audit_add_tree_rule(&entry->rule);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tentry->rule.prio = ~0ULL;\n\tif (entry->rule.listnr == AUDIT_FILTER_EXIT) {\n\t\tif (entry->rule.flags & AUDIT_FILTER_PREPEND)\n\t\t\tentry->rule.prio = ++prio_high;\n\t\telse\n\t\t\tentry->rule.prio = --prio_low;\n\t}\n\n\tif (entry->rule.flags & AUDIT_FILTER_PREPEND) {\n\t\tlist_add(&entry->rule.list,\n\t\t\t &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_rcu(&entry->list, list);\n\t\tentry->rule.flags &= ~AUDIT_FILTER_PREPEND;\n\t} else {\n\t\tlist_add_tail(&entry->rule.list,\n\t\t\t      &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_tail_rcu(&entry->list, list);\n\t}\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules++;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals++;\n#endif\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "audit_find_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "880-913",
    "snippet": "static struct audit_entry *audit_find_rule(struct audit_entry *entry,\n\t\t\t\t\t   struct list_head **p)\n{\n\tstruct audit_entry *e, *found = NULL;\n\tstruct list_head *list;\n\tint h;\n\n\tif (entry->rule.inode_f) {\n\t\th = audit_hash_ino(entry->rule.inode_f->val);\n\t\t*p = list = &audit_inode_hash[h];\n\t} else if (entry->rule.watch) {\n\t\t/* we don't know the inode number, so must walk entire hash */\n\t\tfor (h = 0; h < AUDIT_INODE_BUCKETS; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\t\t\tfound = e;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\t*p = list = &audit_filter_list[entry->rule.listnr];\n\t}\n\n\tlist_for_each_entry(e, list, list)\n\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\tfound = e;\n\t\t\tgoto out;\n\t\t}\n\nout:\n\treturn found;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n#if AUDIT_NR_FILTERS != 7\n#error Fix audit_filter_list initialiser\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_compare_rule",
          "args": [
            "&entry->rule",
            "&e->rule"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "audit_compare_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "685-764",
          "snippet": "static int audit_compare_rule(struct audit_krule *a, struct audit_krule *b)\n{\n\tint i;\n\n\tif (a->flags != b->flags ||\n\t    a->pflags != b->pflags ||\n\t    a->listnr != b->listnr ||\n\t    a->action != b->action ||\n\t    a->field_count != b->field_count)\n\t\treturn 1;\n\n\tfor (i = 0; i < a->field_count; i++) {\n\t\tif (a->fields[i].type != b->fields[i].type ||\n\t\t    a->fields[i].op != b->fields[i].op)\n\t\t\treturn 1;\n\n\t\tswitch(a->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tif (strcmp(a->fields[i].lsm_str, b->fields[i].lsm_str))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (strcmp(audit_watch_path(a->watch),\n\t\t\t\t   audit_watch_path(b->watch)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (strcmp(audit_tree_path(a->tree),\n\t\t\t\t   audit_tree_path(b->tree)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* both filterkeys exist based on above type compare */\n\t\t\tif (strcmp(a->filterkey, b->filterkey))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\t/* both paths exist based on above type compare */\n\t\t\tif (strcmp(audit_mark_path(a->exe),\n\t\t\t\t   audit_mark_path(b->exe)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (!uid_eq(a->fields[i].uid, b->fields[i].uid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (!gid_eq(a->fields[i].gid, b->fields[i].gid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (a->fields[i].val != b->fields[i].val)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tif (a->mask[i] != b->mask[i])\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int audit_compare_rule(struct audit_krule *a, struct audit_krule *b)\n{\n\tint i;\n\n\tif (a->flags != b->flags ||\n\t    a->pflags != b->pflags ||\n\t    a->listnr != b->listnr ||\n\t    a->action != b->action ||\n\t    a->field_count != b->field_count)\n\t\treturn 1;\n\n\tfor (i = 0; i < a->field_count; i++) {\n\t\tif (a->fields[i].type != b->fields[i].type ||\n\t\t    a->fields[i].op != b->fields[i].op)\n\t\t\treturn 1;\n\n\t\tswitch(a->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tif (strcmp(a->fields[i].lsm_str, b->fields[i].lsm_str))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (strcmp(audit_watch_path(a->watch),\n\t\t\t\t   audit_watch_path(b->watch)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (strcmp(audit_tree_path(a->tree),\n\t\t\t\t   audit_tree_path(b->tree)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* both filterkeys exist based on above type compare */\n\t\t\tif (strcmp(a->filterkey, b->filterkey))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\t/* both paths exist based on above type compare */\n\t\t\tif (strcmp(audit_mark_path(a->exe),\n\t\t\t\t   audit_mark_path(b->exe)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (!uid_eq(a->fields[i].uid, b->fields[i].uid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (!gid_eq(a->fields[i].gid, b->fields[i].gid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (a->fields[i].val != b->fields[i].val)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tif (a->mask[i] != b->mask[i])\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "e",
            "list",
            "list"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "e",
            "list",
            "list"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_hash_ino",
          "args": [
            "entry->rule.inode_f->val"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "audit_hash_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.h",
          "lines": "227-230",
          "snippet": "static inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}",
          "includes": [
            "#include <linux/tty.h>",
            "#include <uapi/linux/mqueue.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/audit.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define AUDIT_INODE_BUCKETS\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tty.h>\n#include <uapi/linux/mqueue.h>\n#include <linux/skbuff.h>\n#include <linux/audit.h>\n#include <linux/fs.h>\n\n#define AUDIT_INODE_BUCKETS\t32\n\nstatic inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n#if AUDIT_NR_FILTERS != 7\n#error Fix audit_filter_list initialiser\n#endif\n};\n\nstatic struct audit_entry *audit_find_rule(struct audit_entry *entry,\n\t\t\t\t\t   struct list_head **p)\n{\n\tstruct audit_entry *e, *found = NULL;\n\tstruct list_head *list;\n\tint h;\n\n\tif (entry->rule.inode_f) {\n\t\th = audit_hash_ino(entry->rule.inode_f->val);\n\t\t*p = list = &audit_inode_hash[h];\n\t} else if (entry->rule.watch) {\n\t\t/* we don't know the inode number, so must walk entire hash */\n\t\tfor (h = 0; h < AUDIT_INODE_BUCKETS; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\t\t\tfound = e;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\t*p = list = &audit_filter_list[entry->rule.listnr];\n\t}\n\n\tlist_for_each_entry(e, list, list)\n\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\tfound = e;\n\t\t\tgoto out;\n\t\t}\n\nout:\n\treturn found;\n}"
  },
  {
    "function_name": "audit_dupe_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "800-876",
    "snippet": "struct audit_entry *audit_dupe_rule(struct audit_krule *old)\n{\n\tu32 fcount = old->field_count;\n\tstruct audit_entry *entry;\n\tstruct audit_krule *new;\n\tchar *fk;\n\tint i, err = 0;\n\n\tentry = audit_init_entry(fcount);\n\tif (unlikely(!entry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = &entry->rule;\n\tnew->flags = old->flags;\n\tnew->pflags = old->pflags;\n\tnew->listnr = old->listnr;\n\tnew->action = old->action;\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tnew->mask[i] = old->mask[i];\n\tnew->prio = old->prio;\n\tnew->buflen = old->buflen;\n\tnew->inode_f = old->inode_f;\n\tnew->field_count = old->field_count;\n\n\t/*\n\t * note that we are OK with not refcounting here; audit_match_tree()\n\t * never dereferences tree and we can't get false positives there\n\t * since we'd have to have rule gone from the list *and* removed\n\t * before the chunks found by lookup had been allocated, i.e. before\n\t * the beginning of list scan.\n\t */\n\tnew->tree = old->tree;\n\tmemcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);\n\n\t/* deep copy this information, updating the lsm_rule fields, because\n\t * the originals will all be freed when the old rule is freed. */\n\tfor (i = 0; i < fcount; i++) {\n\t\tswitch (new->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\terr = audit_dupe_lsm_field(&new->fields[i],\n\t\t\t\t\t\t       &old->fields[i]);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tfk = kstrdup(old->filterkey, GFP_KERNEL);\n\t\t\tif (unlikely(!fk))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse\n\t\t\t\tnew->filterkey = fk;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\terr = audit_dupe_exe(new, old);\n\t\t\tbreak;\n\t\t}\n\t\tif (err) {\n\t\t\tif (new->exe)\n\t\t\t\taudit_remove_mark(new->exe);\n\t\t\taudit_free_rule(entry);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tif (old->watch) {\n\t\taudit_get_watch(old->watch);\n\t\tnew->watch = old->watch;\n\t}\n\n\treturn entry;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_get_watch",
          "args": [
            "old->watch"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "113-116",
          "snippet": "void audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_free_rule",
          "args": [
            "entry"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_rule_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "110-114",
          "snippet": "void audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_mark",
          "args": [
            "new->exe"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_fsnotify.c",
          "lines": "149-154",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_dupe_exe",
          "args": [
            "new",
            "old"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "audit_dupe_exe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "537-554",
          "snippet": "int audit_dupe_exe(struct audit_krule *new, struct audit_krule *old)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tchar *pathname;\n\n\tpathname = kstrdup(audit_mark_path(old->exe), GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\taudit_mark = audit_alloc_mark(new, pathname, strlen(pathname));\n\tif (IS_ERR(audit_mark)) {\n\t\tkfree(pathname);\n\t\treturn PTR_ERR(audit_mark);\n\t}\n\tnew->exe = audit_mark;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_dupe_exe(struct audit_krule *new, struct audit_krule *old)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tchar *pathname;\n\n\tpathname = kstrdup(audit_mark_path(old->exe), GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\taudit_mark = audit_alloc_mark(new, pathname, strlen(pathname));\n\tif (IS_ERR(audit_mark)) {\n\t\tkfree(pathname);\n\t\treturn PTR_ERR(audit_mark);\n\t}\n\tnew->exe = audit_mark;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!fk"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "old->filterkey",
            "GFP_KERNEL"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_dupe_lsm_field",
          "args": [
            "&new->fields[i]",
            "&old->fields[i]"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "audit_dupe_lsm_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "768-792",
          "snippet": "static inline int audit_dupe_lsm_field(struct audit_field *df,\n\t\t\t\t\t   struct audit_field *sf)\n{\n\tint ret = 0;\n\tchar *lsm_str;\n\n\t/* our own copy of lsm_str */\n\tlsm_str = kstrdup(sf->lsm_str, GFP_KERNEL);\n\tif (unlikely(!lsm_str))\n\t\treturn -ENOMEM;\n\tdf->lsm_str = lsm_str;\n\n\t/* our own (refreshed) copy of lsm_rule */\n\tret = security_audit_rule_init(df->type, df->op, df->lsm_str,\n\t\t\t\t       (void **)&df->lsm_rule);\n\t/* Keep currently invalid fields around in case they\n\t * become valid after a policy reload. */\n\tif (ret == -EINVAL) {\n\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\tdf->lsm_str);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline int audit_dupe_lsm_field(struct audit_field *df,\n\t\t\t\t\t   struct audit_field *sf)\n{\n\tint ret = 0;\n\tchar *lsm_str;\n\n\t/* our own copy of lsm_str */\n\tlsm_str = kstrdup(sf->lsm_str, GFP_KERNEL);\n\tif (unlikely(!lsm_str))\n\t\treturn -ENOMEM;\n\tdf->lsm_str = lsm_str;\n\n\t/* our own (refreshed) copy of lsm_rule */\n\tret = security_audit_rule_init(df->type, df->op, df->lsm_str,\n\t\t\t\t       (void **)&df->lsm_rule);\n\t/* Keep currently invalid fields around in case they\n\t * become valid after a policy reload. */\n\tif (ret == -EINVAL) {\n\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\tdf->lsm_str);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new->fields",
            "old->fields",
            "sizeof(struct audit_field) * fcount"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!entry"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_init_entry",
          "args": [
            "fcount"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "audit_init_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "117-134",
          "snippet": "static inline struct audit_entry *audit_init_entry(u32 field_count)\n{\n\tstruct audit_entry *entry;\n\tstruct audit_field *fields;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (unlikely(!entry))\n\t\treturn NULL;\n\n\tfields = kcalloc(field_count, sizeof(*fields), GFP_KERNEL);\n\tif (unlikely(!fields)) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->rule.fields = fields;\n\n\treturn entry;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline struct audit_entry *audit_init_entry(u32 field_count)\n{\n\tstruct audit_entry *entry;\n\tstruct audit_field *fields;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (unlikely(!entry))\n\t\treturn NULL;\n\n\tfields = kcalloc(field_count, sizeof(*fields), GFP_KERNEL);\n\tif (unlikely(!fields)) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->rule.fields = fields;\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct audit_entry *audit_dupe_rule(struct audit_krule *old)\n{\n\tu32 fcount = old->field_count;\n\tstruct audit_entry *entry;\n\tstruct audit_krule *new;\n\tchar *fk;\n\tint i, err = 0;\n\n\tentry = audit_init_entry(fcount);\n\tif (unlikely(!entry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = &entry->rule;\n\tnew->flags = old->flags;\n\tnew->pflags = old->pflags;\n\tnew->listnr = old->listnr;\n\tnew->action = old->action;\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tnew->mask[i] = old->mask[i];\n\tnew->prio = old->prio;\n\tnew->buflen = old->buflen;\n\tnew->inode_f = old->inode_f;\n\tnew->field_count = old->field_count;\n\n\t/*\n\t * note that we are OK with not refcounting here; audit_match_tree()\n\t * never dereferences tree and we can't get false positives there\n\t * since we'd have to have rule gone from the list *and* removed\n\t * before the chunks found by lookup had been allocated, i.e. before\n\t * the beginning of list scan.\n\t */\n\tnew->tree = old->tree;\n\tmemcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);\n\n\t/* deep copy this information, updating the lsm_rule fields, because\n\t * the originals will all be freed when the old rule is freed. */\n\tfor (i = 0; i < fcount; i++) {\n\t\tswitch (new->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\terr = audit_dupe_lsm_field(&new->fields[i],\n\t\t\t\t\t\t       &old->fields[i]);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tfk = kstrdup(old->filterkey, GFP_KERNEL);\n\t\t\tif (unlikely(!fk))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse\n\t\t\t\tnew->filterkey = fk;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\terr = audit_dupe_exe(new, old);\n\t\t\tbreak;\n\t\t}\n\t\tif (err) {\n\t\t\tif (new->exe)\n\t\t\t\taudit_remove_mark(new->exe);\n\t\t\taudit_free_rule(entry);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tif (old->watch) {\n\t\taudit_get_watch(old->watch);\n\t\tnew->watch = old->watch;\n\t}\n\n\treturn entry;\n}"
  },
  {
    "function_name": "audit_dupe_lsm_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "768-792",
    "snippet": "static inline int audit_dupe_lsm_field(struct audit_field *df,\n\t\t\t\t\t   struct audit_field *sf)\n{\n\tint ret = 0;\n\tchar *lsm_str;\n\n\t/* our own copy of lsm_str */\n\tlsm_str = kstrdup(sf->lsm_str, GFP_KERNEL);\n\tif (unlikely(!lsm_str))\n\t\treturn -ENOMEM;\n\tdf->lsm_str = lsm_str;\n\n\t/* our own (refreshed) copy of lsm_rule */\n\tret = security_audit_rule_init(df->type, df->op, df->lsm_str,\n\t\t\t\t       (void **)&df->lsm_rule);\n\t/* Keep currently invalid fields around in case they\n\t * become valid after a policy reload. */\n\tif (ret == -EINVAL) {\n\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\tdf->lsm_str);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"audit rule for LSM \\'%s\\' is invalid\\n\"",
            "df->lsm_str"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_audit_rule_init",
          "args": [
            "df->type",
            "df->op",
            "df->lsm_str",
            "(void **)&df->lsm_rule"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lsm_str"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "sf->lsm_str",
            "GFP_KERNEL"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline int audit_dupe_lsm_field(struct audit_field *df,\n\t\t\t\t\t   struct audit_field *sf)\n{\n\tint ret = 0;\n\tchar *lsm_str;\n\n\t/* our own copy of lsm_str */\n\tlsm_str = kstrdup(sf->lsm_str, GFP_KERNEL);\n\tif (unlikely(!lsm_str))\n\t\treturn -ENOMEM;\n\tdf->lsm_str = lsm_str;\n\n\t/* our own (refreshed) copy of lsm_rule */\n\tret = security_audit_rule_init(df->type, df->op, df->lsm_str,\n\t\t\t\t       (void **)&df->lsm_rule);\n\t/* Keep currently invalid fields around in case they\n\t * become valid after a policy reload. */\n\tif (ret == -EINVAL) {\n\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\tdf->lsm_str);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "audit_compare_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "685-764",
    "snippet": "static int audit_compare_rule(struct audit_krule *a, struct audit_krule *b)\n{\n\tint i;\n\n\tif (a->flags != b->flags ||\n\t    a->pflags != b->pflags ||\n\t    a->listnr != b->listnr ||\n\t    a->action != b->action ||\n\t    a->field_count != b->field_count)\n\t\treturn 1;\n\n\tfor (i = 0; i < a->field_count; i++) {\n\t\tif (a->fields[i].type != b->fields[i].type ||\n\t\t    a->fields[i].op != b->fields[i].op)\n\t\t\treturn 1;\n\n\t\tswitch(a->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tif (strcmp(a->fields[i].lsm_str, b->fields[i].lsm_str))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (strcmp(audit_watch_path(a->watch),\n\t\t\t\t   audit_watch_path(b->watch)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (strcmp(audit_tree_path(a->tree),\n\t\t\t\t   audit_tree_path(b->tree)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* both filterkeys exist based on above type compare */\n\t\t\tif (strcmp(a->filterkey, b->filterkey))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\t/* both paths exist based on above type compare */\n\t\t\tif (strcmp(audit_mark_path(a->exe),\n\t\t\t\t   audit_mark_path(b->exe)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (!uid_eq(a->fields[i].uid, b->fields[i].uid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (!gid_eq(a->fields[i].gid, b->fields[i].gid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (a->fields[i].val != b->fields[i].val)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tif (a->mask[i] != b->mask[i])\n\t\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "a->fields[i].gid",
            "b->fields[i].gid"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "a->fields[i].uid",
            "b->fields[i].uid"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "audit_mark_path(a->exe)",
            "audit_mark_path(b->exe)"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_mark_path",
          "args": [
            "b->exe"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mark_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_fsnotify.c",
          "lines": "64-67",
          "snippet": "char *audit_mark_path(struct audit_fsnotify_mark *mark)\n{\n\treturn mark->path;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nchar *audit_mark_path(struct audit_fsnotify_mark *mark)\n{\n\treturn mark->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->filterkey",
            "b->filterkey"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "audit_tree_path(a->tree)",
            "audit_tree_path(b->tree)"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_tree_path",
          "args": [
            "b->tree"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "audit_tree_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "106-109",
          "snippet": "const char *audit_tree_path(struct audit_tree *tree)\n{\n\treturn tree->pathname;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nconst char *audit_tree_path(struct audit_tree *tree)\n{\n\treturn tree->pathname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "audit_watch_path(a->watch)",
            "audit_watch_path(b->watch)"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_watch_path",
          "args": [
            "b->watch"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "audit_watch_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "136-139",
          "snippet": "char *audit_watch_path(struct audit_watch *watch)\n{\n\treturn watch->path;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nchar *audit_watch_path(struct audit_watch *watch)\n{\n\treturn watch->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->fields[i].lsm_str",
            "b->fields[i].lsm_str"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int audit_compare_rule(struct audit_krule *a, struct audit_krule *b)\n{\n\tint i;\n\n\tif (a->flags != b->flags ||\n\t    a->pflags != b->pflags ||\n\t    a->listnr != b->listnr ||\n\t    a->action != b->action ||\n\t    a->field_count != b->field_count)\n\t\treturn 1;\n\n\tfor (i = 0; i < a->field_count; i++) {\n\t\tif (a->fields[i].type != b->fields[i].type ||\n\t\t    a->fields[i].op != b->fields[i].op)\n\t\t\treturn 1;\n\n\t\tswitch(a->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tif (strcmp(a->fields[i].lsm_str, b->fields[i].lsm_str))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (strcmp(audit_watch_path(a->watch),\n\t\t\t\t   audit_watch_path(b->watch)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (strcmp(audit_tree_path(a->tree),\n\t\t\t\t   audit_tree_path(b->tree)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* both filterkeys exist based on above type compare */\n\t\t\tif (strcmp(a->filterkey, b->filterkey))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\t/* both paths exist based on above type compare */\n\t\t\tif (strcmp(audit_mark_path(a->exe),\n\t\t\t\t   audit_mark_path(b->exe)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (!uid_eq(a->fields[i].uid, b->fields[i].uid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (!gid_eq(a->fields[i].gid, b->fields[i].gid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (a->fields[i].val != b->fields[i].val)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tif (a->mask[i] != b->mask[i])\n\t\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_krule_to_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "615-681",
    "snippet": "static struct audit_rule_data *audit_krule_to_data(struct audit_krule *krule)\n{\n\tstruct audit_rule_data *data;\n\tvoid *bufp;\n\tint i;\n\n\tdata = kmalloc(sizeof(*data) + krule->buflen, GFP_KERNEL);\n\tif (unlikely(!data))\n\t\treturn NULL;\n\tmemset(data, 0, sizeof(*data));\n\n\tdata->flags = krule->flags | krule->listnr;\n\tdata->action = krule->action;\n\tdata->field_count = krule->field_count;\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &krule->fields[i];\n\n\t\tdata->fields[i] = f->type;\n\t\tdata->fieldflags[i] = audit_ops[f->op];\n\t\tswitch(f->type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, f->lsm_str);\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_watch_path(krule->watch));\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_tree_path(krule->tree));\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, krule->filterkey);\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, audit_mark_path(krule->exe));\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tif (krule->pflags & AUDIT_LOGINUID_LEGACY && !f->val) {\n\t\t\t\tdata->fields[i] = AUDIT_LOGINUID;\n\t\t\t\tdata->values[i] = AUDIT_UID_UNSET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough if set */\n\t\tdefault:\n\t\t\tdata->values[i] = f->val;\n\t\t}\n\t}\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++) data->mask[i] = krule->mask[i];\n\n\treturn data;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_pack_string",
          "args": [
            "&bufp",
            "audit_mark_path(krule->exe)"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "audit_pack_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "604-612",
          "snippet": "static inline size_t audit_pack_string(void **bufp, const char *str)\n{\n\tsize_t len = strlen(str);\n\n\tmemcpy(*bufp, str, len);\n\t*bufp += len;\n\n\treturn len;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline size_t audit_pack_string(void **bufp, const char *str)\n{\n\tsize_t len = strlen(str);\n\n\tmemcpy(*bufp, str, len);\n\t*bufp += len;\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_mark_path",
          "args": [
            "krule->exe"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mark_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_fsnotify.c",
          "lines": "64-67",
          "snippet": "char *audit_mark_path(struct audit_fsnotify_mark *mark)\n{\n\treturn mark->path;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nchar *audit_mark_path(struct audit_fsnotify_mark *mark)\n{\n\treturn mark->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_tree_path",
          "args": [
            "krule->tree"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "audit_tree_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "106-109",
          "snippet": "const char *audit_tree_path(struct audit_tree *tree)\n{\n\treturn tree->pathname;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nconst char *audit_tree_path(struct audit_tree *tree)\n{\n\treturn tree->pathname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_watch_path",
          "args": [
            "krule->watch"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "audit_watch_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "136-139",
          "snippet": "char *audit_watch_path(struct audit_watch *watch)\n{\n\treturn watch->path;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nchar *audit_watch_path(struct audit_watch *watch)\n{\n\treturn watch->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "sizeof(*data)"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!data"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*data) + krule->buflen",
            "GFP_KERNEL"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};\n\nstatic struct audit_rule_data *audit_krule_to_data(struct audit_krule *krule)\n{\n\tstruct audit_rule_data *data;\n\tvoid *bufp;\n\tint i;\n\n\tdata = kmalloc(sizeof(*data) + krule->buflen, GFP_KERNEL);\n\tif (unlikely(!data))\n\t\treturn NULL;\n\tmemset(data, 0, sizeof(*data));\n\n\tdata->flags = krule->flags | krule->listnr;\n\tdata->action = krule->action;\n\tdata->field_count = krule->field_count;\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &krule->fields[i];\n\n\t\tdata->fields[i] = f->type;\n\t\tdata->fieldflags[i] = audit_ops[f->op];\n\t\tswitch(f->type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, f->lsm_str);\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_watch_path(krule->watch));\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_tree_path(krule->tree));\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, krule->filterkey);\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, audit_mark_path(krule->exe));\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tif (krule->pflags & AUDIT_LOGINUID_LEGACY && !f->val) {\n\t\t\t\tdata->fields[i] = AUDIT_LOGINUID;\n\t\t\t\tdata->values[i] = AUDIT_UID_UNSET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough if set */\n\t\tdefault:\n\t\t\tdata->values[i] = f->val;\n\t\t}\n\t}\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++) data->mask[i] = krule->mask[i];\n\n\treturn data;\n}"
  },
  {
    "function_name": "audit_pack_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "604-612",
    "snippet": "static inline size_t audit_pack_string(void **bufp, const char *str)\n{\n\tsize_t len = strlen(str);\n\n\tmemcpy(*bufp, str, len);\n\t*bufp += len;\n\n\treturn len;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*bufp",
            "str",
            "len"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline size_t audit_pack_string(void **bufp, const char *str)\n{\n\tsize_t len = strlen(str);\n\n\tmemcpy(*bufp, str, len);\n\t*bufp += len;\n\n\treturn len;\n}"
  },
  {
    "function_name": "audit_data_to_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "437-601",
    "snippet": "static struct audit_entry *audit_data_to_entry(struct audit_rule_data *data,\n\t\t\t\t\t       size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\tvoid *bufp;\n\tsize_t remain = datasz - sizeof(struct audit_rule_data);\n\tint i;\n\tchar *str;\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\tentry = audit_to_entry_common(data);\n\tif (IS_ERR(entry))\n\t\tgoto exit_nofree;\n\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &entry->rule.fields[i];\n\n\t\terr = -EINVAL;\n\n\t\tf->op = audit_to_op(data->fieldflags[i]);\n\t\tif (f->op == Audit_bad)\n\t\t\tgoto exit_free;\n\n\t\tf->type = data->fields[i];\n\t\tf->val = data->values[i];\n\n\t\t/* Support legacy tests for a valid loginuid */\n\t\tif ((f->type == AUDIT_LOGINUID) && (f->val == AUDIT_UID_UNSET)) {\n\t\t\tf->type = AUDIT_LOGINUID_SET;\n\t\t\tf->val = 0;\n\t\t\tentry->rule.pflags |= AUDIT_LOGINUID_LEGACY;\n\t\t}\n\n\t\terr = audit_field_valid(entry, f);\n\t\tif (err)\n\t\t\tgoto exit_free;\n\n\t\terr = -EINVAL;\n\t\tswitch (f->type) {\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tf->uid = make_kuid(current_user_ns(), f->val);\n\t\t\tif (!uid_valid(f->uid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tf->gid = make_kgid(current_user_ns(), f->val);\n\t\t\tif (!gid_valid(f->gid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tentry->rule.arch_f = f;\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\terr = security_audit_rule_init(f->type, f->op, str,\n\t\t\t\t\t\t       (void **)&f->lsm_rule);\n\t\t\t/* Keep currently invalid fields around in case they\n\t\t\t * become valid after a policy reload. */\n\t\t\tif (err == -EINVAL) {\n\t\t\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\t\t\tstr);\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t\tif (err) {\n\t\t\t\tkfree(str);\n\t\t\t\tgoto exit_free;\n\t\t\t} else\n\t\t\t\tf->lsm_str = str;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\terr = audit_to_watch(&entry->rule, str, f->val, f->op);\n\t\t\tif (err) {\n\t\t\t\tkfree(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\terr = audit_make_tree(&entry->rule, str, f->op);\n\t\t\tkfree(str);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\terr = audit_to_inode(&entry->rule, f);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tif (entry->rule.filterkey || f->val > AUDIT_MAX_KEY_LEN)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\t\t\tentry->rule.filterkey = str;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tif (entry->rule.exe || f->val > PATH_MAX)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\taudit_mark = audit_alloc_mark(&entry->rule, str, f->val);\n\t\t\tif (IS_ERR(audit_mark)) {\n\t\t\t\tkfree(str);\n\t\t\t\terr = PTR_ERR(audit_mark);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.exe = audit_mark;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (entry->rule.inode_f && entry->rule.inode_f->op == Audit_not_equal)\n\t\tentry->rule.inode_f = NULL;\n\nexit_nofree:\n\treturn entry;\n\nexit_free:\n\tif (entry->rule.tree)\n\t\taudit_put_tree(entry->rule.tree); /* that's the temporary one */\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe); /* that's the template one */\n\taudit_free_rule(entry);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_free_rule",
          "args": [
            "entry"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_rule_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "110-114",
          "snippet": "void audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_mark",
          "args": [
            "entry->rule.exe"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_fsnotify.c",
          "lines": "149-154",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_tree",
          "args": [
            "entry->rule.tree"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "693-696",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "audit_mark"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "str"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "audit_mark"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_alloc_mark",
          "args": [
            "&entry->rule",
            "str",
            "f->val"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "audit_alloc_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_fsnotify.c",
          "lines": "83-121",
          "snippet": "struct audit_fsnotify_mark *audit_alloc_mark(struct audit_krule *krule, char *pathname, int len)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tstruct path path;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint ret;\n\n\tif (pathname[0] != '/' || pathname[len-1] == '/')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdentry = kern_path_locked(pathname, &path);\n\tif (IS_ERR(dentry))\n\t\treturn (void *)dentry; /* returning an error */\n\tinode = path.dentry->d_inode;\n\tinode_unlock(inode);\n\n\taudit_mark = kzalloc(sizeof(*audit_mark), GFP_KERNEL);\n\tif (unlikely(!audit_mark)) {\n\t\taudit_mark = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfsnotify_init_mark(&audit_mark->mark, audit_fsnotify_group);\n\taudit_mark->mark.mask = AUDIT_FS_EVENTS;\n\taudit_mark->path = pathname;\n\taudit_update_mark(audit_mark, dentry->d_inode);\n\taudit_mark->rule = krule;\n\n\tret = fsnotify_add_inode_mark(&audit_mark->mark, inode, true);\n\tif (ret < 0) {\n\t\tfsnotify_put_mark(&audit_mark->mark);\n\t\taudit_mark = ERR_PTR(ret);\n\t}\nout:\n\tdput(dentry);\n\tpath_put(&path);\n\treturn audit_mark;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define AUDIT_FS_EVENTS (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\t FS_MOVE_SELF | FS_EVENT_ON_CHILD)"
          ],
          "globals_used": [
            "static struct fsnotify_group *audit_fsnotify_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\n#define AUDIT_FS_EVENTS (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\t FS_MOVE_SELF | FS_EVENT_ON_CHILD)\n\nstatic struct fsnotify_group *audit_fsnotify_group;\n\nstruct audit_fsnotify_mark *audit_alloc_mark(struct audit_krule *krule, char *pathname, int len)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tstruct path path;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint ret;\n\n\tif (pathname[0] != '/' || pathname[len-1] == '/')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdentry = kern_path_locked(pathname, &path);\n\tif (IS_ERR(dentry))\n\t\treturn (void *)dentry; /* returning an error */\n\tinode = path.dentry->d_inode;\n\tinode_unlock(inode);\n\n\taudit_mark = kzalloc(sizeof(*audit_mark), GFP_KERNEL);\n\tif (unlikely(!audit_mark)) {\n\t\taudit_mark = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfsnotify_init_mark(&audit_mark->mark, audit_fsnotify_group);\n\taudit_mark->mark.mask = AUDIT_FS_EVENTS;\n\taudit_mark->path = pathname;\n\taudit_update_mark(audit_mark, dentry->d_inode);\n\taudit_mark->rule = krule;\n\n\tret = fsnotify_add_inode_mark(&audit_mark->mark, inode, true);\n\tif (ret < 0) {\n\t\tfsnotify_put_mark(&audit_mark->mark);\n\t\taudit_mark = ERR_PTR(ret);\n\t}\nout:\n\tdput(dentry);\n\tpath_put(&path);\n\treturn audit_mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "str"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "str"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_unpack_string",
          "args": [
            "&bufp",
            "&remain",
            "f->val"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "audit_unpack_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "138-161",
          "snippet": "char *audit_unpack_string(void **bufp, size_t *remain, size_t len)\n{\n\tchar *str;\n\n\tif (!*bufp || (len == 0) || (len > *remain))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Of the currently implemented string fields, PATH_MAX\n\t * defines the longest valid length.\n\t */\n\tif (len > PATH_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tstr = kmalloc(len + 1, GFP_KERNEL);\n\tif (unlikely(!str))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(str, *bufp, len);\n\tstr[len] = 0;\n\t*bufp += len;\n\t*remain -= len;\n\n\treturn str;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nchar *audit_unpack_string(void **bufp, size_t *remain, size_t len)\n{\n\tchar *str;\n\n\tif (!*bufp || (len == 0) || (len > *remain))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Of the currently implemented string fields, PATH_MAX\n\t * defines the longest valid length.\n\t */\n\tif (len > PATH_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tstr = kmalloc(len + 1, GFP_KERNEL);\n\tif (unlikely(!str))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(str, *bufp, len);\n\tstr[len] = 0;\n\t*bufp += len;\n\t*remain -= len;\n\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "str"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_to_inode",
          "args": [
            "&entry->rule",
            "f"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "audit_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "164-174",
          "snippet": "static inline int audit_to_inode(struct audit_krule *krule,\n\t\t\t\t struct audit_field *f)\n{\n\tif (krule->listnr != AUDIT_FILTER_EXIT ||\n\t    krule->inode_f || krule->watch || krule->tree ||\n\t    (f->op != Audit_equal && f->op != Audit_not_equal))\n\t\treturn -EINVAL;\n\n\tkrule->inode_f = f;\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline int audit_to_inode(struct audit_krule *krule,\n\t\t\t\t struct audit_field *f)\n{\n\tif (krule->listnr != AUDIT_FILTER_EXIT ||\n\t    krule->inode_f || krule->watch || krule->tree ||\n\t    (f->op != Audit_equal && f->op != Audit_not_equal))\n\t\treturn -EINVAL;\n\n\tkrule->inode_f = f;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_make_tree",
          "args": [
            "&entry->rule",
            "str",
            "f->op"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "audit_make_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "679-691",
          "snippet": "int audit_make_tree(struct audit_krule *rule, char *pathname, u32 op)\n{\n\n\tif (pathname[0] != '/' ||\n\t    rule->listnr != AUDIT_FILTER_EXIT ||\n\t    op != Audit_equal ||\n\t    rule->inode_f || rule->watch || rule->tree)\n\t\treturn -EINVAL;\n\trule->tree = alloc_tree(pathname);\n\tif (!rule->tree)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nint audit_make_tree(struct audit_krule *rule, char *pathname, u32 op)\n{\n\n\tif (pathname[0] != '/' ||\n\t    rule->listnr != AUDIT_FILTER_EXIT ||\n\t    op != Audit_equal ||\n\t    rule->inode_f || rule->watch || rule->tree)\n\t\treturn -EINVAL;\n\trule->tree = alloc_tree(pathname);\n\tif (!rule->tree)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "str"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_to_watch",
          "args": [
            "&entry->rule",
            "str",
            "f->val",
            "f->op"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "audit_to_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "191-211",
          "snippet": "int audit_to_watch(struct audit_krule *krule, char *path, int len, u32 op)\n{\n\tstruct audit_watch *watch;\n\n\tif (!audit_watch_group)\n\t\treturn -EOPNOTSUPP;\n\n\tif (path[0] != '/' || path[len-1] == '/' ||\n\t    krule->listnr != AUDIT_FILTER_EXIT ||\n\t    op != Audit_equal ||\n\t    krule->inode_f || krule->watch || krule->tree)\n\t\treturn -EINVAL;\n\n\twatch = audit_init_watch(path);\n\tif (IS_ERR(watch))\n\t\treturn PTR_ERR(watch);\n\n\tkrule->watch = watch;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_watch_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nint audit_to_watch(struct audit_krule *krule, char *path, int len, u32 op)\n{\n\tstruct audit_watch *watch;\n\n\tif (!audit_watch_group)\n\t\treturn -EOPNOTSUPP;\n\n\tif (path[0] != '/' || path[len-1] == '/' ||\n\t    krule->listnr != AUDIT_FILTER_EXIT ||\n\t    op != Audit_equal ||\n\t    krule->inode_f || krule->watch || krule->tree)\n\t\treturn -EINVAL;\n\n\twatch = audit_init_watch(path);\n\tif (IS_ERR(watch))\n\t\treturn PTR_ERR(watch);\n\n\tkrule->watch = watch;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "str"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"audit rule for LSM \\'%s\\' is invalid\\n\"",
            "str"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_audit_rule_init",
          "args": [
            "f->type",
            "f->op",
            "str",
            "(void **)&f->lsm_rule"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "str"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "f->gid"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "f->val"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "make_kgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "460-464",
          "snippet": "kgid_t make_kgid(struct user_namespace *ns, gid_t gid)\n{\n\t/* Map the gid to a global kernel gid */\n\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nkgid_t make_kgid(struct user_namespace *ns, gid_t gid)\n{\n\t/* Map the gid to a global kernel gid */\n\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "f->uid"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "f->val"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "make_kuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "392-396",
          "snippet": "kuid_t make_kuid(struct user_namespace *ns, uid_t uid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nkuid_t make_kuid(struct user_namespace *ns, uid_t uid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_field_valid",
          "args": [
            "entry",
            "f"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "audit_field_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "336-434",
          "snippet": "static int audit_field_valid(struct audit_entry *entry, struct audit_field *f)\n{\n\tswitch(f->type) {\n\tcase AUDIT_MSGTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_EXCLUDE &&\n\t\t    entry->rule.listnr != AUDIT_FILTER_USER)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FSTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_FS)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_FS:\n\t\tswitch(f->type) {\n\t\tcase AUDIT_FSTYPE:\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch(f->type) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase AUDIT_UID:\n\tcase AUDIT_EUID:\n\tcase AUDIT_SUID:\n\tcase AUDIT_FSUID:\n\tcase AUDIT_LOGINUID:\n\tcase AUDIT_OBJ_UID:\n\tcase AUDIT_GID:\n\tcase AUDIT_EGID:\n\tcase AUDIT_SGID:\n\tcase AUDIT_FSGID:\n\tcase AUDIT_OBJ_GID:\n\tcase AUDIT_PID:\n\tcase AUDIT_PERS:\n\tcase AUDIT_MSGTYPE:\n\tcase AUDIT_PPID:\n\tcase AUDIT_DEVMAJOR:\n\tcase AUDIT_DEVMINOR:\n\tcase AUDIT_EXIT:\n\tcase AUDIT_SUCCESS:\n\tcase AUDIT_INODE:\n\tcase AUDIT_SESSIONID:\n\t\t/* bit ops are only useful on syscall args */\n\t\tif (f->op == Audit_bitmask || f->op == Audit_bittest)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_ARG0:\n\tcase AUDIT_ARG1:\n\tcase AUDIT_ARG2:\n\tcase AUDIT_ARG3:\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\tcase AUDIT_WATCH:\n\tcase AUDIT_DIR:\n\tcase AUDIT_FILTERKEY:\n\t\tbreak;\n\tcase AUDIT_LOGINUID_SET:\n\t\tif ((f->val != 0) && (f->val != 1))\n\t\t\treturn -EINVAL;\n\t/* FALL THROUGH */\n\tcase AUDIT_ARCH:\n\tcase AUDIT_FSTYPE:\n\t\tif (f->op != Audit_not_equal && f->op != Audit_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_PERM:\n\t\tif (f->val & ~15)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FILETYPE:\n\t\tif (f->val & ~S_IFMT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FIELD_COMPARE:\n\t\tif (f->val > AUDIT_MAX_FIELD_COMPARE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_EXE:\n\t\tif (f->op != Audit_not_equal && f->op != Audit_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int audit_field_valid(struct audit_entry *entry, struct audit_field *f)\n{\n\tswitch(f->type) {\n\tcase AUDIT_MSGTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_EXCLUDE &&\n\t\t    entry->rule.listnr != AUDIT_FILTER_USER)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FSTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_FS)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_FS:\n\t\tswitch(f->type) {\n\t\tcase AUDIT_FSTYPE:\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch(f->type) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase AUDIT_UID:\n\tcase AUDIT_EUID:\n\tcase AUDIT_SUID:\n\tcase AUDIT_FSUID:\n\tcase AUDIT_LOGINUID:\n\tcase AUDIT_OBJ_UID:\n\tcase AUDIT_GID:\n\tcase AUDIT_EGID:\n\tcase AUDIT_SGID:\n\tcase AUDIT_FSGID:\n\tcase AUDIT_OBJ_GID:\n\tcase AUDIT_PID:\n\tcase AUDIT_PERS:\n\tcase AUDIT_MSGTYPE:\n\tcase AUDIT_PPID:\n\tcase AUDIT_DEVMAJOR:\n\tcase AUDIT_DEVMINOR:\n\tcase AUDIT_EXIT:\n\tcase AUDIT_SUCCESS:\n\tcase AUDIT_INODE:\n\tcase AUDIT_SESSIONID:\n\t\t/* bit ops are only useful on syscall args */\n\t\tif (f->op == Audit_bitmask || f->op == Audit_bittest)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_ARG0:\n\tcase AUDIT_ARG1:\n\tcase AUDIT_ARG2:\n\tcase AUDIT_ARG3:\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\tcase AUDIT_WATCH:\n\tcase AUDIT_DIR:\n\tcase AUDIT_FILTERKEY:\n\t\tbreak;\n\tcase AUDIT_LOGINUID_SET:\n\t\tif ((f->val != 0) && (f->val != 1))\n\t\t\treturn -EINVAL;\n\t/* FALL THROUGH */\n\tcase AUDIT_ARCH:\n\tcase AUDIT_FSTYPE:\n\t\tif (f->op != Audit_not_equal && f->op != Audit_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_PERM:\n\t\tif (f->val & ~15)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FILETYPE:\n\t\tif (f->val & ~S_IFMT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FIELD_COMPARE:\n\t\tif (f->val > AUDIT_MAX_FIELD_COMPARE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_EXE:\n\t\tif (f->op != Audit_not_equal && f->op != Audit_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_to_op",
          "args": [
            "data->fieldflags[i]"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "audit_to_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "327-333",
          "snippet": "static u32 audit_to_op(u32 op)\n{\n\tu32 n;\n\tfor (n = Audit_equal; n < Audit_bad && audit_ops[n] != op; n++)\n\t\t;\n\treturn n;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};\n\nstatic u32 audit_to_op(u32 op)\n{\n\tu32 n;\n\tfor (n = Audit_equal; n < Audit_bad && audit_ops[n] != op; n++)\n\t\t;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "entry"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_to_entry_common",
          "args": [
            "data"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "audit_to_entry_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "248-313",
          "snippet": "static inline struct audit_entry *audit_to_entry_common(struct audit_rule_data *rule)\n{\n\tunsigned listnr;\n\tstruct audit_entry *entry;\n\tint i, err;\n\n\terr = -EINVAL;\n\tlistnr = rule->flags & ~AUDIT_FILTER_PREPEND;\n\tswitch(listnr) {\n\tdefault:\n\t\tgoto exit_err;\n#ifdef CONFIG_AUDITSYSCALL\n\tcase AUDIT_FILTER_ENTRY:\n\t\tpr_err(\"AUDIT_FILTER_ENTRY is deprecated\\n\");\n\t\tgoto exit_err;\n\tcase AUDIT_FILTER_EXIT:\n\tcase AUDIT_FILTER_TASK:\n#endif\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\t;\n\t}\n\tif (unlikely(rule->action == AUDIT_POSSIBLE)) {\n\t\tpr_err(\"AUDIT_POSSIBLE is deprecated\\n\");\n\t\tgoto exit_err;\n\t}\n\tif (rule->action != AUDIT_NEVER && rule->action != AUDIT_ALWAYS)\n\t\tgoto exit_err;\n\tif (rule->field_count > AUDIT_MAX_FIELDS)\n\t\tgoto exit_err;\n\n\terr = -ENOMEM;\n\tentry = audit_init_entry(rule->field_count);\n\tif (!entry)\n\t\tgoto exit_err;\n\n\tentry->rule.flags = rule->flags & AUDIT_FILTER_PREPEND;\n\tentry->rule.listnr = listnr;\n\tentry->rule.action = rule->action;\n\tentry->rule.field_count = rule->field_count;\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tentry->rule.mask[i] = rule->mask[i];\n\n\tfor (i = 0; i < AUDIT_SYSCALL_CLASSES; i++) {\n\t\tint bit = AUDIT_BITMASK_SIZE * 32 - i - 1;\n\t\t__u32 *p = &entry->rule.mask[AUDIT_WORD(bit)];\n\t\t__u32 *class;\n\n\t\tif (!(*p & AUDIT_BIT(bit)))\n\t\t\tcontinue;\n\t\t*p &= ~AUDIT_BIT(bit);\n\t\tclass = classes[i];\n\t\tif (class) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < AUDIT_BITMASK_SIZE; j++)\n\t\t\t\tentry->rule.mask[j] |= class[j];\n\t\t}\n\t}\n\n\treturn entry;\n\nexit_err:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __u32 *classes[AUDIT_SYSCALL_CLASSES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nstatic inline struct audit_entry *audit_to_entry_common(struct audit_rule_data *rule)\n{\n\tunsigned listnr;\n\tstruct audit_entry *entry;\n\tint i, err;\n\n\terr = -EINVAL;\n\tlistnr = rule->flags & ~AUDIT_FILTER_PREPEND;\n\tswitch(listnr) {\n\tdefault:\n\t\tgoto exit_err;\n#ifdef CONFIG_AUDITSYSCALL\n\tcase AUDIT_FILTER_ENTRY:\n\t\tpr_err(\"AUDIT_FILTER_ENTRY is deprecated\\n\");\n\t\tgoto exit_err;\n\tcase AUDIT_FILTER_EXIT:\n\tcase AUDIT_FILTER_TASK:\n#endif\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\t;\n\t}\n\tif (unlikely(rule->action == AUDIT_POSSIBLE)) {\n\t\tpr_err(\"AUDIT_POSSIBLE is deprecated\\n\");\n\t\tgoto exit_err;\n\t}\n\tif (rule->action != AUDIT_NEVER && rule->action != AUDIT_ALWAYS)\n\t\tgoto exit_err;\n\tif (rule->field_count > AUDIT_MAX_FIELDS)\n\t\tgoto exit_err;\n\n\terr = -ENOMEM;\n\tentry = audit_init_entry(rule->field_count);\n\tif (!entry)\n\t\tgoto exit_err;\n\n\tentry->rule.flags = rule->flags & AUDIT_FILTER_PREPEND;\n\tentry->rule.listnr = listnr;\n\tentry->rule.action = rule->action;\n\tentry->rule.field_count = rule->field_count;\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tentry->rule.mask[i] = rule->mask[i];\n\n\tfor (i = 0; i < AUDIT_SYSCALL_CLASSES; i++) {\n\t\tint bit = AUDIT_BITMASK_SIZE * 32 - i - 1;\n\t\t__u32 *p = &entry->rule.mask[AUDIT_WORD(bit)];\n\t\t__u32 *class;\n\n\t\tif (!(*p & AUDIT_BIT(bit)))\n\t\t\tcontinue;\n\t\t*p &= ~AUDIT_BIT(bit);\n\t\tclass = classes[i];\n\t\tif (class) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < AUDIT_BITMASK_SIZE; j++)\n\t\t\t\tentry->rule.mask[j] |= class[j];\n\t\t}\n\t}\n\n\treturn entry;\n\nexit_err:\n\treturn ERR_PTR(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic struct audit_entry *audit_data_to_entry(struct audit_rule_data *data,\n\t\t\t\t\t       size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\tvoid *bufp;\n\tsize_t remain = datasz - sizeof(struct audit_rule_data);\n\tint i;\n\tchar *str;\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\tentry = audit_to_entry_common(data);\n\tif (IS_ERR(entry))\n\t\tgoto exit_nofree;\n\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &entry->rule.fields[i];\n\n\t\terr = -EINVAL;\n\n\t\tf->op = audit_to_op(data->fieldflags[i]);\n\t\tif (f->op == Audit_bad)\n\t\t\tgoto exit_free;\n\n\t\tf->type = data->fields[i];\n\t\tf->val = data->values[i];\n\n\t\t/* Support legacy tests for a valid loginuid */\n\t\tif ((f->type == AUDIT_LOGINUID) && (f->val == AUDIT_UID_UNSET)) {\n\t\t\tf->type = AUDIT_LOGINUID_SET;\n\t\t\tf->val = 0;\n\t\t\tentry->rule.pflags |= AUDIT_LOGINUID_LEGACY;\n\t\t}\n\n\t\terr = audit_field_valid(entry, f);\n\t\tif (err)\n\t\t\tgoto exit_free;\n\n\t\terr = -EINVAL;\n\t\tswitch (f->type) {\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tf->uid = make_kuid(current_user_ns(), f->val);\n\t\t\tif (!uid_valid(f->uid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tf->gid = make_kgid(current_user_ns(), f->val);\n\t\t\tif (!gid_valid(f->gid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tentry->rule.arch_f = f;\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\terr = security_audit_rule_init(f->type, f->op, str,\n\t\t\t\t\t\t       (void **)&f->lsm_rule);\n\t\t\t/* Keep currently invalid fields around in case they\n\t\t\t * become valid after a policy reload. */\n\t\t\tif (err == -EINVAL) {\n\t\t\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\t\t\tstr);\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t\tif (err) {\n\t\t\t\tkfree(str);\n\t\t\t\tgoto exit_free;\n\t\t\t} else\n\t\t\t\tf->lsm_str = str;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\terr = audit_to_watch(&entry->rule, str, f->val, f->op);\n\t\t\tif (err) {\n\t\t\t\tkfree(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\terr = audit_make_tree(&entry->rule, str, f->op);\n\t\t\tkfree(str);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\terr = audit_to_inode(&entry->rule, f);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tif (entry->rule.filterkey || f->val > AUDIT_MAX_KEY_LEN)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str))\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f->val;\n\t\t\tentry->rule.filterkey = str;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tif (entry->rule.exe || f->val > PATH_MAX)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f->val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f->val;\n\n\t\t\taudit_mark = audit_alloc_mark(&entry->rule, str, f->val);\n\t\t\tif (IS_ERR(audit_mark)) {\n\t\t\t\tkfree(str);\n\t\t\t\terr = PTR_ERR(audit_mark);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.exe = audit_mark;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (entry->rule.inode_f && entry->rule.inode_f->op == Audit_not_equal)\n\t\tentry->rule.inode_f = NULL;\n\nexit_nofree:\n\treturn entry;\n\nexit_free:\n\tif (entry->rule.tree)\n\t\taudit_put_tree(entry->rule.tree); /* that's the temporary one */\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe); /* that's the template one */\n\taudit_free_rule(entry);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "audit_field_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "336-434",
    "snippet": "static int audit_field_valid(struct audit_entry *entry, struct audit_field *f)\n{\n\tswitch(f->type) {\n\tcase AUDIT_MSGTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_EXCLUDE &&\n\t\t    entry->rule.listnr != AUDIT_FILTER_USER)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FSTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_FS)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_FS:\n\t\tswitch(f->type) {\n\t\tcase AUDIT_FSTYPE:\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch(f->type) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase AUDIT_UID:\n\tcase AUDIT_EUID:\n\tcase AUDIT_SUID:\n\tcase AUDIT_FSUID:\n\tcase AUDIT_LOGINUID:\n\tcase AUDIT_OBJ_UID:\n\tcase AUDIT_GID:\n\tcase AUDIT_EGID:\n\tcase AUDIT_SGID:\n\tcase AUDIT_FSGID:\n\tcase AUDIT_OBJ_GID:\n\tcase AUDIT_PID:\n\tcase AUDIT_PERS:\n\tcase AUDIT_MSGTYPE:\n\tcase AUDIT_PPID:\n\tcase AUDIT_DEVMAJOR:\n\tcase AUDIT_DEVMINOR:\n\tcase AUDIT_EXIT:\n\tcase AUDIT_SUCCESS:\n\tcase AUDIT_INODE:\n\tcase AUDIT_SESSIONID:\n\t\t/* bit ops are only useful on syscall args */\n\t\tif (f->op == Audit_bitmask || f->op == Audit_bittest)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_ARG0:\n\tcase AUDIT_ARG1:\n\tcase AUDIT_ARG2:\n\tcase AUDIT_ARG3:\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\tcase AUDIT_WATCH:\n\tcase AUDIT_DIR:\n\tcase AUDIT_FILTERKEY:\n\t\tbreak;\n\tcase AUDIT_LOGINUID_SET:\n\t\tif ((f->val != 0) && (f->val != 1))\n\t\t\treturn -EINVAL;\n\t/* FALL THROUGH */\n\tcase AUDIT_ARCH:\n\tcase AUDIT_FSTYPE:\n\t\tif (f->op != Audit_not_equal && f->op != Audit_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_PERM:\n\t\tif (f->val & ~15)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FILETYPE:\n\t\tif (f->val & ~S_IFMT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FIELD_COMPARE:\n\t\tif (f->val > AUDIT_MAX_FIELD_COMPARE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_EXE:\n\t\tif (f->op != Audit_not_equal && f->op != Audit_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int audit_field_valid(struct audit_entry *entry, struct audit_field *f)\n{\n\tswitch(f->type) {\n\tcase AUDIT_MSGTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_EXCLUDE &&\n\t\t    entry->rule.listnr != AUDIT_FILTER_USER)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FSTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_FS)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_FS:\n\t\tswitch(f->type) {\n\t\tcase AUDIT_FSTYPE:\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch(f->type) {\n\tdefault:\n\t\treturn -EINVAL;\n\tcase AUDIT_UID:\n\tcase AUDIT_EUID:\n\tcase AUDIT_SUID:\n\tcase AUDIT_FSUID:\n\tcase AUDIT_LOGINUID:\n\tcase AUDIT_OBJ_UID:\n\tcase AUDIT_GID:\n\tcase AUDIT_EGID:\n\tcase AUDIT_SGID:\n\tcase AUDIT_FSGID:\n\tcase AUDIT_OBJ_GID:\n\tcase AUDIT_PID:\n\tcase AUDIT_PERS:\n\tcase AUDIT_MSGTYPE:\n\tcase AUDIT_PPID:\n\tcase AUDIT_DEVMAJOR:\n\tcase AUDIT_DEVMINOR:\n\tcase AUDIT_EXIT:\n\tcase AUDIT_SUCCESS:\n\tcase AUDIT_INODE:\n\tcase AUDIT_SESSIONID:\n\t\t/* bit ops are only useful on syscall args */\n\t\tif (f->op == Audit_bitmask || f->op == Audit_bittest)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_ARG0:\n\tcase AUDIT_ARG1:\n\tcase AUDIT_ARG2:\n\tcase AUDIT_ARG3:\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\tcase AUDIT_WATCH:\n\tcase AUDIT_DIR:\n\tcase AUDIT_FILTERKEY:\n\t\tbreak;\n\tcase AUDIT_LOGINUID_SET:\n\t\tif ((f->val != 0) && (f->val != 1))\n\t\t\treturn -EINVAL;\n\t/* FALL THROUGH */\n\tcase AUDIT_ARCH:\n\tcase AUDIT_FSTYPE:\n\t\tif (f->op != Audit_not_equal && f->op != Audit_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_PERM:\n\t\tif (f->val & ~15)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FILETYPE:\n\t\tif (f->val & ~S_IFMT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FIELD_COMPARE:\n\t\tif (f->val > AUDIT_MAX_FIELD_COMPARE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_EXE:\n\t\tif (f->op != Audit_not_equal && f->op != Audit_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_to_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "327-333",
    "snippet": "static u32 audit_to_op(u32 op)\n{\n\tu32 n;\n\tfor (n = Audit_equal; n < Audit_bad && audit_ops[n] != op; n++)\n\t\t;\n\treturn n;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};\n\nstatic u32 audit_to_op(u32 op)\n{\n\tu32 n;\n\tfor (n = Audit_equal; n < Audit_bad && audit_ops[n] != op; n++)\n\t\t;\n\treturn n;\n}"
  },
  {
    "function_name": "audit_to_entry_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "248-313",
    "snippet": "static inline struct audit_entry *audit_to_entry_common(struct audit_rule_data *rule)\n{\n\tunsigned listnr;\n\tstruct audit_entry *entry;\n\tint i, err;\n\n\terr = -EINVAL;\n\tlistnr = rule->flags & ~AUDIT_FILTER_PREPEND;\n\tswitch(listnr) {\n\tdefault:\n\t\tgoto exit_err;\n#ifdef CONFIG_AUDITSYSCALL\n\tcase AUDIT_FILTER_ENTRY:\n\t\tpr_err(\"AUDIT_FILTER_ENTRY is deprecated\\n\");\n\t\tgoto exit_err;\n\tcase AUDIT_FILTER_EXIT:\n\tcase AUDIT_FILTER_TASK:\n#endif\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\t;\n\t}\n\tif (unlikely(rule->action == AUDIT_POSSIBLE)) {\n\t\tpr_err(\"AUDIT_POSSIBLE is deprecated\\n\");\n\t\tgoto exit_err;\n\t}\n\tif (rule->action != AUDIT_NEVER && rule->action != AUDIT_ALWAYS)\n\t\tgoto exit_err;\n\tif (rule->field_count > AUDIT_MAX_FIELDS)\n\t\tgoto exit_err;\n\n\terr = -ENOMEM;\n\tentry = audit_init_entry(rule->field_count);\n\tif (!entry)\n\t\tgoto exit_err;\n\n\tentry->rule.flags = rule->flags & AUDIT_FILTER_PREPEND;\n\tentry->rule.listnr = listnr;\n\tentry->rule.action = rule->action;\n\tentry->rule.field_count = rule->field_count;\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tentry->rule.mask[i] = rule->mask[i];\n\n\tfor (i = 0; i < AUDIT_SYSCALL_CLASSES; i++) {\n\t\tint bit = AUDIT_BITMASK_SIZE * 32 - i - 1;\n\t\t__u32 *p = &entry->rule.mask[AUDIT_WORD(bit)];\n\t\t__u32 *class;\n\n\t\tif (!(*p & AUDIT_BIT(bit)))\n\t\t\tcontinue;\n\t\t*p &= ~AUDIT_BIT(bit);\n\t\tclass = classes[i];\n\t\tif (class) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < AUDIT_BITMASK_SIZE; j++)\n\t\t\t\tentry->rule.mask[j] |= class[j];\n\t\t}\n\t}\n\n\treturn entry;\n\nexit_err:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __u32 *classes[AUDIT_SYSCALL_CLASSES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_BIT",
          "args": [
            "bit"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_BIT",
          "args": [
            "bit"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_WORD",
          "args": [
            "bit"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_init_entry",
          "args": [
            "rule->field_count"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "audit_init_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "117-134",
          "snippet": "static inline struct audit_entry *audit_init_entry(u32 field_count)\n{\n\tstruct audit_entry *entry;\n\tstruct audit_field *fields;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (unlikely(!entry))\n\t\treturn NULL;\n\n\tfields = kcalloc(field_count, sizeof(*fields), GFP_KERNEL);\n\tif (unlikely(!fields)) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->rule.fields = fields;\n\n\treturn entry;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline struct audit_entry *audit_init_entry(u32 field_count)\n{\n\tstruct audit_entry *entry;\n\tstruct audit_field *fields;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (unlikely(!entry))\n\t\treturn NULL;\n\n\tfields = kcalloc(field_count, sizeof(*fields), GFP_KERNEL);\n\tif (unlikely(!fields)) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->rule.fields = fields;\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"AUDIT_POSSIBLE is deprecated\\n\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rule->action == AUDIT_POSSIBLE"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"AUDIT_FILTER_ENTRY is deprecated\\n\""
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nstatic inline struct audit_entry *audit_to_entry_common(struct audit_rule_data *rule)\n{\n\tunsigned listnr;\n\tstruct audit_entry *entry;\n\tint i, err;\n\n\terr = -EINVAL;\n\tlistnr = rule->flags & ~AUDIT_FILTER_PREPEND;\n\tswitch(listnr) {\n\tdefault:\n\t\tgoto exit_err;\n#ifdef CONFIG_AUDITSYSCALL\n\tcase AUDIT_FILTER_ENTRY:\n\t\tpr_err(\"AUDIT_FILTER_ENTRY is deprecated\\n\");\n\t\tgoto exit_err;\n\tcase AUDIT_FILTER_EXIT:\n\tcase AUDIT_FILTER_TASK:\n#endif\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\t;\n\t}\n\tif (unlikely(rule->action == AUDIT_POSSIBLE)) {\n\t\tpr_err(\"AUDIT_POSSIBLE is deprecated\\n\");\n\t\tgoto exit_err;\n\t}\n\tif (rule->action != AUDIT_NEVER && rule->action != AUDIT_ALWAYS)\n\t\tgoto exit_err;\n\tif (rule->field_count > AUDIT_MAX_FIELDS)\n\t\tgoto exit_err;\n\n\terr = -ENOMEM;\n\tentry = audit_init_entry(rule->field_count);\n\tif (!entry)\n\t\tgoto exit_err;\n\n\tentry->rule.flags = rule->flags & AUDIT_FILTER_PREPEND;\n\tentry->rule.listnr = listnr;\n\tentry->rule.action = rule->action;\n\tentry->rule.field_count = rule->field_count;\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tentry->rule.mask[i] = rule->mask[i];\n\n\tfor (i = 0; i < AUDIT_SYSCALL_CLASSES; i++) {\n\t\tint bit = AUDIT_BITMASK_SIZE * 32 - i - 1;\n\t\t__u32 *p = &entry->rule.mask[AUDIT_WORD(bit)];\n\t\t__u32 *class;\n\n\t\tif (!(*p & AUDIT_BIT(bit)))\n\t\t\tcontinue;\n\t\t*p &= ~AUDIT_BIT(bit);\n\t\tclass = classes[i];\n\t\tif (class) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < AUDIT_BITMASK_SIZE; j++)\n\t\t\t\tentry->rule.mask[j] |= class[j];\n\t\t}\n\t}\n\n\treturn entry;\n\nexit_err:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "audit_match_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "221-244",
    "snippet": "static int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->rule.arch_f;\n\n\tif (!arch) {\n\t\t/* When arch is unspecified, we must check both masks on biarch\n\t\t * as syscall number alone is ambiguous. */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask) &&\n\t\t\taudit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\t}\n\n\tswitch(audit_classify_arch(arch->val)) {\n\tcase 0: /* native */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask));\n\tcase 1: /* 32bit on biarch */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\tdefault:\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_match_class_bits",
          "args": [
            "AUDIT_CLASS_SIGNAL_32",
            "entry->rule.mask"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "audit_match_class_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "209-219",
          "snippet": "static inline int audit_match_class_bits(int class, u32 *mask)\n{\n\tint i;\n\n\tif (classes[class]) {\n\t\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __u32 *classes[AUDIT_SYSCALL_CLASSES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nstatic inline int audit_match_class_bits(int class, u32 *mask)\n{\n\tint i;\n\n\tif (classes[class]) {\n\t\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_classify_arch",
          "args": [
            "arch->val"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->rule.arch_f;\n\n\tif (!arch) {\n\t\t/* When arch is unspecified, we must check both masks on biarch\n\t\t * as syscall number alone is ambiguous. */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask) &&\n\t\t\taudit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\t}\n\n\tswitch(audit_classify_arch(arch->val)) {\n\tcase 0: /* native */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask));\n\tcase 1: /* 32bit on biarch */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\tdefault:\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "audit_match_class_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "209-219",
    "snippet": "static inline int audit_match_class_bits(int class, u32 *mask)\n{\n\tint i;\n\n\tif (classes[class]) {\n\t\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __u32 *classes[AUDIT_SYSCALL_CLASSES];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nstatic inline int audit_match_class_bits(int class, u32 *mask)\n{\n\tint i;\n\n\tif (classes[class]) {\n\t\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "audit_match_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "199-206",
    "snippet": "int audit_match_class(int class, unsigned syscall)\n{\n\tif (unlikely(syscall >= AUDIT_BITMASK_SIZE * 32))\n\t\treturn 0;\n\tif (unlikely(class >= AUDIT_SYSCALL_CLASSES || !classes[class]))\n\t\treturn 0;\n\treturn classes[class][AUDIT_WORD(syscall)] & AUDIT_BIT(syscall);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __u32 *classes[AUDIT_SYSCALL_CLASSES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUDIT_BIT",
          "args": [
            "syscall"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_WORD",
          "args": [
            "syscall"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "class >= AUDIT_SYSCALL_CLASSES || !classes[class]"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "syscall >= AUDIT_BITMASK_SIZE * 32"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nint audit_match_class(int class, unsigned syscall)\n{\n\tif (unlikely(syscall >= AUDIT_BITMASK_SIZE * 32))\n\t\treturn 0;\n\tif (unlikely(class >= AUDIT_SYSCALL_CLASSES || !classes[class]))\n\t\treturn 0;\n\treturn classes[class][AUDIT_WORD(syscall)] & AUDIT_BIT(syscall);\n}"
  },
  {
    "function_name": "audit_register_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "178-197",
    "snippet": "int __init audit_register_class(int class, unsigned *list)\n{\n\t__u32 *p = kcalloc(AUDIT_BITMASK_SIZE, sizeof(__u32), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\twhile (*list != ~0U) {\n\t\tunsigned n = *list++;\n\t\tif (n >= AUDIT_BITMASK_SIZE * 32 - AUDIT_SYSCALL_CLASSES) {\n\t\t\tkfree(p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp[AUDIT_WORD(n)] |= AUDIT_BIT(n);\n\t}\n\tif (class >= AUDIT_SYSCALL_CLASSES || classes[class]) {\n\t\tkfree(p);\n\t\treturn -EINVAL;\n\t}\n\tclasses[class] = p;\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __u32 *classes[AUDIT_SYSCALL_CLASSES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUDIT_BIT",
          "args": [
            "n"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_WORD",
          "args": [
            "n"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "AUDIT_BITMASK_SIZE",
            "sizeof(__u32)",
            "GFP_KERNEL"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nint __init audit_register_class(int class, unsigned *list)\n{\n\t__u32 *p = kcalloc(AUDIT_BITMASK_SIZE, sizeof(__u32), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\twhile (*list != ~0U) {\n\t\tunsigned n = *list++;\n\t\tif (n >= AUDIT_BITMASK_SIZE * 32 - AUDIT_SYSCALL_CLASSES) {\n\t\t\tkfree(p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp[AUDIT_WORD(n)] |= AUDIT_BIT(n);\n\t}\n\tif (class >= AUDIT_SYSCALL_CLASSES || classes[class]) {\n\t\tkfree(p);\n\t\treturn -EINVAL;\n\t}\n\tclasses[class] = p;\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_to_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "164-174",
    "snippet": "static inline int audit_to_inode(struct audit_krule *krule,\n\t\t\t\t struct audit_field *f)\n{\n\tif (krule->listnr != AUDIT_FILTER_EXIT ||\n\t    krule->inode_f || krule->watch || krule->tree ||\n\t    (f->op != Audit_equal && f->op != Audit_not_equal))\n\t\treturn -EINVAL;\n\n\tkrule->inode_f = f;\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline int audit_to_inode(struct audit_krule *krule,\n\t\t\t\t struct audit_field *f)\n{\n\tif (krule->listnr != AUDIT_FILTER_EXIT ||\n\t    krule->inode_f || krule->watch || krule->tree ||\n\t    (f->op != Audit_equal && f->op != Audit_not_equal))\n\t\treturn -EINVAL;\n\n\tkrule->inode_f = f;\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_unpack_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "138-161",
    "snippet": "char *audit_unpack_string(void **bufp, size_t *remain, size_t len)\n{\n\tchar *str;\n\n\tif (!*bufp || (len == 0) || (len > *remain))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Of the currently implemented string fields, PATH_MAX\n\t * defines the longest valid length.\n\t */\n\tif (len > PATH_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tstr = kmalloc(len + 1, GFP_KERNEL);\n\tif (unlikely(!str))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(str, *bufp, len);\n\tstr[len] = 0;\n\t*bufp += len;\n\t*remain -= len;\n\n\treturn str;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "str",
            "*bufp",
            "len"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!str"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nchar *audit_unpack_string(void **bufp, size_t *remain, size_t len)\n{\n\tchar *str;\n\n\tif (!*bufp || (len == 0) || (len > *remain))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Of the currently implemented string fields, PATH_MAX\n\t * defines the longest valid length.\n\t */\n\tif (len > PATH_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tstr = kmalloc(len + 1, GFP_KERNEL);\n\tif (unlikely(!str))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(str, *bufp, len);\n\tstr[len] = 0;\n\t*bufp += len;\n\t*remain -= len;\n\n\treturn str;\n}"
  },
  {
    "function_name": "audit_init_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "117-134",
    "snippet": "static inline struct audit_entry *audit_init_entry(u32 field_count)\n{\n\tstruct audit_entry *entry;\n\tstruct audit_field *fields;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (unlikely(!entry))\n\t\treturn NULL;\n\n\tfields = kcalloc(field_count, sizeof(*fields), GFP_KERNEL);\n\tif (unlikely(!fields)) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->rule.fields = fields;\n\n\treturn entry;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!fields"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "field_count",
            "sizeof(*fields)",
            "GFP_KERNEL"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!entry"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*entry)",
            "GFP_KERNEL"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline struct audit_entry *audit_init_entry(u32 field_count)\n{\n\tstruct audit_entry *entry;\n\tstruct audit_field *fields;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (unlikely(!entry))\n\t\treturn NULL;\n\n\tfields = kcalloc(field_count, sizeof(*fields), GFP_KERNEL);\n\tif (unlikely(!fields)) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->rule.fields = fields;\n\n\treturn entry;\n}"
  },
  {
    "function_name": "audit_free_rule_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "110-114",
    "snippet": "void audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_free_rule",
          "args": [
            "e"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_rule_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "110-114",
          "snippet": "void audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structaudit_entry",
            "rcu"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}"
  },
  {
    "function_name": "audit_free_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "94-108",
    "snippet": "static inline void audit_free_rule(struct audit_entry *e)\n{\n\tint i;\n\tstruct audit_krule *erule = &e->rule;\n\n\t/* some rules don't have associated watches */\n\tif (erule->watch)\n\t\taudit_put_watch(erule->watch);\n\tif (erule->fields)\n\t\tfor (i = 0; i < erule->field_count; i++)\n\t\t\taudit_free_lsm_field(&erule->fields[i]);\n\tkfree(erule->fields);\n\tkfree(erule->filterkey);\n\tkfree(e);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "e"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_free_lsm_field",
          "args": [
            "&erule->fields[i]"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_lsm_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "76-92",
          "snippet": "static void audit_free_lsm_field(struct audit_field *f)\n{\n\tswitch (f->type) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tkfree(f->lsm_str);\n\t\tsecurity_audit_rule_free(f->lsm_rule);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic void audit_free_lsm_field(struct audit_field *f)\n{\n\tswitch (f->type) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tkfree(f->lsm_str);\n\t\tsecurity_audit_rule_free(f->lsm_rule);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_watch",
          "args": [
            "erule->watch"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "118-126",
          "snippet": "void audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline void audit_free_rule(struct audit_entry *e)\n{\n\tint i;\n\tstruct audit_krule *erule = &e->rule;\n\n\t/* some rules don't have associated watches */\n\tif (erule->watch)\n\t\taudit_put_watch(erule->watch);\n\tif (erule->fields)\n\t\tfor (i = 0; i < erule->field_count; i++)\n\t\t\taudit_free_lsm_field(&erule->fields[i]);\n\tkfree(erule->fields);\n\tkfree(erule->filterkey);\n\tkfree(e);\n}"
  },
  {
    "function_name": "audit_free_lsm_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
    "lines": "76-92",
    "snippet": "static void audit_free_lsm_field(struct audit_field *f)\n{\n\tswitch (f->type) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tkfree(f->lsm_str);\n\t\tsecurity_audit_rule_free(f->lsm_rule);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_audit_rule_free",
          "args": [
            "f->lsm_rule"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "f->lsm_str"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic void audit_free_lsm_field(struct audit_field *f)\n{\n\tswitch (f->type) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tkfree(f->lsm_str);\n\t\tsecurity_audit_rule_free(f->lsm_rule);\n\t}\n}"
  }
]