[
  {
    "function_name": "klp_force_transition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "621-637",
    "snippet": "void klp_force_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_warn(\"forcing remaining tasks to the patched state\\n\");\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tklp_update_patch_state(task);\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu)\n\t\tklp_update_patch_state(idle_task(cpu));\n\n\tklp_forced = true;\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool klp_forced = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_update_patch_state",
          "args": [
            "task"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "klp_update_patch_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "175-199",
          "snippet": "void klp_update_patch_state(struct task_struct *task)\n{\n\t/*\n\t * A variant of synchronize_sched() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\t/*\n\t * This test_and_clear_tsk_thread_flag() call also serves as a read\n\t * barrier (smp_rmb) for two cases:\n\t *\n\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the\n\t *    klp_target_state read.  The corresponding write barrier is in\n\t *    klp_init_transition().\n\t *\n\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read\n\t *    of func->transition, if klp_ftrace_handler() is called later on\n\t *    the same CPU.  See __klp_disable_patch().\n\t */\n\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))\n\t\ttask->patch_state = READ_ONCE(klp_target_state);\n\n\tpreempt_enable_notrace();\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_update_patch_state(struct task_struct *task)\n{\n\t/*\n\t * A variant of synchronize_sched() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\t/*\n\t * This test_and_clear_tsk_thread_flag() call also serves as a read\n\t * barrier (smp_rmb) for two cases:\n\t *\n\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the\n\t *    klp_target_state read.  The corresponding write barrier is in\n\t *    klp_init_transition().\n\t *\n\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read\n\t *    of func->transition, if klp_ftrace_handler() is called later on\n\t *    the same CPU.  See __klp_disable_patch().\n\t */\n\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))\n\t\ttask->patch_state = READ_ONCE(klp_target_state);\n\n\tpreempt_enable_notrace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "task"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"forcing remaining tasks to the patched state\\n\""
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic bool klp_forced = false;\n\nvoid klp_force_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_warn(\"forcing remaining tasks to the patched state\\n\");\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tklp_update_patch_state(task);\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu)\n\t\tklp_update_patch_state(idle_task(cpu));\n\n\tklp_forced = true;\n}"
  },
  {
    "function_name": "klp_send_signals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "576-610",
    "snippet": "void klp_send_signals(void)\n{\n\tstruct task_struct *g, *task;\n\n\tpr_notice(\"signaling remaining tasks\\n\");\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tif (!klp_patch_pending(task))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * There is a small race here. We could see TIF_PATCH_PENDING\n\t\t * set and decide to wake up a kthread or send a fake signal.\n\t\t * Meanwhile the task could migrate itself and the action\n\t\t * would be meaningless. It is not serious though.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD) {\n\t\t\t/*\n\t\t\t * Wake up a kthread which sleeps interruptedly and\n\t\t\t * still has not been migrated.\n\t\t\t */\n\t\t\twake_up_state(task, TASK_INTERRUPTIBLE);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Send fake signal to all non-kthread tasks which are\n\t\t\t * still not migrated.\n\t\t\t */\n\t\t\tspin_lock_irq(&task->sighand->siglock);\n\t\t\tsignal_wake_up(task, 0);\n\t\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "task",
            "0"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "702-714",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_patch_pending",
          "args": [
            "task"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "task"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"signaling remaining tasks\\n\""
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nvoid klp_send_signals(void)\n{\n\tstruct task_struct *g, *task;\n\n\tpr_notice(\"signaling remaining tasks\\n\");\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tif (!klp_patch_pending(task))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * There is a small race here. We could see TIF_PATCH_PENDING\n\t\t * set and decide to wake up a kthread or send a fake signal.\n\t\t * Meanwhile the task could migrate itself and the action\n\t\t * would be meaningless. It is not serious though.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD) {\n\t\t\t/*\n\t\t\t * Wake up a kthread which sleeps interruptedly and\n\t\t\t * still has not been migrated.\n\t\t\t */\n\t\t\twake_up_state(task, TASK_INTERRUPTIBLE);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Send fake signal to all non-kthread tasks which are\n\t\t\t * still not migrated.\n\t\t\t */\n\t\t\tspin_lock_irq(&task->sighand->siglock);\n\t\t\tsignal_wake_up(task, 0);\n\t\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n}"
  },
  {
    "function_name": "klp_copy_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "564-569",
    "snippet": "void klp_copy_process(struct task_struct *child)\n{\n\tchild->patch_state = current->patch_state;\n\n\t/* TIF_PATCH_PENDING gets copied in setup_thread_stack() */\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nvoid klp_copy_process(struct task_struct *child)\n{\n\tchild->patch_state = current->patch_state;\n\n\t/* TIF_PATCH_PENDING gets copied in setup_thread_stack() */\n}"
  },
  {
    "function_name": "klp_reverse_transition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "530-561",
    "snippet": "void klp_reverse_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\n\tpr_debug(\"'%s': reversing transition from %s\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching to unpatching\" :\n\t\t\t\t\t\t   \"unpatching to patching\");\n\n\tklp_transition_patch->enabled = !klp_transition_patch->enabled;\n\n\tklp_target_state = !klp_target_state;\n\n\t/*\n\t * Clear all TIF_PATCH_PENDING flags to prevent races caused by\n\t * klp_update_patch_state() running in parallel with\n\t * klp_start_transition().\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu)\n\t\tclear_tsk_thread_flag(idle_task(cpu), TIF_PATCH_PENDING);\n\n\t/* Let any remaining calls to klp_update_patch_state() complete */\n\tklp_synchronize_transition();\n\n\tklp_start_transition();\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;",
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_start_transition",
          "args": [],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "klp_start_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "417-449",
          "snippet": "void klp_start_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\tpr_notice(\"'%s': starting %s transition\\n\",\n\t\t  klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Mark all normal tasks as needing a patch state update.  They'll\n\t * switch either in klp_try_complete_transition() or as they exit the\n\t * kernel.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Mark all idle tasks as needing a patch state update.  They'll switch\n\t * either in klp_try_complete_transition() or at the idle loop switch\n\t * point.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t}\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;",
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_start_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\tpr_notice(\"'%s': starting %s transition\\n\",\n\t\t  klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Mark all normal tasks as needing a patch state update.  They'll\n\t * switch either in klp_try_complete_transition() or as they exit the\n\t * kernel.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Mark all idle tasks as needing a patch state update.  They'll switch\n\t * either in klp_try_complete_transition() or at the idle loop switch\n\t * point.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_synchronize_transition",
          "args": [],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "klp_synchronize_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "70-73",
          "snippet": "static void klp_synchronize_transition(void)\n{\n\tschedule_on_each_cpu(klp_sync);\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic void klp_synchronize_transition(void)\n{\n\tschedule_on_each_cpu(klp_sync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "task"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"'%s': reversing transition from %s\\n\"",
            "klp_transition_patch->mod->name",
            "klp_target_state == KLP_PATCHED ? \"patching to unpatching\" :\n\t\t\t\t\t\t   \"unpatching to patching\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_reverse_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\n\tpr_debug(\"'%s': reversing transition from %s\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching to unpatching\" :\n\t\t\t\t\t\t   \"unpatching to patching\");\n\n\tklp_transition_patch->enabled = !klp_transition_patch->enabled;\n\n\tklp_target_state = !klp_target_state;\n\n\t/*\n\t * Clear all TIF_PATCH_PENDING flags to prevent races caused by\n\t * klp_update_patch_state() running in parallel with\n\t * klp_start_transition().\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu)\n\t\tclear_tsk_thread_flag(idle_task(cpu), TIF_PATCH_PENDING);\n\n\t/* Let any remaining calls to klp_update_patch_state() complete */\n\tklp_synchronize_transition();\n\n\tklp_start_transition();\n}"
  },
  {
    "function_name": "klp_init_transition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "456-522",
    "snippet": "void klp_init_transition(struct klp_patch *patch, int state)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint initial_state = !state;\n\n\tWARN_ON_ONCE(klp_target_state != KLP_UNDEFINED);\n\n\tklp_transition_patch = patch;\n\n\t/*\n\t * Set the global target patch state which tasks will switch to.  This\n\t * has no effect until the TIF_PATCH_PENDING flags get set later.\n\t */\n\tklp_target_state = state;\n\n\tpr_debug(\"'%s': initializing %s transition\\n\", patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Initialize all tasks to the initial patch state to prepare them for\n\t * switching to the target state.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\n\t/*\n\t * Enforce the order of the task->patch_state initializations and the\n\t * func->transition updates to ensure that klp_ftrace_handler() doesn't\n\t * see a func in transition with a task->patch_state of KLP_UNDEFINED.\n\t *\n\t * Also enforce the order of the klp_target_state write and future\n\t * TIF_PATCH_PENDING writes to ensure klp_update_patch_state() doesn't\n\t * set a task->patch_state to KLP_UNDEFINED.\n\t */\n\tsmp_wmb();\n\n\t/*\n\t * Set the func transition states so klp_ftrace_handler() will know to\n\t * switch to the transition logic.\n\t *\n\t * When patching, the funcs aren't yet in the func_stack and will be\n\t * made visible to the ftrace handler shortly by the calls to\n\t * klp_patch_object().\n\t *\n\t * When unpatching, the funcs are already in the func_stack and so are\n\t * already visible to the ftrace handler.\n\t */\n\tklp_for_each_object(patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = true;\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;",
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_for_each_func",
          "args": [
            "obj",
            "func"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "patch",
            "obj"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "task->patch_state != KLP_UNDEFINED"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_task",
          "args": [
            "cpu"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "idle_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4029-4032",
          "snippet": "struct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "task->patch_state != KLP_UNDEFINED"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "task"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"'%s': initializing %s transition\\n\"",
            "patch->mod->name",
            "klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "klp_target_state != KLP_UNDEFINED"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_init_transition(struct klp_patch *patch, int state)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint initial_state = !state;\n\n\tWARN_ON_ONCE(klp_target_state != KLP_UNDEFINED);\n\n\tklp_transition_patch = patch;\n\n\t/*\n\t * Set the global target patch state which tasks will switch to.  This\n\t * has no effect until the TIF_PATCH_PENDING flags get set later.\n\t */\n\tklp_target_state = state;\n\n\tpr_debug(\"'%s': initializing %s transition\\n\", patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Initialize all tasks to the initial patch state to prepare them for\n\t * switching to the target state.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\n\t/*\n\t * Enforce the order of the task->patch_state initializations and the\n\t * func->transition updates to ensure that klp_ftrace_handler() doesn't\n\t * see a func in transition with a task->patch_state of KLP_UNDEFINED.\n\t *\n\t * Also enforce the order of the klp_target_state write and future\n\t * TIF_PATCH_PENDING writes to ensure klp_update_patch_state() doesn't\n\t * set a task->patch_state to KLP_UNDEFINED.\n\t */\n\tsmp_wmb();\n\n\t/*\n\t * Set the func transition states so klp_ftrace_handler() will know to\n\t * switch to the transition logic.\n\t *\n\t * When patching, the funcs aren't yet in the func_stack and will be\n\t * made visible to the ftrace handler shortly by the calls to\n\t * klp_patch_object().\n\t *\n\t * When unpatching, the funcs are already in the func_stack and so are\n\t * already visible to the ftrace handler.\n\t */\n\tklp_for_each_object(patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = true;\n}"
  },
  {
    "function_name": "klp_start_transition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "417-449",
    "snippet": "void klp_start_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\tpr_notice(\"'%s': starting %s transition\\n\",\n\t\t  klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Mark all normal tasks as needing a patch state update.  They'll\n\t * switch either in klp_try_complete_transition() or as they exit the\n\t * kernel.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Mark all idle tasks as needing a patch state update.  They'll switch\n\t * either in klp_try_complete_transition() or at the idle loop switch\n\t * point.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t}\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;",
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_task",
          "args": [
            "cpu"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "idle_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4029-4032",
          "snippet": "struct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "task"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"'%s': starting %s transition\\n\"",
            "klp_transition_patch->mod->name",
            "klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\""
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "klp_target_state == KLP_UNDEFINED"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_start_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\tpr_notice(\"'%s': starting %s transition\\n\",\n\t\t  klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Mark all normal tasks as needing a patch state update.  They'll\n\t * switch either in klp_try_complete_transition() or as they exit the\n\t * kernel.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Mark all idle tasks as needing a patch state update.  They'll switch\n\t * either in klp_try_complete_transition() or at the idle loop switch\n\t * point.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t}\n}"
  },
  {
    "function_name": "klp_try_complete_transition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "358-411",
    "snippet": "void klp_try_complete_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\tbool complete = true;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\t/*\n\t * Try to switch the tasks to the target patch state by walking their\n\t * stacks and looking for any to-be-patched or to-be-unpatched\n\t * functions.  If such functions are found on a stack, or if the stack\n\t * is deemed unreliable, the task can't be switched yet.\n\t *\n\t * Usually this will transition most (or all) of the tasks on a system\n\t * unless the patch includes changes to a very common function.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (!klp_try_switch_task(task))\n\t\t\tcomplete = false;\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tget_online_cpus();\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (cpu_online(cpu)) {\n\t\t\tif (!klp_try_switch_task(task))\n\t\t\t\tcomplete = false;\n\t\t} else if (task->patch_state != klp_target_state) {\n\t\t\t/* offline idle tasks can be switched immediately */\n\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t\t\ttask->patch_state = klp_target_state;\n\t\t}\n\t}\n\tput_online_cpus();\n\n\tif (!complete) {\n\t\t/*\n\t\t * Some tasks weren't able to be switched over.  Try again\n\t\t * later and/or wait for other methods like kernel exit\n\t\t * switching.\n\t\t */\n\t\tschedule_delayed_work(&klp_transition_work,\n\t\t\t\t      round_jiffies_relative(HZ));\n\t\treturn;\n\t}\n\n\t/* we're done, now cleanup the data structures */\n\tklp_complete_transition();\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_complete_transition",
          "args": [],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "klp_complete_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "79-148",
          "snippet": "static void klp_complete_transition(void)\n{\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_debug(\"'%s': completing %s transition\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t/*\n\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now\n\t\t * remove the new functions from the func_stack.\n\t\t */\n\t\tklp_unpatch_objects(klp_transition_patch);\n\n\t\t/*\n\t\t * Make sure klp_ftrace_handler() can no longer see functions\n\t\t * from this patch on the ops->func_stack.  Otherwise, after\n\t\t * func->transition gets cleared, the handler may choose a\n\t\t * removed function.\n\t\t */\n\t\tklp_synchronize_transition();\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = false;\n\n\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */\n\tif (klp_target_state == KLP_PATCHED)\n\t\tklp_synchronize_transition();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\t\tif (klp_target_state == KLP_PATCHED)\n\t\t\tklp_post_patch_callback(obj);\n\t\telse if (klp_target_state == KLP_UNPATCHED)\n\t\t\tklp_post_unpatch_callback(obj);\n\t}\n\n\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * klp_forced set implies unbounded increase of module's ref count if\n\t * the module is disabled/enabled in a loop.\n\t */\n\tif (!klp_forced && klp_target_state == KLP_UNPATCHED)\n\t\tmodule_put(klp_transition_patch->mod);\n\n\tklp_target_state = KLP_UNDEFINED;\n\tklp_transition_patch = NULL;\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;",
            "static int klp_target_state = KLP_UNDEFINED;",
            "static bool klp_forced = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\nstatic bool klp_forced = false;\n\nstatic void klp_complete_transition(void)\n{\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_debug(\"'%s': completing %s transition\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t/*\n\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now\n\t\t * remove the new functions from the func_stack.\n\t\t */\n\t\tklp_unpatch_objects(klp_transition_patch);\n\n\t\t/*\n\t\t * Make sure klp_ftrace_handler() can no longer see functions\n\t\t * from this patch on the ops->func_stack.  Otherwise, after\n\t\t * func->transition gets cleared, the handler may choose a\n\t\t * removed function.\n\t\t */\n\t\tklp_synchronize_transition();\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = false;\n\n\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */\n\tif (klp_target_state == KLP_PATCHED)\n\t\tklp_synchronize_transition();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\t\tif (klp_target_state == KLP_PATCHED)\n\t\t\tklp_post_patch_callback(obj);\n\t\telse if (klp_target_state == KLP_UNPATCHED)\n\t\t\tklp_post_unpatch_callback(obj);\n\t}\n\n\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * klp_forced set implies unbounded increase of module's ref count if\n\t * the module is disabled/enabled in a loop.\n\t */\n\tif (!klp_forced && klp_target_state == KLP_UNPATCHED)\n\t\tmodule_put(klp_transition_patch->mod);\n\n\tklp_target_state = KLP_UNDEFINED;\n\tklp_transition_patch = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&klp_transition_work",
            "round_jiffies_relative(HZ)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_jiffies_relative",
          "args": [
            "HZ"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "round_jiffies_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "401-404",
          "snippet": "unsigned long round_jiffies_relative(unsigned long j)\n{\n\treturn __round_jiffies_relative(j, raw_smp_processor_id());\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long round_jiffies_relative(unsigned long j)\n{\n\treturn __round_jiffies_relative(j, raw_smp_processor_id());\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_try_switch_task",
          "args": [
            "task"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "klp_try_switch_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "298-348",
          "snippet": "static bool klp_try_switch_task(struct task_struct *task)\n{\n\tstruct rq *rq;\n\tstruct rq_flags flags;\n\tint ret;\n\tbool success = false;\n\tchar err_buf[STACK_ERR_BUF_SIZE];\n\n\terr_buf[0] = '\\0';\n\n\t/* check if this task has already switched over */\n\tif (task->patch_state == klp_target_state)\n\t\treturn true;\n\n\t/*\n\t * Now try to check the stack for any to-be-patched or to-be-unpatched\n\t * functions.  If all goes well, switch the task to the target patch\n\t * state.\n\t */\n\trq = task_rq_lock(task, &flags);\n\n\tif (task_running(rq, task) && task != current) {\n\t\tsnprintf(err_buf, STACK_ERR_BUF_SIZE,\n\t\t\t \"%s: %s:%d is running\\n\", __func__, task->comm,\n\t\t\t task->pid);\n\t\tgoto done;\n\t}\n\n\tret = klp_check_stack(task, err_buf);\n\tif (ret)\n\t\tgoto done;\n\n\tsuccess = true;\n\n\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\ttask->patch_state = klp_target_state;\n\ndone:\n\ttask_rq_unlock(rq, task, &flags);\n\n\t/*\n\t * Due to console deadlock issues, pr_debug() can't be used while\n\t * holding the task rq lock.  Instead we have to use a temporary buffer\n\t * and print the debug message after releasing the lock.\n\t */\n\tif (err_buf[0] != '\\0')\n\t\tpr_debug(\"%s\", err_buf);\n\n\treturn success;\n\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define STACK_ERR_BUF_SIZE 128"
          ],
          "globals_used": [
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\n#define STACK_ERR_BUF_SIZE 128\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nstatic bool klp_try_switch_task(struct task_struct *task)\n{\n\tstruct rq *rq;\n\tstruct rq_flags flags;\n\tint ret;\n\tbool success = false;\n\tchar err_buf[STACK_ERR_BUF_SIZE];\n\n\terr_buf[0] = '\\0';\n\n\t/* check if this task has already switched over */\n\tif (task->patch_state == klp_target_state)\n\t\treturn true;\n\n\t/*\n\t * Now try to check the stack for any to-be-patched or to-be-unpatched\n\t * functions.  If all goes well, switch the task to the target patch\n\t * state.\n\t */\n\trq = task_rq_lock(task, &flags);\n\n\tif (task_running(rq, task) && task != current) {\n\t\tsnprintf(err_buf, STACK_ERR_BUF_SIZE,\n\t\t\t \"%s: %s:%d is running\\n\", __func__, task->comm,\n\t\t\t task->pid);\n\t\tgoto done;\n\t}\n\n\tret = klp_check_stack(task, err_buf);\n\tif (ret)\n\t\tgoto done;\n\n\tsuccess = true;\n\n\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\ttask->patch_state = klp_target_state;\n\ndone:\n\ttask_rq_unlock(rq, task, &flags);\n\n\t/*\n\t * Due to console deadlock issues, pr_debug() can't be used while\n\t * holding the task rq lock.  Instead we have to use a temporary buffer\n\t * and print the debug message after releasing the lock.\n\t */\n\tif (err_buf[0] != '\\0')\n\t\tpr_debug(\"%s\", err_buf);\n\n\treturn success;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idle_task",
          "args": [
            "cpu"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "idle_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4029-4032",
          "snippet": "struct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "task"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "klp_target_state == KLP_UNDEFINED"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_try_complete_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\tbool complete = true;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\t/*\n\t * Try to switch the tasks to the target patch state by walking their\n\t * stacks and looking for any to-be-patched or to-be-unpatched\n\t * functions.  If such functions are found on a stack, or if the stack\n\t * is deemed unreliable, the task can't be switched yet.\n\t *\n\t * Usually this will transition most (or all) of the tasks on a system\n\t * unless the patch includes changes to a very common function.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (!klp_try_switch_task(task))\n\t\t\tcomplete = false;\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tget_online_cpus();\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (cpu_online(cpu)) {\n\t\t\tif (!klp_try_switch_task(task))\n\t\t\t\tcomplete = false;\n\t\t} else if (task->patch_state != klp_target_state) {\n\t\t\t/* offline idle tasks can be switched immediately */\n\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t\t\ttask->patch_state = klp_target_state;\n\t\t}\n\t}\n\tput_online_cpus();\n\n\tif (!complete) {\n\t\t/*\n\t\t * Some tasks weren't able to be switched over.  Try again\n\t\t * later and/or wait for other methods like kernel exit\n\t\t * switching.\n\t\t */\n\t\tschedule_delayed_work(&klp_transition_work,\n\t\t\t\t      round_jiffies_relative(HZ));\n\t\treturn;\n\t}\n\n\t/* we're done, now cleanup the data structures */\n\tklp_complete_transition();\n}"
  },
  {
    "function_name": "klp_try_switch_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "298-348",
    "snippet": "static bool klp_try_switch_task(struct task_struct *task)\n{\n\tstruct rq *rq;\n\tstruct rq_flags flags;\n\tint ret;\n\tbool success = false;\n\tchar err_buf[STACK_ERR_BUF_SIZE];\n\n\terr_buf[0] = '\\0';\n\n\t/* check if this task has already switched over */\n\tif (task->patch_state == klp_target_state)\n\t\treturn true;\n\n\t/*\n\t * Now try to check the stack for any to-be-patched or to-be-unpatched\n\t * functions.  If all goes well, switch the task to the target patch\n\t * state.\n\t */\n\trq = task_rq_lock(task, &flags);\n\n\tif (task_running(rq, task) && task != current) {\n\t\tsnprintf(err_buf, STACK_ERR_BUF_SIZE,\n\t\t\t \"%s: %s:%d is running\\n\", __func__, task->comm,\n\t\t\t task->pid);\n\t\tgoto done;\n\t}\n\n\tret = klp_check_stack(task, err_buf);\n\tif (ret)\n\t\tgoto done;\n\n\tsuccess = true;\n\n\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\ttask->patch_state = klp_target_state;\n\ndone:\n\ttask_rq_unlock(rq, task, &flags);\n\n\t/*\n\t * Due to console deadlock issues, pr_debug() can't be used while\n\t * holding the task rq lock.  Instead we have to use a temporary buffer\n\t * and print the debug message after releasing the lock.\n\t */\n\tif (err_buf[0] != '\\0')\n\t\tpr_debug(\"%s\", err_buf);\n\n\treturn success;\n\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define STACK_ERR_BUF_SIZE 128"
    ],
    "globals_used": [
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s\"",
            "err_buf"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "task",
            "&flags"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_check_stack",
          "args": [
            "task",
            "err_buf"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "klp_check_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "254-291",
          "snippet": "static int klp_check_stack(struct task_struct *task, char *err_buf)\n{\n\tstatic unsigned long entries[MAX_STACK_ENTRIES];\n\tstruct stack_trace trace;\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint ret;\n\n\ttrace.skip = 0;\n\ttrace.nr_entries = 0;\n\ttrace.max_entries = MAX_STACK_ENTRIES;\n\ttrace.entries = entries;\n\tret = save_stack_trace_tsk_reliable(task, &trace);\n\tWARN_ON_ONCE(ret == -ENOSYS);\n\tif (ret) {\n\t\tsnprintf(err_buf, STACK_ERR_BUF_SIZE,\n\t\t\t \"%s: %s:%d has an unreliable stack\\n\",\n\t\t\t __func__, task->comm, task->pid);\n\t\treturn ret;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!obj->patched)\n\t\t\tcontinue;\n\t\tklp_for_each_func(obj, func) {\n\t\t\tret = klp_check_stack_func(func, &trace);\n\t\t\tif (ret) {\n\t\t\t\tsnprintf(err_buf, STACK_ERR_BUF_SIZE,\n\t\t\t\t\t \"%s: %s:%d is sleeping on function %s\\n\",\n\t\t\t\t\t __func__, task->comm, task->pid,\n\t\t\t\t\t func->old_name);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define STACK_ERR_BUF_SIZE 128",
            "#define MAX_STACK_ENTRIES  100"
          ],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\n#define STACK_ERR_BUF_SIZE 128\n#define MAX_STACK_ENTRIES  100\n\nstruct klp_patch *klp_transition_patch;\n\nstatic int klp_check_stack(struct task_struct *task, char *err_buf)\n{\n\tstatic unsigned long entries[MAX_STACK_ENTRIES];\n\tstruct stack_trace trace;\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint ret;\n\n\ttrace.skip = 0;\n\ttrace.nr_entries = 0;\n\ttrace.max_entries = MAX_STACK_ENTRIES;\n\ttrace.entries = entries;\n\tret = save_stack_trace_tsk_reliable(task, &trace);\n\tWARN_ON_ONCE(ret == -ENOSYS);\n\tif (ret) {\n\t\tsnprintf(err_buf, STACK_ERR_BUF_SIZE,\n\t\t\t \"%s: %s:%d has an unreliable stack\\n\",\n\t\t\t __func__, task->comm, task->pid);\n\t\treturn ret;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!obj->patched)\n\t\t\tcontinue;\n\t\tklp_for_each_func(obj, func) {\n\t\t\tret = klp_check_stack_func(func, &trace);\n\t\t\tif (ret) {\n\t\t\t\tsnprintf(err_buf, STACK_ERR_BUF_SIZE,\n\t\t\t\t\t \"%s: %s:%d is sleeping on function %s\\n\",\n\t\t\t\t\t __func__, task->comm, task->pid,\n\t\t\t\t\t func->old_name);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "err_buf",
            "STACK_ERR_BUF_SIZE",
            "\"%s: %s:%d is running\\n\"",
            "__func__",
            "task->comm",
            "task->pid"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_running",
          "args": [
            "rq",
            "task"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "task_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1526-1533",
          "snippet": "static inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "task",
            "&flags"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\n#define STACK_ERR_BUF_SIZE 128\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nstatic bool klp_try_switch_task(struct task_struct *task)\n{\n\tstruct rq *rq;\n\tstruct rq_flags flags;\n\tint ret;\n\tbool success = false;\n\tchar err_buf[STACK_ERR_BUF_SIZE];\n\n\terr_buf[0] = '\\0';\n\n\t/* check if this task has already switched over */\n\tif (task->patch_state == klp_target_state)\n\t\treturn true;\n\n\t/*\n\t * Now try to check the stack for any to-be-patched or to-be-unpatched\n\t * functions.  If all goes well, switch the task to the target patch\n\t * state.\n\t */\n\trq = task_rq_lock(task, &flags);\n\n\tif (task_running(rq, task) && task != current) {\n\t\tsnprintf(err_buf, STACK_ERR_BUF_SIZE,\n\t\t\t \"%s: %s:%d is running\\n\", __func__, task->comm,\n\t\t\t task->pid);\n\t\tgoto done;\n\t}\n\n\tret = klp_check_stack(task, err_buf);\n\tif (ret)\n\t\tgoto done;\n\n\tsuccess = true;\n\n\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\ttask->patch_state = klp_target_state;\n\ndone:\n\ttask_rq_unlock(rq, task, &flags);\n\n\t/*\n\t * Due to console deadlock issues, pr_debug() can't be used while\n\t * holding the task rq lock.  Instead we have to use a temporary buffer\n\t * and print the debug message after releasing the lock.\n\t */\n\tif (err_buf[0] != '\\0')\n\t\tpr_debug(\"%s\", err_buf);\n\n\treturn success;\n\n}"
  },
  {
    "function_name": "klp_check_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "254-291",
    "snippet": "static int klp_check_stack(struct task_struct *task, char *err_buf)\n{\n\tstatic unsigned long entries[MAX_STACK_ENTRIES];\n\tstruct stack_trace trace;\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint ret;\n\n\ttrace.skip = 0;\n\ttrace.nr_entries = 0;\n\ttrace.max_entries = MAX_STACK_ENTRIES;\n\ttrace.entries = entries;\n\tret = save_stack_trace_tsk_reliable(task, &trace);\n\tWARN_ON_ONCE(ret == -ENOSYS);\n\tif (ret) {\n\t\tsnprintf(err_buf, STACK_ERR_BUF_SIZE,\n\t\t\t \"%s: %s:%d has an unreliable stack\\n\",\n\t\t\t __func__, task->comm, task->pid);\n\t\treturn ret;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!obj->patched)\n\t\t\tcontinue;\n\t\tklp_for_each_func(obj, func) {\n\t\t\tret = klp_check_stack_func(func, &trace);\n\t\t\tif (ret) {\n\t\t\t\tsnprintf(err_buf, STACK_ERR_BUF_SIZE,\n\t\t\t\t\t \"%s: %s:%d is sleeping on function %s\\n\",\n\t\t\t\t\t __func__, task->comm, task->pid,\n\t\t\t\t\t func->old_name);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define STACK_ERR_BUF_SIZE 128",
      "#define MAX_STACK_ENTRIES  100"
    ],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "err_buf",
            "STACK_ERR_BUF_SIZE",
            "\"%s: %s:%d is sleeping on function %s\\n\"",
            "__func__",
            "task->comm",
            "task->pid",
            "func->old_name"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_check_stack_func",
          "args": [
            "func",
            "&trace"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "klp_check_stack_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "205-248",
          "snippet": "static int klp_check_stack_func(struct klp_func *func,\n\t\t\t\tstruct stack_trace *trace)\n{\n\tunsigned long func_addr, func_size, address;\n\tstruct klp_ops *ops;\n\tint i;\n\n\tfor (i = 0; i < trace->nr_entries; i++) {\n\t\taddress = trace->entries[i];\n\n\t\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t\t /*\n\t\t\t  * Check for the to-be-unpatched function\n\t\t\t  * (the func itself).\n\t\t\t  */\n\t\t\tfunc_addr = (unsigned long)func->new_func;\n\t\t\tfunc_size = func->new_size;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Check for the to-be-patched function\n\t\t\t * (the previous func).\n\t\t\t */\n\t\t\tops = klp_find_ops(func->old_addr);\n\n\t\t\tif (list_is_singular(&ops->func_stack)) {\n\t\t\t\t/* original function */\n\t\t\t\tfunc_addr = func->old_addr;\n\t\t\t\tfunc_size = func->old_size;\n\t\t\t} else {\n\t\t\t\t/* previously patched function */\n\t\t\t\tstruct klp_func *prev;\n\n\t\t\t\tprev = list_next_entry(func, stack_node);\n\t\t\t\tfunc_addr = (unsigned long)prev->new_func;\n\t\t\t\tfunc_size = prev->new_size;\n\t\t\t}\n\t\t}\n\n\t\tif (address >= func_addr && address < func_addr + func_size)\n\t\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nstatic int klp_check_stack_func(struct klp_func *func,\n\t\t\t\tstruct stack_trace *trace)\n{\n\tunsigned long func_addr, func_size, address;\n\tstruct klp_ops *ops;\n\tint i;\n\n\tfor (i = 0; i < trace->nr_entries; i++) {\n\t\taddress = trace->entries[i];\n\n\t\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t\t /*\n\t\t\t  * Check for the to-be-unpatched function\n\t\t\t  * (the func itself).\n\t\t\t  */\n\t\t\tfunc_addr = (unsigned long)func->new_func;\n\t\t\tfunc_size = func->new_size;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Check for the to-be-patched function\n\t\t\t * (the previous func).\n\t\t\t */\n\t\t\tops = klp_find_ops(func->old_addr);\n\n\t\t\tif (list_is_singular(&ops->func_stack)) {\n\t\t\t\t/* original function */\n\t\t\t\tfunc_addr = func->old_addr;\n\t\t\t\tfunc_size = func->old_size;\n\t\t\t} else {\n\t\t\t\t/* previously patched function */\n\t\t\t\tstruct klp_func *prev;\n\n\t\t\t\tprev = list_next_entry(func, stack_node);\n\t\t\t\tfunc_addr = (unsigned long)prev->new_func;\n\t\t\t\tfunc_size = prev->new_size;\n\t\t\t}\n\t\t}\n\n\t\tif (address >= func_addr && address < func_addr + func_size)\n\t\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_func",
          "args": [
            "obj",
            "func"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "klp_transition_patch",
            "obj"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "err_buf",
            "STACK_ERR_BUF_SIZE",
            "\"%s: %s:%d has an unreliable stack\\n\"",
            "__func__",
            "task->comm",
            "task->pid"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret == -ENOSYS"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_stack_trace_tsk_reliable",
          "args": [
            "task",
            "&trace"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "save_stack_trace_tsk_reliable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stacktrace.c",
          "lines": "73-79",
          "snippet": "__weak int\nsave_stack_trace_tsk_reliable(struct task_struct *tsk,\n\t\t\t      struct stack_trace *trace)\n{\n\tWARN_ONCE(1, KERN_INFO \"save_stack_tsk_reliable() not implemented yet.\\n\");\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n\n__weak int\nsave_stack_trace_tsk_reliable(struct task_struct *tsk,\n\t\t\t      struct stack_trace *trace)\n{\n\tWARN_ONCE(1, KERN_INFO \"save_stack_tsk_reliable() not implemented yet.\\n\");\n\treturn -ENOSYS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\n#define STACK_ERR_BUF_SIZE 128\n#define MAX_STACK_ENTRIES  100\n\nstruct klp_patch *klp_transition_patch;\n\nstatic int klp_check_stack(struct task_struct *task, char *err_buf)\n{\n\tstatic unsigned long entries[MAX_STACK_ENTRIES];\n\tstruct stack_trace trace;\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint ret;\n\n\ttrace.skip = 0;\n\ttrace.nr_entries = 0;\n\ttrace.max_entries = MAX_STACK_ENTRIES;\n\ttrace.entries = entries;\n\tret = save_stack_trace_tsk_reliable(task, &trace);\n\tWARN_ON_ONCE(ret == -ENOSYS);\n\tif (ret) {\n\t\tsnprintf(err_buf, STACK_ERR_BUF_SIZE,\n\t\t\t \"%s: %s:%d has an unreliable stack\\n\",\n\t\t\t __func__, task->comm, task->pid);\n\t\treturn ret;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!obj->patched)\n\t\t\tcontinue;\n\t\tklp_for_each_func(obj, func) {\n\t\t\tret = klp_check_stack_func(func, &trace);\n\t\t\tif (ret) {\n\t\t\t\tsnprintf(err_buf, STACK_ERR_BUF_SIZE,\n\t\t\t\t\t \"%s: %s:%d is sleeping on function %s\\n\",\n\t\t\t\t\t __func__, task->comm, task->pid,\n\t\t\t\t\t func->old_name);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "klp_check_stack_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "205-248",
    "snippet": "static int klp_check_stack_func(struct klp_func *func,\n\t\t\t\tstruct stack_trace *trace)\n{\n\tunsigned long func_addr, func_size, address;\n\tstruct klp_ops *ops;\n\tint i;\n\n\tfor (i = 0; i < trace->nr_entries; i++) {\n\t\taddress = trace->entries[i];\n\n\t\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t\t /*\n\t\t\t  * Check for the to-be-unpatched function\n\t\t\t  * (the func itself).\n\t\t\t  */\n\t\t\tfunc_addr = (unsigned long)func->new_func;\n\t\t\tfunc_size = func->new_size;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Check for the to-be-patched function\n\t\t\t * (the previous func).\n\t\t\t */\n\t\t\tops = klp_find_ops(func->old_addr);\n\n\t\t\tif (list_is_singular(&ops->func_stack)) {\n\t\t\t\t/* original function */\n\t\t\t\tfunc_addr = func->old_addr;\n\t\t\t\tfunc_size = func->old_size;\n\t\t\t} else {\n\t\t\t\t/* previously patched function */\n\t\t\t\tstruct klp_func *prev;\n\n\t\t\t\tprev = list_next_entry(func, stack_node);\n\t\t\t\tfunc_addr = (unsigned long)prev->new_func;\n\t\t\t\tfunc_size = prev->new_size;\n\t\t\t}\n\t\t}\n\n\t\tif (address >= func_addr && address < func_addr + func_size)\n\t\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "func",
            "stack_node"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&ops->func_stack"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_find_ops",
          "args": [
            "func->old_addr"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "klp_find_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
          "lines": "37-50",
          "snippet": "struct klp_ops *klp_find_ops(unsigned long old_addr)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_addr == old_addr)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstruct klp_ops *klp_find_ops(unsigned long old_addr)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_addr == old_addr)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nstatic int klp_check_stack_func(struct klp_func *func,\n\t\t\t\tstruct stack_trace *trace)\n{\n\tunsigned long func_addr, func_size, address;\n\tstruct klp_ops *ops;\n\tint i;\n\n\tfor (i = 0; i < trace->nr_entries; i++) {\n\t\taddress = trace->entries[i];\n\n\t\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t\t /*\n\t\t\t  * Check for the to-be-unpatched function\n\t\t\t  * (the func itself).\n\t\t\t  */\n\t\t\tfunc_addr = (unsigned long)func->new_func;\n\t\t\tfunc_size = func->new_size;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Check for the to-be-patched function\n\t\t\t * (the previous func).\n\t\t\t */\n\t\t\tops = klp_find_ops(func->old_addr);\n\n\t\t\tif (list_is_singular(&ops->func_stack)) {\n\t\t\t\t/* original function */\n\t\t\t\tfunc_addr = func->old_addr;\n\t\t\t\tfunc_size = func->old_size;\n\t\t\t} else {\n\t\t\t\t/* previously patched function */\n\t\t\t\tstruct klp_func *prev;\n\n\t\t\t\tprev = list_next_entry(func, stack_node);\n\t\t\t\tfunc_addr = (unsigned long)prev->new_func;\n\t\t\t\tfunc_size = prev->new_size;\n\t\t\t}\n\t\t}\n\n\t\tif (address >= func_addr && address < func_addr + func_size)\n\t\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "klp_update_patch_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "175-199",
    "snippet": "void klp_update_patch_state(struct task_struct *task)\n{\n\t/*\n\t * A variant of synchronize_sched() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\t/*\n\t * This test_and_clear_tsk_thread_flag() call also serves as a read\n\t * barrier (smp_rmb) for two cases:\n\t *\n\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the\n\t *    klp_target_state read.  The corresponding write barrier is in\n\t *    klp_init_transition().\n\t *\n\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read\n\t *    of func->transition, if klp_ftrace_handler() is called later on\n\t *    the same CPU.  See __klp_disable_patch().\n\t */\n\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))\n\t\ttask->patch_state = READ_ONCE(klp_target_state);\n\n\tpreempt_enable_notrace();\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "klp_target_state"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_update_patch_state(struct task_struct *task)\n{\n\t/*\n\t * A variant of synchronize_sched() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\t/*\n\t * This test_and_clear_tsk_thread_flag() call also serves as a read\n\t * barrier (smp_rmb) for two cases:\n\t *\n\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the\n\t *    klp_target_state read.  The corresponding write barrier is in\n\t *    klp_init_transition().\n\t *\n\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read\n\t *    of func->transition, if klp_ftrace_handler() is called later on\n\t *    the same CPU.  See __klp_disable_patch().\n\t */\n\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))\n\t\ttask->patch_state = READ_ONCE(klp_target_state);\n\n\tpreempt_enable_notrace();\n}"
  },
  {
    "function_name": "klp_cancel_transition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "156-166",
    "snippet": "void klp_cancel_transition(void)\n{\n\tif (WARN_ON_ONCE(klp_target_state != KLP_PATCHED))\n\t\treturn;\n\n\tpr_debug(\"'%s': canceling patching transition, going to unpatch\\n\",\n\t\t klp_transition_patch->mod->name);\n\n\tklp_target_state = KLP_UNPATCHED;\n\tklp_complete_transition();\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;",
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_complete_transition",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "klp_complete_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "79-148",
          "snippet": "static void klp_complete_transition(void)\n{\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_debug(\"'%s': completing %s transition\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t/*\n\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now\n\t\t * remove the new functions from the func_stack.\n\t\t */\n\t\tklp_unpatch_objects(klp_transition_patch);\n\n\t\t/*\n\t\t * Make sure klp_ftrace_handler() can no longer see functions\n\t\t * from this patch on the ops->func_stack.  Otherwise, after\n\t\t * func->transition gets cleared, the handler may choose a\n\t\t * removed function.\n\t\t */\n\t\tklp_synchronize_transition();\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = false;\n\n\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */\n\tif (klp_target_state == KLP_PATCHED)\n\t\tklp_synchronize_transition();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\t\tif (klp_target_state == KLP_PATCHED)\n\t\t\tklp_post_patch_callback(obj);\n\t\telse if (klp_target_state == KLP_UNPATCHED)\n\t\t\tklp_post_unpatch_callback(obj);\n\t}\n\n\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * klp_forced set implies unbounded increase of module's ref count if\n\t * the module is disabled/enabled in a loop.\n\t */\n\tif (!klp_forced && klp_target_state == KLP_UNPATCHED)\n\t\tmodule_put(klp_transition_patch->mod);\n\n\tklp_target_state = KLP_UNDEFINED;\n\tklp_transition_patch = NULL;\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;",
            "static int klp_target_state = KLP_UNDEFINED;",
            "static bool klp_forced = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\nstatic bool klp_forced = false;\n\nstatic void klp_complete_transition(void)\n{\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_debug(\"'%s': completing %s transition\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t/*\n\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now\n\t\t * remove the new functions from the func_stack.\n\t\t */\n\t\tklp_unpatch_objects(klp_transition_patch);\n\n\t\t/*\n\t\t * Make sure klp_ftrace_handler() can no longer see functions\n\t\t * from this patch on the ops->func_stack.  Otherwise, after\n\t\t * func->transition gets cleared, the handler may choose a\n\t\t * removed function.\n\t\t */\n\t\tklp_synchronize_transition();\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = false;\n\n\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */\n\tif (klp_target_state == KLP_PATCHED)\n\t\tklp_synchronize_transition();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\t\tif (klp_target_state == KLP_PATCHED)\n\t\t\tklp_post_patch_callback(obj);\n\t\telse if (klp_target_state == KLP_UNPATCHED)\n\t\t\tklp_post_unpatch_callback(obj);\n\t}\n\n\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * klp_forced set implies unbounded increase of module's ref count if\n\t * the module is disabled/enabled in a loop.\n\t */\n\tif (!klp_forced && klp_target_state == KLP_UNPATCHED)\n\t\tmodule_put(klp_transition_patch->mod);\n\n\tklp_target_state = KLP_UNDEFINED;\n\tklp_transition_patch = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"'%s': canceling patching transition, going to unpatch\\n\"",
            "klp_transition_patch->mod->name"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "klp_target_state != KLP_PATCHED"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_cancel_transition(void)\n{\n\tif (WARN_ON_ONCE(klp_target_state != KLP_PATCHED))\n\t\treturn;\n\n\tpr_debug(\"'%s': canceling patching transition, going to unpatch\\n\",\n\t\t klp_transition_patch->mod->name);\n\n\tklp_target_state = KLP_UNPATCHED;\n\tklp_complete_transition();\n}"
  },
  {
    "function_name": "klp_complete_transition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "79-148",
    "snippet": "static void klp_complete_transition(void)\n{\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_debug(\"'%s': completing %s transition\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t/*\n\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now\n\t\t * remove the new functions from the func_stack.\n\t\t */\n\t\tklp_unpatch_objects(klp_transition_patch);\n\n\t\t/*\n\t\t * Make sure klp_ftrace_handler() can no longer see functions\n\t\t * from this patch on the ops->func_stack.  Otherwise, after\n\t\t * func->transition gets cleared, the handler may choose a\n\t\t * removed function.\n\t\t */\n\t\tklp_synchronize_transition();\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = false;\n\n\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */\n\tif (klp_target_state == KLP_PATCHED)\n\t\tklp_synchronize_transition();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\t\tif (klp_target_state == KLP_PATCHED)\n\t\t\tklp_post_patch_callback(obj);\n\t\telse if (klp_target_state == KLP_UNPATCHED)\n\t\t\tklp_post_unpatch_callback(obj);\n\t}\n\n\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * klp_forced set implies unbounded increase of module's ref count if\n\t * the module is disabled/enabled in a loop.\n\t */\n\tif (!klp_forced && klp_target_state == KLP_UNPATCHED)\n\t\tmodule_put(klp_transition_patch->mod);\n\n\tklp_target_state = KLP_UNDEFINED;\n\tklp_transition_patch = NULL;\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;",
      "static int klp_target_state = KLP_UNDEFINED;",
      "static bool klp_forced = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "klp_transition_patch->mod"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1132-1143",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"'%s': %s complete\\n\"",
            "klp_transition_patch->mod->name",
            "klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_post_unpatch_callback",
          "args": [
            "obj"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "klp_post_unpatch_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.h",
          "lines": "38-45",
          "snippet": "static inline void klp_post_unpatch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.post_unpatch_enabled &&\n\t    obj->callbacks.post_unpatch)\n\t\t(*obj->callbacks.post_unpatch)(obj);\n\n\tobj->callbacks.post_unpatch_enabled = false;\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline void klp_post_unpatch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.post_unpatch_enabled &&\n\t    obj->callbacks.post_unpatch)\n\t\t(*obj->callbacks.post_unpatch)(obj);\n\n\tobj->callbacks.post_unpatch_enabled = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_post_patch_callback",
          "args": [
            "obj"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "klp_post_patch_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.h",
          "lines": "26-30",
          "snippet": "static inline void klp_post_patch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.post_patch)\n\t\t(*obj->callbacks.post_patch)(obj);\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline void klp_post_patch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.post_patch)\n\t\t(*obj->callbacks.post_patch)(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_is_object_loaded",
          "args": [
            "obj"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_object_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.h",
          "lines": "9-12",
          "snippet": "static inline bool klp_is_object_loaded(struct klp_object *obj)\n{\n\treturn !obj->name || obj->mod;\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline bool klp_is_object_loaded(struct klp_object *obj)\n{\n\treturn !obj->name || obj->mod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "klp_transition_patch",
            "obj"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "test_tsk_thread_flag(task, TIF_PATCH_PENDING)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_task",
          "args": [
            "cpu"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "idle_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4029-4032",
          "snippet": "struct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "test_tsk_thread_flag(task, TIF_PATCH_PENDING)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "task"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_synchronize_transition",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "klp_synchronize_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "70-73",
          "snippet": "static void klp_synchronize_transition(void)\n{\n\tschedule_on_each_cpu(klp_sync);\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic void klp_synchronize_transition(void)\n{\n\tschedule_on_each_cpu(klp_sync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_func",
          "args": [
            "obj",
            "func"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "klp_transition_patch",
            "obj"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_unpatch_objects",
          "args": [
            "klp_transition_patch"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "klp_unpatch_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
          "lines": "270-277",
          "snippet": "void klp_unpatch_objects(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_unpatch_object(obj);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nvoid klp_unpatch_objects(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_unpatch_object(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"'%s': completing %s transition\\n\"",
            "klp_transition_patch->mod->name",
            "klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\nstatic bool klp_forced = false;\n\nstatic void klp_complete_transition(void)\n{\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_debug(\"'%s': completing %s transition\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t/*\n\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now\n\t\t * remove the new functions from the func_stack.\n\t\t */\n\t\tklp_unpatch_objects(klp_transition_patch);\n\n\t\t/*\n\t\t * Make sure klp_ftrace_handler() can no longer see functions\n\t\t * from this patch on the ops->func_stack.  Otherwise, after\n\t\t * func->transition gets cleared, the handler may choose a\n\t\t * removed function.\n\t\t */\n\t\tklp_synchronize_transition();\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = false;\n\n\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */\n\tif (klp_target_state == KLP_PATCHED)\n\t\tklp_synchronize_transition();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\t\tif (klp_target_state == KLP_PATCHED)\n\t\t\tklp_post_patch_callback(obj);\n\t\telse if (klp_target_state == KLP_UNPATCHED)\n\t\t\tklp_post_unpatch_callback(obj);\n\t}\n\n\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * klp_forced set implies unbounded increase of module's ref count if\n\t * the module is disabled/enabled in a loop.\n\t */\n\tif (!klp_forced && klp_target_state == KLP_UNPATCHED)\n\t\tmodule_put(klp_transition_patch->mod);\n\n\tklp_target_state = KLP_UNDEFINED;\n\tklp_transition_patch = NULL;\n}"
  },
  {
    "function_name": "klp_synchronize_transition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "70-73",
    "snippet": "static void klp_synchronize_transition(void)\n{\n\tschedule_on_each_cpu(klp_sync);\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_on_each_cpu",
          "args": [
            "klp_sync"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_on_each_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3151-3175",
          "snippet": "int schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tget_online_cpus();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tput_online_cpus();\n\tfree_percpu(works);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tget_online_cpus();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tput_online_cpus();\n\tfree_percpu(works);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic void klp_synchronize_transition(void)\n{\n\tschedule_on_each_cpu(klp_sync);\n}"
  },
  {
    "function_name": "klp_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "58-60",
    "snippet": "static void klp_sync(struct work_struct *work)\n{\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic void klp_sync(struct work_struct *work)\n{\n}"
  },
  {
    "function_name": "klp_transition_work_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
    "lines": "42-50",
    "snippet": "static void klp_transition_work_fn(struct work_struct *work)\n{\n\tmutex_lock(&klp_mutex);\n\n\tif (klp_transition_patch)\n\t\tklp_try_complete_transition();\n\n\tmutex_unlock(&klp_mutex);\n}",
    "includes": [
      "#include \"../sched/sched.h\"",
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;",
      "static DECLARE_DELAYED_WORK(klp_transition_work, klp_transition_work_fn);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&klp_mutex"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_try_complete_transition",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "klp_try_complete_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "358-411",
          "snippet": "void klp_try_complete_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\tbool complete = true;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\t/*\n\t * Try to switch the tasks to the target patch state by walking their\n\t * stacks and looking for any to-be-patched or to-be-unpatched\n\t * functions.  If such functions are found on a stack, or if the stack\n\t * is deemed unreliable, the task can't be switched yet.\n\t *\n\t * Usually this will transition most (or all) of the tasks on a system\n\t * unless the patch includes changes to a very common function.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (!klp_try_switch_task(task))\n\t\t\tcomplete = false;\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tget_online_cpus();\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (cpu_online(cpu)) {\n\t\t\tif (!klp_try_switch_task(task))\n\t\t\t\tcomplete = false;\n\t\t} else if (task->patch_state != klp_target_state) {\n\t\t\t/* offline idle tasks can be switched immediately */\n\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t\t\ttask->patch_state = klp_target_state;\n\t\t}\n\t}\n\tput_online_cpus();\n\n\tif (!complete) {\n\t\t/*\n\t\t * Some tasks weren't able to be switched over.  Try again\n\t\t * later and/or wait for other methods like kernel exit\n\t\t * switching.\n\t\t */\n\t\tschedule_delayed_work(&klp_transition_work,\n\t\t\t\t      round_jiffies_relative(HZ));\n\t\treturn;\n\t}\n\n\t/* we're done, now cleanup the data structures */\n\tklp_complete_transition();\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_try_complete_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\tbool complete = true;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\t/*\n\t * Try to switch the tasks to the target patch state by walking their\n\t * stacks and looking for any to-be-patched or to-be-unpatched\n\t * functions.  If such functions are found on a stack, or if the stack\n\t * is deemed unreliable, the task can't be switched yet.\n\t *\n\t * Usually this will transition most (or all) of the tasks on a system\n\t * unless the patch includes changes to a very common function.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (!klp_try_switch_task(task))\n\t\t\tcomplete = false;\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tget_online_cpus();\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (cpu_online(cpu)) {\n\t\t\tif (!klp_try_switch_task(task))\n\t\t\t\tcomplete = false;\n\t\t} else if (task->patch_state != klp_target_state) {\n\t\t\t/* offline idle tasks can be switched immediately */\n\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t\t\ttask->patch_state = klp_target_state;\n\t\t}\n\t}\n\tput_online_cpus();\n\n\tif (!complete) {\n\t\t/*\n\t\t * Some tasks weren't able to be switched over.  Try again\n\t\t * later and/or wait for other methods like kernel exit\n\t\t * switching.\n\t\t */\n\t\tschedule_delayed_work(&klp_transition_work,\n\t\t\t\t      round_jiffies_relative(HZ));\n\t\treturn;\n\t}\n\n\t/* we're done, now cleanup the data structures */\n\tklp_complete_transition();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&klp_mutex"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic DECLARE_DELAYED_WORK(klp_transition_work, klp_transition_work_fn);\n\nstatic void klp_transition_work_fn(struct work_struct *work)\n{\n\tmutex_lock(&klp_mutex);\n\n\tif (klp_transition_patch)\n\t\tklp_try_complete_transition();\n\n\tmutex_unlock(&klp_mutex);\n}"
  }
]