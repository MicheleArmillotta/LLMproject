[
  {
    "function_name": "create_proc_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "525-563",
    "snippet": "int __ref create_proc_profile(void)\n{\n\tstruct proc_dir_entry *entry;\n#ifdef CONFIG_SMP\n\tenum cpuhp_state online_state;\n#endif\n\n\tint err = 0;\n\n\tif (!prof_on)\n\t\treturn 0;\n#ifdef CONFIG_SMP\n\terr = cpuhp_setup_state(CPUHP_PROFILE_PREPARE, \"PROFILE_PREPARE\",\n\t\t\t\tprofile_prepare_cpu, profile_dead_cpu);\n\tif (err)\n\t\treturn err;\n\n\terr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"AP_PROFILE_ONLINE\",\n\t\t\t\tprofile_online_cpu, NULL);\n\tif (err < 0)\n\t\tgoto err_state_prep;\n\tonline_state = err;\n\terr = 0;\n#endif\n\tentry = proc_create(\"profile\", S_IWUSR | S_IRUGO,\n\t\t\t    NULL, &proc_profile_operations);\n\tif (!entry)\n\t\tgoto err_state_onl;\n\tproc_set_size(entry, (1 + prof_len) * sizeof(atomic_t));\n\n\treturn err;\nerr_state_onl:\n#ifdef CONFIG_SMP\n\tcpuhp_remove_state(online_state);\nerr_state_prep:\n\tcpuhp_remove_state(CPUHP_PROFILE_PREPARE);\n#endif\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_remove_state",
          "args": [
            "CPUHP_PROFILE_PREPARE"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_set_size",
          "args": [
            "entry",
            "(1 + prof_len) * sizeof(atomic_t)"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"profile\"",
            "S_IWUSR | S_IRUGO",
            "NULL",
            "&proc_profile_operations"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"AP_PROFILE_ONLINE\"",
            "profile_online_cpu",
            "NULL"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state",
          "args": [
            "CPUHP_PROFILE_PREPARE",
            "\"PROFILE_PREPARE\"",
            "profile_prepare_cpu",
            "profile_dead_cpu"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nint __ref create_proc_profile(void)\n{\n\tstruct proc_dir_entry *entry;\n#ifdef CONFIG_SMP\n\tenum cpuhp_state online_state;\n#endif\n\n\tint err = 0;\n\n\tif (!prof_on)\n\t\treturn 0;\n#ifdef CONFIG_SMP\n\terr = cpuhp_setup_state(CPUHP_PROFILE_PREPARE, \"PROFILE_PREPARE\",\n\t\t\t\tprofile_prepare_cpu, profile_dead_cpu);\n\tif (err)\n\t\treturn err;\n\n\terr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"AP_PROFILE_ONLINE\",\n\t\t\t\tprofile_online_cpu, NULL);\n\tif (err < 0)\n\t\tgoto err_state_prep;\n\tonline_state = err;\n\terr = 0;\n#endif\n\tentry = proc_create(\"profile\", S_IWUSR | S_IRUGO,\n\t\t\t    NULL, &proc_profile_operations);\n\tif (!entry)\n\t\tgoto err_state_onl;\n\tproc_set_size(entry, (1 + prof_len) * sizeof(atomic_t));\n\n\treturn err;\nerr_state_onl:\n#ifdef CONFIG_SMP\n\tcpuhp_remove_state(online_state);\nerr_state_prep:\n\tcpuhp_remove_state(CPUHP_PROFILE_PREPARE);\n#endif\n\treturn err;\n}"
  },
  {
    "function_name": "write_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "498-517",
    "snippet": "static ssize_t write_profile(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n#ifdef CONFIG_SMP\n\textern int setup_profiling_timer(unsigned int multiplier);\n\n\tif (count == sizeof(int)) {\n\t\tunsigned int multiplier;\n\n\t\tif (copy_from_user(&multiplier, buf, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tif (setup_profiling_timer(multiplier))\n\t\t\treturn -EINVAL;\n\t}\n#endif\n\tprofile_discard_flip_buffers();\n\tmemset(prof_buffer, 0, prof_len * sizeof(atomic_t));\n\treturn count;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t *prof_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "prof_buffer",
            "0",
            "prof_len * sizeof(atomic_t)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_discard_flip_buffers",
          "args": [],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "profile_discard_flip_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
          "lines": "269-282",
          "snippet": "static void profile_discard_flip_buffers(void)\n{\n\tint i, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\ti = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[i];\n\t\tmemset(hits, 0, NR_PROFILE_HIT*sizeof(struct profile_hit));\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/sections.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/mm.h>",
            "#include <linux/notifier.h>",
            "#include <linux/memblock.h>",
            "#include <linux/profile.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\n#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))\n\nstatic void profile_discard_flip_buffers(void)\n{\n\tint i, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\ti = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[i];\n\t\tmemset(hits, 0, NR_PROFILE_HIT*sizeof(struct profile_hit));\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_profiling_timer",
          "args": [
            "multiplier"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&multiplier",
            "buf",
            "sizeof(int)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic atomic_t *prof_buffer;\n\nstatic ssize_t write_profile(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n#ifdef CONFIG_SMP\n\textern int setup_profiling_timer(unsigned int multiplier);\n\n\tif (count == sizeof(int)) {\n\t\tunsigned int multiplier;\n\n\t\tif (copy_from_user(&multiplier, buf, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tif (setup_profiling_timer(multiplier))\n\t\t\treturn -EINVAL;\n\t}\n#endif\n\tprofile_discard_flip_buffers();\n\tmemset(prof_buffer, 0, prof_len * sizeof(atomic_t));\n\treturn count;\n}"
  },
  {
    "function_name": "read_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "464-490",
    "snippet": "static ssize_t\nread_profile(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long p = *ppos;\n\tssize_t read;\n\tchar *pnt;\n\tunsigned int sample_step = 1 << prof_shift;\n\n\tprofile_flip_buffers();\n\tif (p >= (prof_len+1)*sizeof(unsigned int))\n\t\treturn 0;\n\tif (count > (prof_len+1)*sizeof(unsigned int) - p)\n\t\tcount = (prof_len+1)*sizeof(unsigned int) - p;\n\tread = 0;\n\n\twhile (p < sizeof(unsigned int) && count > 0) {\n\t\tif (put_user(*((char *)(&sample_step)+p), buf))\n\t\t\treturn -EFAULT;\n\t\tbuf++; p++; count--; read++;\n\t}\n\tpnt = (char *)prof_buffer + p - sizeof(atomic_t);\n\tif (copy_to_user(buf, (void *)pnt, count))\n\t\treturn -EFAULT;\n\tread += count;\n\t*ppos += read;\n\treturn read;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t *prof_buffer;",
      "static unsigned long prof_len, prof_shift;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "(void *)pnt",
            "count"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "*((char *)(&sample_step)+p)",
            "buf"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_flip_buffers",
          "args": [],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "profile_flip_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
          "lines": "246-267",
          "snippet": "static void profile_flip_buffers(void)\n{\n\tint i, j, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\tj = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[j];\n\t\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {\n\t\t\tif (!hits[i].hits) {\n\t\t\t\tif (hits[i].pc)\n\t\t\t\t\thits[i].pc = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\t\thits[i].hits = hits[i].pc = 0;\n\t\t}\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/sections.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/mm.h>",
            "#include <linux/notifier.h>",
            "#include <linux/memblock.h>",
            "#include <linux/profile.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))"
          ],
          "globals_used": [
            "static atomic_t *prof_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\n#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))\n\nstatic atomic_t *prof_buffer;\n\nstatic void profile_flip_buffers(void)\n{\n\tint i, j, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\tj = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[j];\n\t\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {\n\t\t\tif (!hits[i].hits) {\n\t\t\t\tif (hits[i].pc)\n\t\t\t\t\thits[i].pc = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\t\thits[i].hits = hits[i].pc = 0;\n\t\t}\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic atomic_t *prof_buffer;\nstatic unsigned long prof_len, prof_shift;\n\nstatic ssize_t\nread_profile(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long p = *ppos;\n\tssize_t read;\n\tchar *pnt;\n\tunsigned int sample_step = 1 << prof_shift;\n\n\tprofile_flip_buffers();\n\tif (p >= (prof_len+1)*sizeof(unsigned int))\n\t\treturn 0;\n\tif (count > (prof_len+1)*sizeof(unsigned int) - p)\n\t\tcount = (prof_len+1)*sizeof(unsigned int) - p;\n\tread = 0;\n\n\twhile (p < sizeof(unsigned int) && count > 0) {\n\t\tif (put_user(*((char *)(&sample_step)+p), buf))\n\t\t\treturn -EFAULT;\n\t\tbuf++; p++; count--; read++;\n\t}\n\tpnt = (char *)prof_buffer + p - sizeof(atomic_t);\n\tif (copy_to_user(buf, (void *)pnt, count))\n\t\treturn -EFAULT;\n\tread += count;\n\t*ppos += read;\n\treturn read;\n}"
  },
  {
    "function_name": "create_prof_cpu_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "452-456",
    "snippet": "void create_prof_cpu_mask(void)\n{\n\t/* create /proc/irq/prof_cpu_mask */\n\tproc_create(\"irq/prof_cpu_mask\", 0600, NULL, &prof_cpu_mask_proc_fops);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t prof_cpu_mask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"irq/prof_cpu_mask\"",
            "0600",
            "NULL",
            "&prof_cpu_mask_proc_fops"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nvoid create_prof_cpu_mask(void)\n{\n\t/* create /proc/irq/prof_cpu_mask */\n\tproc_create(\"irq/prof_cpu_mask\", 0600, NULL, &prof_cpu_mask_proc_fops);\n}"
  },
  {
    "function_name": "prof_cpu_mask_proc_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "426-442",
    "snippet": "static ssize_t prof_cpu_mask_proc_write(struct file *file,\n\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!alloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (!err) {\n\t\tcpumask_copy(prof_cpu_mask, new_value);\n\t\terr = count;\n\t}\n\tfree_cpumask_var(new_value);\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t prof_cpu_mask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "new_value"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "prof_cpu_mask",
            "new_value"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_parse_user",
          "args": [
            "buffer",
            "count",
            "new_value"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&new_value",
            "GFP_KERNEL"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nstatic ssize_t prof_cpu_mask_proc_write(struct file *file,\n\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!alloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (!err) {\n\t\tcpumask_copy(prof_cpu_mask, new_value);\n\t\terr = count;\n\t}\n\tfree_cpumask_var(new_value);\n\treturn err;\n}"
  },
  {
    "function_name": "prof_cpu_mask_proc_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "421-424",
    "snippet": "static int prof_cpu_mask_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, prof_cpu_mask_proc_show, NULL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "prof_cpu_mask_proc_show",
            "NULL"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic int prof_cpu_mask_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, prof_cpu_mask_proc_show, NULL);\n}"
  },
  {
    "function_name": "prof_cpu_mask_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "415-419",
    "snippet": "static int prof_cpu_mask_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(prof_cpu_mask));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t prof_cpu_mask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*pb\\n\"",
            "cpumask_pr_args(prof_cpu_mask)"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "prof_cpu_mask"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nstatic int prof_cpu_mask_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(prof_cpu_mask));\n\treturn 0;\n}"
  },
  {
    "function_name": "profile_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "401-408",
    "snippet": "void profile_tick(int type)\n{\n\tstruct pt_regs *regs = get_irq_regs();\n\n\tif (!user_mode(regs) && prof_cpu_mask != NULL &&\n\t    cpumask_test_cpu(smp_processor_id(), prof_cpu_mask))\n\t\tprofile_hit(type, (void *)profile_pc(regs));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t prof_cpu_mask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_hit",
          "args": [
            "type",
            "(void *)profile_pc(regs)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_pc",
          "args": [
            "regs"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "smp_processor_id()",
            "prof_cpu_mask"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_irq_regs",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nvoid profile_tick(int type)\n{\n\tstruct pt_regs *regs = get_irq_regs();\n\n\tif (!user_mode(regs) && prof_cpu_mask != NULL &&\n\t    cpumask_test_cpu(smp_processor_id(), prof_cpu_mask))\n\t\tprofile_hit(type, (void *)profile_pc(regs));\n}"
  },
  {
    "function_name": "profile_hits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "393-398",
    "snippet": "void profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tif (prof_on != type || !prof_buffer)\n\t\treturn;\n\tdo_profile_hits(type, __pc, nr_hits);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t *prof_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_profile_hits",
          "args": [
            "type",
            "__pc",
            "nr_hits"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "do_profile_hits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
          "lines": "385-390",
          "snippet": "static void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long pc;\n\tpc = ((unsigned long)__pc - (unsigned long)_stext) >> prof_shift;\n\tatomic_add(nr_hits, &prof_buffer[min(pc, prof_len - 1)]);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/sections.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/mm.h>",
            "#include <linux/notifier.h>",
            "#include <linux/memblock.h>",
            "#include <linux/profile.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t *prof_buffer;",
            "static unsigned long prof_len, prof_shift;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic atomic_t *prof_buffer;\nstatic unsigned long prof_len, prof_shift;\n\nstatic void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long pc;\n\tpc = ((unsigned long)__pc - (unsigned long)_stext) >> prof_shift;\n\tatomic_add(nr_hits, &prof_buffer[min(pc, prof_len - 1)]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic atomic_t *prof_buffer;\n\nvoid profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tif (prof_on != type || !prof_buffer)\n\t\treturn;\n\tdo_profile_hits(type, __pc, nr_hits);\n}"
  },
  {
    "function_name": "do_profile_hits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "385-390",
    "snippet": "static void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long pc;\n\tpc = ((unsigned long)__pc - (unsigned long)_stext) >> prof_shift;\n\tatomic_add(nr_hits, &prof_buffer[min(pc, prof_len - 1)]);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t *prof_buffer;",
      "static unsigned long prof_len, prof_shift;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "nr_hits",
            "&prof_buffer[min(pc, prof_len - 1)]"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pc",
            "prof_len - 1"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic atomic_t *prof_buffer;\nstatic unsigned long prof_len, prof_shift;\n\nstatic void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long pc;\n\tpc = ((unsigned long)__pc - (unsigned long)_stext) >> prof_shift;\n\tatomic_add(nr_hits, &prof_buffer[min(pc, prof_len - 1)]);\n}"
  },
  {
    "function_name": "profile_online_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "373-379",
    "snippet": "static int profile_online_cpu(unsigned int cpu)\n{\n\tif (prof_cpu_mask != NULL)\n\t\tcpumask_set_cpu(cpu, prof_cpu_mask);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t prof_cpu_mask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "prof_cpu_mask"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nstatic int profile_online_cpu(unsigned int cpu)\n{\n\tif (prof_cpu_mask != NULL)\n\t\tcpumask_set_cpu(cpu, prof_cpu_mask);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "profile_prepare_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "351-371",
    "snippet": "static int profile_prepare_cpu(unsigned int cpu)\n{\n\tint i, node = cpu_to_mem(cpu);\n\tstruct page *page;\n\n\tper_cpu(cpu_profile_flip, cpu) = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (per_cpu(cpu_profile_hits, cpu)[i])\n\t\t\tcontinue;\n\n\t\tpage = __alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\t\tif (!page) {\n\t\t\tprofile_dead_cpu(cpu);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_cpu(cpu_profile_hits, cpu)[i] = page_address(page);\n\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_profile_hits",
            "cpu"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_dead_cpu",
          "args": [
            "cpu"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "profile_dead_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
          "lines": "333-349",
          "snippet": "static int profile_dead_cpu(unsigned int cpu)\n{\n\tstruct page *page;\n\tint i;\n\n\tif (prof_cpu_mask != NULL)\n\t\tcpumask_clear_cpu(cpu, prof_cpu_mask);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (per_cpu(cpu_profile_hits, cpu)[i]) {\n\t\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[i]);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[i] = NULL;\n\t\t\t__free_page(page);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/sections.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/mm.h>",
            "#include <linux/notifier.h>",
            "#include <linux/memblock.h>",
            "#include <linux/profile.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t prof_cpu_mask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nstatic int profile_dead_cpu(unsigned int cpu)\n{\n\tstruct page *page;\n\tint i;\n\n\tif (prof_cpu_mask != NULL)\n\t\tcpumask_clear_cpu(cpu, prof_cpu_mask);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (per_cpu(cpu_profile_hits, cpu)[i]) {\n\t\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[i]);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[i] = NULL;\n\t\t\t__free_page(page);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_pages_node",
          "args": [
            "node",
            "GFP_KERNEL | __GFP_ZERO",
            "0"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_mem",
          "args": [
            "cpu"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic int profile_prepare_cpu(unsigned int cpu)\n{\n\tint i, node = cpu_to_mem(cpu);\n\tstruct page *page;\n\n\tper_cpu(cpu_profile_flip, cpu) = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (per_cpu(cpu_profile_hits, cpu)[i])\n\t\t\tcontinue;\n\n\t\tpage = __alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\t\tif (!page) {\n\t\t\tprofile_dead_cpu(cpu);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_cpu(cpu_profile_hits, cpu)[i] = page_address(page);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "profile_dead_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "333-349",
    "snippet": "static int profile_dead_cpu(unsigned int cpu)\n{\n\tstruct page *page;\n\tint i;\n\n\tif (prof_cpu_mask != NULL)\n\t\tcpumask_clear_cpu(cpu, prof_cpu_mask);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (per_cpu(cpu_profile_hits, cpu)[i]) {\n\t\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[i]);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[i] = NULL;\n\t\t\t__free_page(page);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t prof_cpu_mask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_profile_hits",
            "cpu"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "per_cpu(cpu_profile_hits, cpu)[i]"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "prof_cpu_mask"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nstatic int profile_dead_cpu(unsigned int cpu)\n{\n\tstruct page *page;\n\tint i;\n\n\tif (prof_cpu_mask != NULL)\n\t\tcpumask_clear_cpu(cpu, prof_cpu_mask);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (per_cpu(cpu_profile_hits, cpu)[i]) {\n\t\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[i]);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[i] = NULL;\n\t\t\t__free_page(page);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "do_profile_hits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "284-331",
    "snippet": "static void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long primary, secondary, flags, pc = (unsigned long)__pc;\n\tint i, j, cpu;\n\tstruct profile_hit *hits;\n\n\tpc = min((pc - (unsigned long)_stext) >> prof_shift, prof_len - 1);\n\ti = primary = (pc & (NR_PROFILE_GRP - 1)) << PROFILE_GRPSHIFT;\n\tsecondary = (~(pc << 1) & (NR_PROFILE_GRP - 1)) << PROFILE_GRPSHIFT;\n\tcpu = get_cpu();\n\thits = per_cpu(cpu_profile_hits, cpu)[per_cpu(cpu_profile_flip, cpu)];\n\tif (!hits) {\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t/*\n\t * We buffer the global profiler buffer into a per-CPU\n\t * queue and thus reduce the number of global (and possibly\n\t * NUMA-alien) accesses. The write-queue is self-coalescing:\n\t */\n\tlocal_irq_save(flags);\n\tdo {\n\t\tfor (j = 0; j < PROFILE_GRPSZ; ++j) {\n\t\t\tif (hits[i + j].pc == pc) {\n\t\t\t\thits[i + j].hits += nr_hits;\n\t\t\t\tgoto out;\n\t\t\t} else if (!hits[i + j].hits) {\n\t\t\t\thits[i + j].pc = pc;\n\t\t\t\thits[i + j].hits = nr_hits;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ti = (i + secondary) & (NR_PROFILE_HIT - 1);\n\t} while (i != primary);\n\n\t/*\n\t * Add the current hit(s) and flush the write-queue out\n\t * to the global buffer:\n\t */\n\tatomic_add(nr_hits, &prof_buffer[pc]);\n\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {\n\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\thits[i].pc = hits[i].hits = 0;\n\t}\nout:\n\tlocal_irq_restore(flags);\n\tput_cpu();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define NR_PROFILE_GRP\t\t(NR_PROFILE_HIT/PROFILE_GRPSZ)",
      "#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))",
      "#define PROFILE_GRPSZ\t\t(1 << PROFILE_GRPSHIFT)",
      "#define PROFILE_GRPSHIFT\t3"
    ],
    "globals_used": [
      "static atomic_t *prof_buffer;",
      "static unsigned long prof_len, prof_shift;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "hits[i].hits",
            "&prof_buffer[hits[i].pc]"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "nr_hits",
            "&prof_buffer[pc]"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_profile_flip",
            "cpu"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(pc - (unsigned long)_stext) >> prof_shift",
            "prof_len - 1"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\n#define NR_PROFILE_GRP\t\t(NR_PROFILE_HIT/PROFILE_GRPSZ)\n#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))\n#define PROFILE_GRPSZ\t\t(1 << PROFILE_GRPSHIFT)\n#define PROFILE_GRPSHIFT\t3\n\nstatic atomic_t *prof_buffer;\nstatic unsigned long prof_len, prof_shift;\n\nstatic void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long primary, secondary, flags, pc = (unsigned long)__pc;\n\tint i, j, cpu;\n\tstruct profile_hit *hits;\n\n\tpc = min((pc - (unsigned long)_stext) >> prof_shift, prof_len - 1);\n\ti = primary = (pc & (NR_PROFILE_GRP - 1)) << PROFILE_GRPSHIFT;\n\tsecondary = (~(pc << 1) & (NR_PROFILE_GRP - 1)) << PROFILE_GRPSHIFT;\n\tcpu = get_cpu();\n\thits = per_cpu(cpu_profile_hits, cpu)[per_cpu(cpu_profile_flip, cpu)];\n\tif (!hits) {\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t/*\n\t * We buffer the global profiler buffer into a per-CPU\n\t * queue and thus reduce the number of global (and possibly\n\t * NUMA-alien) accesses. The write-queue is self-coalescing:\n\t */\n\tlocal_irq_save(flags);\n\tdo {\n\t\tfor (j = 0; j < PROFILE_GRPSZ; ++j) {\n\t\t\tif (hits[i + j].pc == pc) {\n\t\t\t\thits[i + j].hits += nr_hits;\n\t\t\t\tgoto out;\n\t\t\t} else if (!hits[i + j].hits) {\n\t\t\t\thits[i + j].pc = pc;\n\t\t\t\thits[i + j].hits = nr_hits;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ti = (i + secondary) & (NR_PROFILE_HIT - 1);\n\t} while (i != primary);\n\n\t/*\n\t * Add the current hit(s) and flush the write-queue out\n\t * to the global buffer:\n\t */\n\tatomic_add(nr_hits, &prof_buffer[pc]);\n\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {\n\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\thits[i].pc = hits[i].hits = 0;\n\t}\nout:\n\tlocal_irq_restore(flags);\n\tput_cpu();\n}"
  },
  {
    "function_name": "profile_discard_flip_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "269-282",
    "snippet": "static void profile_discard_flip_buffers(void)\n{\n\tint i, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\ti = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[i];\n\t\tmemset(hits, 0, NR_PROFILE_HIT*sizeof(struct profile_hit));\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&profile_flip_mutex"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "hits",
            "0",
            "NR_PROFILE_HIT*sizeof(struct profile_hit)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_profile_hits",
            "cpu"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "__profile_flip_buffers",
            "NULL",
            "1"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "on_each_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/up.c",
          "lines": "37-45",
          "snippet": "int on_each_cpu(smp_call_func_t func, void *info, int wait)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint on_each_cpu(smp_call_func_t func, void *info, int wait)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&profile_flip_mutex"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\n#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))\n\nstatic void profile_discard_flip_buffers(void)\n{\n\tint i, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\ti = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[i];\n\t\tmemset(hits, 0, NR_PROFILE_HIT*sizeof(struct profile_hit));\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}"
  },
  {
    "function_name": "profile_flip_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "246-267",
    "snippet": "static void profile_flip_buffers(void)\n{\n\tint i, j, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\tj = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[j];\n\t\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {\n\t\t\tif (!hits[i].hits) {\n\t\t\t\tif (hits[i].pc)\n\t\t\t\t\thits[i].pc = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\t\thits[i].hits = hits[i].pc = 0;\n\t\t}\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))"
    ],
    "globals_used": [
      "static atomic_t *prof_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&profile_flip_mutex"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "hits[i].hits",
            "&prof_buffer[hits[i].pc]"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_profile_hits",
            "cpu"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "__profile_flip_buffers",
            "NULL",
            "1"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "on_each_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/up.c",
          "lines": "37-45",
          "snippet": "int on_each_cpu(smp_call_func_t func, void *info, int wait)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint on_each_cpu(smp_call_func_t func, void *info, int wait)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&profile_flip_mutex"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\n#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))\n\nstatic atomic_t *prof_buffer;\n\nstatic void profile_flip_buffers(void)\n{\n\tint i, j, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\tj = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[j];\n\t\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {\n\t\t\tif (!hits[i].hits) {\n\t\t\t\tif (hits[i].pc)\n\t\t\t\t\thits[i].pc = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\t\thits[i].hits = hits[i].pc = 0;\n\t\t}\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}"
  },
  {
    "function_name": "__profile_flip_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "239-244",
    "snippet": "static void __profile_flip_buffers(void *unused)\n{\n\tint cpu = smp_processor_id();\n\n\tper_cpu(cpu_profile_flip, cpu) = !per_cpu(cpu_profile_flip, cpu);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_profile_flip",
            "cpu"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic void __profile_flip_buffers(void *unused)\n{\n\tint cpu = smp_processor_id();\n\n\tper_cpu(cpu_profile_flip, cpu) = !per_cpu(cpu_profile_flip, cpu);\n}"
  },
  {
    "function_name": "profile_event_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "188-204",
    "snippet": "int profile_event_unregister(enum profile_type type, struct notifier_block *n)\n{\n\tint err = -EINVAL;\n\n\tswitch (type) {\n\tcase PROFILE_TASK_EXIT:\n\t\terr = blocking_notifier_chain_unregister(\n\t\t\t\t&task_exit_notifier, n);\n\t\tbreak;\n\tcase PROFILE_MUNMAP:\n\t\terr = blocking_notifier_chain_unregister(\n\t\t\t\t&munmap_notifier, n);\n\t\tbreak;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static BLOCKING_NOTIFIER_HEAD(task_exit_notifier);",
      "static BLOCKING_NOTIFIER_HEAD(munmap_notifier);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_unregister",
          "args": [
            "&munmap_notifier",
            "n"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_chain_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "266-283",
          "snippet": "int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(task_exit_notifier);\nstatic BLOCKING_NOTIFIER_HEAD(munmap_notifier);\n\nint profile_event_unregister(enum profile_type type, struct notifier_block *n)\n{\n\tint err = -EINVAL;\n\n\tswitch (type) {\n\tcase PROFILE_TASK_EXIT:\n\t\terr = blocking_notifier_chain_unregister(\n\t\t\t\t&task_exit_notifier, n);\n\t\tbreak;\n\tcase PROFILE_MUNMAP:\n\t\terr = blocking_notifier_chain_unregister(\n\t\t\t\t&munmap_notifier, n);\n\t\tbreak;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "profile_event_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "169-185",
    "snippet": "int profile_event_register(enum profile_type type, struct notifier_block *n)\n{\n\tint err = -EINVAL;\n\n\tswitch (type) {\n\tcase PROFILE_TASK_EXIT:\n\t\terr = blocking_notifier_chain_register(\n\t\t\t\t&task_exit_notifier, n);\n\t\tbreak;\n\tcase PROFILE_MUNMAP:\n\t\terr = blocking_notifier_chain_register(\n\t\t\t\t&munmap_notifier, n);\n\t\tbreak;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static BLOCKING_NOTIFIER_HEAD(task_exit_notifier);",
      "static BLOCKING_NOTIFIER_HEAD(munmap_notifier);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_register",
          "args": [
            "&munmap_notifier",
            "n"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_chain_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "213-230",
          "snippet": "int blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(task_exit_notifier);\nstatic BLOCKING_NOTIFIER_HEAD(munmap_notifier);\n\nint profile_event_register(enum profile_type type, struct notifier_block *n)\n{\n\tint err = -EINVAL;\n\n\tswitch (type) {\n\tcase PROFILE_TASK_EXIT:\n\t\terr = blocking_notifier_chain_register(\n\t\t\t\t&task_exit_notifier, n);\n\t\tbreak;\n\tcase PROFILE_MUNMAP:\n\t\terr = blocking_notifier_chain_register(\n\t\t\t\t&munmap_notifier, n);\n\t\tbreak;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "task_handoff_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "163-166",
    "snippet": "int task_handoff_unregister(struct notifier_block *n)\n{\n\treturn atomic_notifier_chain_unregister(&task_free_notifier, n);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ATOMIC_NOTIFIER_HEAD(task_free_notifier);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_notifier_chain_unregister",
          "args": [
            "&task_free_notifier",
            "n"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_chain_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "143-154",
          "snippet": "int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\tsynchronize_rcu();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\tsynchronize_rcu();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(task_free_notifier);\n\nint task_handoff_unregister(struct notifier_block *n)\n{\n\treturn atomic_notifier_chain_unregister(&task_free_notifier, n);\n}"
  },
  {
    "function_name": "task_handoff_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "157-160",
    "snippet": "int task_handoff_register(struct notifier_block *n)\n{\n\treturn atomic_notifier_chain_register(&task_free_notifier, n);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ATOMIC_NOTIFIER_HEAD(task_free_notifier);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_notifier_chain_register",
          "args": [
            "&task_free_notifier",
            "n"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_chain_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "121-131",
          "snippet": "int atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(task_free_notifier);\n\nint task_handoff_register(struct notifier_block *n)\n{\n\treturn atomic_notifier_chain_register(&task_free_notifier, n);\n}"
  },
  {
    "function_name": "profile_munmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "152-155",
    "snippet": "void profile_munmap(unsigned long addr)\n{\n\tblocking_notifier_call_chain(&munmap_notifier, 0, (void *)addr);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static BLOCKING_NOTIFIER_HEAD(munmap_notifier);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_call_chain",
          "args": [
            "&munmap_notifier",
            "0",
            "(void *)addr"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_call_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "325-329",
          "snippet": "int blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn __blocking_notifier_call_chain(nh, val, v, -1, NULL);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn __blocking_notifier_call_chain(nh, val, v, -1, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(munmap_notifier);\n\nvoid profile_munmap(unsigned long addr)\n{\n\tblocking_notifier_call_chain(&munmap_notifier, 0, (void *)addr);\n}"
  },
  {
    "function_name": "profile_handoff_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "145-150",
    "snippet": "int profile_handoff_task(struct task_struct *task)\n{\n\tint ret;\n\tret = atomic_notifier_call_chain(&task_free_notifier, 0, task);\n\treturn (ret == NOTIFY_OK) ? 1 : 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ATOMIC_NOTIFIER_HEAD(task_free_notifier);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_notifier_call_chain",
          "args": [
            "&task_free_notifier",
            "0",
            "task"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_call_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "190-194",
          "snippet": "int atomic_notifier_call_chain(struct atomic_notifier_head *nh,\n\t\t\t       unsigned long val, void *v)\n{\n\treturn __atomic_notifier_call_chain(nh, val, v, -1, NULL);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_call_chain(struct atomic_notifier_head *nh,\n\t\t\t       unsigned long val, void *v)\n{\n\treturn __atomic_notifier_call_chain(nh, val, v, -1, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(task_free_notifier);\n\nint profile_handoff_task(struct task_struct *task)\n{\n\tint ret;\n\tret = atomic_notifier_call_chain(&task_free_notifier, 0, task);\n\treturn (ret == NOTIFY_OK) ? 1 : 0;\n}"
  },
  {
    "function_name": "profile_task_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "140-143",
    "snippet": "void profile_task_exit(struct task_struct *task)\n{\n\tblocking_notifier_call_chain(&task_exit_notifier, 0, task);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static BLOCKING_NOTIFIER_HEAD(task_exit_notifier);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_call_chain",
          "args": [
            "&task_exit_notifier",
            "0",
            "task"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_call_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "325-329",
          "snippet": "int blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn __blocking_notifier_call_chain(nh, val, v, -1, NULL);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn __blocking_notifier_call_chain(nh, val, v, -1, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(task_exit_notifier);\n\nvoid profile_task_exit(struct task_struct *task)\n{\n\tblocking_notifier_call_chain(&task_exit_notifier, 0, task);\n}"
  },
  {
    "function_name": "profile_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "102-132",
    "snippet": "int __ref profile_init(void)\n{\n\tint buffer_bytes;\n\tif (!prof_on)\n\t\treturn 0;\n\n\t/* only text is profiled */\n\tprof_len = (_etext - _stext) >> prof_shift;\n\tbuffer_bytes = prof_len*sizeof(atomic_t);\n\n\tif (!alloc_cpumask_var(&prof_cpu_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpumask_copy(prof_cpu_mask, cpu_possible_mask);\n\n\tprof_buffer = kzalloc(buffer_bytes, GFP_KERNEL|__GFP_NOWARN);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tprof_buffer = alloc_pages_exact(buffer_bytes,\n\t\t\t\t\tGFP_KERNEL|__GFP_ZERO|__GFP_NOWARN);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tprof_buffer = vzalloc(buffer_bytes);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tfree_cpumask_var(prof_cpu_mask);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t *prof_buffer;",
      "static unsigned long prof_len, prof_shift;",
      "static cpumask_var_t prof_cpu_mask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "prof_cpu_mask"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "buffer_bytes"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_exact",
          "args": [
            "buffer_bytes",
            "GFP_KERNEL|__GFP_ZERO|__GFP_NOWARN"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "buffer_bytes",
            "GFP_KERNEL|__GFP_NOWARN"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "prof_cpu_mask",
            "cpu_possible_mask"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&prof_cpu_mask",
            "GFP_KERNEL"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic atomic_t *prof_buffer;\nstatic unsigned long prof_len, prof_shift;\nstatic cpumask_var_t prof_cpu_mask;\n\nint __ref profile_init(void)\n{\n\tint buffer_bytes;\n\tif (!prof_on)\n\t\treturn 0;\n\n\t/* only text is profiled */\n\tprof_len = (_etext - _stext) >> prof_shift;\n\tbuffer_bytes = prof_len*sizeof(atomic_t);\n\n\tif (!alloc_cpumask_var(&prof_cpu_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpumask_copy(prof_cpu_mask, cpu_possible_mask);\n\n\tprof_buffer = kzalloc(buffer_bytes, GFP_KERNEL|__GFP_NOWARN);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tprof_buffer = alloc_pages_exact(buffer_bytes,\n\t\t\t\t\tGFP_KERNEL|__GFP_ZERO|__GFP_NOWARN);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tprof_buffer = vzalloc(buffer_bytes);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tfree_cpumask_var(prof_cpu_mask);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "profile_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
    "lines": "55-98",
    "snippet": "int profile_setup(char *str)\n{\n\tstatic const char schedstr[] = \"schedule\";\n\tstatic const char sleepstr[] = \"sleep\";\n\tstatic const char kvmstr[] = \"kvm\";\n\tint par;\n\n\tif (!strncmp(str, sleepstr, strlen(sleepstr))) {\n#ifdef CONFIG_SCHEDSTATS\n\t\tforce_schedstat_enabled();\n\t\tprof_on = SLEEP_PROFILING;\n\t\tif (str[strlen(sleepstr)] == ',')\n\t\t\tstr += strlen(sleepstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = par;\n\t\tpr_info(\"kernel sleep profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n#else\n\t\tpr_warn(\"kernel sleep profiling requires CONFIG_SCHEDSTATS\\n\");\n#endif /* CONFIG_SCHEDSTATS */\n\t} else if (!strncmp(str, schedstr, strlen(schedstr))) {\n\t\tprof_on = SCHED_PROFILING;\n\t\tif (str[strlen(schedstr)] == ',')\n\t\t\tstr += strlen(schedstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = par;\n\t\tpr_info(\"kernel schedule profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n\t} else if (!strncmp(str, kvmstr, strlen(kvmstr))) {\n\t\tprof_on = KVM_PROFILING;\n\t\tif (str[strlen(kvmstr)] == ',')\n\t\t\tstr += strlen(kvmstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = par;\n\t\tpr_info(\"kernel KVM profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n\t} else if (get_option(&str, &par)) {\n\t\tprof_shift = par;\n\t\tprof_on = CPU_PROFILING;\n\t\tpr_info(\"kernel profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/irq_regs.h>",
      "#include <asm/sections.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/mm.h>",
      "#include <linux/notifier.h>",
      "#include <linux/memblock.h>",
      "#include <linux/profile.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long prof_len, prof_shift;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"kernel profiling enabled (shift: %ld)\\n\"",
            "prof_shift"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&par"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"kernel KVM profiling enabled (shift: %ld)\\n\"",
            "prof_shift"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&par"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kvmstr"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "kvmstr",
            "strlen(kvmstr)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"kernel schedule profiling enabled (shift: %ld)\\n\"",
            "prof_shift"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&par"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "schedstr",
            "strlen(schedstr)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"kernel sleep profiling requires CONFIG_SCHEDSTATS\\n\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"kernel sleep profiling enabled (shift: %ld)\\n\"",
            "prof_shift"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&par"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_schedstat_enabled",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "force_schedstat_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2231-2237",
          "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "sleepstr",
            "strlen(sleepstr)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic unsigned long prof_len, prof_shift;\n\nint profile_setup(char *str)\n{\n\tstatic const char schedstr[] = \"schedule\";\n\tstatic const char sleepstr[] = \"sleep\";\n\tstatic const char kvmstr[] = \"kvm\";\n\tint par;\n\n\tif (!strncmp(str, sleepstr, strlen(sleepstr))) {\n#ifdef CONFIG_SCHEDSTATS\n\t\tforce_schedstat_enabled();\n\t\tprof_on = SLEEP_PROFILING;\n\t\tif (str[strlen(sleepstr)] == ',')\n\t\t\tstr += strlen(sleepstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = par;\n\t\tpr_info(\"kernel sleep profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n#else\n\t\tpr_warn(\"kernel sleep profiling requires CONFIG_SCHEDSTATS\\n\");\n#endif /* CONFIG_SCHEDSTATS */\n\t} else if (!strncmp(str, schedstr, strlen(schedstr))) {\n\t\tprof_on = SCHED_PROFILING;\n\t\tif (str[strlen(schedstr)] == ',')\n\t\t\tstr += strlen(schedstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = par;\n\t\tpr_info(\"kernel schedule profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n\t} else if (!strncmp(str, kvmstr, strlen(kvmstr))) {\n\t\tprof_on = KVM_PROFILING;\n\t\tif (str[strlen(kvmstr)] == ',')\n\t\t\tstr += strlen(kvmstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = par;\n\t\tpr_info(\"kernel KVM profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n\t} else if (get_option(&str, &par)) {\n\t\tprof_shift = par;\n\t\tprof_on = CPU_PROFILING;\n\t\tpr_info(\"kernel profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n\t}\n\treturn 1;\n}"
  }
]