[
  {
    "function_name": "bpf_cgroup_storage_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "479-495",
    "snippet": "void bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list);\n\tspin_unlock_bh(&map->lock);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&storage->list"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&storage->node",
            "root"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list);\n\tspin_unlock_bh(&map->lock);\n}"
  },
  {
    "function_name": "bpf_cgroup_storage_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "459-477",
    "snippet": "void bpf_cgroup_storage_link(struct bpf_cgroup_storage *storage,\n\t\t\t     struct cgroup *cgroup,\n\t\t\t     enum bpf_attach_type type)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\n\tif (!storage)\n\t\treturn;\n\n\tstorage->key.attach_type = type;\n\tstorage->key.cgroup_inode_id = cgroup->kn->id.id;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\tWARN_ON(cgroup_storage_insert(map, storage));\n\tlist_add(&storage->list, &map->list);\n\tspin_unlock_bh(&map->lock);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&storage->list",
            "&map->list"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cgroup_storage_insert(map, storage)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_insert",
          "args": [
            "map",
            "storage"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_storage_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "83-111",
          "snippet": "static int cgroup_storage_insert(struct bpf_cgroup_storage_map *map,\n\t\t\t\t struct bpf_cgroup_storage *storage)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\n\twhile (*new) {\n\t\tstruct bpf_cgroup_storage *this;\n\n\t\tthis = container_of(*new, struct bpf_cgroup_storage, node);\n\n\t\tparent = *new;\n\t\tswitch (bpf_cgroup_storage_key_cmp(&storage->key, &this->key)) {\n\t\tcase -1:\n\t\t\tnew = &((*new)->rb_left);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnew = &((*new)->rb_right);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&storage->node, parent, new);\n\trb_insert_color(&storage->node, root);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int cgroup_storage_insert(struct bpf_cgroup_storage_map *map,\n\t\t\t\t struct bpf_cgroup_storage *storage)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\n\twhile (*new) {\n\t\tstruct bpf_cgroup_storage *this;\n\n\t\tthis = container_of(*new, struct bpf_cgroup_storage, node);\n\n\t\tparent = *new;\n\t\tswitch (bpf_cgroup_storage_key_cmp(&storage->key, &this->key)) {\n\t\tcase -1:\n\t\t\tnew = &((*new)->rb_left);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnew = &((*new)->rb_right);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&storage->node, parent, new);\n\trb_insert_color(&storage->node, root);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_link(struct bpf_cgroup_storage *storage,\n\t\t\t     struct cgroup *cgroup,\n\t\t\t     enum bpf_attach_type type)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\n\tif (!storage)\n\t\treturn;\n\n\tstorage->key.attach_type = type;\n\tstorage->key.cgroup_inode_id = cgroup->kn->id.id;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\tWARN_ON(cgroup_storage_insert(map, storage));\n\tlist_add(&storage->list, &map->list);\n\tspin_unlock_bh(&map->lock);\n}"
  },
  {
    "function_name": "bpf_cgroup_storage_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "438-457",
    "snippet": "void bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\tu32 pages;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\n\tbpf_cgroup_storage_calculate_size(map, &pages);\n\tbpf_map_uncharge_memlock(map, pages);\n\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&storage->rcu",
            "free_percpu_cgroup_storage_rcu"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_storage_type",
          "args": [
            "map"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_uncharge_memlock",
          "args": [
            "map",
            "pages"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_uncharge_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "232-236",
          "snippet": "void bpf_map_uncharge_memlock(struct bpf_map *map, u32 pages)\n{\n\tbpf_uncharge_memlock(map->user, pages);\n\tmap->pages -= pages;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_uncharge_memlock(struct bpf_map *map, u32 pages)\n{\n\tbpf_uncharge_memlock(map->user, pages);\n\tmap->pages -= pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_calculate_size",
          "args": [
            "map",
            "&pages"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_calculate_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "358-373",
          "snippet": "static size_t bpf_cgroup_storage_calculate_size(struct bpf_map *map, u32 *pages)\n{\n\tsize_t size;\n\n\tif (cgroup_storage_type(map) == BPF_CGROUP_STORAGE_SHARED) {\n\t\tsize = sizeof(struct bpf_storage_buffer) + map->value_size;\n\t\t*pages = round_up(sizeof(struct bpf_cgroup_storage) + size,\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t} else {\n\t\tsize = map->value_size;\n\t\t*pages = round_up(round_up(size, 8) * num_possible_cpus(),\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic size_t bpf_cgroup_storage_calculate_size(struct bpf_map *map, u32 *pages)\n{\n\tsize_t size;\n\n\tif (cgroup_storage_type(map) == BPF_CGROUP_STORAGE_SHARED) {\n\t\tsize = sizeof(struct bpf_storage_buffer) + map->value_size;\n\t\t*pages = round_up(sizeof(struct bpf_cgroup_storage) + size,\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t} else {\n\t\tsize = map->value_size;\n\t\t*pages = round_up(round_up(size, 8) * num_possible_cpus(),\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\tu32 pages;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\n\tbpf_cgroup_storage_calculate_size(map, &pages);\n\tbpf_map_uncharge_memlock(map, pages);\n\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}"
  },
  {
    "function_name": "free_percpu_cgroup_storage_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "429-436",
    "snippet": "static void free_percpu_cgroup_storage_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_cgroup_storage *storage =\n\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);\n\n\tfree_percpu(storage->percpu_buf);\n\tkfree(storage);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "storage"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "storage->percpu_buf"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "free_percpu_cgroup_storage_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "429-436",
          "snippet": "static void free_percpu_cgroup_storage_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_cgroup_storage *storage =\n\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);\n\n\tfree_percpu(storage->percpu_buf);\n\tkfree(storage);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structbpf_cgroup_storage",
            "rcu"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic void free_percpu_cgroup_storage_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_cgroup_storage *storage =\n\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);\n\n\tfree_percpu(storage->percpu_buf);\n\tkfree(storage);\n}"
  },
  {
    "function_name": "free_shared_cgroup_storage_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "420-427",
    "snippet": "static void free_shared_cgroup_storage_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_cgroup_storage *storage =\n\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);\n\n\tkfree(storage->buf);\n\tkfree(storage);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "storage"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structbpf_cgroup_storage",
            "rcu"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic void free_shared_cgroup_storage_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_cgroup_storage *storage =\n\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);\n\n\tkfree(storage->buf);\n\tkfree(storage);\n}"
  },
  {
    "function_name": "bpf_cgroup_storage_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "375-418",
    "snippet": "struct bpf_cgroup_storage *bpf_cgroup_storage_alloc(struct bpf_prog *prog,\n\t\t\t\t\tenum bpf_cgroup_storage_type stype)\n{\n\tstruct bpf_cgroup_storage *storage;\n\tstruct bpf_map *map;\n\tgfp_t flags;\n\tsize_t size;\n\tu32 pages;\n\n\tmap = prog->aux->cgroup_storage[stype];\n\tif (!map)\n\t\treturn NULL;\n\n\tsize = bpf_cgroup_storage_calculate_size(map, &pages);\n\n\tif (bpf_map_charge_memlock(map, pages))\n\t\treturn ERR_PTR(-EPERM);\n\n\tstorage = kmalloc_node(sizeof(struct bpf_cgroup_storage),\n\t\t\t       __GFP_ZERO | GFP_USER, map->numa_node);\n\tif (!storage)\n\t\tgoto enomem;\n\n\tflags = __GFP_ZERO | GFP_USER;\n\n\tif (stype == BPF_CGROUP_STORAGE_SHARED) {\n\t\tstorage->buf = kmalloc_node(size, flags, map->numa_node);\n\t\tif (!storage->buf)\n\t\t\tgoto enomem;\n\t} else {\n\t\tstorage->percpu_buf = __alloc_percpu_gfp(size, 8, flags);\n\t\tif (!storage->percpu_buf)\n\t\t\tgoto enomem;\n\t}\n\n\tstorage->map = (struct bpf_cgroup_storage_map *)map;\n\n\treturn storage;\n\nenomem:\n\tbpf_map_uncharge_memlock(map, pages);\n\tkfree(storage);\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "storage"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_uncharge_memlock",
          "args": [
            "map",
            "pages"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_uncharge_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "232-236",
          "snippet": "void bpf_map_uncharge_memlock(struct bpf_map *map, u32 pages)\n{\n\tbpf_uncharge_memlock(map->user, pages);\n\tmap->pages -= pages;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_uncharge_memlock(struct bpf_map *map, u32 pages)\n{\n\tbpf_uncharge_memlock(map->user, pages);\n\tmap->pages -= pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_percpu_gfp",
          "args": [
            "size",
            "8",
            "flags"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "size",
            "flags",
            "map->numa_node"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "sizeof(struct bpf_cgroup_storage)",
            "__GFP_ZERO | GFP_USER",
            "map->numa_node"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_charge_memlock",
          "args": [
            "map",
            "pages"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_charge_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "221-230",
          "snippet": "int bpf_map_charge_memlock(struct bpf_map *map, u32 pages)\n{\n\tint ret;\n\n\tret = bpf_charge_memlock(map->user, pages);\n\tif (ret)\n\t\treturn ret;\n\tmap->pages += pages;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_map_charge_memlock(struct bpf_map *map, u32 pages)\n{\n\tint ret;\n\n\tret = bpf_charge_memlock(map->user, pages);\n\tif (ret)\n\t\treturn ret;\n\tmap->pages += pages;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_calculate_size",
          "args": [
            "map",
            "&pages"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_calculate_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "358-373",
          "snippet": "static size_t bpf_cgroup_storage_calculate_size(struct bpf_map *map, u32 *pages)\n{\n\tsize_t size;\n\n\tif (cgroup_storage_type(map) == BPF_CGROUP_STORAGE_SHARED) {\n\t\tsize = sizeof(struct bpf_storage_buffer) + map->value_size;\n\t\t*pages = round_up(sizeof(struct bpf_cgroup_storage) + size,\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t} else {\n\t\tsize = map->value_size;\n\t\t*pages = round_up(round_up(size, 8) * num_possible_cpus(),\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic size_t bpf_cgroup_storage_calculate_size(struct bpf_map *map, u32 *pages)\n{\n\tsize_t size;\n\n\tif (cgroup_storage_type(map) == BPF_CGROUP_STORAGE_SHARED) {\n\t\tsize = sizeof(struct bpf_storage_buffer) + map->value_size;\n\t\t*pages = round_up(sizeof(struct bpf_cgroup_storage) + size,\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t} else {\n\t\tsize = map->value_size;\n\t\t*pages = round_up(round_up(size, 8) * num_possible_cpus(),\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstruct bpf_cgroup_storage *bpf_cgroup_storage_alloc(struct bpf_prog *prog,\n\t\t\t\t\tenum bpf_cgroup_storage_type stype)\n{\n\tstruct bpf_cgroup_storage *storage;\n\tstruct bpf_map *map;\n\tgfp_t flags;\n\tsize_t size;\n\tu32 pages;\n\n\tmap = prog->aux->cgroup_storage[stype];\n\tif (!map)\n\t\treturn NULL;\n\n\tsize = bpf_cgroup_storage_calculate_size(map, &pages);\n\n\tif (bpf_map_charge_memlock(map, pages))\n\t\treturn ERR_PTR(-EPERM);\n\n\tstorage = kmalloc_node(sizeof(struct bpf_cgroup_storage),\n\t\t\t       __GFP_ZERO | GFP_USER, map->numa_node);\n\tif (!storage)\n\t\tgoto enomem;\n\n\tflags = __GFP_ZERO | GFP_USER;\n\n\tif (stype == BPF_CGROUP_STORAGE_SHARED) {\n\t\tstorage->buf = kmalloc_node(size, flags, map->numa_node);\n\t\tif (!storage->buf)\n\t\t\tgoto enomem;\n\t} else {\n\t\tstorage->percpu_buf = __alloc_percpu_gfp(size, 8, flags);\n\t\tif (!storage->percpu_buf)\n\t\t\tgoto enomem;\n\t}\n\n\tstorage->map = (struct bpf_cgroup_storage_map *)map;\n\n\treturn storage;\n\nenomem:\n\tbpf_map_uncharge_memlock(map, pages);\n\tkfree(storage);\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "bpf_cgroup_storage_calculate_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "358-373",
    "snippet": "static size_t bpf_cgroup_storage_calculate_size(struct bpf_map *map, u32 *pages)\n{\n\tsize_t size;\n\n\tif (cgroup_storage_type(map) == BPF_CGROUP_STORAGE_SHARED) {\n\t\tsize = sizeof(struct bpf_storage_buffer) + map->value_size;\n\t\t*pages = round_up(sizeof(struct bpf_cgroup_storage) + size,\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t} else {\n\t\tsize = map->value_size;\n\t\t*pages = round_up(round_up(size, 8) * num_possible_cpus(),\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t}\n\n\treturn size;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "round_up(size, 8) * num_possible_cpus()",
            "PAGE_SIZE"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "size",
            "8"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "sizeof(struct bpf_cgroup_storage) + size",
            "PAGE_SIZE"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_type",
          "args": [
            "map"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic size_t bpf_cgroup_storage_calculate_size(struct bpf_map *map, u32 *pages)\n{\n\tsize_t size;\n\n\tif (cgroup_storage_type(map) == BPF_CGROUP_STORAGE_SHARED) {\n\t\tsize = sizeof(struct bpf_storage_buffer) + map->value_size;\n\t\t*pages = round_up(sizeof(struct bpf_cgroup_storage) + size,\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t} else {\n\t\tsize = map->value_size;\n\t\t*pages = round_up(round_up(size, 8) * num_possible_cpus(),\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t}\n\n\treturn size;\n}"
  },
  {
    "function_name": "bpf_cgroup_storage_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "344-356",
    "snippet": "void bpf_cgroup_storage_release(struct bpf_prog *prog, struct bpf_map *_map)\n{\n\tenum bpf_cgroup_storage_type stype = cgroup_storage_type(_map);\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\n\tspin_lock_bh(&map->lock);\n\tif (map->prog == prog) {\n\t\tWARN_ON(prog->aux->cgroup_storage[stype] != _map);\n\t\tmap->prog = NULL;\n\t\tprog->aux->cgroup_storage[stype] = NULL;\n\t}\n\tspin_unlock_bh(&map->lock);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "prog->aux->cgroup_storage[stype] != _map"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_to_storage",
          "args": [
            "_map"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "map_to_storage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "27-30",
          "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_storage_type",
          "args": [
            "_map"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_release(struct bpf_prog *prog, struct bpf_map *_map)\n{\n\tenum bpf_cgroup_storage_type stype = cgroup_storage_type(_map);\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\n\tspin_lock_bh(&map->lock);\n\tif (map->prog == prog) {\n\t\tWARN_ON(prog->aux->cgroup_storage[stype] != _map);\n\t\tmap->prog = NULL;\n\t\tprog->aux->cgroup_storage[stype] = NULL;\n\t}\n\tspin_unlock_bh(&map->lock);\n}"
  },
  {
    "function_name": "bpf_cgroup_storage_assign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "321-342",
    "snippet": "int bpf_cgroup_storage_assign(struct bpf_prog *prog, struct bpf_map *_map)\n{\n\tenum bpf_cgroup_storage_type stype = cgroup_storage_type(_map);\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tint ret = -EBUSY;\n\n\tspin_lock_bh(&map->lock);\n\n\tif (map->prog && map->prog != prog)\n\t\tgoto unlock;\n\tif (prog->aux->cgroup_storage[stype] &&\n\t    prog->aux->cgroup_storage[stype] != _map)\n\t\tgoto unlock;\n\n\tmap->prog = prog;\n\tprog->aux->cgroup_storage[stype] = _map;\n\tret = 0;\nunlock:\n\tspin_unlock_bh(&map->lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_to_storage",
          "args": [
            "_map"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "map_to_storage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "27-30",
          "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_storage_type",
          "args": [
            "_map"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nint bpf_cgroup_storage_assign(struct bpf_prog *prog, struct bpf_map *_map)\n{\n\tenum bpf_cgroup_storage_type stype = cgroup_storage_type(_map);\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tint ret = -EBUSY;\n\n\tspin_lock_bh(&map->lock);\n\n\tif (map->prog && map->prog != prog)\n\t\tgoto unlock;\n\tif (prog->aux->cgroup_storage[stype] &&\n\t    prog->aux->cgroup_storage[stype] != _map)\n\t\tgoto unlock;\n\n\tmap->prog = prog;\n\tprog->aux->cgroup_storage[stype] = _map;\n\tret = 0;\nunlock:\n\tspin_unlock_bh(&map->lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_storage_delete_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "306-309",
    "snippet": "static int cgroup_storage_delete_elem(struct bpf_map *map, void *key)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int cgroup_storage_delete_elem(struct bpf_map *map, void *key)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "cgroup_storage_map_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "296-304",
    "snippet": "static void cgroup_storage_map_free(struct bpf_map *_map)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\n\tWARN_ON(!RB_EMPTY_ROOT(&map->root));\n\tWARN_ON(!list_empty(&map->list));\n\n\tkfree(map);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "map"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&map->list)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&map->list"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!RB_EMPTY_ROOT(&map->root)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&map->root"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_to_storage",
          "args": [
            "_map"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "map_to_storage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "27-30",
          "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic void cgroup_storage_map_free(struct bpf_map *_map)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\n\tWARN_ON(!RB_EMPTY_ROOT(&map->root));\n\tWARN_ON(!list_empty(&map->list));\n\n\tkfree(map);\n}"
  },
  {
    "function_name": "cgroup_storage_map_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "256-294",
    "snippet": "static struct bpf_map *cgroup_storage_map_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_cgroup_storage_map *map;\n\n\tif (attr->key_size != sizeof(struct bpf_cgroup_storage_key))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->value_size == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->value_size > PAGE_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tif (attr->map_flags & ~LOCAL_STORAGE_CREATE_FLAG_MASK)\n\t\t/* reserved bits should not be used */\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->max_entries)\n\t\t/* max_entries is not used and enforced to be 0 */\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmap = kmalloc_node(sizeof(struct bpf_cgroup_storage_map),\n\t\t\t   __GFP_ZERO | GFP_USER, numa_node);\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmap->map.pages = round_up(sizeof(struct bpf_cgroup_storage_map),\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&map->map, attr);\n\n\tspin_lock_init(&map->lock);\n\tmap->root = RB_ROOT;\n\tINIT_LIST_HEAD(&map->list);\n\n\treturn &map->map;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [
      "#define LOCAL_STORAGE_CREATE_FLAG_MASK\t\t\t\t\t\\\n\t(BPF_F_NUMA_NODE | BPF_F_RDONLY | BPF_F_WRONLY)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&map->list"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&map->lock"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "&map->map",
            "attr"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "161-169",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = attr->map_flags;\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = attr->map_flags;\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "sizeof(struct bpf_cgroup_storage_map)",
            "PAGE_SIZE"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "sizeof(struct bpf_cgroup_storage_map)",
            "__GFP_ZERO | GFP_USER",
            "numa_node"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-E2BIG"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_attr_numa_node",
          "args": [
            "attr"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\n#define LOCAL_STORAGE_CREATE_FLAG_MASK\t\t\t\t\t\\\n\t(BPF_F_NUMA_NODE | BPF_F_RDONLY | BPF_F_WRONLY)\n\nstatic struct bpf_map *cgroup_storage_map_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_cgroup_storage_map *map;\n\n\tif (attr->key_size != sizeof(struct bpf_cgroup_storage_key))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->value_size == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->value_size > PAGE_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tif (attr->map_flags & ~LOCAL_STORAGE_CREATE_FLAG_MASK)\n\t\t/* reserved bits should not be used */\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->max_entries)\n\t\t/* max_entries is not used and enforced to be 0 */\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmap = kmalloc_node(sizeof(struct bpf_cgroup_storage_map),\n\t\t\t   __GFP_ZERO | GFP_USER, numa_node);\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmap->map.pages = round_up(sizeof(struct bpf_cgroup_storage_map),\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&map->map, attr);\n\n\tspin_lock_init(&map->lock);\n\tmap->root = RB_ROOT;\n\tINIT_LIST_HEAD(&map->list);\n\n\treturn &map->map;\n}"
  },
  {
    "function_name": "cgroup_storage_get_next_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "220-254",
    "snippet": "static int cgroup_storage_get_next_key(struct bpf_map *_map, void *_key,\n\t\t\t\t       void *_next_key)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage_key *key = _key;\n\tstruct bpf_cgroup_storage_key *next = _next_key;\n\tstruct bpf_cgroup_storage *storage;\n\n\tspin_lock_bh(&map->lock);\n\n\tif (list_empty(&map->list))\n\t\tgoto enoent;\n\n\tif (key) {\n\t\tstorage = cgroup_storage_lookup(map, key, true);\n\t\tif (!storage)\n\t\t\tgoto enoent;\n\n\t\tstorage = list_next_entry(storage, list);\n\t\tif (!storage)\n\t\t\tgoto enoent;\n\t} else {\n\t\tstorage = list_first_entry(&map->list,\n\t\t\t\t\t struct bpf_cgroup_storage, list);\n\t}\n\n\tspin_unlock_bh(&map->lock);\n\tnext->attach_type = storage->key.attach_type;\n\tnext->cgroup_inode_id = storage->key.cgroup_inode_id;\n\treturn 0;\n\nenoent:\n\tspin_unlock_bh(&map->lock);\n\treturn -ENOENT;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&map->list",
            "structbpf_cgroup_storage",
            "list"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "storage",
            "list"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_lookup",
          "args": [
            "map",
            "key",
            "true"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_storage_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "47-81",
          "snippet": "static struct bpf_cgroup_storage *cgroup_storage_lookup(\n\tstruct bpf_cgroup_storage_map *map, struct bpf_cgroup_storage_key *key,\n\tbool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage *cgroup_storage_lookup(\n\tstruct bpf_cgroup_storage_map *map, struct bpf_cgroup_storage_key *key,\n\tbool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&map->list"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_to_storage",
          "args": [
            "_map"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "map_to_storage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "27-30",
          "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int cgroup_storage_get_next_key(struct bpf_map *_map, void *_key,\n\t\t\t\t       void *_next_key)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage_key *key = _key;\n\tstruct bpf_cgroup_storage_key *next = _next_key;\n\tstruct bpf_cgroup_storage *storage;\n\n\tspin_lock_bh(&map->lock);\n\n\tif (list_empty(&map->list))\n\t\tgoto enoent;\n\n\tif (key) {\n\t\tstorage = cgroup_storage_lookup(map, key, true);\n\t\tif (!storage)\n\t\t\tgoto enoent;\n\n\t\tstorage = list_next_entry(storage, list);\n\t\tif (!storage)\n\t\t\tgoto enoent;\n\t} else {\n\t\tstorage = list_first_entry(&map->list,\n\t\t\t\t\t struct bpf_cgroup_storage, list);\n\t}\n\n\tspin_unlock_bh(&map->lock);\n\tnext->attach_type = storage->key.attach_type;\n\tnext->cgroup_inode_id = storage->key.cgroup_inode_id;\n\treturn 0;\n\nenoent:\n\tspin_unlock_bh(&map->lock);\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "bpf_percpu_cgroup_storage_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "185-218",
    "snippet": "int bpf_percpu_cgroup_storage_update(struct bpf_map *_map, void *_key,\n\t\t\t\t     void *value, u64 map_flags)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage_key *key = _key;\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (map_flags != BPF_ANY && map_flags != BPF_EXIST)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* the user space will provide round_up(value_size, 8) bytes that\n\t * will be copied into per-cpu area. bpf programs can only access\n\t * value_size of it. During lookup the same extra bytes will be\n\t * returned or zeros which were zero-filled by percpu_alloc,\n\t * so no kernel data leaks possible\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(storage->percpu_buf, cpu),\n\t\t\t\tvalue + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_long_memcpy",
          "args": [
            "per_cpu_ptr(storage->percpu_buf, cpu)",
            "value + off",
            "size"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "storage->percpu_buf",
            "cpu"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "_map->value_size",
            "8"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_lookup",
          "args": [
            "map",
            "key",
            "false"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_storage_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "47-81",
          "snippet": "static struct bpf_cgroup_storage *cgroup_storage_lookup(\n\tstruct bpf_cgroup_storage_map *map, struct bpf_cgroup_storage_key *key,\n\tbool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage *cgroup_storage_lookup(\n\tstruct bpf_cgroup_storage_map *map, struct bpf_cgroup_storage_key *key,\n\tbool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_to_storage",
          "args": [
            "_map"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "map_to_storage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "27-30",
          "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nint bpf_percpu_cgroup_storage_update(struct bpf_map *_map, void *_key,\n\t\t\t\t     void *value, u64 map_flags)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage_key *key = _key;\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (map_flags != BPF_ANY && map_flags != BPF_EXIST)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* the user space will provide round_up(value_size, 8) bytes that\n\t * will be copied into per-cpu area. bpf programs can only access\n\t * value_size of it. During lookup the same extra bytes will be\n\t * returned or zeros which were zero-filled by percpu_alloc,\n\t * so no kernel data leaks possible\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(storage->percpu_buf, cpu),\n\t\t\t\tvalue + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_percpu_cgroup_storage_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "155-183",
    "snippet": "int bpf_percpu_cgroup_storage_copy(struct bpf_map *_map, void *_key,\n\t\t\t\t   void *value)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage_key *key = _key;\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(storage->percpu_buf, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_long_memcpy",
          "args": [
            "value + off",
            "per_cpu_ptr(storage->percpu_buf, cpu)",
            "size"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "storage->percpu_buf",
            "cpu"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "_map->value_size",
            "8"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_lookup",
          "args": [
            "map",
            "key",
            "false"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_storage_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "47-81",
          "snippet": "static struct bpf_cgroup_storage *cgroup_storage_lookup(\n\tstruct bpf_cgroup_storage_map *map, struct bpf_cgroup_storage_key *key,\n\tbool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage *cgroup_storage_lookup(\n\tstruct bpf_cgroup_storage_map *map, struct bpf_cgroup_storage_key *key,\n\tbool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_to_storage",
          "args": [
            "_map"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "map_to_storage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "27-30",
          "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nint bpf_percpu_cgroup_storage_copy(struct bpf_map *_map, void *_key,\n\t\t\t\t   void *value)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage_key *key = _key;\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(storage->percpu_buf, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_storage_update_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "126-153",
    "snippet": "static int cgroup_storage_update_elem(struct bpf_map *map, void *_key,\n\t\t\t\t      void *value, u64 flags)\n{\n\tstruct bpf_cgroup_storage_key *key = _key;\n\tstruct bpf_cgroup_storage *storage;\n\tstruct bpf_storage_buffer *new;\n\n\tif (flags != BPF_ANY && flags != BPF_EXIST)\n\t\treturn -EINVAL;\n\n\tstorage = cgroup_storage_lookup((struct bpf_cgroup_storage_map *)map,\n\t\t\t\t\tkey, false);\n\tif (!storage)\n\t\treturn -ENOENT;\n\n\tnew = kmalloc_node(sizeof(struct bpf_storage_buffer) +\n\t\t\t   map->value_size, __GFP_ZERO | GFP_USER,\n\t\t\t   map->numa_node);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&new->data[0], value, map->value_size);\n\n\tnew = xchg(&storage->buf, new);\n\tkfree_rcu(new, rcu);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "new",
            "rcu"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&storage->buf",
            "new"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock.c",
          "lines": "231-249",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new->data[0]",
            "value",
            "map->value_size"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "sizeof(struct bpf_storage_buffer) +\n\t\t\t   map->value_size",
            "__GFP_ZERO | GFP_USER",
            "map->numa_node"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_lookup",
          "args": [
            "(struct bpf_cgroup_storage_map *)map",
            "key",
            "false"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_storage_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "47-81",
          "snippet": "static struct bpf_cgroup_storage *cgroup_storage_lookup(\n\tstruct bpf_cgroup_storage_map *map, struct bpf_cgroup_storage_key *key,\n\tbool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage *cgroup_storage_lookup(\n\tstruct bpf_cgroup_storage_map *map, struct bpf_cgroup_storage_key *key,\n\tbool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int cgroup_storage_update_elem(struct bpf_map *map, void *_key,\n\t\t\t\t      void *value, u64 flags)\n{\n\tstruct bpf_cgroup_storage_key *key = _key;\n\tstruct bpf_cgroup_storage *storage;\n\tstruct bpf_storage_buffer *new;\n\n\tif (flags != BPF_ANY && flags != BPF_EXIST)\n\t\treturn -EINVAL;\n\n\tstorage = cgroup_storage_lookup((struct bpf_cgroup_storage_map *)map,\n\t\t\t\t\tkey, false);\n\tif (!storage)\n\t\treturn -ENOENT;\n\n\tnew = kmalloc_node(sizeof(struct bpf_storage_buffer) +\n\t\t\t   map->value_size, __GFP_ZERO | GFP_USER,\n\t\t\t   map->numa_node);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&new->data[0], value, map->value_size);\n\n\tnew = xchg(&storage->buf, new);\n\tkfree_rcu(new, rcu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_storage_lookup_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "113-124",
    "snippet": "static void *cgroup_storage_lookup_elem(struct bpf_map *_map, void *_key)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage_key *key = _key;\n\tstruct bpf_cgroup_storage *storage;\n\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage)\n\t\treturn NULL;\n\n\treturn &READ_ONCE(storage->buf)->data[0];\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "storage->buf"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_lookup",
          "args": [
            "map",
            "key",
            "false"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_storage_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "47-81",
          "snippet": "static struct bpf_cgroup_storage *cgroup_storage_lookup(\n\tstruct bpf_cgroup_storage_map *map, struct bpf_cgroup_storage_key *key,\n\tbool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage *cgroup_storage_lookup(\n\tstruct bpf_cgroup_storage_map *map, struct bpf_cgroup_storage_key *key,\n\tbool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_to_storage",
          "args": [
            "_map"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "map_to_storage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "27-30",
          "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic void *cgroup_storage_lookup_elem(struct bpf_map *_map, void *_key)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage_key *key = _key;\n\tstruct bpf_cgroup_storage *storage;\n\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage)\n\t\treturn NULL;\n\n\treturn &READ_ONCE(storage->buf)->data[0];\n}"
  },
  {
    "function_name": "cgroup_storage_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "83-111",
    "snippet": "static int cgroup_storage_insert(struct bpf_cgroup_storage_map *map,\n\t\t\t\t struct bpf_cgroup_storage *storage)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\n\twhile (*new) {\n\t\tstruct bpf_cgroup_storage *this;\n\n\t\tthis = container_of(*new, struct bpf_cgroup_storage, node);\n\n\t\tparent = *new;\n\t\tswitch (bpf_cgroup_storage_key_cmp(&storage->key, &this->key)) {\n\t\tcase -1:\n\t\t\tnew = &((*new)->rb_left);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnew = &((*new)->rb_right);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&storage->node, parent, new);\n\trb_insert_color(&storage->node, root);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&storage->node",
            "root"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&storage->node",
            "parent",
            "new"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_key_cmp",
          "args": [
            "&storage->key",
            "&this->key"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_key_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "32-45",
          "snippet": "static int bpf_cgroup_storage_key_cmp(\n\tconst struct bpf_cgroup_storage_key *key1,\n\tconst struct bpf_cgroup_storage_key *key2)\n{\n\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)\n\t\treturn -1;\n\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)\n\t\treturn 1;\n\telse if (key1->attach_type < key2->attach_type)\n\t\treturn -1;\n\telse if (key1->attach_type > key2->attach_type)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int bpf_cgroup_storage_key_cmp(\n\tconst struct bpf_cgroup_storage_key *key1,\n\tconst struct bpf_cgroup_storage_key *key2)\n{\n\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)\n\t\treturn -1;\n\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)\n\t\treturn 1;\n\telse if (key1->attach_type < key2->attach_type)\n\t\treturn -1;\n\telse if (key1->attach_type > key2->attach_type)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "*new",
            "structbpf_cgroup_storage",
            "node"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int cgroup_storage_insert(struct bpf_cgroup_storage_map *map,\n\t\t\t\t struct bpf_cgroup_storage *storage)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\n\twhile (*new) {\n\t\tstruct bpf_cgroup_storage *this;\n\n\t\tthis = container_of(*new, struct bpf_cgroup_storage, node);\n\n\t\tparent = *new;\n\t\tswitch (bpf_cgroup_storage_key_cmp(&storage->key, &this->key)) {\n\t\tcase -1:\n\t\t\tnew = &((*new)->rb_left);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnew = &((*new)->rb_right);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&storage->node, parent, new);\n\trb_insert_color(&storage->node, root);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_storage_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "47-81",
    "snippet": "static struct bpf_cgroup_storage *cgroup_storage_lookup(\n\tstruct bpf_cgroup_storage_map *map, struct bpf_cgroup_storage_key *key,\n\tbool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_key_cmp",
          "args": [
            "key",
            "&storage->key"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_key_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "32-45",
          "snippet": "static int bpf_cgroup_storage_key_cmp(\n\tconst struct bpf_cgroup_storage_key *key1,\n\tconst struct bpf_cgroup_storage_key *key2)\n{\n\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)\n\t\treturn -1;\n\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)\n\t\treturn 1;\n\telse if (key1->attach_type < key2->attach_type)\n\t\treturn -1;\n\telse if (key1->attach_type > key2->attach_type)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int bpf_cgroup_storage_key_cmp(\n\tconst struct bpf_cgroup_storage_key *key1,\n\tconst struct bpf_cgroup_storage_key *key2)\n{\n\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)\n\t\treturn -1;\n\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)\n\t\treturn 1;\n\telse if (key1->attach_type < key2->attach_type)\n\t\treturn -1;\n\telse if (key1->attach_type > key2->attach_type)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structbpf_cgroup_storage",
            "node"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage *cgroup_storage_lookup(\n\tstruct bpf_cgroup_storage_map *map, struct bpf_cgroup_storage_key *key,\n\tbool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "bpf_cgroup_storage_key_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "32-45",
    "snippet": "static int bpf_cgroup_storage_key_cmp(\n\tconst struct bpf_cgroup_storage_key *key1,\n\tconst struct bpf_cgroup_storage_key *key2)\n{\n\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)\n\t\treturn -1;\n\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)\n\t\treturn 1;\n\telse if (key1->attach_type < key2->attach_type)\n\t\treturn -1;\n\telse if (key1->attach_type > key2->attach_type)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int bpf_cgroup_storage_key_cmp(\n\tconst struct bpf_cgroup_storage_key *key1,\n\tconst struct bpf_cgroup_storage_key *key2)\n{\n\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)\n\t\treturn -1;\n\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)\n\t\treturn 1;\n\telse if (key1->attach_type < key2->attach_type)\n\t\treturn -1;\n\telse if (key1->attach_type > key2->attach_type)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "map_to_storage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
    "lines": "27-30",
    "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_cgroup_storage_map",
            "map"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
  }
]