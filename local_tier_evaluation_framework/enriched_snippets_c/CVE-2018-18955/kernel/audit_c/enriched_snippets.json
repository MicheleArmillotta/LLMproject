[
  {
    "function_name": "audit_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2372-2385",
    "snippet": "void audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,\n\t       const char *fmt, ...)\n{\n\tstruct audit_buffer *ab;\n\tva_list args;\n\n\tab = audit_log_start(ctx, gfp_mask, type);\n\tif (ab) {\n\t\tva_start(args, fmt);\n\t\taudit_log_vformat(ab, fmt, args);\n\t\tva_end(args);\n\t\taudit_log_end(ab);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_vformat",
          "args": [
            "ab",
            "fmt",
            "args"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_vformat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1836-1872",
          "snippet": "static void audit_log_vformat(struct audit_buffer *ab, const char *fmt,\n\t\t\t      va_list args)\n{\n\tint len, avail;\n\tstruct sk_buff *skb;\n\tva_list args2;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tif (avail == 0) {\n\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);\n\t\tif (!avail)\n\t\t\tgoto out;\n\t}\n\tva_copy(args2, args);\n\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);\n\tif (len >= avail) {\n\t\t/* The printk buffer is 1024 bytes long, so if we get\n\t\t * here and AUDIT_BUFSIZ is at least 1024, then we can\n\t\t * log everything that printk could have logged. */\n\t\tavail = audit_expand(ab,\n\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));\n\t\tif (!avail)\n\t\t\tgoto out_va_end;\n\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);\n\t}\n\tif (len > 0)\n\t\tskb_put(skb, len);\nout_va_end:\n\tva_end(args2);\nout:\n\treturn;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_BUFSIZ 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nstatic void audit_log_vformat(struct audit_buffer *ab, const char *fmt,\n\t\t\t      va_list args)\n{\n\tint len, avail;\n\tstruct sk_buff *skb;\n\tva_list args2;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tif (avail == 0) {\n\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);\n\t\tif (!avail)\n\t\t\tgoto out;\n\t}\n\tva_copy(args2, args);\n\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);\n\tif (len >= avail) {\n\t\t/* The printk buffer is 1024 bytes long, so if we get\n\t\t * here and AUDIT_BUFSIZ is at least 1024, then we can\n\t\t * log everything that printk could have logged. */\n\t\tavail = audit_expand(ab,\n\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));\n\t\tif (!avail)\n\t\t\tgoto out_va_end;\n\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);\n\t}\n\tif (len > 0)\n\t\tskb_put(skb, len);\nout_va_end:\n\tva_end(args2);\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "ctx",
            "gfp_mask",
            "type"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,\n\t       const char *fmt, ...)\n{\n\tstruct audit_buffer *ab;\n\tva_list args;\n\n\tab = audit_log_start(ctx, gfp_mask, type);\n\tif (ab) {\n\t\tva_start(args, fmt);\n\t\taudit_log_vformat(ab, fmt, args);\n\t\tva_end(args);\n\t\taudit_log_end(ab);\n\t}\n}"
  },
  {
    "function_name": "audit_log_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2334-2358",
    "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sk_buff_head audit_queue;",
      "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_buffer_free",
          "args": [
            "ab"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "audit_buffer_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1662-1669",
          "snippet": "static void audit_buffer_free(struct audit_buffer *ab)\n{\n\tif (!ab)\n\t\treturn;\n\n\tkfree_skb(ab->skb);\n\tkmem_cache_free(audit_buffer_cache, ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *audit_buffer_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *audit_buffer_cache;\n\nstatic void audit_buffer_free(struct audit_buffer *ab)\n{\n\tif (!ab)\n\t\treturn;\n\n\tkfree_skb(ab->skb);\n\tkmem_cache_free(audit_buffer_cache, ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_lost",
          "args": [
            "\"rate limit exceeded\""
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_lost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "362-392",
          "snippet": "void audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
            "static u32\taudit_rate_limit;",
            "static u32\taudit_backlog_limit = 64;",
            "static atomic_t\taudit_lost = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&kauditd_wait"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_tail",
          "args": [
            "&audit_queue",
            "skb"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_hdr",
          "args": [
            "skb"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_rate_check",
          "args": [],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "audit_rate_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "325-352",
          "snippet": "static inline int audit_rate_check(void)\n{\n\tstatic unsigned long\tlast_check = 0;\n\tstatic int\t\tmessages   = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tunsigned long\t\telapsed;\n\tint\t\t\tretval\t   = 0;\n\n\tif (!audit_rate_limit) return 1;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (++messages < audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow     = jiffies;\n\t\telapsed = now - last_check;\n\t\tif (elapsed > HZ) {\n\t\t\tlast_check = now;\n\t\t\tmessages   = 0;\n\t\t\tretval     = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lock, flags);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_rate_limit;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_rate_limit;\n\nstatic inline int audit_rate_check(void)\n{\n\tstatic unsigned long\tlast_check = 0;\n\tstatic int\t\tmessages   = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tunsigned long\t\telapsed;\n\tint\t\t\tretval\t   = 0;\n\n\tif (!audit_rate_limit) return 1;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (++messages < audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow     = jiffies;\n\t\telapsed = now - last_check;\n\t\tif (elapsed > HZ) {\n\t\t\tlast_check = now;\n\t\t\tmessages   = 0;\n\t\t\tretval     = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lock, flags);\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
  },
  {
    "function_name": "audit_log_link_denied",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2308-2323",
    "snippet": "void audit_log_link_denied(const char *operation)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled || audit_dummy_context())\n\t\treturn;\n\n\t/* Generate AUDIT_ANOM_LINK with subject, operation, outcome. */\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_ANOM_LINK);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"op=%s\", operation);\n\taudit_log_task_info(ab, current);\n\taudit_log_format(ab, \" res=0\");\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32\t\taudit_enabled = AUDIT_OFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" res=0\""
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_task_info",
          "args": [
            "ab",
            "current"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2267-2301",
          "snippet": "void audit_log_task_info(struct audit_buffer *ab, struct task_struct *tsk)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(tsk->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\t/* tsk == current */\n\tcred = current_cred();\n\ttty = audit_get_tty(tsk);\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(tsk),\n\t\t\t task_tgid_nr(tsk),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(tsk)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(tsk));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, tsk));\n\taudit_log_d_path_exe(ab, tsk->mm);\n\taudit_log_task_context(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_task_info(struct audit_buffer *ab, struct task_struct *tsk)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(tsk->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\t/* tsk == current */\n\tcred = current_cred();\n\ttty = audit_get_tty(tsk);\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(tsk),\n\t\t\t task_tgid_nr(tsk),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(tsk)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(tsk));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, tsk));\n\taudit_log_d_path_exe(ab, tsk->mm);\n\taudit_log_task_context(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_ANOM_LINK"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_dummy_context",
          "args": [],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nvoid audit_log_link_denied(const char *operation)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled || audit_dummy_context())\n\t\treturn;\n\n\t/* Generate AUDIT_ANOM_LINK with subject, operation, outcome. */\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_ANOM_LINK);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"op=%s\", operation);\n\taudit_log_task_info(ab, current);\n\taudit_log_format(ab, \" res=0\");\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_log_task_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2267-2301",
    "snippet": "void audit_log_task_info(struct audit_buffer *ab, struct task_struct *tsk)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(tsk->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\t/* tsk == current */\n\tcred = current_cred();\n\ttty = audit_get_tty(tsk);\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(tsk),\n\t\t\t task_tgid_nr(tsk),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(tsk)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(tsk));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, tsk));\n\taudit_log_d_path_exe(ab, tsk->mm);\n\taudit_log_task_context(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "ab"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2203-2228",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_task_getsecid(current, &sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_task_getsecid(current, &sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_d_path_exe",
          "args": [
            "ab",
            "tsk->mm"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_d_path_exe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2231-2248",
          "snippet": "void audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "get_task_comm(comm, tsk)"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2011-2014",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_comm",
          "args": [
            "comm",
            "tsk"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" comm=\""
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_tty",
          "args": [
            "tty"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2262-2265",
          "snippet": "void audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "tsk"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tty_name",
          "args": [
            "tty"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "cred->fsgid"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "503-511",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "cred->fsuid"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "tsk"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "tsk"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_ppid_nr",
          "args": [
            "tsk"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_tty",
          "args": [
            "tsk"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2250-2260",
          "snippet": "struct tty_struct *audit_get_tty(struct task_struct *tsk)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\tif (tsk->signal)\n\t\ttty = tty_kref_get(tsk->signal->tty);\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n\treturn tty;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct tty_struct *audit_get_tty(struct task_struct *tsk)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\tif (tsk->signal)\n\t\ttty = tty_kref_get(tsk->signal->tty);\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n\treturn tty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_task_info(struct audit_buffer *ab, struct task_struct *tsk)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(tsk->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\t/* tsk == current */\n\tcred = current_cred();\n\ttty = audit_get_tty(tsk);\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(tsk),\n\t\t\t task_tgid_nr(tsk),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(tsk)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(tsk));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, tsk));\n\taudit_log_d_path_exe(ab, tsk->mm);\n\taudit_log_task_context(ab);\n}"
  },
  {
    "function_name": "audit_put_tty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2262-2265",
    "snippet": "void audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tty_kref_put",
          "args": [
            "tty"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}"
  },
  {
    "function_name": "audit_get_tty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2250-2260",
    "snippet": "struct tty_struct *audit_get_tty(struct task_struct *tsk)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\tif (tsk->signal)\n\t\ttty = tty_kref_get(tsk->signal->tty);\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n\treturn tty;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&tsk->sighand->siglock",
            "flags"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tty_kref_get",
          "args": [
            "tsk->signal->tty"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&tsk->sighand->siglock",
            "flags"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct tty_struct *audit_get_tty(struct task_struct *tsk)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\tif (tsk->signal)\n\t\ttty = tty_kref_get(tsk->signal->tty);\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n\treturn tty;\n}"
  },
  {
    "function_name": "audit_log_d_path_exe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2231-2248",
    "snippet": "void audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" exe=(null)\""
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "exe_file"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_d_path",
          "args": [
            "ab",
            "\" exe=\"",
            "&exe_file->f_path"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_d_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2017-2038",
          "snippet": "void audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_string(ab, \"<no_memory>\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_string(ab, \"<too_long>\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_string(ab, \"<no_memory>\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_string(ab, \"<too_long>\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mm_exe_file",
          "args": [
            "mm"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "get_mm_exe_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1123-1133",
          "snippet": "struct file *get_mm_exe_file(struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\trcu_read_lock();\n\texe_file = rcu_dereference(mm->exe_file);\n\tif (exe_file && !get_file_rcu(exe_file))\n\t\texe_file = NULL;\n\trcu_read_unlock();\n\treturn exe_file;\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstruct file *get_mm_exe_file(struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\trcu_read_lock();\n\texe_file = rcu_dereference(mm->exe_file);\n\tif (exe_file && !get_file_rcu(exe_file))\n\t\texe_file = NULL;\n\trcu_read_unlock();\n\treturn exe_file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}"
  },
  {
    "function_name": "audit_log_task_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2203-2228",
    "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_task_getsecid(current, &sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"error in audit_log_task_context\""
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "310-323",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "ctx",
            "len"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" subj=%s\"",
            "ctx"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_secid_to_secctx",
          "args": [
            "sid",
            "&ctx",
            "&len"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_task_getsecid",
          "args": [
            "current",
            "&sid"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_task_getsecid(current, &sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
  },
  {
    "function_name": "audit_log_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2120-2201",
    "snippet": "void audit_log_name(struct audit_context *context, struct audit_names *n,\n\t\t    const struct path *path, int record_num, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PATH);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"item=%d\", record_num);\n\n\tif (path)\n\t\taudit_log_d_path(ab, \" name=\", path);\n\telse if (n->name) {\n\t\tswitch (n->name_len) {\n\t\tcase AUDIT_NAME_FULL:\n\t\t\t/* log the full path */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_untrustedstring(ab, n->name->name);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t/* name was specified as a relative path and the\n\t\t\t * directory component is the cwd */\n\t\t\taudit_log_d_path(ab, \" name=\", &context->pwd);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* log the name's directory component */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_n_untrustedstring(ab, n->name->name,\n\t\t\t\t\t\t    n->name_len);\n\t\t}\n\t} else\n\t\taudit_log_format(ab, \" name=(null)\");\n\n\tif (n->ino != AUDIT_INO_UNSET)\n\t\taudit_log_format(ab, \" inode=%lu\"\n\t\t\t\t \" dev=%02x:%02x mode=%#ho\"\n\t\t\t\t \" ouid=%u ogid=%u rdev=%02x:%02x\",\n\t\t\t\t n->ino,\n\t\t\t\t MAJOR(n->dev),\n\t\t\t\t MINOR(n->dev),\n\t\t\t\t n->mode,\n\t\t\t\t from_kuid(&init_user_ns, n->uid),\n\t\t\t\t from_kgid(&init_user_ns, n->gid),\n\t\t\t\t MAJOR(n->rdev),\n\t\t\t\t MINOR(n->rdev));\n\tif (n->osid != 0) {\n\t\tchar *ctx = NULL;\n\t\tu32 len;\n\t\tif (security_secid_to_secctx(\n\t\t\tn->osid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" osid=%u\", n->osid);\n\t\t\tif (call_panic)\n\t\t\t\t*call_panic = 2;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\n\t/* log the audit_names record type */\n\taudit_log_format(ab, \" nametype=\");\n\tswitch(n->type) {\n\tcase AUDIT_TYPE_NORMAL:\n\t\taudit_log_format(ab, \"NORMAL\");\n\t\tbreak;\n\tcase AUDIT_TYPE_PARENT:\n\t\taudit_log_format(ab, \"PARENT\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_DELETE:\n\t\taudit_log_format(ab, \"DELETE\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_CREATE:\n\t\taudit_log_format(ab, \"CREATE\");\n\t\tbreak;\n\tdefault:\n\t\taudit_log_format(ab, \"UNKNOWN\");\n\t\tbreak;\n\t}\n\n\taudit_log_fcaps(ab, n);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_fcaps",
          "args": [
            "ab",
            "n"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_fcaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2068-2074",
          "snippet": "static void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)\n{\n\taudit_log_cap(ab, \"cap_fp\", &name->fcap.permitted);\n\taudit_log_cap(ab, \"cap_fi\", &name->fcap.inheritable);\n\taudit_log_format(ab, \" cap_fe=%d cap_fver=%x\",\n\t\t\t name->fcap.fE, name->fcap_ver);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)\n{\n\taudit_log_cap(ab, \"cap_fp\", &name->fcap.permitted);\n\taudit_log_cap(ab, \"cap_fi\", &name->fcap.inheritable);\n\taudit_log_format(ab, \" cap_fe=%d cap_fver=%x\",\n\t\t\t name->fcap.fE, name->fcap_ver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"UNKNOWN\""
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "ctx",
            "len"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_secid_to_secctx",
          "args": [
            "n->osid",
            "&ctx",
            "&len"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "n->rdev"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "n->rdev"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "n->gid"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "503-511",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "n->uid"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "n->dev"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "n->dev"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_n_untrustedstring",
          "args": [
            "ab",
            "n->name->name",
            "n->name_len"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_untrustedstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1994-2001",
          "snippet": "void audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_d_path",
          "args": [
            "ab",
            "\" name=\"",
            "&context->pwd"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_d_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2017-2038",
          "snippet": "void audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_string(ab, \"<no_memory>\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_string(ab, \"<too_long>\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_string(ab, \"<no_memory>\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_string(ab, \"<too_long>\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "n->name->name"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2011-2014",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "context",
            "GFP_KERNEL",
            "AUDIT_PATH"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_name(struct audit_context *context, struct audit_names *n,\n\t\t    const struct path *path, int record_num, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PATH);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"item=%d\", record_num);\n\n\tif (path)\n\t\taudit_log_d_path(ab, \" name=\", path);\n\telse if (n->name) {\n\t\tswitch (n->name_len) {\n\t\tcase AUDIT_NAME_FULL:\n\t\t\t/* log the full path */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_untrustedstring(ab, n->name->name);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t/* name was specified as a relative path and the\n\t\t\t * directory component is the cwd */\n\t\t\taudit_log_d_path(ab, \" name=\", &context->pwd);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* log the name's directory component */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_n_untrustedstring(ab, n->name->name,\n\t\t\t\t\t\t    n->name_len);\n\t\t}\n\t} else\n\t\taudit_log_format(ab, \" name=(null)\");\n\n\tif (n->ino != AUDIT_INO_UNSET)\n\t\taudit_log_format(ab, \" inode=%lu\"\n\t\t\t\t \" dev=%02x:%02x mode=%#ho\"\n\t\t\t\t \" ouid=%u ogid=%u rdev=%02x:%02x\",\n\t\t\t\t n->ino,\n\t\t\t\t MAJOR(n->dev),\n\t\t\t\t MINOR(n->dev),\n\t\t\t\t n->mode,\n\t\t\t\t from_kuid(&init_user_ns, n->uid),\n\t\t\t\t from_kgid(&init_user_ns, n->gid),\n\t\t\t\t MAJOR(n->rdev),\n\t\t\t\t MINOR(n->rdev));\n\tif (n->osid != 0) {\n\t\tchar *ctx = NULL;\n\t\tu32 len;\n\t\tif (security_secid_to_secctx(\n\t\t\tn->osid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" osid=%u\", n->osid);\n\t\t\tif (call_panic)\n\t\t\t\t*call_panic = 2;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\n\t/* log the audit_names record type */\n\taudit_log_format(ab, \" nametype=\");\n\tswitch(n->type) {\n\tcase AUDIT_TYPE_NORMAL:\n\t\taudit_log_format(ab, \"NORMAL\");\n\t\tbreak;\n\tcase AUDIT_TYPE_PARENT:\n\t\taudit_log_format(ab, \"PARENT\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_DELETE:\n\t\taudit_log_format(ab, \"DELETE\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_CREATE:\n\t\taudit_log_format(ab, \"CREATE\");\n\t\tbreak;\n\tdefault:\n\t\taudit_log_format(ab, \"UNKNOWN\");\n\t\tbreak;\n\t}\n\n\taudit_log_fcaps(ab, n);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_copy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2099-2110",
    "snippet": "void audit_copy_inode(struct audit_names *name, const struct dentry *dentry,\n\t\t      struct inode *inode)\n{\n\tname->ino   = inode->i_ino;\n\tname->dev   = inode->i_sb->s_dev;\n\tname->mode  = inode->i_mode;\n\tname->uid   = inode->i_uid;\n\tname->gid   = inode->i_gid;\n\tname->rdev  = inode->i_rdev;\n\tsecurity_inode_getsecid(inode, &name->osid);\n\taudit_copy_fcaps(name, dentry);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_copy_fcaps",
          "args": [
            "name",
            "dentry"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "audit_copy_fcaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2076-2096",
          "snippet": "static inline int audit_copy_fcaps(struct audit_names *name,\n\t\t\t\t   const struct dentry *dentry)\n{\n\tstruct cpu_vfs_cap_data caps;\n\tint rc;\n\n\tif (!dentry)\n\t\treturn 0;\n\n\trc = get_vfs_caps_from_disk(dentry, &caps);\n\tif (rc)\n\t\treturn rc;\n\n\tname->fcap.permitted = caps.permitted;\n\tname->fcap.inheritable = caps.inheritable;\n\tname->fcap.fE = !!(caps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tname->fcap_ver = (caps.magic_etc & VFS_CAP_REVISION_MASK) >>\n\t\t\t\tVFS_CAP_REVISION_SHIFT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline int audit_copy_fcaps(struct audit_names *name,\n\t\t\t\t   const struct dentry *dentry)\n{\n\tstruct cpu_vfs_cap_data caps;\n\tint rc;\n\n\tif (!dentry)\n\t\treturn 0;\n\n\trc = get_vfs_caps_from_disk(dentry, &caps);\n\tif (rc)\n\t\treturn rc;\n\n\tname->fcap.permitted = caps.permitted;\n\tname->fcap.inheritable = caps.inheritable;\n\tname->fcap.fE = !!(caps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tname->fcap_ver = (caps.magic_etc & VFS_CAP_REVISION_MASK) >>\n\t\t\t\tVFS_CAP_REVISION_SHIFT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_inode_getsecid",
          "args": [
            "inode",
            "&name->osid"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_copy_inode(struct audit_names *name, const struct dentry *dentry,\n\t\t      struct inode *inode)\n{\n\tname->ino   = inode->i_ino;\n\tname->dev   = inode->i_sb->s_dev;\n\tname->mode  = inode->i_mode;\n\tname->uid   = inode->i_uid;\n\tname->gid   = inode->i_gid;\n\tname->rdev  = inode->i_rdev;\n\tsecurity_inode_getsecid(inode, &name->osid);\n\taudit_copy_fcaps(name, dentry);\n}"
  },
  {
    "function_name": "audit_copy_fcaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2076-2096",
    "snippet": "static inline int audit_copy_fcaps(struct audit_names *name,\n\t\t\t\t   const struct dentry *dentry)\n{\n\tstruct cpu_vfs_cap_data caps;\n\tint rc;\n\n\tif (!dentry)\n\t\treturn 0;\n\n\trc = get_vfs_caps_from_disk(dentry, &caps);\n\tif (rc)\n\t\treturn rc;\n\n\tname->fcap.permitted = caps.permitted;\n\tname->fcap.inheritable = caps.inheritable;\n\tname->fcap.fE = !!(caps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tname->fcap_ver = (caps.magic_etc & VFS_CAP_REVISION_MASK) >>\n\t\t\t\tVFS_CAP_REVISION_SHIFT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_vfs_caps_from_disk",
          "args": [
            "dentry",
            "&caps"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline int audit_copy_fcaps(struct audit_names *name,\n\t\t\t\t   const struct dentry *dentry)\n{\n\tstruct cpu_vfs_cap_data caps;\n\tint rc;\n\n\tif (!dentry)\n\t\treturn 0;\n\n\trc = get_vfs_caps_from_disk(dentry, &caps);\n\tif (rc)\n\t\treturn rc;\n\n\tname->fcap.permitted = caps.permitted;\n\tname->fcap.inheritable = caps.inheritable;\n\tname->fcap.fE = !!(caps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tname->fcap_ver = (caps.magic_etc & VFS_CAP_REVISION_MASK) >>\n\t\t\t\tVFS_CAP_REVISION_SHIFT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_log_fcaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2068-2074",
    "snippet": "static void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)\n{\n\taudit_log_cap(ab, \"cap_fp\", &name->fcap.permitted);\n\taudit_log_cap(ab, \"cap_fi\", &name->fcap.inheritable);\n\taudit_log_format(ab, \" cap_fe=%d cap_fver=%x\",\n\t\t\t name->fcap.fE, name->fcap_ver);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" cap_fe=%d cap_fver=%x\"",
            "name->fcap.fE",
            "name->fcap_ver"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_cap",
          "args": [
            "ab",
            "\"cap_fi\"",
            "&name->fcap.inheritable"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2057-2066",
          "snippet": "void audit_log_cap(struct audit_buffer *ab, char *prefix, kernel_cap_t *cap)\n{\n\tint i;\n\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i) {\n\t\taudit_log_format(ab, \"%08x\",\n\t\t\t\t cap->cap[CAP_LAST_U32 - i]);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_cap(struct audit_buffer *ab, char *prefix, kernel_cap_t *cap)\n{\n\tint i;\n\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i) {\n\t\taudit_log_format(ab, \"%08x\",\n\t\t\t\t cap->cap[CAP_LAST_U32 - i]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)\n{\n\taudit_log_cap(ab, \"cap_fp\", &name->fcap.permitted);\n\taudit_log_cap(ab, \"cap_fi\", &name->fcap.inheritable);\n\taudit_log_format(ab, \" cap_fe=%d cap_fver=%x\",\n\t\t\t name->fcap.fE, name->fcap_ver);\n}"
  },
  {
    "function_name": "audit_log_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2057-2066",
    "snippet": "void audit_log_cap(struct audit_buffer *ab, char *prefix, kernel_cap_t *cap)\n{\n\tint i;\n\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i) {\n\t\taudit_log_format(ab, \"%08x\",\n\t\t\t\t cap->cap[CAP_LAST_U32 - i]);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"%08x\"",
            "cap->cap[CAP_LAST_U32 - i]"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_cap(struct audit_buffer *ab, char *prefix, kernel_cap_t *cap)\n{\n\tint i;\n\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i) {\n\t\taudit_log_format(ab, \"%08x\",\n\t\t\t\t cap->cap[CAP_LAST_U32 - i]);\n\t}\n}"
  },
  {
    "function_name": "audit_log_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2048-2055",
    "snippet": "void audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"(null)\""
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "key"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2011-2014",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}"
  },
  {
    "function_name": "audit_log_session_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2040-2046",
    "snippet": "void audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \" auid=%u ses=%u\", auid, sessionid);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" auid=%u ses=%u\"",
            "auid",
            "sessionid"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "audit_get_loginuid(current)"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "current"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \" auid=%u ses=%u\", auid, sessionid);\n}"
  },
  {
    "function_name": "audit_log_d_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2017-2038",
    "snippet": "void audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_string(ab, \"<no_memory>\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_string(ab, \"<too_long>\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pathname"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "p"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2011-2014",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_string",
          "args": [
            "ab",
            "\"<too_long>\""
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_path",
          "args": [
            "path",
            "pathname",
            "PATH_MAX+11"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_d_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2017-2038",
          "snippet": "void audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_string(ab, \"<no_memory>\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_string(ab, \"<too_long>\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_string",
          "args": [
            "ab",
            "\"<no_memory>\""
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PATH_MAX+11",
            "ab->gfp_mask"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"%s\"",
            "prefix"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_string(ab, \"<no_memory>\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_string(ab, \"<too_long>\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}"
  },
  {
    "function_name": "audit_log_untrustedstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "2011-2014",
    "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_n_untrustedstring",
          "args": [
            "ab",
            "string",
            "strlen(string)"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_untrustedstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1994-2001",
          "snippet": "void audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "string"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
  },
  {
    "function_name": "audit_log_n_untrustedstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1994-2001",
    "snippet": "void audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_n_string",
          "args": [
            "ab",
            "string",
            "len"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1937-1963",
          "snippet": "void audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = slen + 3;\t/* enclosing quotes + null terminator */\n\tif (new_len > avail) {\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\tptr = skb_tail_pointer(skb);\n\t*ptr++ = '\"';\n\tmemcpy(ptr, string, slen);\n\tptr += slen;\n\t*ptr++ = '\"';\n\t*ptr = 0;\n\tskb_put(skb, slen + 2);\t/* don't include null terminator */\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = slen + 3;\t/* enclosing quotes + null terminator */\n\tif (new_len > avail) {\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\tptr = skb_tail_pointer(skb);\n\t*ptr++ = '\"';\n\tmemcpy(ptr, string, slen);\n\tptr += slen;\n\t*ptr++ = '\"';\n\t*ptr = 0;\n\tskb_put(skb, slen + 2);\t/* don't include null terminator */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_n_hex",
          "args": [
            "ab",
            "string",
            "len"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1904-1931",
          "snippet": "void audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_BUFSIZ 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nvoid audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_string_contains_control",
          "args": [
            "string",
            "len"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "audit_string_contains_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1970-1978",
          "snippet": "bool audit_string_contains_control(const char *string, size_t len)\n{\n\tconst unsigned char *p;\n\tfor (p = string; p < (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nbool audit_string_contains_control(const char *string, size_t len)\n{\n\tconst unsigned char *p;\n\tfor (p = string; p < (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}"
  },
  {
    "function_name": "audit_string_contains_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1970-1978",
    "snippet": "bool audit_string_contains_control(const char *string, size_t len)\n{\n\tconst unsigned char *p;\n\tfor (p = string; p < (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nbool audit_string_contains_control(const char *string, size_t len)\n{\n\tconst unsigned char *p;\n\tfor (p = string; p < (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "audit_log_n_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1937-1963",
    "snippet": "void audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = slen + 3;\t/* enclosing quotes + null terminator */\n\tif (new_len > avail) {\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\tptr = skb_tail_pointer(skb);\n\t*ptr++ = '\"';\n\tmemcpy(ptr, string, slen);\n\tptr += slen;\n\t*ptr++ = '\"';\n\t*ptr = 0;\n\tskb_put(skb, slen + 2);\t/* don't include null terminator */\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skb_put",
          "args": [
            "skb",
            "slen + 2"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "string",
            "slen"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_tail_pointer",
          "args": [
            "skb"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_expand",
          "args": [
            "ab",
            "new_len"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "audit_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1814-1828",
          "snippet": "static inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_tailroom",
          "args": [
            "skb"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ab->skb"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = slen + 3;\t/* enclosing quotes + null terminator */\n\tif (new_len > avail) {\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\tptr = skb_tail_pointer(skb);\n\t*ptr++ = '\"';\n\tmemcpy(ptr, string, slen);\n\tptr += slen;\n\t*ptr++ = '\"';\n\t*ptr = 0;\n\tskb_put(skb, slen + 2);\t/* don't include null terminator */\n}"
  },
  {
    "function_name": "audit_log_n_hex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1904-1931",
    "snippet": "void audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_BUFSIZ 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skb_put",
          "args": [
            "skb",
            "len << 1"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_byte_pack_upper",
          "args": [
            "ptr",
            "buf[i]"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_tail_pointer",
          "args": [
            "skb"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_expand",
          "args": [
            "ab",
            "new_len"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "audit_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1814-1828",
          "snippet": "static inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_tailroom",
          "args": [
            "skb"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ab->skb"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nvoid audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}"
  },
  {
    "function_name": "audit_log_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1882-1891",
    "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_vformat",
          "args": [
            "ab",
            "fmt",
            "args"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_vformat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1836-1872",
          "snippet": "static void audit_log_vformat(struct audit_buffer *ab, const char *fmt,\n\t\t\t      va_list args)\n{\n\tint len, avail;\n\tstruct sk_buff *skb;\n\tva_list args2;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tif (avail == 0) {\n\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);\n\t\tif (!avail)\n\t\t\tgoto out;\n\t}\n\tva_copy(args2, args);\n\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);\n\tif (len >= avail) {\n\t\t/* The printk buffer is 1024 bytes long, so if we get\n\t\t * here and AUDIT_BUFSIZ is at least 1024, then we can\n\t\t * log everything that printk could have logged. */\n\t\tavail = audit_expand(ab,\n\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));\n\t\tif (!avail)\n\t\t\tgoto out_va_end;\n\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);\n\t}\n\tif (len > 0)\n\t\tskb_put(skb, len);\nout_va_end:\n\tva_end(args2);\nout:\n\treturn;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_BUFSIZ 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nstatic void audit_log_vformat(struct audit_buffer *ab, const char *fmt,\n\t\t\t      va_list args)\n{\n\tint len, avail;\n\tstruct sk_buff *skb;\n\tva_list args2;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tif (avail == 0) {\n\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);\n\t\tif (!avail)\n\t\t\tgoto out;\n\t}\n\tva_copy(args2, args);\n\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);\n\tif (len >= avail) {\n\t\t/* The printk buffer is 1024 bytes long, so if we get\n\t\t * here and AUDIT_BUFSIZ is at least 1024, then we can\n\t\t * log everything that printk could have logged. */\n\t\tavail = audit_expand(ab,\n\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));\n\t\tif (!avail)\n\t\t\tgoto out_va_end;\n\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);\n\t}\n\tif (len > 0)\n\t\tskb_put(skb, len);\nout_va_end:\n\tva_end(args2);\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
  },
  {
    "function_name": "audit_log_vformat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1836-1872",
    "snippet": "static void audit_log_vformat(struct audit_buffer *ab, const char *fmt,\n\t\t\t      va_list args)\n{\n\tint len, avail;\n\tstruct sk_buff *skb;\n\tva_list args2;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tif (avail == 0) {\n\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);\n\t\tif (!avail)\n\t\t\tgoto out;\n\t}\n\tva_copy(args2, args);\n\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);\n\tif (len >= avail) {\n\t\t/* The printk buffer is 1024 bytes long, so if we get\n\t\t * here and AUDIT_BUFSIZ is at least 1024, then we can\n\t\t * log everything that printk could have logged. */\n\t\tavail = audit_expand(ab,\n\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));\n\t\tif (!avail)\n\t\t\tgoto out_va_end;\n\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);\n\t}\n\tif (len > 0)\n\t\tskb_put(skb, len);\nout_va_end:\n\tva_end(args2);\nout:\n\treturn;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_BUFSIZ 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args2"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_put",
          "args": [
            "skb",
            "len"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "skb_tail_pointer(skb)",
            "avail",
            "fmt",
            "args2"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_tail_pointer",
          "args": [
            "skb"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_expand",
          "args": [
            "ab",
            "max_t(unsigned, AUDIT_BUFSIZ, 1+len-avail)"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "audit_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1814-1828",
          "snippet": "static inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsigned",
            "AUDIT_BUFSIZ",
            "1+len-avail"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1397-1431",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "skb_tail_pointer(skb)",
            "avail",
            "fmt",
            "args"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_tail_pointer",
          "args": [
            "skb"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_copy",
          "args": [
            "args2",
            "args"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_tailroom",
          "args": [
            "skb"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ab->skb"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nstatic void audit_log_vformat(struct audit_buffer *ab, const char *fmt,\n\t\t\t      va_list args)\n{\n\tint len, avail;\n\tstruct sk_buff *skb;\n\tva_list args2;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tif (avail == 0) {\n\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);\n\t\tif (!avail)\n\t\t\tgoto out;\n\t}\n\tva_copy(args2, args);\n\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);\n\tif (len >= avail) {\n\t\t/* The printk buffer is 1024 bytes long, so if we get\n\t\t * here and AUDIT_BUFSIZ is at least 1024, then we can\n\t\t * log everything that printk could have logged. */\n\t\tavail = audit_expand(ab,\n\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));\n\t\tif (!avail)\n\t\t\tgoto out_va_end;\n\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);\n\t}\n\tif (len > 0)\n\t\tskb_put(skb, len);\nout_va_end:\n\tva_end(args2);\nout:\n\treturn;\n}"
  },
  {
    "function_name": "audit_expand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1814-1828",
    "snippet": "static inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_lost",
          "args": [
            "\"out of memory in audit_expand\""
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_lost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "362-392",
          "snippet": "void audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
            "static u32\taudit_rate_limit;",
            "static u32\taudit_backlog_limit = 64;",
            "static atomic_t\taudit_lost = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_tailroom",
          "args": [
            "skb"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pskb_expand_head",
          "args": [
            "skb",
            "0",
            "extra",
            "ab->gfp_mask"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_tailroom",
          "args": [
            "skb"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}"
  },
  {
    "function_name": "audit_log_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1744-1804",
    "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_INITIALIZED\t1"
    ],
    "globals_used": [
      "static int\taudit_initialized;",
      "static u32\taudit_backlog_limit = 64;",
      "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
      "static struct sk_buff_head audit_queue;",
      "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
      "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
      "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"audit(%llu.%03lu:%u): \"",
            "(unsigned long long)t.tv_sec",
            "t.tv_nsec/1000000",
            "serial"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_stamp",
          "args": [
            "ab->ctx",
            "&t",
            "&serial"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_stamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1720-1727",
          "snippet": "static inline void audit_get_stamp(struct audit_context *ctx,\n\t\t\t\t   struct timespec64 *t, unsigned int *serial)\n{\n\tif (!ctx || !auditsc_get_stamp(ctx, t, serial)) {\n\t\tktime_get_coarse_real_ts64(t);\n\t\t*serial = audit_serial();\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline void audit_get_stamp(struct audit_context *ctx,\n\t\t\t\t   struct timespec64 *t, unsigned int *serial)\n{\n\tif (!ctx || !auditsc_get_stamp(ctx, t, serial)) {\n\t\tktime_get_coarse_real_ts64(t);\n\t\t*serial = audit_serial();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_lost",
          "args": [
            "\"out of memory in audit_log_start\""
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_lost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "362-392",
          "snippet": "void audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
            "static u32\taudit_rate_limit;",
            "static u32\taudit_backlog_limit = 64;",
            "static atomic_t\taudit_lost = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_buffer_alloc",
          "args": [
            "ctx",
            "gfp_mask",
            "type"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "audit_buffer_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1671-1694",
          "snippet": "static struct audit_buffer *audit_buffer_alloc(struct audit_context *ctx,\n\t\t\t\t\t       gfp_t gfp_mask, int type)\n{\n\tstruct audit_buffer *ab;\n\n\tab = kmem_cache_alloc(audit_buffer_cache, gfp_mask);\n\tif (!ab)\n\t\treturn NULL;\n\n\tab->skb = nlmsg_new(AUDIT_BUFSIZ, gfp_mask);\n\tif (!ab->skb)\n\t\tgoto err;\n\tif (!nlmsg_put(ab->skb, 0, 0, type, 0, 0))\n\t\tgoto err;\n\n\tab->ctx = ctx;\n\tab->gfp_mask = gfp_mask;\n\n\treturn ab;\n\nerr:\n\taudit_buffer_free(ab);\n\treturn NULL;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_BUFSIZ 1024"
          ],
          "globals_used": [
            "static struct kmem_cache *audit_buffer_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nstatic struct kmem_cache *audit_buffer_cache;\n\nstatic struct audit_buffer *audit_buffer_alloc(struct audit_context *ctx,\n\t\t\t\t\t       gfp_t gfp_mask, int type)\n{\n\tstruct audit_buffer *ab;\n\n\tab = kmem_cache_alloc(audit_buffer_cache, gfp_mask);\n\tif (!ab)\n\t\treturn NULL;\n\n\tab->skb = nlmsg_new(AUDIT_BUFSIZ, gfp_mask);\n\tif (!ab->skb)\n\t\tgoto err;\n\tif (!nlmsg_put(ab->skb, 0, 0, type, 0, 0))\n\t\tgoto err;\n\n\tab->ctx = ctx;\n\tab->gfp_mask = gfp_mask;\n\n\treturn ab;\n\nerr:\n\taudit_buffer_free(ab);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"audit_backlog=%d > audit_backlog_limit=%d\\n\"",
            "skb_queue_len(&audit_queue)",
            "audit_backlog_limit"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_len",
          "args": [
            "&audit_queue"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_rate_check",
          "args": [],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "audit_rate_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "325-352",
          "snippet": "static inline int audit_rate_check(void)\n{\n\tstatic unsigned long\tlast_check = 0;\n\tstatic int\t\tmessages   = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tunsigned long\t\telapsed;\n\tint\t\t\tretval\t   = 0;\n\n\tif (!audit_rate_limit) return 1;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (++messages < audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow     = jiffies;\n\t\telapsed = now - last_check;\n\t\tif (elapsed > HZ) {\n\t\t\tlast_check = now;\n\t\t\tmessages   = 0;\n\t\t\tretval     = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lock, flags);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_rate_limit;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_rate_limit;\n\nstatic inline int audit_rate_check(void)\n{\n\tstatic unsigned long\tlast_check = 0;\n\tstatic int\t\tmessages   = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tunsigned long\t\telapsed;\n\tint\t\t\tretval\t   = 0;\n\n\tif (!audit_rate_limit) return 1;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (++messages < audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow     = jiffies;\n\t\telapsed = now - last_check;\n\t\tif (elapsed > HZ) {\n\t\t\tlast_check = now;\n\t\t\tmessages   = 0;\n\t\t\tretval     = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lock, flags);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&audit_backlog_wait",
            "&wait"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "remove_wait_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "39-46",
          "snippet": "void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "stime"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5119-5129",
          "snippet": "long __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nlong __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue_exclusive",
          "args": [
            "&audit_backlog_wait",
            "&wait"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "add_wait_queue_exclusive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "28-36",
          "snippet": "void add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "gfp_mask"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&kauditd_wait"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_len",
          "args": [
            "&audit_queue"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ctl_owner_current",
          "args": [],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_owner_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "264-267",
          "snippet": "static bool audit_ctl_owner_current(void)\n{\n\treturn (current == audit_cmd_mutex.owner);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstatic bool audit_ctl_owner_current(void)\n{\n\treturn (current == audit_cmd_mutex.owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auditd_test_task",
          "args": [
            "current"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_test_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "226-237",
          "snippet": "int auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\n\nint auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!audit_filter(type, AUDIT_FILTER_EXCLUDE)"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_filter",
          "args": [
            "type",
            "AUDIT_FILTER_EXCLUDE"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1312-1383",
          "snippet": "int audit_filter(int msgtype, unsigned int listtype)\n{\n\tstruct audit_entry *e;\n\tint ret = 1; /* Audit by default */\n\n\trcu_read_lock();\n\tif (list_empty(&audit_filter_list[listtype]))\n\t\tgoto unlock_and_return;\n\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {\n\t\tint i, result = 0;\n\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\t\t\tpid_t pid;\n\t\t\tu32 sid;\n\n\t\t\tswitch (f->type) {\n\t\t\tcase AUDIT_PID:\n\t\t\t\tpid = task_pid_nr(current);\n\t\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_UID:\n\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_GID:\n\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID:\n\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),\n\t\t\t\t\t\t\t      f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID_SET:\n\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_MSGTYPE:\n\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_SUBJ_USER:\n\t\t\tcase AUDIT_SUBJ_ROLE:\n\t\t\tcase AUDIT_SUBJ_TYPE:\n\t\t\tcase AUDIT_SUBJ_SEN:\n\t\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t\tif (f->lsm_rule) {\n\t\t\t\t\tsecurity_task_getsecid(current, &sid);\n\t\t\t\t\tresult = security_audit_rule_match(sid,\n\t\t\t\t\t\t\tf->type, f->op, f->lsm_rule, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_EXE:\n\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t\tif (result < 0) /* error */\n\t\t\t\tgoto unlock_and_return;\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result > 0) {\n\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_and_return:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n#if AUDIT_NR_FILTERS != 7\n#error Fix audit_filter_list initialiser\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n#if AUDIT_NR_FILTERS != 7\n#error Fix audit_filter_list initialiser\n#endif\n};\n\nint audit_filter(int msgtype, unsigned int listtype)\n{\n\tstruct audit_entry *e;\n\tint ret = 1; /* Audit by default */\n\n\trcu_read_lock();\n\tif (list_empty(&audit_filter_list[listtype]))\n\t\tgoto unlock_and_return;\n\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {\n\t\tint i, result = 0;\n\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\t\t\tpid_t pid;\n\t\t\tu32 sid;\n\n\t\t\tswitch (f->type) {\n\t\t\tcase AUDIT_PID:\n\t\t\t\tpid = task_pid_nr(current);\n\t\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_UID:\n\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_GID:\n\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID:\n\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),\n\t\t\t\t\t\t\t      f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID_SET:\n\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_MSGTYPE:\n\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_SUBJ_USER:\n\t\t\tcase AUDIT_SUBJ_ROLE:\n\t\t\tcase AUDIT_SUBJ_TYPE:\n\t\t\tcase AUDIT_SUBJ_SEN:\n\t\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t\tif (f->lsm_rule) {\n\t\t\t\t\tsecurity_task_getsecid(current, &sid);\n\t\t\t\t\tresult = security_audit_rule_match(sid,\n\t\t\t\t\t\t\tf->type, f->op, f->lsm_rule, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_EXE:\n\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t\tif (result < 0) /* error */\n\t\t\t\tgoto unlock_and_return;\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result > 0) {\n\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_and_return:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
  },
  {
    "function_name": "audit_get_stamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1720-1727",
    "snippet": "static inline void audit_get_stamp(struct audit_context *ctx,\n\t\t\t\t   struct timespec64 *t, unsigned int *serial)\n{\n\tif (!ctx || !auditsc_get_stamp(ctx, t, serial)) {\n\t\tktime_get_coarse_real_ts64(t);\n\t\t*serial = audit_serial();\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_serial",
          "args": [],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "audit_serial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1713-1718",
          "snippet": "unsigned int audit_serial(void)\n{\n\tstatic atomic_t serial = ATOMIC_INIT(0);\n\n\treturn atomic_add_return(1, &serial);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nunsigned int audit_serial(void)\n{\n\tstatic atomic_t serial = ATOMIC_INIT(0);\n\n\treturn atomic_add_return(1, &serial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_coarse_real_ts64",
          "args": [
            "t"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_coarse_real_ts64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2161-2171",
          "snippet": "void ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "auditsc_get_stamp",
          "args": [
            "ctx",
            "t",
            "serial"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "auditsc_get_stamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "1983-1998",
          "snippet": "int auditsc_get_stamp(struct audit_context *ctx,\n\t\t       struct timespec64 *t, unsigned int *serial)\n{\n\tif (!ctx->in_syscall)\n\t\treturn 0;\n\tif (!ctx->serial)\n\t\tctx->serial = audit_serial();\n\tt->tv_sec  = ctx->ctime.tv_sec;\n\tt->tv_nsec = ctx->ctime.tv_nsec;\n\t*serial    = ctx->serial;\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_RECORD_CONTEXT;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint auditsc_get_stamp(struct audit_context *ctx,\n\t\t       struct timespec64 *t, unsigned int *serial)\n{\n\tif (!ctx->in_syscall)\n\t\treturn 0;\n\tif (!ctx->serial)\n\t\tctx->serial = audit_serial();\n\tt->tv_sec  = ctx->ctime.tv_sec;\n\tt->tv_nsec = ctx->ctime.tv_nsec;\n\t*serial    = ctx->serial;\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_RECORD_CONTEXT;\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic inline void audit_get_stamp(struct audit_context *ctx,\n\t\t\t\t   struct timespec64 *t, unsigned int *serial)\n{\n\tif (!ctx || !auditsc_get_stamp(ctx, t, serial)) {\n\t\tktime_get_coarse_real_ts64(t);\n\t\t*serial = audit_serial();\n\t}\n}"
  },
  {
    "function_name": "audit_serial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1713-1718",
    "snippet": "unsigned int audit_serial(void)\n{\n\tstatic atomic_t serial = ATOMIC_INIT(0);\n\n\treturn atomic_add_return(1, &serial);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "1",
            "&serial"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATOMIC_INIT",
          "args": [
            "0"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nunsigned int audit_serial(void)\n{\n\tstatic atomic_t serial = ATOMIC_INIT(0);\n\n\treturn atomic_add_return(1, &serial);\n}"
  },
  {
    "function_name": "audit_buffer_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1671-1694",
    "snippet": "static struct audit_buffer *audit_buffer_alloc(struct audit_context *ctx,\n\t\t\t\t\t       gfp_t gfp_mask, int type)\n{\n\tstruct audit_buffer *ab;\n\n\tab = kmem_cache_alloc(audit_buffer_cache, gfp_mask);\n\tif (!ab)\n\t\treturn NULL;\n\n\tab->skb = nlmsg_new(AUDIT_BUFSIZ, gfp_mask);\n\tif (!ab->skb)\n\t\tgoto err;\n\tif (!nlmsg_put(ab->skb, 0, 0, type, 0, 0))\n\t\tgoto err;\n\n\tab->ctx = ctx;\n\tab->gfp_mask = gfp_mask;\n\n\treturn ab;\n\nerr:\n\taudit_buffer_free(ab);\n\treturn NULL;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_BUFSIZ 1024"
    ],
    "globals_used": [
      "static struct kmem_cache *audit_buffer_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_buffer_free",
          "args": [
            "ab"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "audit_buffer_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1662-1669",
          "snippet": "static void audit_buffer_free(struct audit_buffer *ab)\n{\n\tif (!ab)\n\t\treturn;\n\n\tkfree_skb(ab->skb);\n\tkmem_cache_free(audit_buffer_cache, ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *audit_buffer_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *audit_buffer_cache;\n\nstatic void audit_buffer_free(struct audit_buffer *ab)\n{\n\tif (!ab)\n\t\treturn;\n\n\tkfree_skb(ab->skb);\n\tkmem_cache_free(audit_buffer_cache, ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_put",
          "args": [
            "ab->skb",
            "0",
            "0",
            "type",
            "0",
            "0"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_new",
          "args": [
            "AUDIT_BUFSIZ",
            "gfp_mask"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "audit_buffer_cache",
            "gfp_mask"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nstatic struct kmem_cache *audit_buffer_cache;\n\nstatic struct audit_buffer *audit_buffer_alloc(struct audit_context *ctx,\n\t\t\t\t\t       gfp_t gfp_mask, int type)\n{\n\tstruct audit_buffer *ab;\n\n\tab = kmem_cache_alloc(audit_buffer_cache, gfp_mask);\n\tif (!ab)\n\t\treturn NULL;\n\n\tab->skb = nlmsg_new(AUDIT_BUFSIZ, gfp_mask);\n\tif (!ab->skb)\n\t\tgoto err;\n\tif (!nlmsg_put(ab->skb, 0, 0, type, 0, 0))\n\t\tgoto err;\n\n\tab->ctx = ctx;\n\tab->gfp_mask = gfp_mask;\n\n\treturn ab;\n\nerr:\n\taudit_buffer_free(ab);\n\treturn NULL;\n}"
  },
  {
    "function_name": "audit_buffer_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1662-1669",
    "snippet": "static void audit_buffer_free(struct audit_buffer *ab)\n{\n\tif (!ab)\n\t\treturn;\n\n\tkfree_skb(ab->skb);\n\tkmem_cache_free(audit_buffer_cache, ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *audit_buffer_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "audit_buffer_cache",
            "ab"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_skb",
          "args": [
            "ab->skb"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *audit_buffer_cache;\n\nstatic void audit_buffer_free(struct audit_buffer *ab)\n{\n\tif (!ab)\n\t\treturn;\n\n\tkfree_skb(ab->skb);\n\tkmem_cache_free(audit_buffer_cache, ab);\n}"
  },
  {
    "function_name": "audit_backlog_limit_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1644-1659",
    "snippet": "static int __init audit_backlog_limit_set(char *str)\n{\n\tu32 audit_backlog_limit_arg;\n\n\tpr_info(\"audit_backlog_limit: \");\n\tif (kstrtouint(str, 0, &audit_backlog_limit_arg)) {\n\t\tpr_cont(\"using default of %u, unable to parse %s\\n\",\n\t\t\taudit_backlog_limit, str);\n\t\treturn 1;\n\t}\n\n\taudit_backlog_limit = audit_backlog_limit_arg;\n\tpr_cont(\"%d\\n\", audit_backlog_limit);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_backlog_limit = 64;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%d\\n\"",
            "audit_backlog_limit"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"using default of %u, unable to parse %s\\n\"",
            "audit_backlog_limit",
            "str"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "str",
            "0",
            "&audit_backlog_limit_arg"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"audit_backlog_limit: \""
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_backlog_limit = 64;\n\nstatic int __init audit_backlog_limit_set(char *str)\n{\n\tu32 audit_backlog_limit_arg;\n\n\tpr_info(\"audit_backlog_limit: \");\n\tif (kstrtouint(str, 0, &audit_backlog_limit_arg)) {\n\t\tpr_cont(\"using default of %u, unable to parse %s\\n\",\n\t\t\taudit_backlog_limit, str);\n\t\treturn 1;\n\t}\n\n\taudit_backlog_limit = audit_backlog_limit_arg;\n\tpr_cont(\"%d\\n\", audit_backlog_limit);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "audit_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1618-1639",
    "snippet": "static int __init audit_enable(char *str)\n{\n\tif (!strcasecmp(str, \"off\") || !strcmp(str, \"0\"))\n\t\taudit_default = AUDIT_OFF;\n\telse if (!strcasecmp(str, \"on\") || !strcmp(str, \"1\"))\n\t\taudit_default = AUDIT_ON;\n\telse {\n\t\tpr_err(\"audit: invalid 'audit' parameter value (%s)\\n\", str);\n\t\taudit_default = AUDIT_ON;\n\t}\n\n\tif (audit_default == AUDIT_OFF)\n\t\taudit_initialized = AUDIT_DISABLED;\n\tif (audit_set_enabled(audit_default))\n\t\tpr_err(\"audit: error setting audit state (%d)\\n\",\n\t\t       audit_default);\n\n\tpr_info(\"%s\\n\", audit_default ?\n\t\t\"enabled (after initialization)\" : \"disabled (until reboot)\");\n\n\treturn 1;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_DISABLED\t\t-1"
    ],
    "globals_used": [
      "static int\taudit_initialized;",
      "static u32\taudit_default = AUDIT_OFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s\\n\"",
            "audit_default ?\n\t\t\"enabled (after initialization)\" : \"disabled (until reboot)\""
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"audit: error setting audit state (%d)\\n\"",
            "audit_default"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_set_enabled",
          "args": [
            "audit_default"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "455-466",
          "snippet": "static int audit_set_enabled(u32 state)\n{\n\tint rc;\n\tif (state > AUDIT_LOCKED)\n\t\treturn -EINVAL;\n\n\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);\n\tif (!rc)\n\t\taudit_ever_enabled |= !!state;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;",
            "bool\t\taudit_ever_enabled = !!AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\nbool\t\taudit_ever_enabled = !!AUDIT_OFF;\n\nstatic int audit_set_enabled(u32 state)\n{\n\tint rc;\n\tif (state > AUDIT_LOCKED)\n\t\treturn -EINVAL;\n\n\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);\n\tif (!rc)\n\t\taudit_ever_enabled |= !!state;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"audit: invalid 'audit' parameter value (%s)\\n\"",
            "str"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"1\""
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "str",
            "\"on\""
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"0\""
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "str",
            "\"off\""
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_DISABLED\t\t-1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_default = AUDIT_OFF;\n\nstatic int __init audit_enable(char *str)\n{\n\tif (!strcasecmp(str, \"off\") || !strcmp(str, \"0\"))\n\t\taudit_default = AUDIT_OFF;\n\telse if (!strcasecmp(str, \"on\") || !strcmp(str, \"1\"))\n\t\taudit_default = AUDIT_ON;\n\telse {\n\t\tpr_err(\"audit: invalid 'audit' parameter value (%s)\\n\", str);\n\t\taudit_default = AUDIT_ON;\n\t}\n\n\tif (audit_default == AUDIT_OFF)\n\t\taudit_initialized = AUDIT_DISABLED;\n\tif (audit_set_enabled(audit_default))\n\t\tpr_err(\"audit: error setting audit state (%d)\\n\",\n\t\t       audit_default);\n\n\tpr_info(\"%s\\n\", audit_default ?\n\t\t\"enabled (after initialization)\" : \"disabled (until reboot)\");\n\n\treturn 1;\n}"
  },
  {
    "function_name": "audit_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1573-1611",
    "snippet": "static int __init audit_init(void)\n{\n\tint i;\n\n\tif (audit_initialized == AUDIT_DISABLED)\n\t\treturn 0;\n\n\taudit_buffer_cache = kmem_cache_create(\"audit_buffer\",\n\t\t\t\t\t       sizeof(struct audit_buffer),\n\t\t\t\t\t       0, SLAB_PANIC, NULL);\n\n\tskb_queue_head_init(&audit_queue);\n\tskb_queue_head_init(&audit_retry_queue);\n\tskb_queue_head_init(&audit_hold_queue);\n\n\tfor (i = 0; i < AUDIT_INODE_BUCKETS; i++)\n\t\tINIT_LIST_HEAD(&audit_inode_hash[i]);\n\n\tmutex_init(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = NULL;\n\n\tpr_info(\"initializing netlink subsys (%s)\\n\",\n\t\taudit_default ? \"enabled\" : \"disabled\");\n\tregister_pernet_subsys(&audit_net_ops);\n\n\taudit_initialized = AUDIT_INITIALIZED;\n\n\tkauditd_task = kthread_run(kauditd_thread, NULL, \"kauditd\");\n\tif (IS_ERR(kauditd_task)) {\n\t\tint err = PTR_ERR(kauditd_task);\n\t\tpanic(\"audit: failed to start the kauditd thread (%d)\\n\", err);\n\t}\n\n\taudit_log(NULL, GFP_KERNEL, AUDIT_KERNEL,\n\t\t\"state=initialized audit_enabled=%u res=1\",\n\t\t audit_enabled);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_INITIALIZED\t1",
      "#define AUDIT_DISABLED\t\t-1"
    ],
    "globals_used": [
      "static int\taudit_initialized;",
      "u32\t\taudit_enabled = AUDIT_OFF;",
      "static u32\taudit_default = AUDIT_OFF;",
      "struct list_head audit_inode_hash[AUDIT_INODE_BUCKETS];",
      "static struct kmem_cache *audit_buffer_cache;",
      "static struct sk_buff_head audit_queue;",
      "static struct sk_buff_head audit_retry_queue;",
      "static struct sk_buff_head audit_hold_queue;",
      "static struct task_struct *kauditd_task;",
      "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log",
          "args": [
            "NULL",
            "GFP_KERNEL",
            "AUDIT_KERNEL",
            "\"state=initialized audit_enabled=%u res=1\"",
            "audit_enabled"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"audit: failed to start the kauditd thread (%d)\\n\"",
            "err"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "135-307",
          "snippet": "void panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\tprintk_safe_flush_on_panic();\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\t/* Call flush even twice. It tries harder with a single online CPU */\n\tprintk_safe_flush_on_panic();\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n\tbust_spinlocks(0);\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\t{\n\t\tunsigned long caller;\n\n\t\tcaller = (unsigned long)__builtin_return_address(0);\n\t\tdisabled_wait(caller);\n\t}\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define PANIC_BLINK_SPD 18",
            "#define PANIC_TIMER_STEP 100"
          ],
          "globals_used": [
            "bool crash_kexec_post_notifiers;",
            "int panic_timeout = CONFIG_PANIC_TIMEOUT;",
            "long (*panic_blink)(int state);",
            "atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_BLINK_SPD 18\n#define PANIC_TIMER_STEP 100\n\nbool crash_kexec_post_notifiers;\nint panic_timeout = CONFIG_PANIC_TIMEOUT;\nlong (*panic_blink)(int state);\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\nvoid panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\tprintk_safe_flush_on_panic();\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\t/* Call flush even twice. It tries harder with a single online CPU */\n\tprintk_safe_flush_on_panic();\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n\tbust_spinlocks(0);\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\t{\n\t\tunsigned long caller;\n\n\t\tcaller = (unsigned long)__builtin_return_address(0);\n\t\tdisabled_wait(caller);\n\t}\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kauditd_task"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kauditd_task"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "kauditd_thread",
            "NULL",
            "\"kauditd\""
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_pernet_subsys",
          "args": [
            "&audit_net_ops"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"initializing netlink subsys (%s)\\n\"",
            "audit_default ? \"enabled\" : \"disabled\""
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&audit_cmd_mutex.lock"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1604-1612",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&audit_inode_hash[i]"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_head_init",
          "args": [
            "&audit_hold_queue"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_head_init",
          "args": [
            "&audit_retry_queue"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_head_init",
          "args": [
            "&audit_queue"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"audit_buffer\"",
            "sizeof(struct audit_buffer)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n#define AUDIT_DISABLED\t\t-1\n\nstatic int\taudit_initialized;\nu32\t\taudit_enabled = AUDIT_OFF;\nstatic u32\taudit_default = AUDIT_OFF;\nstruct list_head audit_inode_hash[AUDIT_INODE_BUCKETS];\nstatic struct kmem_cache *audit_buffer_cache;\nstatic struct sk_buff_head audit_queue;\nstatic struct sk_buff_head audit_retry_queue;\nstatic struct sk_buff_head audit_hold_queue;\nstatic struct task_struct *kauditd_task;\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstatic int __init audit_init(void)\n{\n\tint i;\n\n\tif (audit_initialized == AUDIT_DISABLED)\n\t\treturn 0;\n\n\taudit_buffer_cache = kmem_cache_create(\"audit_buffer\",\n\t\t\t\t\t       sizeof(struct audit_buffer),\n\t\t\t\t\t       0, SLAB_PANIC, NULL);\n\n\tskb_queue_head_init(&audit_queue);\n\tskb_queue_head_init(&audit_retry_queue);\n\tskb_queue_head_init(&audit_hold_queue);\n\n\tfor (i = 0; i < AUDIT_INODE_BUCKETS; i++)\n\t\tINIT_LIST_HEAD(&audit_inode_hash[i]);\n\n\tmutex_init(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = NULL;\n\n\tpr_info(\"initializing netlink subsys (%s)\\n\",\n\t\taudit_default ? \"enabled\" : \"disabled\");\n\tregister_pernet_subsys(&audit_net_ops);\n\n\taudit_initialized = AUDIT_INITIALIZED;\n\n\tkauditd_task = kthread_run(kauditd_thread, NULL, \"kauditd\");\n\tif (IS_ERR(kauditd_task)) {\n\t\tint err = PTR_ERR(kauditd_task);\n\t\tpanic(\"audit: failed to start the kauditd thread (%d)\\n\", err);\n\t}\n\n\taudit_log(NULL, GFP_KERNEL, AUDIT_KERNEL,\n\t\t\"state=initialized audit_enabled=%u res=1\",\n\t\t audit_enabled);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_net_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1552-1563",
    "snippet": "static void __net_exit audit_net_exit(struct net *net)\n{\n\tstruct audit_net *aunet = net_generic(net, audit_net_id);\n\n\t/* NOTE: you would think that we would want to check the auditd\n\t * connection and potentially reset it here if it lives in this\n\t * namespace, but since the auditd connection tracking struct holds a\n\t * reference to this namespace (see auditd_set()) we are only ever\n\t * going to get here after that connection has been released */\n\n\tnetlink_kernel_release(aunet->sk);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int audit_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlink_kernel_release",
          "args": [
            "aunet->sk"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "audit_net_id"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic void __net_exit audit_net_exit(struct net *net)\n{\n\tstruct audit_net *aunet = net_generic(net, audit_net_id);\n\n\t/* NOTE: you would think that we would want to check the auditd\n\t * connection and potentially reset it here if it lives in this\n\t * namespace, but since the auditd connection tracking struct holds a\n\t * reference to this namespace (see auditd_set()) we are only ever\n\t * going to get here after that connection has been released */\n\n\tnetlink_kernel_release(aunet->sk);\n}"
  },
  {
    "function_name": "audit_net_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1531-1550",
    "snippet": "static int __net_init audit_net_init(struct net *net)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t= audit_receive,\n\t\t.bind\t= audit_bind,\n\t\t.flags\t= NL_CFG_F_NONROOT_RECV,\n\t\t.groups\t= AUDIT_NLGRP_MAX,\n\t};\n\n\tstruct audit_net *aunet = net_generic(net, audit_net_id);\n\n\taunet->sk = netlink_kernel_create(net, NETLINK_AUDIT, &cfg);\n\tif (aunet->sk == NULL) {\n\t\taudit_panic(\"cannot initialize netlink socket in namespace\");\n\t\treturn -ENOMEM;\n\t}\n\taunet->sk->sk_sndtimeo = MAX_SCHEDULE_TIMEOUT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int audit_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"cannot initialize netlink socket in namespace\""
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "310-323",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlink_kernel_create",
          "args": [
            "net",
            "NETLINK_AUDIT",
            "&cfg"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "audit_net_id"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic int __net_init audit_net_init(struct net *net)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t= audit_receive,\n\t\t.bind\t= audit_bind,\n\t\t.flags\t= NL_CFG_F_NONROOT_RECV,\n\t\t.groups\t= AUDIT_NLGRP_MAX,\n\t};\n\n\tstruct audit_net *aunet = net_generic(net, audit_net_id);\n\n\taunet->sk = netlink_kernel_create(net, NETLINK_AUDIT, &cfg);\n\tif (aunet->sk == NULL) {\n\t\taudit_panic(\"cannot initialize netlink socket in namespace\");\n\t\treturn -ENOMEM;\n\t}\n\taunet->sk->sk_sndtimeo = MAX_SCHEDULE_TIMEOUT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_bind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1523-1529",
    "snippet": "static int audit_bind(struct net *net, int group)\n{\n\tif (!capable(CAP_AUDIT_READ))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_AUDIT_READ"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_bind(struct net *net, int group)\n{\n\tif (!capable(CAP_AUDIT_READ))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1497-1520",
    "snippet": "static void audit_receive(struct sk_buff  *skb)\n{\n\tstruct nlmsghdr *nlh;\n\t/*\n\t * len MUST be signed for nlmsg_next to be able to dec it below 0\n\t * if the nlmsg_len was not aligned\n\t */\n\tint len;\n\tint err;\n\n\tnlh = nlmsg_hdr(skb);\n\tlen = skb->len;\n\n\taudit_ctl_lock();\n\twhile (nlmsg_ok(nlh, len)) {\n\t\terr = audit_receive_msg(skb, nlh);\n\t\t/* if err or if this message says it wants a response */\n\t\tif (err || (nlh->nlmsg_flags & NLM_F_ACK))\n\t\t\tnetlink_ack(skb, nlh, err, NULL);\n\n\t\tnlh = nlmsg_next(nlh, &len);\n\t}\n\taudit_ctl_unlock();\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_ctl_unlock",
          "args": [],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "251-255",
          "snippet": "void audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_next",
          "args": [
            "nlh",
            "&len"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_ack",
          "args": [
            "skb",
            "nlh",
            "err",
            "NULL"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_receive_msg",
          "args": [
            "skb",
            "nlh"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "audit_receive_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1179-1488",
          "snippet": "static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tu32\t\t\tseq;\n\tvoid\t\t\t*data;\n\tint\t\t\terr;\n\tstruct audit_buffer\t*ab;\n\tu16\t\t\tmsg_type = nlh->nlmsg_type;\n\tstruct audit_sig_info   *sig_data;\n\tchar\t\t\t*ctx = NULL;\n\tu32\t\t\tlen;\n\n\terr = audit_netlink_ok(skb, msg_type);\n\tif (err)\n\t\treturn err;\n\n\tseq  = nlh->nlmsg_seq;\n\tdata = nlmsg_data(nlh);\n\n\tswitch (msg_type) {\n\tcase AUDIT_GET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\ts.enabled\t\t= audit_enabled;\n\t\ts.failure\t\t= audit_failure;\n\t\t/* NOTE: use pid_vnr() so the PID is relative to the current\n\t\t *       namespace */\n\t\ts.pid\t\t\t= auditd_pid_vnr();\n\t\ts.rate_limit\t\t= audit_rate_limit;\n\t\ts.backlog_limit\t\t= audit_backlog_limit;\n\t\ts.lost\t\t\t= atomic_read(&audit_lost);\n\t\ts.backlog\t\t= skb_queue_len(&audit_queue);\n\t\ts.feature_bitmap\t= AUDIT_FEATURE_BITMAP_ALL;\n\t\ts.backlog_wait_time\t= audit_backlog_wait_time;\n\t\taudit_send_reply(skb, seq, AUDIT_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_SET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), nlmsg_len(nlh)));\n\t\tif (s.mask & AUDIT_STATUS_ENABLED) {\n\t\t\terr = audit_set_enabled(s.enabled);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_FAILURE) {\n\t\t\terr = audit_set_failure(s.failure);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_PID) {\n\t\t\t/* NOTE: we are using the vnr PID functions below\n\t\t\t *       because the s.pid value is relative to the\n\t\t\t *       namespace of the caller; at present this\n\t\t\t *       doesn't matter much since you can really only\n\t\t\t *       run auditd from the initial pid namespace, but\n\t\t\t *       something to keep in mind if this changes */\n\t\t\tpid_t new_pid = s.pid;\n\t\t\tpid_t auditd_pid;\n\t\t\tstruct pid *req_pid = task_tgid(current);\n\n\t\t\t/* Sanity check - PID values must match. Setting\n\t\t\t * pid to 0 is how auditd ends auditing. */\n\t\t\tif (new_pid && (new_pid != pid_vnr(req_pid)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* test the auditd connection */\n\t\t\taudit_replace(req_pid);\n\n\t\t\tauditd_pid = auditd_pid_vnr();\n\t\t\tif (auditd_pid) {\n\t\t\t\t/* replacing a healthy auditd is not allowed */\n\t\t\t\tif (new_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\t/* only current auditd can unregister itself */\n\t\t\t\tif (pid_vnr(req_pid) != auditd_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (new_pid) {\n\t\t\t\t/* register a new auditd connection */\n\t\t\t\terr = auditd_set(req_pid,\n\t\t\t\t\t\t NETLINK_CB(skb).portid,\n\t\t\t\t\t\t sock_net(NETLINK_CB(skb).sk));\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid,\n\t\t\t\t\t\t\t\terr ? 0 : 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\t/* try to process any backlog */\n\t\t\t\twake_up_interruptible(&kauditd_wait);\n\t\t\t} else {\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid, 1);\n\n\t\t\t\t/* unregister the auditd connection */\n\t\t\t\tauditd_reset(NULL);\n\t\t\t}\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_RATE_LIMIT) {\n\t\t\terr = audit_set_rate_limit(s.rate_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_LIMIT) {\n\t\t\terr = audit_set_backlog_limit(s.backlog_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_WAIT_TIME) {\n\t\t\tif (sizeof(s) > (size_t)nlh->nlmsg_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (s.backlog_wait_time > 10*AUDIT_BACKLOG_WAIT_TIME)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = audit_set_backlog_wait_time(s.backlog_wait_time);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask == AUDIT_STATUS_LOST) {\n\t\t\tu32 lost = atomic_xchg(&audit_lost, 0);\n\n\t\t\taudit_log_config_change(\"lost\", 0, lost, 1);\n\t\t\treturn lost;\n\t\t}\n\t\tbreak;\n\t}\n\tcase AUDIT_GET_FEATURE:\n\t\terr = audit_get_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_SET_FEATURE:\n\t\terr = audit_set_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!audit_enabled && msg_type != AUDIT_USER_AVC)\n\t\t\treturn 0;\n\n\t\terr = audit_filter(msg_type, AUDIT_FILTER_USER);\n\t\tif (err == 1) { /* match or error */\n\t\t\terr = 0;\n\t\t\tif (msg_type == AUDIT_USER_TTY) {\n\t\t\t\terr = tty_audit_push();\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\taudit_log_common_recv_msg(&ab, msg_type);\n\t\t\tif (msg_type != AUDIT_USER_TTY)\n\t\t\t\taudit_log_format(ab, \" msg='%.*s'\",\n\t\t\t\t\t\t AUDIT_MESSAGE_TEXT_MAX,\n\t\t\t\t\t\t (char *)data);\n\t\t\telse {\n\t\t\t\tint size;\n\n\t\t\t\taudit_log_format(ab, \" data=\");\n\t\t\t\tsize = nlmsg_len(nlh);\n\t\t\t\tif (size > 0 &&\n\t\t\t\t    ((unsigned char *)data)[size - 1] == '\\0')\n\t\t\t\t\tsize--;\n\t\t\t\taudit_log_n_untrustedstring(ab, data, size);\n\t\t\t}\n\t\t\taudit_log_end(ab);\n\t\t}\n\t\tbreak;\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\t\tif (nlmsg_len(nlh) < sizeof(struct audit_rule_data))\n\t\t\treturn -EINVAL;\n\t\tif (audit_enabled == AUDIT_LOCKED) {\n\t\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\t\t\taudit_log_format(ab, \" audit_enabled=%d res=0\", audit_enabled);\n\t\t\taudit_log_end(ab);\n\t\t\treturn -EPERM;\n\t\t}\n\t\terr = audit_rule_change(msg_type, seq, data, nlmsg_len(nlh));\n\t\tbreak;\n\tcase AUDIT_LIST_RULES:\n\t\terr = audit_list_rules_send(skb, seq);\n\t\tbreak;\n\tcase AUDIT_TRIM:\n\t\taudit_trim_trees();\n\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=trim res=1\");\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_MAKE_EQUIV: {\n\t\tvoid *bufp = data;\n\t\tu32 sizes[2];\n\t\tsize_t msglen = nlmsg_len(nlh);\n\t\tchar *old, *new;\n\n\t\terr = -EINVAL;\n\t\tif (msglen < 2 * sizeof(u32))\n\t\t\tbreak;\n\t\tmemcpy(sizes, bufp, 2 * sizeof(u32));\n\t\tbufp += 2 * sizeof(u32);\n\t\tmsglen -= 2 * sizeof(u32);\n\t\told = audit_unpack_string(&bufp, &msglen, sizes[0]);\n\t\tif (IS_ERR(old)) {\n\t\t\terr = PTR_ERR(old);\n\t\t\tbreak;\n\t\t}\n\t\tnew = audit_unpack_string(&bufp, &msglen, sizes[1]);\n\t\tif (IS_ERR(new)) {\n\t\t\terr = PTR_ERR(new);\n\t\t\tkfree(old);\n\t\t\tbreak;\n\t\t}\n\t\t/* OK, here comes... */\n\t\terr = audit_tag_tree(old, new);\n\n\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\n\t\taudit_log_format(ab, \" op=make_equiv old=\");\n\t\taudit_log_untrustedstring(ab, old);\n\t\taudit_log_format(ab, \" new=\");\n\t\taudit_log_untrustedstring(ab, new);\n\t\taudit_log_format(ab, \" res=%d\", !err);\n\t\taudit_log_end(ab);\n\t\tkfree(old);\n\t\tkfree(new);\n\t\tbreak;\n\t}\n\tcase AUDIT_SIGNAL_INFO:\n\t\tlen = 0;\n\t\tif (audit_sig_sid) {\n\t\t\terr = security_secid_to_secctx(audit_sig_sid, &ctx, &len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tsig_data = kmalloc(sizeof(*sig_data) + len, GFP_KERNEL);\n\t\tif (!sig_data) {\n\t\t\tif (audit_sig_sid)\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsig_data->uid = from_kuid(&init_user_ns, audit_sig_uid);\n\t\tsig_data->pid = audit_sig_pid;\n\t\tif (audit_sig_sid) {\n\t\t\tmemcpy(sig_data->ctx, ctx, len);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t\taudit_send_reply(skb, seq, AUDIT_SIGNAL_INFO, 0, 0,\n\t\t\t\t sig_data, sizeof(*sig_data) + len);\n\t\tkfree(sig_data);\n\t\tbreak;\n\tcase AUDIT_TTY_GET: {\n\t\tstruct audit_tty_status s;\n\t\tunsigned int t;\n\n\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\ts.enabled = t & AUDIT_TTY_ENABLE;\n\t\ts.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_send_reply(skb, seq, AUDIT_TTY_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_TTY_SET: {\n\t\tstruct audit_tty_status s, old;\n\t\tstruct audit_buffer\t*ab;\n\t\tunsigned int t;\n\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), nlmsg_len(nlh)));\n\t\t/* check if new data is valid */\n\t\tif ((s.enabled != 0 && s.enabled != 1) ||\n\t\t    (s.log_passwd != 0 && s.log_passwd != 1))\n\t\t\terr = -EINVAL;\n\n\t\tif (err)\n\t\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\telse {\n\t\t\tt = s.enabled | (-s.log_passwd & AUDIT_TTY_LOG_PASSWD);\n\t\t\tt = xchg(&current->signal->audit_tty, t);\n\t\t}\n\t\told.enabled = t & AUDIT_TTY_ENABLE;\n\t\told.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=tty_set old-enabled=%d new-enabled=%d\"\n\t\t\t\t \" old-log_passwd=%d new-log_passwd=%d res=%d\",\n\t\t\t\t old.enabled, s.enabled, old.log_passwd,\n\t\t\t\t s.log_passwd, !err);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err < 0 ? err : 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_BACKLOG_WAIT_TIME (60 * HZ)"
          ],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;",
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
            "static u32\taudit_rate_limit;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "kuid_t\t\taudit_sig_uid = INVALID_UID;",
            "pid_t\t\taudit_sig_pid = -1;",
            "u32\t\taudit_sig_sid = 0;",
            "static atomic_t\taudit_lost = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BACKLOG_WAIT_TIME (60 * HZ)\n\nu32\t\taudit_enabled = AUDIT_OFF;\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nkuid_t\t\taudit_sig_uid = INVALID_UID;\npid_t\t\taudit_sig_pid = -1;\nu32\t\taudit_sig_sid = 0;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nstatic int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tu32\t\t\tseq;\n\tvoid\t\t\t*data;\n\tint\t\t\terr;\n\tstruct audit_buffer\t*ab;\n\tu16\t\t\tmsg_type = nlh->nlmsg_type;\n\tstruct audit_sig_info   *sig_data;\n\tchar\t\t\t*ctx = NULL;\n\tu32\t\t\tlen;\n\n\terr = audit_netlink_ok(skb, msg_type);\n\tif (err)\n\t\treturn err;\n\n\tseq  = nlh->nlmsg_seq;\n\tdata = nlmsg_data(nlh);\n\n\tswitch (msg_type) {\n\tcase AUDIT_GET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\ts.enabled\t\t= audit_enabled;\n\t\ts.failure\t\t= audit_failure;\n\t\t/* NOTE: use pid_vnr() so the PID is relative to the current\n\t\t *       namespace */\n\t\ts.pid\t\t\t= auditd_pid_vnr();\n\t\ts.rate_limit\t\t= audit_rate_limit;\n\t\ts.backlog_limit\t\t= audit_backlog_limit;\n\t\ts.lost\t\t\t= atomic_read(&audit_lost);\n\t\ts.backlog\t\t= skb_queue_len(&audit_queue);\n\t\ts.feature_bitmap\t= AUDIT_FEATURE_BITMAP_ALL;\n\t\ts.backlog_wait_time\t= audit_backlog_wait_time;\n\t\taudit_send_reply(skb, seq, AUDIT_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_SET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), nlmsg_len(nlh)));\n\t\tif (s.mask & AUDIT_STATUS_ENABLED) {\n\t\t\terr = audit_set_enabled(s.enabled);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_FAILURE) {\n\t\t\terr = audit_set_failure(s.failure);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_PID) {\n\t\t\t/* NOTE: we are using the vnr PID functions below\n\t\t\t *       because the s.pid value is relative to the\n\t\t\t *       namespace of the caller; at present this\n\t\t\t *       doesn't matter much since you can really only\n\t\t\t *       run auditd from the initial pid namespace, but\n\t\t\t *       something to keep in mind if this changes */\n\t\t\tpid_t new_pid = s.pid;\n\t\t\tpid_t auditd_pid;\n\t\t\tstruct pid *req_pid = task_tgid(current);\n\n\t\t\t/* Sanity check - PID values must match. Setting\n\t\t\t * pid to 0 is how auditd ends auditing. */\n\t\t\tif (new_pid && (new_pid != pid_vnr(req_pid)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* test the auditd connection */\n\t\t\taudit_replace(req_pid);\n\n\t\t\tauditd_pid = auditd_pid_vnr();\n\t\t\tif (auditd_pid) {\n\t\t\t\t/* replacing a healthy auditd is not allowed */\n\t\t\t\tif (new_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\t/* only current auditd can unregister itself */\n\t\t\t\tif (pid_vnr(req_pid) != auditd_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (new_pid) {\n\t\t\t\t/* register a new auditd connection */\n\t\t\t\terr = auditd_set(req_pid,\n\t\t\t\t\t\t NETLINK_CB(skb).portid,\n\t\t\t\t\t\t sock_net(NETLINK_CB(skb).sk));\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid,\n\t\t\t\t\t\t\t\terr ? 0 : 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\t/* try to process any backlog */\n\t\t\t\twake_up_interruptible(&kauditd_wait);\n\t\t\t} else {\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid, 1);\n\n\t\t\t\t/* unregister the auditd connection */\n\t\t\t\tauditd_reset(NULL);\n\t\t\t}\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_RATE_LIMIT) {\n\t\t\terr = audit_set_rate_limit(s.rate_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_LIMIT) {\n\t\t\terr = audit_set_backlog_limit(s.backlog_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_WAIT_TIME) {\n\t\t\tif (sizeof(s) > (size_t)nlh->nlmsg_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (s.backlog_wait_time > 10*AUDIT_BACKLOG_WAIT_TIME)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = audit_set_backlog_wait_time(s.backlog_wait_time);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask == AUDIT_STATUS_LOST) {\n\t\t\tu32 lost = atomic_xchg(&audit_lost, 0);\n\n\t\t\taudit_log_config_change(\"lost\", 0, lost, 1);\n\t\t\treturn lost;\n\t\t}\n\t\tbreak;\n\t}\n\tcase AUDIT_GET_FEATURE:\n\t\terr = audit_get_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_SET_FEATURE:\n\t\terr = audit_set_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!audit_enabled && msg_type != AUDIT_USER_AVC)\n\t\t\treturn 0;\n\n\t\terr = audit_filter(msg_type, AUDIT_FILTER_USER);\n\t\tif (err == 1) { /* match or error */\n\t\t\terr = 0;\n\t\t\tif (msg_type == AUDIT_USER_TTY) {\n\t\t\t\terr = tty_audit_push();\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\taudit_log_common_recv_msg(&ab, msg_type);\n\t\t\tif (msg_type != AUDIT_USER_TTY)\n\t\t\t\taudit_log_format(ab, \" msg='%.*s'\",\n\t\t\t\t\t\t AUDIT_MESSAGE_TEXT_MAX,\n\t\t\t\t\t\t (char *)data);\n\t\t\telse {\n\t\t\t\tint size;\n\n\t\t\t\taudit_log_format(ab, \" data=\");\n\t\t\t\tsize = nlmsg_len(nlh);\n\t\t\t\tif (size > 0 &&\n\t\t\t\t    ((unsigned char *)data)[size - 1] == '\\0')\n\t\t\t\t\tsize--;\n\t\t\t\taudit_log_n_untrustedstring(ab, data, size);\n\t\t\t}\n\t\t\taudit_log_end(ab);\n\t\t}\n\t\tbreak;\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\t\tif (nlmsg_len(nlh) < sizeof(struct audit_rule_data))\n\t\t\treturn -EINVAL;\n\t\tif (audit_enabled == AUDIT_LOCKED) {\n\t\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\t\t\taudit_log_format(ab, \" audit_enabled=%d res=0\", audit_enabled);\n\t\t\taudit_log_end(ab);\n\t\t\treturn -EPERM;\n\t\t}\n\t\terr = audit_rule_change(msg_type, seq, data, nlmsg_len(nlh));\n\t\tbreak;\n\tcase AUDIT_LIST_RULES:\n\t\terr = audit_list_rules_send(skb, seq);\n\t\tbreak;\n\tcase AUDIT_TRIM:\n\t\taudit_trim_trees();\n\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=trim res=1\");\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_MAKE_EQUIV: {\n\t\tvoid *bufp = data;\n\t\tu32 sizes[2];\n\t\tsize_t msglen = nlmsg_len(nlh);\n\t\tchar *old, *new;\n\n\t\terr = -EINVAL;\n\t\tif (msglen < 2 * sizeof(u32))\n\t\t\tbreak;\n\t\tmemcpy(sizes, bufp, 2 * sizeof(u32));\n\t\tbufp += 2 * sizeof(u32);\n\t\tmsglen -= 2 * sizeof(u32);\n\t\told = audit_unpack_string(&bufp, &msglen, sizes[0]);\n\t\tif (IS_ERR(old)) {\n\t\t\terr = PTR_ERR(old);\n\t\t\tbreak;\n\t\t}\n\t\tnew = audit_unpack_string(&bufp, &msglen, sizes[1]);\n\t\tif (IS_ERR(new)) {\n\t\t\terr = PTR_ERR(new);\n\t\t\tkfree(old);\n\t\t\tbreak;\n\t\t}\n\t\t/* OK, here comes... */\n\t\terr = audit_tag_tree(old, new);\n\n\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\n\t\taudit_log_format(ab, \" op=make_equiv old=\");\n\t\taudit_log_untrustedstring(ab, old);\n\t\taudit_log_format(ab, \" new=\");\n\t\taudit_log_untrustedstring(ab, new);\n\t\taudit_log_format(ab, \" res=%d\", !err);\n\t\taudit_log_end(ab);\n\t\tkfree(old);\n\t\tkfree(new);\n\t\tbreak;\n\t}\n\tcase AUDIT_SIGNAL_INFO:\n\t\tlen = 0;\n\t\tif (audit_sig_sid) {\n\t\t\terr = security_secid_to_secctx(audit_sig_sid, &ctx, &len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tsig_data = kmalloc(sizeof(*sig_data) + len, GFP_KERNEL);\n\t\tif (!sig_data) {\n\t\t\tif (audit_sig_sid)\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsig_data->uid = from_kuid(&init_user_ns, audit_sig_uid);\n\t\tsig_data->pid = audit_sig_pid;\n\t\tif (audit_sig_sid) {\n\t\t\tmemcpy(sig_data->ctx, ctx, len);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t\taudit_send_reply(skb, seq, AUDIT_SIGNAL_INFO, 0, 0,\n\t\t\t\t sig_data, sizeof(*sig_data) + len);\n\t\tkfree(sig_data);\n\t\tbreak;\n\tcase AUDIT_TTY_GET: {\n\t\tstruct audit_tty_status s;\n\t\tunsigned int t;\n\n\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\ts.enabled = t & AUDIT_TTY_ENABLE;\n\t\ts.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_send_reply(skb, seq, AUDIT_TTY_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_TTY_SET: {\n\t\tstruct audit_tty_status s, old;\n\t\tstruct audit_buffer\t*ab;\n\t\tunsigned int t;\n\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), nlmsg_len(nlh)));\n\t\t/* check if new data is valid */\n\t\tif ((s.enabled != 0 && s.enabled != 1) ||\n\t\t    (s.log_passwd != 0 && s.log_passwd != 1))\n\t\t\terr = -EINVAL;\n\n\t\tif (err)\n\t\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\telse {\n\t\t\tt = s.enabled | (-s.log_passwd & AUDIT_TTY_LOG_PASSWD);\n\t\t\tt = xchg(&current->signal->audit_tty, t);\n\t\t}\n\t\told.enabled = t & AUDIT_TTY_ENABLE;\n\t\told.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=tty_set old-enabled=%d new-enabled=%d\"\n\t\t\t\t \" old-log_passwd=%d new-log_passwd=%d res=%d\",\n\t\t\t\t old.enabled, s.enabled, old.log_passwd,\n\t\t\t\t s.log_passwd, !err);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err < 0 ? err : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_ok",
          "args": [
            "nlh",
            "len"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ctl_lock",
          "args": [],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "242-246",
          "snippet": "void audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_hdr",
          "args": [
            "skb"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void audit_receive(struct sk_buff  *skb)\n{\n\tstruct nlmsghdr *nlh;\n\t/*\n\t * len MUST be signed for nlmsg_next to be able to dec it below 0\n\t * if the nlmsg_len was not aligned\n\t */\n\tint len;\n\tint err;\n\n\tnlh = nlmsg_hdr(skb);\n\tlen = skb->len;\n\n\taudit_ctl_lock();\n\twhile (nlmsg_ok(nlh, len)) {\n\t\terr = audit_receive_msg(skb, nlh);\n\t\t/* if err or if this message says it wants a response */\n\t\tif (err || (nlh->nlmsg_flags & NLM_F_ACK))\n\t\t\tnetlink_ack(skb, nlh, err, NULL);\n\n\t\tnlh = nlmsg_next(nlh, &len);\n\t}\n\taudit_ctl_unlock();\n}"
  },
  {
    "function_name": "audit_receive_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1179-1488",
    "snippet": "static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tu32\t\t\tseq;\n\tvoid\t\t\t*data;\n\tint\t\t\terr;\n\tstruct audit_buffer\t*ab;\n\tu16\t\t\tmsg_type = nlh->nlmsg_type;\n\tstruct audit_sig_info   *sig_data;\n\tchar\t\t\t*ctx = NULL;\n\tu32\t\t\tlen;\n\n\terr = audit_netlink_ok(skb, msg_type);\n\tif (err)\n\t\treturn err;\n\n\tseq  = nlh->nlmsg_seq;\n\tdata = nlmsg_data(nlh);\n\n\tswitch (msg_type) {\n\tcase AUDIT_GET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\ts.enabled\t\t= audit_enabled;\n\t\ts.failure\t\t= audit_failure;\n\t\t/* NOTE: use pid_vnr() so the PID is relative to the current\n\t\t *       namespace */\n\t\ts.pid\t\t\t= auditd_pid_vnr();\n\t\ts.rate_limit\t\t= audit_rate_limit;\n\t\ts.backlog_limit\t\t= audit_backlog_limit;\n\t\ts.lost\t\t\t= atomic_read(&audit_lost);\n\t\ts.backlog\t\t= skb_queue_len(&audit_queue);\n\t\ts.feature_bitmap\t= AUDIT_FEATURE_BITMAP_ALL;\n\t\ts.backlog_wait_time\t= audit_backlog_wait_time;\n\t\taudit_send_reply(skb, seq, AUDIT_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_SET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), nlmsg_len(nlh)));\n\t\tif (s.mask & AUDIT_STATUS_ENABLED) {\n\t\t\terr = audit_set_enabled(s.enabled);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_FAILURE) {\n\t\t\terr = audit_set_failure(s.failure);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_PID) {\n\t\t\t/* NOTE: we are using the vnr PID functions below\n\t\t\t *       because the s.pid value is relative to the\n\t\t\t *       namespace of the caller; at present this\n\t\t\t *       doesn't matter much since you can really only\n\t\t\t *       run auditd from the initial pid namespace, but\n\t\t\t *       something to keep in mind if this changes */\n\t\t\tpid_t new_pid = s.pid;\n\t\t\tpid_t auditd_pid;\n\t\t\tstruct pid *req_pid = task_tgid(current);\n\n\t\t\t/* Sanity check - PID values must match. Setting\n\t\t\t * pid to 0 is how auditd ends auditing. */\n\t\t\tif (new_pid && (new_pid != pid_vnr(req_pid)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* test the auditd connection */\n\t\t\taudit_replace(req_pid);\n\n\t\t\tauditd_pid = auditd_pid_vnr();\n\t\t\tif (auditd_pid) {\n\t\t\t\t/* replacing a healthy auditd is not allowed */\n\t\t\t\tif (new_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\t/* only current auditd can unregister itself */\n\t\t\t\tif (pid_vnr(req_pid) != auditd_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (new_pid) {\n\t\t\t\t/* register a new auditd connection */\n\t\t\t\terr = auditd_set(req_pid,\n\t\t\t\t\t\t NETLINK_CB(skb).portid,\n\t\t\t\t\t\t sock_net(NETLINK_CB(skb).sk));\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid,\n\t\t\t\t\t\t\t\terr ? 0 : 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\t/* try to process any backlog */\n\t\t\t\twake_up_interruptible(&kauditd_wait);\n\t\t\t} else {\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid, 1);\n\n\t\t\t\t/* unregister the auditd connection */\n\t\t\t\tauditd_reset(NULL);\n\t\t\t}\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_RATE_LIMIT) {\n\t\t\terr = audit_set_rate_limit(s.rate_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_LIMIT) {\n\t\t\terr = audit_set_backlog_limit(s.backlog_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_WAIT_TIME) {\n\t\t\tif (sizeof(s) > (size_t)nlh->nlmsg_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (s.backlog_wait_time > 10*AUDIT_BACKLOG_WAIT_TIME)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = audit_set_backlog_wait_time(s.backlog_wait_time);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask == AUDIT_STATUS_LOST) {\n\t\t\tu32 lost = atomic_xchg(&audit_lost, 0);\n\n\t\t\taudit_log_config_change(\"lost\", 0, lost, 1);\n\t\t\treturn lost;\n\t\t}\n\t\tbreak;\n\t}\n\tcase AUDIT_GET_FEATURE:\n\t\terr = audit_get_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_SET_FEATURE:\n\t\terr = audit_set_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!audit_enabled && msg_type != AUDIT_USER_AVC)\n\t\t\treturn 0;\n\n\t\terr = audit_filter(msg_type, AUDIT_FILTER_USER);\n\t\tif (err == 1) { /* match or error */\n\t\t\terr = 0;\n\t\t\tif (msg_type == AUDIT_USER_TTY) {\n\t\t\t\terr = tty_audit_push();\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\taudit_log_common_recv_msg(&ab, msg_type);\n\t\t\tif (msg_type != AUDIT_USER_TTY)\n\t\t\t\taudit_log_format(ab, \" msg='%.*s'\",\n\t\t\t\t\t\t AUDIT_MESSAGE_TEXT_MAX,\n\t\t\t\t\t\t (char *)data);\n\t\t\telse {\n\t\t\t\tint size;\n\n\t\t\t\taudit_log_format(ab, \" data=\");\n\t\t\t\tsize = nlmsg_len(nlh);\n\t\t\t\tif (size > 0 &&\n\t\t\t\t    ((unsigned char *)data)[size - 1] == '\\0')\n\t\t\t\t\tsize--;\n\t\t\t\taudit_log_n_untrustedstring(ab, data, size);\n\t\t\t}\n\t\t\taudit_log_end(ab);\n\t\t}\n\t\tbreak;\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\t\tif (nlmsg_len(nlh) < sizeof(struct audit_rule_data))\n\t\t\treturn -EINVAL;\n\t\tif (audit_enabled == AUDIT_LOCKED) {\n\t\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\t\t\taudit_log_format(ab, \" audit_enabled=%d res=0\", audit_enabled);\n\t\t\taudit_log_end(ab);\n\t\t\treturn -EPERM;\n\t\t}\n\t\terr = audit_rule_change(msg_type, seq, data, nlmsg_len(nlh));\n\t\tbreak;\n\tcase AUDIT_LIST_RULES:\n\t\terr = audit_list_rules_send(skb, seq);\n\t\tbreak;\n\tcase AUDIT_TRIM:\n\t\taudit_trim_trees();\n\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=trim res=1\");\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_MAKE_EQUIV: {\n\t\tvoid *bufp = data;\n\t\tu32 sizes[2];\n\t\tsize_t msglen = nlmsg_len(nlh);\n\t\tchar *old, *new;\n\n\t\terr = -EINVAL;\n\t\tif (msglen < 2 * sizeof(u32))\n\t\t\tbreak;\n\t\tmemcpy(sizes, bufp, 2 * sizeof(u32));\n\t\tbufp += 2 * sizeof(u32);\n\t\tmsglen -= 2 * sizeof(u32);\n\t\told = audit_unpack_string(&bufp, &msglen, sizes[0]);\n\t\tif (IS_ERR(old)) {\n\t\t\terr = PTR_ERR(old);\n\t\t\tbreak;\n\t\t}\n\t\tnew = audit_unpack_string(&bufp, &msglen, sizes[1]);\n\t\tif (IS_ERR(new)) {\n\t\t\terr = PTR_ERR(new);\n\t\t\tkfree(old);\n\t\t\tbreak;\n\t\t}\n\t\t/* OK, here comes... */\n\t\terr = audit_tag_tree(old, new);\n\n\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\n\t\taudit_log_format(ab, \" op=make_equiv old=\");\n\t\taudit_log_untrustedstring(ab, old);\n\t\taudit_log_format(ab, \" new=\");\n\t\taudit_log_untrustedstring(ab, new);\n\t\taudit_log_format(ab, \" res=%d\", !err);\n\t\taudit_log_end(ab);\n\t\tkfree(old);\n\t\tkfree(new);\n\t\tbreak;\n\t}\n\tcase AUDIT_SIGNAL_INFO:\n\t\tlen = 0;\n\t\tif (audit_sig_sid) {\n\t\t\terr = security_secid_to_secctx(audit_sig_sid, &ctx, &len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tsig_data = kmalloc(sizeof(*sig_data) + len, GFP_KERNEL);\n\t\tif (!sig_data) {\n\t\t\tif (audit_sig_sid)\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsig_data->uid = from_kuid(&init_user_ns, audit_sig_uid);\n\t\tsig_data->pid = audit_sig_pid;\n\t\tif (audit_sig_sid) {\n\t\t\tmemcpy(sig_data->ctx, ctx, len);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t\taudit_send_reply(skb, seq, AUDIT_SIGNAL_INFO, 0, 0,\n\t\t\t\t sig_data, sizeof(*sig_data) + len);\n\t\tkfree(sig_data);\n\t\tbreak;\n\tcase AUDIT_TTY_GET: {\n\t\tstruct audit_tty_status s;\n\t\tunsigned int t;\n\n\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\ts.enabled = t & AUDIT_TTY_ENABLE;\n\t\ts.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_send_reply(skb, seq, AUDIT_TTY_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_TTY_SET: {\n\t\tstruct audit_tty_status s, old;\n\t\tstruct audit_buffer\t*ab;\n\t\tunsigned int t;\n\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), nlmsg_len(nlh)));\n\t\t/* check if new data is valid */\n\t\tif ((s.enabled != 0 && s.enabled != 1) ||\n\t\t    (s.log_passwd != 0 && s.log_passwd != 1))\n\t\t\terr = -EINVAL;\n\n\t\tif (err)\n\t\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\telse {\n\t\t\tt = s.enabled | (-s.log_passwd & AUDIT_TTY_LOG_PASSWD);\n\t\t\tt = xchg(&current->signal->audit_tty, t);\n\t\t}\n\t\told.enabled = t & AUDIT_TTY_ENABLE;\n\t\told.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=tty_set old-enabled=%d new-enabled=%d\"\n\t\t\t\t \" old-log_passwd=%d new-log_passwd=%d res=%d\",\n\t\t\t\t old.enabled, s.enabled, old.log_passwd,\n\t\t\t\t s.log_passwd, !err);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err < 0 ? err : 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_BACKLOG_WAIT_TIME (60 * HZ)"
    ],
    "globals_used": [
      "u32\t\taudit_enabled = AUDIT_OFF;",
      "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
      "static u32\taudit_rate_limit;",
      "static u32\taudit_backlog_limit = 64;",
      "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
      "kuid_t\t\taudit_sig_uid = INVALID_UID;",
      "pid_t\t\taudit_sig_pid = -1;",
      "u32\t\taudit_sig_sid = 0;",
      "static atomic_t\taudit_lost = ATOMIC_INIT(0);",
      "static struct sk_buff_head audit_queue;",
      "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" op=tty_set old-enabled=%d new-enabled=%d\"\n\t\t\t\t \" old-log_passwd=%d new-log_passwd=%d res=%d\"",
            "old.enabled",
            "s.enabled",
            "old.log_passwd",
            "s.log_passwd",
            "!err"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_common_recv_msg",
          "args": [
            "&ab",
            "AUDIT_CONFIG_CHANGE"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_common_recv_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1057-1073",
          "snippet": "static void audit_log_common_recv_msg(struct audit_buffer **ab, u16 msg_type)\n{\n\tuid_t uid = from_kuid(&init_user_ns, current_uid());\n\tpid_t pid = task_tgid_nr(current);\n\n\tif (!audit_enabled && msg_type != AUDIT_USER_AVC) {\n\t\t*ab = NULL;\n\t\treturn;\n\t}\n\n\t*ab = audit_log_start(NULL, GFP_KERNEL, msg_type);\n\tif (unlikely(!*ab))\n\t\treturn;\n\taudit_log_format(*ab, \"pid=%d uid=%u\", pid, uid);\n\taudit_log_session_info(*ab);\n\taudit_log_task_context(*ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic void audit_log_common_recv_msg(struct audit_buffer **ab, u16 msg_type)\n{\n\tuid_t uid = from_kuid(&init_user_ns, current_uid());\n\tpid_t pid = task_tgid_nr(current);\n\n\tif (!audit_enabled && msg_type != AUDIT_USER_AVC) {\n\t\t*ab = NULL;\n\t\treturn;\n\t}\n\n\t*ab = audit_log_start(NULL, GFP_KERNEL, msg_type);\n\tif (unlikely(!*ab))\n\t\treturn;\n\taudit_log_format(*ab, \"pid=%d uid=%u\", pid, uid);\n\taudit_log_session_info(*ab);\n\taudit_log_task_context(*ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&current->signal->audit_tty",
            "t"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock.c",
          "lines": "231-249",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "current->signal->audit_tty"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&s",
            "data",
            "min_t(size_t, sizeof(s), nlmsg_len(nlh))"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "sizeof(s)",
            "nlmsg_len(nlh)"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_len",
          "args": [
            "nlh"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&s",
            "0",
            "sizeof(s)"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_send_reply",
          "args": [
            "skb",
            "seq",
            "AUDIT_TTY_GET",
            "0",
            "0",
            "&s",
            "sizeof(s)"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "audit_send_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "969-995",
          "snippet": "static void audit_send_reply(struct sk_buff *request_skb, int seq, int type, int done,\n\t\t\t     int multi, const void *payload, int size)\n{\n\tstruct net *net = sock_net(NETLINK_CB(request_skb).sk);\n\tstruct sk_buff *skb;\n\tstruct task_struct *tsk;\n\tstruct audit_reply *reply = kmalloc(sizeof(struct audit_reply),\n\t\t\t\t\t    GFP_KERNEL);\n\n\tif (!reply)\n\t\treturn;\n\n\tskb = audit_make_reply(seq, type, done, multi, payload, size);\n\tif (!skb)\n\t\tgoto out;\n\n\treply->net = get_net(net);\n\treply->portid = NETLINK_CB(request_skb).portid;\n\treply->skb = skb;\n\n\ttsk = kthread_run(audit_send_reply_thread, reply, \"audit_send_reply\");\n\tif (!IS_ERR(tsk))\n\t\treturn;\n\tkfree_skb(skb);\nout:\n\tkfree(reply);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void audit_send_reply(struct sk_buff *request_skb, int seq, int type, int done,\n\t\t\t     int multi, const void *payload, int size)\n{\n\tstruct net *net = sock_net(NETLINK_CB(request_skb).sk);\n\tstruct sk_buff *skb;\n\tstruct task_struct *tsk;\n\tstruct audit_reply *reply = kmalloc(sizeof(struct audit_reply),\n\t\t\t\t\t    GFP_KERNEL);\n\n\tif (!reply)\n\t\treturn;\n\n\tskb = audit_make_reply(seq, type, done, multi, payload, size);\n\tif (!skb)\n\t\tgoto out;\n\n\treply->net = get_net(net);\n\treply->portid = NETLINK_CB(request_skb).portid;\n\treply->skb = skb;\n\n\ttsk = kthread_run(audit_send_reply_thread, reply, \"audit_send_reply\");\n\tif (!IS_ERR(tsk))\n\t\treturn;\n\tkfree_skb(skb);\nout:\n\tkfree(reply);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "current->signal->audit_tty"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sig_data"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "ctx",
            "len"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "audit_sig_uid"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "ctx",
            "len"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*sig_data) + len",
            "GFP_KERNEL"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_secid_to_secctx",
          "args": [
            "audit_sig_sid",
            "&ctx",
            "&len"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "new"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2011-2014",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_tag_tree",
          "args": [
            "old",
            "new"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "audit_tag_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "823-916",
          "snippet": "int audit_tag_tree(char *old, char *new)\n{\n\tstruct list_head cursor, barrier;\n\tint failed = 0;\n\tstruct path path1, path2;\n\tstruct vfsmount *tagged;\n\tint err;\n\n\terr = kern_path(new, 0, &path2);\n\tif (err)\n\t\treturn err;\n\ttagged = collect_mounts(&path2);\n\tpath_put(&path2);\n\tif (IS_ERR(tagged))\n\t\treturn PTR_ERR(tagged);\n\n\terr = kern_path(old, 0, &path1);\n\tif (err) {\n\t\tdrop_collected_mounts(tagged);\n\t\treturn err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&barrier, &tree_list);\n\tlist_add(&cursor, &barrier);\n\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tint good_one = 0;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_del(&cursor);\n\t\tlist_add(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path2);\n\t\tif (!err) {\n\t\t\tgood_one = path_is_under(&path1, &path2);\n\t\t\tpath_put(&path2);\n\t\t}\n\n\t\tif (!good_one) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfailed = iterate_mounts(tag_mount, tree, tagged);\n\t\tif (failed) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tspin_lock(&hash_lock);\n\t\tif (!tree->goner) {\n\t\t\tlist_del(&tree->list);\n\t\t\tlist_add(&tree->list, &tree_list);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\tput_tree(tree);\n\t}\n\n\twhile (barrier.prev != &tree_list) {\n\t\tstruct audit_tree *tree;\n\n\t\ttree = container_of(barrier.prev, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_del(&tree->list);\n\t\tlist_add(&tree->list, &barrier);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tif (!failed) {\n\t\t\tstruct node *node;\n\t\t\tspin_lock(&hash_lock);\n\t\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t\tspin_unlock(&hash_lock);\n\t\t} else {\n\t\t\ttrim_marked(tree);\n\t\t}\n\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&barrier);\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n\tpath_put(&path1);\n\tdrop_collected_mounts(tagged);\n\treturn failed;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(tree_list);",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(tree_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nint audit_tag_tree(char *old, char *new)\n{\n\tstruct list_head cursor, barrier;\n\tint failed = 0;\n\tstruct path path1, path2;\n\tstruct vfsmount *tagged;\n\tint err;\n\n\terr = kern_path(new, 0, &path2);\n\tif (err)\n\t\treturn err;\n\ttagged = collect_mounts(&path2);\n\tpath_put(&path2);\n\tif (IS_ERR(tagged))\n\t\treturn PTR_ERR(tagged);\n\n\terr = kern_path(old, 0, &path1);\n\tif (err) {\n\t\tdrop_collected_mounts(tagged);\n\t\treturn err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&barrier, &tree_list);\n\tlist_add(&cursor, &barrier);\n\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tint good_one = 0;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_del(&cursor);\n\t\tlist_add(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path2);\n\t\tif (!err) {\n\t\t\tgood_one = path_is_under(&path1, &path2);\n\t\t\tpath_put(&path2);\n\t\t}\n\n\t\tif (!good_one) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfailed = iterate_mounts(tag_mount, tree, tagged);\n\t\tif (failed) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tspin_lock(&hash_lock);\n\t\tif (!tree->goner) {\n\t\t\tlist_del(&tree->list);\n\t\t\tlist_add(&tree->list, &tree_list);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\tput_tree(tree);\n\t}\n\n\twhile (barrier.prev != &tree_list) {\n\t\tstruct audit_tree *tree;\n\n\t\ttree = container_of(barrier.prev, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_del(&tree->list);\n\t\tlist_add(&tree->list, &barrier);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tif (!failed) {\n\t\t\tstruct node *node;\n\t\t\tspin_lock(&hash_lock);\n\t\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t\tspin_unlock(&hash_lock);\n\t\t} else {\n\t\t\ttrim_marked(tree);\n\t\t}\n\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&barrier);\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n\tpath_put(&path1);\n\tdrop_collected_mounts(tagged);\n\treturn failed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_unpack_string",
          "args": [
            "&bufp",
            "&msglen",
            "sizes[1]"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "audit_unpack_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "138-161",
          "snippet": "char *audit_unpack_string(void **bufp, size_t *remain, size_t len)\n{\n\tchar *str;\n\n\tif (!*bufp || (len == 0) || (len > *remain))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Of the currently implemented string fields, PATH_MAX\n\t * defines the longest valid length.\n\t */\n\tif (len > PATH_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tstr = kmalloc(len + 1, GFP_KERNEL);\n\tif (unlikely(!str))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(str, *bufp, len);\n\tstr[len] = 0;\n\t*bufp += len;\n\t*remain -= len;\n\n\treturn str;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nchar *audit_unpack_string(void **bufp, size_t *remain, size_t len)\n{\n\tchar *str;\n\n\tif (!*bufp || (len == 0) || (len > *remain))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Of the currently implemented string fields, PATH_MAX\n\t * defines the longest valid length.\n\t */\n\tif (len > PATH_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tstr = kmalloc(len + 1, GFP_KERNEL);\n\tif (unlikely(!str))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(str, *bufp, len);\n\tstr[len] = 0;\n\t*bufp += len;\n\t*remain -= len;\n\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_len",
          "args": [
            "nlh"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_trim_trees",
          "args": [],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "audit_trim_trees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "630-677",
          "snippet": "void audit_trim_trees(void)\n{\n\tstruct list_head cursor;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&cursor, &tree_list);\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tstruct path path;\n\t\tstruct vfsmount *root_mnt;\n\t\tstruct node *node;\n\t\tint err;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_del(&cursor);\n\t\tlist_add(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path);\n\t\tif (err)\n\t\t\tgoto skip_it;\n\n\t\troot_mnt = collect_mounts(&path);\n\t\tpath_put(&path);\n\t\tif (IS_ERR(root_mnt))\n\t\t\tgoto skip_it;\n\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list) {\n\t\t\tstruct audit_chunk *chunk = find_chunk(node);\n\t\t\t/* this could be NULL if the watch is dying else where... */\n\t\t\tnode->index |= 1U<<31;\n\t\t\tif (iterate_mounts(compare_root,\n\t\t\t\t\t   (void *)chunk_to_key(chunk),\n\t\t\t\t\t   root_mnt))\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\ttrim_marked(tree);\n\t\tdrop_collected_mounts(root_mnt);\nskip_it:\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(tree_list);",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(tree_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nvoid audit_trim_trees(void)\n{\n\tstruct list_head cursor;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&cursor, &tree_list);\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tstruct path path;\n\t\tstruct vfsmount *root_mnt;\n\t\tstruct node *node;\n\t\tint err;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_del(&cursor);\n\t\tlist_add(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path);\n\t\tif (err)\n\t\t\tgoto skip_it;\n\n\t\troot_mnt = collect_mounts(&path);\n\t\tpath_put(&path);\n\t\tif (IS_ERR(root_mnt))\n\t\t\tgoto skip_it;\n\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list) {\n\t\t\tstruct audit_chunk *chunk = find_chunk(node);\n\t\t\t/* this could be NULL if the watch is dying else where... */\n\t\t\tnode->index |= 1U<<31;\n\t\t\tif (iterate_mounts(compare_root,\n\t\t\t\t\t   (void *)chunk_to_key(chunk),\n\t\t\t\t\t   root_mnt))\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\ttrim_marked(tree);\n\t\tdrop_collected_mounts(root_mnt);\nskip_it:\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_list_rules_send",
          "args": [
            "skb",
            "seq"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "audit_list_rules_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1149-1182",
          "snippet": "int audit_list_rules_send(struct sk_buff *request_skb, int seq)\n{\n\tu32 portid = NETLINK_CB(request_skb).portid;\n\tstruct net *net = sock_net(NETLINK_CB(request_skb).sk);\n\tstruct task_struct *tsk;\n\tstruct audit_netlink_list *dest;\n\tint err = 0;\n\n\t/* We can't just spew out the rules here because we might fill\n\t * the available socket buffer space and deadlock waiting for\n\t * auditctl to read from it... which isn't ever going to\n\t * happen if we're actually running in the context of auditctl\n\t * trying to _send_ the stuff */\n\n\tdest = kmalloc(sizeof(struct audit_netlink_list), GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest->net = get_net(net);\n\tdest->portid = portid;\n\tskb_queue_head_init(&dest->q);\n\n\tmutex_lock(&audit_filter_mutex);\n\taudit_list_rules(seq, &dest->q);\n\tmutex_unlock(&audit_filter_mutex);\n\n\ttsk = kthread_run(audit_send_list, dest, \"audit_send_list\");\n\tif (IS_ERR(tsk)) {\n\t\tskb_queue_purge(&dest->q);\n\t\tkfree(dest);\n\t\terr = PTR_ERR(tsk);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_list_rules_send(struct sk_buff *request_skb, int seq)\n{\n\tu32 portid = NETLINK_CB(request_skb).portid;\n\tstruct net *net = sock_net(NETLINK_CB(request_skb).sk);\n\tstruct task_struct *tsk;\n\tstruct audit_netlink_list *dest;\n\tint err = 0;\n\n\t/* We can't just spew out the rules here because we might fill\n\t * the available socket buffer space and deadlock waiting for\n\t * auditctl to read from it... which isn't ever going to\n\t * happen if we're actually running in the context of auditctl\n\t * trying to _send_ the stuff */\n\n\tdest = kmalloc(sizeof(struct audit_netlink_list), GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest->net = get_net(net);\n\tdest->portid = portid;\n\tskb_queue_head_init(&dest->q);\n\n\tmutex_lock(&audit_filter_mutex);\n\taudit_list_rules(seq, &dest->q);\n\tmutex_unlock(&audit_filter_mutex);\n\n\ttsk = kthread_run(audit_send_list, dest, \"audit_send_list\");\n\tif (IS_ERR(tsk)) {\n\t\tskb_queue_purge(&dest->q);\n\t\tkfree(dest);\n\t\terr = PTR_ERR(tsk);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_rule_change",
          "args": [
            "msg_type",
            "seq",
            "data",
            "nlmsg_len(nlh)"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "audit_rule_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1112-1142",
          "snippet": "int audit_rule_change(int type, int seq, void *data, size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\n\tentry = audit_data_to_entry(data, datasz);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\n\tswitch (type) {\n\tcase AUDIT_ADD_RULE:\n\t\terr = audit_add_rule(entry);\n\t\taudit_log_rule_change(\"add_rule\", &entry->rule, !err);\n\t\tbreak;\n\tcase AUDIT_DEL_RULE:\n\t\terr = audit_del_rule(entry);\n\t\taudit_log_rule_change(\"remove_rule\", &entry->rule, !err);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tWARN_ON(1);\n\t}\n\n\tif (err || type == AUDIT_DEL_RULE) {\n\t\tif (entry->rule.exe)\n\t\t\taudit_remove_mark(entry->rule.exe);\n\t\taudit_free_rule(entry);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_rule_change(int type, int seq, void *data, size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\n\tentry = audit_data_to_entry(data, datasz);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\n\tswitch (type) {\n\tcase AUDIT_ADD_RULE:\n\t\terr = audit_add_rule(entry);\n\t\taudit_log_rule_change(\"add_rule\", &entry->rule, !err);\n\t\tbreak;\n\tcase AUDIT_DEL_RULE:\n\t\terr = audit_del_rule(entry);\n\t\taudit_log_rule_change(\"remove_rule\", &entry->rule, !err);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tWARN_ON(1);\n\t}\n\n\tif (err || type == AUDIT_DEL_RULE) {\n\t\tif (entry->rule.exe)\n\t\t\taudit_remove_mark(entry->rule.exe);\n\t\taudit_free_rule(entry);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_len",
          "args": [
            "nlh"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_len",
          "args": [
            "nlh"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_n_untrustedstring",
          "args": [
            "ab",
            "data",
            "size"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_untrustedstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1994-2001",
          "snippet": "void audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_len",
          "args": [
            "nlh"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tty_audit_push",
          "args": [],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_filter",
          "args": [
            "msg_type",
            "AUDIT_FILTER_USER"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1312-1383",
          "snippet": "int audit_filter(int msgtype, unsigned int listtype)\n{\n\tstruct audit_entry *e;\n\tint ret = 1; /* Audit by default */\n\n\trcu_read_lock();\n\tif (list_empty(&audit_filter_list[listtype]))\n\t\tgoto unlock_and_return;\n\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {\n\t\tint i, result = 0;\n\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\t\t\tpid_t pid;\n\t\t\tu32 sid;\n\n\t\t\tswitch (f->type) {\n\t\t\tcase AUDIT_PID:\n\t\t\t\tpid = task_pid_nr(current);\n\t\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_UID:\n\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_GID:\n\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID:\n\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),\n\t\t\t\t\t\t\t      f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID_SET:\n\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_MSGTYPE:\n\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_SUBJ_USER:\n\t\t\tcase AUDIT_SUBJ_ROLE:\n\t\t\tcase AUDIT_SUBJ_TYPE:\n\t\t\tcase AUDIT_SUBJ_SEN:\n\t\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t\tif (f->lsm_rule) {\n\t\t\t\t\tsecurity_task_getsecid(current, &sid);\n\t\t\t\t\tresult = security_audit_rule_match(sid,\n\t\t\t\t\t\t\tf->type, f->op, f->lsm_rule, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_EXE:\n\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t\tif (result < 0) /* error */\n\t\t\t\tgoto unlock_and_return;\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result > 0) {\n\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_and_return:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n#if AUDIT_NR_FILTERS != 7\n#error Fix audit_filter_list initialiser\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n#if AUDIT_NR_FILTERS != 7\n#error Fix audit_filter_list initialiser\n#endif\n};\n\nint audit_filter(int msgtype, unsigned int listtype)\n{\n\tstruct audit_entry *e;\n\tint ret = 1; /* Audit by default */\n\n\trcu_read_lock();\n\tif (list_empty(&audit_filter_list[listtype]))\n\t\tgoto unlock_and_return;\n\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {\n\t\tint i, result = 0;\n\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\t\t\tpid_t pid;\n\t\t\tu32 sid;\n\n\t\t\tswitch (f->type) {\n\t\t\tcase AUDIT_PID:\n\t\t\t\tpid = task_pid_nr(current);\n\t\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_UID:\n\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_GID:\n\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID:\n\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),\n\t\t\t\t\t\t\t      f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID_SET:\n\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_MSGTYPE:\n\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_SUBJ_USER:\n\t\t\tcase AUDIT_SUBJ_ROLE:\n\t\t\tcase AUDIT_SUBJ_TYPE:\n\t\t\tcase AUDIT_SUBJ_SEN:\n\t\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t\tif (f->lsm_rule) {\n\t\t\t\t\tsecurity_task_getsecid(current, &sid);\n\t\t\t\t\tresult = security_audit_rule_match(sid,\n\t\t\t\t\t\t\tf->type, f->op, f->lsm_rule, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_EXE:\n\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t\tif (result < 0) /* error */\n\t\t\t\tgoto unlock_and_return;\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result > 0) {\n\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_and_return:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_set_feature",
          "args": [
            "skb"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1109-1165",
          "snippet": "static int audit_set_feature(struct sk_buff *skb)\n{\n\tstruct audit_features *uaf;\n\tint i;\n\n\tBUILD_BUG_ON(AUDIT_LAST_FEATURE + 1 > ARRAY_SIZE(audit_feature_names));\n\tuaf = nlmsg_data(nlmsg_hdr(skb));\n\n\t/* if there is ever a version 2 we should handle that here */\n\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\t\told_lock = af.lock & feature;\n\n\t\t/* are we changing a locked feature? */\n\t\tif (old_lock && (new_feature != old_feature)) {\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 0);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\t/* nothing invalid, do the changes */\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\told_lock = af.lock & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\n\t\tif (new_feature != old_feature)\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 1);\n\n\t\tif (new_feature)\n\t\t\taf.features |= feature;\n\t\telse\n\t\t\taf.features &= ~feature;\n\t\taf.lock |= new_lock;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};",
            "static char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};\nstatic char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};\n\nstatic int audit_set_feature(struct sk_buff *skb)\n{\n\tstruct audit_features *uaf;\n\tint i;\n\n\tBUILD_BUG_ON(AUDIT_LAST_FEATURE + 1 > ARRAY_SIZE(audit_feature_names));\n\tuaf = nlmsg_data(nlmsg_hdr(skb));\n\n\t/* if there is ever a version 2 we should handle that here */\n\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\t\told_lock = af.lock & feature;\n\n\t\t/* are we changing a locked feature? */\n\t\tif (old_lock && (new_feature != old_feature)) {\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 0);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\t/* nothing invalid, do the changes */\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\told_lock = af.lock & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\n\t\tif (new_feature != old_feature)\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 1);\n\n\t\tif (new_feature)\n\t\t\taf.features |= feature;\n\t\telse\n\t\t\taf.features &= ~feature;\n\t\taf.lock |= new_lock;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_feature",
          "args": [
            "skb"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1081-1090",
          "snippet": "static int audit_get_feature(struct sk_buff *skb)\n{\n\tu32 seq;\n\n\tseq = nlmsg_hdr(skb)->nlmsg_seq;\n\n\taudit_send_reply(skb, seq, AUDIT_GET_FEATURE, 0, 0, &af, sizeof(af));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};\n\nstatic int audit_get_feature(struct sk_buff *skb)\n{\n\tu32 seq;\n\n\tseq = nlmsg_hdr(skb)->nlmsg_seq;\n\n\taudit_send_reply(skb, seq, AUDIT_GET_FEATURE, 0, 0, &af, sizeof(af));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_config_change",
          "args": [
            "\"lost\"",
            "0",
            "lost",
            "1"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_config_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "394-411",
          "snippet": "static int audit_log_config_change(char *function_name, u32 new, u32 old,\n\t\t\t\t   int allow_changes)\n{\n\tstruct audit_buffer *ab;\n\tint rc = 0;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn rc;\n\taudit_log_format(ab, \"%s=%u old=%u\", function_name, new, old);\n\taudit_log_session_info(ab);\n\trc = audit_log_task_context(ab);\n\tif (rc)\n\t\tallow_changes = 0; /* Something weird, deny request */\n\taudit_log_format(ab, \" res=%d\", allow_changes);\n\taudit_log_end(ab);\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_log_config_change(char *function_name, u32 new, u32 old,\n\t\t\t\t   int allow_changes)\n{\n\tstruct audit_buffer *ab;\n\tint rc = 0;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn rc;\n\taudit_log_format(ab, \"%s=%u old=%u\", function_name, new, old);\n\taudit_log_session_info(ab);\n\trc = audit_log_task_context(ab);\n\tif (rc)\n\t\tallow_changes = 0; /* Something weird, deny request */\n\taudit_log_format(ab, \" res=%d\", allow_changes);\n\taudit_log_end(ab);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&audit_lost",
            "0"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_set_backlog_wait_time",
          "args": [
            "s.backlog_wait_time"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_backlog_wait_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "449-453",
          "snippet": "static int audit_set_backlog_wait_time(u32 timeout)\n{\n\treturn audit_do_config_change(\"audit_backlog_wait_time\",\n\t\t\t\t      &audit_backlog_wait_time, timeout);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\n\nstatic int audit_set_backlog_wait_time(u32 timeout)\n{\n\treturn audit_do_config_change(\"audit_backlog_wait_time\",\n\t\t\t\t      &audit_backlog_wait_time, timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_set_backlog_limit",
          "args": [
            "s.backlog_limit"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_backlog_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "444-447",
          "snippet": "static int audit_set_backlog_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_backlog_limit\", &audit_backlog_limit, limit);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_backlog_limit = 64;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_backlog_limit = 64;\n\nstatic int audit_set_backlog_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_backlog_limit\", &audit_backlog_limit, limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_set_rate_limit",
          "args": [
            "s.rate_limit"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_rate_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "439-442",
          "snippet": "static int audit_set_rate_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_rate_limit\", &audit_rate_limit, limit);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_rate_limit;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_rate_limit;\n\nstatic int audit_set_rate_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_rate_limit\", &audit_rate_limit, limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auditd_reset",
          "args": [
            "NULL"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "627-652",
          "snippet": "static void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;",
            "static DEFINE_SPINLOCK(auditd_conn_lock);",
            "static struct sk_buff_head audit_retry_queue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\nstatic DEFINE_SPINLOCK(auditd_conn_lock);\nstatic struct sk_buff_head audit_retry_queue;\n\nstatic void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&kauditd_wait"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auditd_set",
          "args": [
            "req_pid",
            "NETLINK_CB(skb).portid",
            "sock_net(NETLINK_CB(skb).sk)"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "506-531",
          "snippet": "static int auditd_set(struct pid *pid, u32 portid, struct net *net)\n{\n\tunsigned long flags;\n\tstruct auditd_connection *ac_old, *ac_new;\n\n\tif (!pid || !net)\n\t\treturn -EINVAL;\n\n\tac_new = kzalloc(sizeof(*ac_new), GFP_KERNEL);\n\tif (!ac_new)\n\t\treturn -ENOMEM;\n\tac_new->pid = get_pid(pid);\n\tac_new->portid = portid;\n\tac_new->net = get_net(net);\n\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\trcu_assign_pointer(auditd_conn, ac_new);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;",
            "static DEFINE_SPINLOCK(auditd_conn_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\nstatic DEFINE_SPINLOCK(auditd_conn_lock);\n\nstatic int auditd_set(struct pid *pid, u32 portid, struct net *net)\n{\n\tunsigned long flags;\n\tstruct auditd_connection *ac_old, *ac_new;\n\n\tif (!pid || !net)\n\t\treturn -EINVAL;\n\n\tac_new = kzalloc(sizeof(*ac_new), GFP_KERNEL);\n\tif (!ac_new)\n\t\treturn -ENOMEM;\n\tac_new->pid = get_pid(pid);\n\tac_new->portid = portid;\n\tac_new->net = get_net(net);\n\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\trcu_assign_pointer(auditd_conn, ac_new);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_net",
          "args": [
            "NETLINK_CB(skb).sk"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_CB",
          "args": [
            "skb"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_CB",
          "args": [
            "skb"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_vnr",
          "args": [
            "req_pid"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "pid_vnr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "414-417",
          "snippet": "pid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\npid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "auditd_pid_vnr",
          "args": [],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_pid_vnr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "275-289",
          "snippet": "static pid_t auditd_pid_vnr(void)\n{\n\tpid_t pid;\n\tconst struct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac || !ac->pid)\n\t\tpid = 0;\n\telse\n\t\tpid = pid_vnr(ac->pid);\n\trcu_read_unlock();\n\n\treturn pid;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\n\nstatic pid_t auditd_pid_vnr(void)\n{\n\tpid_t pid;\n\tconst struct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac || !ac->pid)\n\t\tpid = 0;\n\telse\n\t\tpid = pid_vnr(ac->pid);\n\trcu_read_unlock();\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_replace",
          "args": [
            "req_pid"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "audit_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1167-1177",
          "snippet": "static int audit_replace(struct pid *pid)\n{\n\tpid_t pvnr;\n\tstruct sk_buff *skb;\n\n\tpvnr = pid_vnr(pid);\n\tskb = audit_make_reply(0, AUDIT_REPLACE, 0, 0, &pvnr, sizeof(pvnr));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\treturn auditd_send_unicast_skb(skb);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_replace(struct pid *pid)\n{\n\tpid_t pvnr;\n\tstruct sk_buff *skb;\n\n\tpvnr = pid_vnr(pid);\n\tskb = audit_make_reply(0, AUDIT_REPLACE, 0, 0, &pvnr, sizeof(pvnr));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\treturn auditd_send_unicast_skb(skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "current"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_set_failure",
          "args": [
            "s.failure"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "468-476",
          "snippet": "static int audit_set_failure(u32 state)\n{\n\tif (state != AUDIT_FAIL_SILENT\n\t    && state != AUDIT_FAIL_PRINTK\n\t    && state != AUDIT_FAIL_PANIC)\n\t\treturn -EINVAL;\n\n\treturn audit_do_config_change(\"audit_failure\", &audit_failure, state);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nstatic int audit_set_failure(u32 state)\n{\n\tif (state != AUDIT_FAIL_SILENT\n\t    && state != AUDIT_FAIL_PRINTK\n\t    && state != AUDIT_FAIL_PANIC)\n\t\treturn -EINVAL;\n\n\treturn audit_do_config_change(\"audit_failure\", &audit_failure, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_set_enabled",
          "args": [
            "s.enabled"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "455-466",
          "snippet": "static int audit_set_enabled(u32 state)\n{\n\tint rc;\n\tif (state > AUDIT_LOCKED)\n\t\treturn -EINVAL;\n\n\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);\n\tif (!rc)\n\t\taudit_ever_enabled |= !!state;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;",
            "bool\t\taudit_ever_enabled = !!AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\nbool\t\taudit_ever_enabled = !!AUDIT_OFF;\n\nstatic int audit_set_enabled(u32 state)\n{\n\tint rc;\n\tif (state > AUDIT_LOCKED)\n\t\treturn -EINVAL;\n\n\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);\n\tif (!rc)\n\t\taudit_ever_enabled |= !!state;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "sizeof(s)",
            "nlmsg_len(nlh)"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_len",
          "args": [
            "nlh"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&s",
            "0",
            "sizeof(s)"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_len",
          "args": [
            "&audit_queue"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&audit_lost"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&s",
            "0",
            "sizeof(s)"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_data",
          "args": [
            "nlh"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_netlink_ok",
          "args": [
            "skb",
            "msg_type"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "audit_netlink_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1001-1055",
          "snippet": "static int audit_netlink_ok(struct sk_buff *skb, u16 msg_type)\n{\n\tint err = 0;\n\n\t/* Only support initial user namespace for now. */\n\t/*\n\t * We return ECONNREFUSED because it tricks userspace into thinking\n\t * that audit was not configured into the kernel.  Lots of users\n\t * configure their PAM stack (because that's what the distro does)\n\t * to reject login if unable to send messages to audit.  If we return\n\t * ECONNREFUSED the PAM stack thinks the kernel does not have audit\n\t * configured in and will let login proceed.  If we return EPERM\n\t * userspace will reject all logins.  This should be removed when we\n\t * support non init namespaces!!\n\t */\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -ECONNREFUSED;\n\n\tswitch (msg_type) {\n\tcase AUDIT_LIST:\n\tcase AUDIT_ADD:\n\tcase AUDIT_DEL:\n\t\treturn -EOPNOTSUPP;\n\tcase AUDIT_GET:\n\tcase AUDIT_SET:\n\tcase AUDIT_GET_FEATURE:\n\tcase AUDIT_SET_FEATURE:\n\tcase AUDIT_LIST_RULES:\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\tcase AUDIT_SIGNAL_INFO:\n\tcase AUDIT_TTY_GET:\n\tcase AUDIT_TTY_SET:\n\tcase AUDIT_TRIM:\n\tcase AUDIT_MAKE_EQUIV:\n\t\t/* Only support auditd and auditctl in initial pid namespace\n\t\t * for now. */\n\t\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\t\treturn -EPERM;\n\n\t\tif (!netlink_capable(skb, CAP_AUDIT_CONTROL))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!netlink_capable(skb, CAP_AUDIT_WRITE))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tdefault:  /* bad msg */\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_netlink_ok(struct sk_buff *skb, u16 msg_type)\n{\n\tint err = 0;\n\n\t/* Only support initial user namespace for now. */\n\t/*\n\t * We return ECONNREFUSED because it tricks userspace into thinking\n\t * that audit was not configured into the kernel.  Lots of users\n\t * configure their PAM stack (because that's what the distro does)\n\t * to reject login if unable to send messages to audit.  If we return\n\t * ECONNREFUSED the PAM stack thinks the kernel does not have audit\n\t * configured in and will let login proceed.  If we return EPERM\n\t * userspace will reject all logins.  This should be removed when we\n\t * support non init namespaces!!\n\t */\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -ECONNREFUSED;\n\n\tswitch (msg_type) {\n\tcase AUDIT_LIST:\n\tcase AUDIT_ADD:\n\tcase AUDIT_DEL:\n\t\treturn -EOPNOTSUPP;\n\tcase AUDIT_GET:\n\tcase AUDIT_SET:\n\tcase AUDIT_GET_FEATURE:\n\tcase AUDIT_SET_FEATURE:\n\tcase AUDIT_LIST_RULES:\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\tcase AUDIT_SIGNAL_INFO:\n\tcase AUDIT_TTY_GET:\n\tcase AUDIT_TTY_SET:\n\tcase AUDIT_TRIM:\n\tcase AUDIT_MAKE_EQUIV:\n\t\t/* Only support auditd and auditctl in initial pid namespace\n\t\t * for now. */\n\t\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\t\treturn -EPERM;\n\n\t\tif (!netlink_capable(skb, CAP_AUDIT_CONTROL))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!netlink_capable(skb, CAP_AUDIT_WRITE))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tdefault:  /* bad msg */\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BACKLOG_WAIT_TIME (60 * HZ)\n\nu32\t\taudit_enabled = AUDIT_OFF;\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nkuid_t\t\taudit_sig_uid = INVALID_UID;\npid_t\t\taudit_sig_pid = -1;\nu32\t\taudit_sig_sid = 0;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nstatic int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tu32\t\t\tseq;\n\tvoid\t\t\t*data;\n\tint\t\t\terr;\n\tstruct audit_buffer\t*ab;\n\tu16\t\t\tmsg_type = nlh->nlmsg_type;\n\tstruct audit_sig_info   *sig_data;\n\tchar\t\t\t*ctx = NULL;\n\tu32\t\t\tlen;\n\n\terr = audit_netlink_ok(skb, msg_type);\n\tif (err)\n\t\treturn err;\n\n\tseq  = nlh->nlmsg_seq;\n\tdata = nlmsg_data(nlh);\n\n\tswitch (msg_type) {\n\tcase AUDIT_GET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\ts.enabled\t\t= audit_enabled;\n\t\ts.failure\t\t= audit_failure;\n\t\t/* NOTE: use pid_vnr() so the PID is relative to the current\n\t\t *       namespace */\n\t\ts.pid\t\t\t= auditd_pid_vnr();\n\t\ts.rate_limit\t\t= audit_rate_limit;\n\t\ts.backlog_limit\t\t= audit_backlog_limit;\n\t\ts.lost\t\t\t= atomic_read(&audit_lost);\n\t\ts.backlog\t\t= skb_queue_len(&audit_queue);\n\t\ts.feature_bitmap\t= AUDIT_FEATURE_BITMAP_ALL;\n\t\ts.backlog_wait_time\t= audit_backlog_wait_time;\n\t\taudit_send_reply(skb, seq, AUDIT_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_SET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), nlmsg_len(nlh)));\n\t\tif (s.mask & AUDIT_STATUS_ENABLED) {\n\t\t\terr = audit_set_enabled(s.enabled);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_FAILURE) {\n\t\t\terr = audit_set_failure(s.failure);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_PID) {\n\t\t\t/* NOTE: we are using the vnr PID functions below\n\t\t\t *       because the s.pid value is relative to the\n\t\t\t *       namespace of the caller; at present this\n\t\t\t *       doesn't matter much since you can really only\n\t\t\t *       run auditd from the initial pid namespace, but\n\t\t\t *       something to keep in mind if this changes */\n\t\t\tpid_t new_pid = s.pid;\n\t\t\tpid_t auditd_pid;\n\t\t\tstruct pid *req_pid = task_tgid(current);\n\n\t\t\t/* Sanity check - PID values must match. Setting\n\t\t\t * pid to 0 is how auditd ends auditing. */\n\t\t\tif (new_pid && (new_pid != pid_vnr(req_pid)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* test the auditd connection */\n\t\t\taudit_replace(req_pid);\n\n\t\t\tauditd_pid = auditd_pid_vnr();\n\t\t\tif (auditd_pid) {\n\t\t\t\t/* replacing a healthy auditd is not allowed */\n\t\t\t\tif (new_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\t/* only current auditd can unregister itself */\n\t\t\t\tif (pid_vnr(req_pid) != auditd_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (new_pid) {\n\t\t\t\t/* register a new auditd connection */\n\t\t\t\terr = auditd_set(req_pid,\n\t\t\t\t\t\t NETLINK_CB(skb).portid,\n\t\t\t\t\t\t sock_net(NETLINK_CB(skb).sk));\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid,\n\t\t\t\t\t\t\t\terr ? 0 : 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\t/* try to process any backlog */\n\t\t\t\twake_up_interruptible(&kauditd_wait);\n\t\t\t} else {\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid, 1);\n\n\t\t\t\t/* unregister the auditd connection */\n\t\t\t\tauditd_reset(NULL);\n\t\t\t}\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_RATE_LIMIT) {\n\t\t\terr = audit_set_rate_limit(s.rate_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_LIMIT) {\n\t\t\terr = audit_set_backlog_limit(s.backlog_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_WAIT_TIME) {\n\t\t\tif (sizeof(s) > (size_t)nlh->nlmsg_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (s.backlog_wait_time > 10*AUDIT_BACKLOG_WAIT_TIME)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = audit_set_backlog_wait_time(s.backlog_wait_time);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask == AUDIT_STATUS_LOST) {\n\t\t\tu32 lost = atomic_xchg(&audit_lost, 0);\n\n\t\t\taudit_log_config_change(\"lost\", 0, lost, 1);\n\t\t\treturn lost;\n\t\t}\n\t\tbreak;\n\t}\n\tcase AUDIT_GET_FEATURE:\n\t\terr = audit_get_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_SET_FEATURE:\n\t\terr = audit_set_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!audit_enabled && msg_type != AUDIT_USER_AVC)\n\t\t\treturn 0;\n\n\t\terr = audit_filter(msg_type, AUDIT_FILTER_USER);\n\t\tif (err == 1) { /* match or error */\n\t\t\terr = 0;\n\t\t\tif (msg_type == AUDIT_USER_TTY) {\n\t\t\t\terr = tty_audit_push();\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\taudit_log_common_recv_msg(&ab, msg_type);\n\t\t\tif (msg_type != AUDIT_USER_TTY)\n\t\t\t\taudit_log_format(ab, \" msg='%.*s'\",\n\t\t\t\t\t\t AUDIT_MESSAGE_TEXT_MAX,\n\t\t\t\t\t\t (char *)data);\n\t\t\telse {\n\t\t\t\tint size;\n\n\t\t\t\taudit_log_format(ab, \" data=\");\n\t\t\t\tsize = nlmsg_len(nlh);\n\t\t\t\tif (size > 0 &&\n\t\t\t\t    ((unsigned char *)data)[size - 1] == '\\0')\n\t\t\t\t\tsize--;\n\t\t\t\taudit_log_n_untrustedstring(ab, data, size);\n\t\t\t}\n\t\t\taudit_log_end(ab);\n\t\t}\n\t\tbreak;\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\t\tif (nlmsg_len(nlh) < sizeof(struct audit_rule_data))\n\t\t\treturn -EINVAL;\n\t\tif (audit_enabled == AUDIT_LOCKED) {\n\t\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\t\t\taudit_log_format(ab, \" audit_enabled=%d res=0\", audit_enabled);\n\t\t\taudit_log_end(ab);\n\t\t\treturn -EPERM;\n\t\t}\n\t\terr = audit_rule_change(msg_type, seq, data, nlmsg_len(nlh));\n\t\tbreak;\n\tcase AUDIT_LIST_RULES:\n\t\terr = audit_list_rules_send(skb, seq);\n\t\tbreak;\n\tcase AUDIT_TRIM:\n\t\taudit_trim_trees();\n\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=trim res=1\");\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_MAKE_EQUIV: {\n\t\tvoid *bufp = data;\n\t\tu32 sizes[2];\n\t\tsize_t msglen = nlmsg_len(nlh);\n\t\tchar *old, *new;\n\n\t\terr = -EINVAL;\n\t\tif (msglen < 2 * sizeof(u32))\n\t\t\tbreak;\n\t\tmemcpy(sizes, bufp, 2 * sizeof(u32));\n\t\tbufp += 2 * sizeof(u32);\n\t\tmsglen -= 2 * sizeof(u32);\n\t\told = audit_unpack_string(&bufp, &msglen, sizes[0]);\n\t\tif (IS_ERR(old)) {\n\t\t\terr = PTR_ERR(old);\n\t\t\tbreak;\n\t\t}\n\t\tnew = audit_unpack_string(&bufp, &msglen, sizes[1]);\n\t\tif (IS_ERR(new)) {\n\t\t\terr = PTR_ERR(new);\n\t\t\tkfree(old);\n\t\t\tbreak;\n\t\t}\n\t\t/* OK, here comes... */\n\t\terr = audit_tag_tree(old, new);\n\n\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\n\t\taudit_log_format(ab, \" op=make_equiv old=\");\n\t\taudit_log_untrustedstring(ab, old);\n\t\taudit_log_format(ab, \" new=\");\n\t\taudit_log_untrustedstring(ab, new);\n\t\taudit_log_format(ab, \" res=%d\", !err);\n\t\taudit_log_end(ab);\n\t\tkfree(old);\n\t\tkfree(new);\n\t\tbreak;\n\t}\n\tcase AUDIT_SIGNAL_INFO:\n\t\tlen = 0;\n\t\tif (audit_sig_sid) {\n\t\t\terr = security_secid_to_secctx(audit_sig_sid, &ctx, &len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tsig_data = kmalloc(sizeof(*sig_data) + len, GFP_KERNEL);\n\t\tif (!sig_data) {\n\t\t\tif (audit_sig_sid)\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsig_data->uid = from_kuid(&init_user_ns, audit_sig_uid);\n\t\tsig_data->pid = audit_sig_pid;\n\t\tif (audit_sig_sid) {\n\t\t\tmemcpy(sig_data->ctx, ctx, len);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t\taudit_send_reply(skb, seq, AUDIT_SIGNAL_INFO, 0, 0,\n\t\t\t\t sig_data, sizeof(*sig_data) + len);\n\t\tkfree(sig_data);\n\t\tbreak;\n\tcase AUDIT_TTY_GET: {\n\t\tstruct audit_tty_status s;\n\t\tunsigned int t;\n\n\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\ts.enabled = t & AUDIT_TTY_ENABLE;\n\t\ts.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_send_reply(skb, seq, AUDIT_TTY_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_TTY_SET: {\n\t\tstruct audit_tty_status s, old;\n\t\tstruct audit_buffer\t*ab;\n\t\tunsigned int t;\n\n\t\tmemset(&s, 0, sizeof(s));\n\t\t/* guard against past and future API changes */\n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), nlmsg_len(nlh)));\n\t\t/* check if new data is valid */\n\t\tif ((s.enabled != 0 && s.enabled != 1) ||\n\t\t    (s.log_passwd != 0 && s.log_passwd != 1))\n\t\t\terr = -EINVAL;\n\n\t\tif (err)\n\t\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\telse {\n\t\t\tt = s.enabled | (-s.log_passwd & AUDIT_TTY_LOG_PASSWD);\n\t\t\tt = xchg(&current->signal->audit_tty, t);\n\t\t}\n\t\told.enabled = t & AUDIT_TTY_ENABLE;\n\t\told.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_log_common_recv_msg(&ab, AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=tty_set old-enabled=%d new-enabled=%d\"\n\t\t\t\t \" old-log_passwd=%d new-log_passwd=%d res=%d\",\n\t\t\t\t old.enabled, s.enabled, old.log_passwd,\n\t\t\t\t s.log_passwd, !err);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err < 0 ? err : 0;\n}"
  },
  {
    "function_name": "audit_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1167-1177",
    "snippet": "static int audit_replace(struct pid *pid)\n{\n\tpid_t pvnr;\n\tstruct sk_buff *skb;\n\n\tpvnr = pid_vnr(pid);\n\tskb = audit_make_reply(0, AUDIT_REPLACE, 0, 0, &pvnr, sizeof(pvnr));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\treturn auditd_send_unicast_skb(skb);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "auditd_send_unicast_skb",
          "args": [
            "skb"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_send_unicast_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "665-704",
          "snippet": "static int auditd_send_unicast_skb(struct sk_buff *skb)\n{\n\tint rc;\n\tu32 portid;\n\tstruct net *net;\n\tstruct sock *sk;\n\tstruct auditd_connection *ac;\n\n\t/* NOTE: we can't call netlink_unicast while in the RCU section so\n\t *       take a reference to the network namespace and grab local\n\t *       copies of the namespace, the sock, and the portid; the\n\t *       namespace and sock aren't going to go away while we hold a\n\t *       reference and if the portid does become invalid after the RCU\n\t *       section netlink_unicast() should safely return an error */\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\trc = -ECONNREFUSED;\n\t\tgoto err;\n\t}\n\tnet = get_net(ac->net);\n\tsk = audit_get_sk(net);\n\tportid = ac->portid;\n\trcu_read_unlock();\n\n\trc = netlink_unicast(sk, skb, portid, 0);\n\tput_net(net);\n\tif (rc < 0)\n\t\tgoto err;\n\n\treturn rc;\n\nerr:\n\tif (ac && rc == -ECONNREFUSED)\n\t\tauditd_reset(ac);\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\n\nstatic int auditd_send_unicast_skb(struct sk_buff *skb)\n{\n\tint rc;\n\tu32 portid;\n\tstruct net *net;\n\tstruct sock *sk;\n\tstruct auditd_connection *ac;\n\n\t/* NOTE: we can't call netlink_unicast while in the RCU section so\n\t *       take a reference to the network namespace and grab local\n\t *       copies of the namespace, the sock, and the portid; the\n\t *       namespace and sock aren't going to go away while we hold a\n\t *       reference and if the portid does become invalid after the RCU\n\t *       section netlink_unicast() should safely return an error */\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\trc = -ECONNREFUSED;\n\t\tgoto err;\n\t}\n\tnet = get_net(ac->net);\n\tsk = audit_get_sk(net);\n\tportid = ac->portid;\n\trcu_read_unlock();\n\n\trc = netlink_unicast(sk, skb, portid, 0);\n\tput_net(net);\n\tif (rc < 0)\n\t\tgoto err;\n\n\treturn rc;\n\nerr:\n\tif (ac && rc == -ECONNREFUSED)\n\t\tauditd_reset(ac);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_make_reply",
          "args": [
            "0",
            "AUDIT_REPLACE",
            "0",
            "0",
            "&pvnr",
            "sizeof(pvnr)"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "audit_make_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "915-938",
          "snippet": "struct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_vnr",
          "args": [
            "pid"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "pid_vnr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "414-417",
          "snippet": "pid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\npid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_replace(struct pid *pid)\n{\n\tpid_t pvnr;\n\tstruct sk_buff *skb;\n\n\tpvnr = pid_vnr(pid);\n\tskb = audit_make_reply(0, AUDIT_REPLACE, 0, 0, &pvnr, sizeof(pvnr));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\treturn auditd_send_unicast_skb(skb);\n}"
  },
  {
    "function_name": "audit_set_feature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1109-1165",
    "snippet": "static int audit_set_feature(struct sk_buff *skb)\n{\n\tstruct audit_features *uaf;\n\tint i;\n\n\tBUILD_BUG_ON(AUDIT_LAST_FEATURE + 1 > ARRAY_SIZE(audit_feature_names));\n\tuaf = nlmsg_data(nlmsg_hdr(skb));\n\n\t/* if there is ever a version 2 we should handle that here */\n\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\t\told_lock = af.lock & feature;\n\n\t\t/* are we changing a locked feature? */\n\t\tif (old_lock && (new_feature != old_feature)) {\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 0);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\t/* nothing invalid, do the changes */\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\told_lock = af.lock & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\n\t\tif (new_feature != old_feature)\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 1);\n\n\t\tif (new_feature)\n\t\t\taf.features |= feature;\n\t\telse\n\t\t\taf.features &= ~feature;\n\t\taf.lock |= new_lock;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};",
      "static char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_feature_change",
          "args": [
            "i",
            "old_feature",
            "new_feature",
            "old_lock",
            "new_lock",
            "1"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_feature_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1092-1107",
          "snippet": "static void audit_log_feature_change(int which, u32 old_feature, u32 new_feature,\n\t\t\t\t     u32 old_lock, u32 new_lock, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_FEATURE_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_task_info(ab, current);\n\taudit_log_format(ab, \" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d\",\n\t\t\t audit_feature_names[which], !!old_feature, !!new_feature,\n\t\t\t !!old_lock, !!new_lock, res);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;",
            "static char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\nstatic char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};\n\nstatic void audit_log_feature_change(int which, u32 old_feature, u32 new_feature,\n\t\t\t\t     u32 old_lock, u32 new_lock, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_FEATURE_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_task_info(ab, current);\n\taudit_log_format(ab, \" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d\",\n\t\t\t audit_feature_names[which], !!old_feature, !!new_feature,\n\t\t\t !!old_lock, !!new_lock, res);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUDIT_FEATURE_TO_MASK",
          "args": [
            "i"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_FEATURE_TO_MASK",
          "args": [
            "i"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_data",
          "args": [
            "nlmsg_hdr(skb)"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_hdr",
          "args": [
            "skb"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "AUDIT_LAST_FEATURE + 1 > ARRAY_SIZE(audit_feature_names)"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "audit_feature_names"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};\nstatic char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};\n\nstatic int audit_set_feature(struct sk_buff *skb)\n{\n\tstruct audit_features *uaf;\n\tint i;\n\n\tBUILD_BUG_ON(AUDIT_LAST_FEATURE + 1 > ARRAY_SIZE(audit_feature_names));\n\tuaf = nlmsg_data(nlmsg_hdr(skb));\n\n\t/* if there is ever a version 2 we should handle that here */\n\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\t\told_lock = af.lock & feature;\n\n\t\t/* are we changing a locked feature? */\n\t\tif (old_lock && (new_feature != old_feature)) {\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 0);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\t/* nothing invalid, do the changes */\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t/* if we are not changing this feature, move along */\n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\told_lock = af.lock & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\n\t\tif (new_feature != old_feature)\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 1);\n\n\t\tif (new_feature)\n\t\t\taf.features |= feature;\n\t\telse\n\t\t\taf.features &= ~feature;\n\t\taf.lock |= new_lock;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_log_feature_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1092-1107",
    "snippet": "static void audit_log_feature_change(int which, u32 old_feature, u32 new_feature,\n\t\t\t\t     u32 old_lock, u32 new_lock, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_FEATURE_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_task_info(ab, current);\n\taudit_log_format(ab, \" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d\",\n\t\t\t audit_feature_names[which], !!old_feature, !!new_feature,\n\t\t\t !!old_lock, !!new_lock, res);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32\t\taudit_enabled = AUDIT_OFF;",
      "static char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d\"",
            "audit_feature_names[which]",
            "!!old_feature",
            "!!new_feature",
            "!!old_lock",
            "!!new_lock",
            "res"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_task_info",
          "args": [
            "ab",
            "current"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2267-2301",
          "snippet": "void audit_log_task_info(struct audit_buffer *ab, struct task_struct *tsk)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(tsk->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\t/* tsk == current */\n\tcred = current_cred();\n\ttty = audit_get_tty(tsk);\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(tsk),\n\t\t\t task_tgid_nr(tsk),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(tsk)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(tsk));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, tsk));\n\taudit_log_d_path_exe(ab, tsk->mm);\n\taudit_log_task_context(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_task_info(struct audit_buffer *ab, struct task_struct *tsk)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(tsk->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\t/* tsk == current */\n\tcred = current_cred();\n\ttty = audit_get_tty(tsk);\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(tsk),\n\t\t\t task_tgid_nr(tsk),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(tsk)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(tsk));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, tsk));\n\taudit_log_d_path_exe(ab, tsk->mm);\n\taudit_log_task_context(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_FEATURE_CHANGE"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\nstatic char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};\n\nstatic void audit_log_feature_change(int which, u32 old_feature, u32 new_feature,\n\t\t\t\t     u32 old_lock, u32 new_lock, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_FEATURE_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_task_info(ab, current);\n\taudit_log_format(ab, \" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d\",\n\t\t\t audit_feature_names[which], !!old_feature, !!new_feature,\n\t\t\t !!old_lock, !!new_lock, res);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_get_feature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1081-1090",
    "snippet": "static int audit_get_feature(struct sk_buff *skb)\n{\n\tu32 seq;\n\n\tseq = nlmsg_hdr(skb)->nlmsg_seq;\n\n\taudit_send_reply(skb, seq, AUDIT_GET_FEATURE, 0, 0, &af, sizeof(af));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_send_reply",
          "args": [
            "skb",
            "seq",
            "AUDIT_GET_FEATURE",
            "0",
            "0",
            "&af",
            "sizeof(af)"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "audit_send_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "969-995",
          "snippet": "static void audit_send_reply(struct sk_buff *request_skb, int seq, int type, int done,\n\t\t\t     int multi, const void *payload, int size)\n{\n\tstruct net *net = sock_net(NETLINK_CB(request_skb).sk);\n\tstruct sk_buff *skb;\n\tstruct task_struct *tsk;\n\tstruct audit_reply *reply = kmalloc(sizeof(struct audit_reply),\n\t\t\t\t\t    GFP_KERNEL);\n\n\tif (!reply)\n\t\treturn;\n\n\tskb = audit_make_reply(seq, type, done, multi, payload, size);\n\tif (!skb)\n\t\tgoto out;\n\n\treply->net = get_net(net);\n\treply->portid = NETLINK_CB(request_skb).portid;\n\treply->skb = skb;\n\n\ttsk = kthread_run(audit_send_reply_thread, reply, \"audit_send_reply\");\n\tif (!IS_ERR(tsk))\n\t\treturn;\n\tkfree_skb(skb);\nout:\n\tkfree(reply);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void audit_send_reply(struct sk_buff *request_skb, int seq, int type, int done,\n\t\t\t     int multi, const void *payload, int size)\n{\n\tstruct net *net = sock_net(NETLINK_CB(request_skb).sk);\n\tstruct sk_buff *skb;\n\tstruct task_struct *tsk;\n\tstruct audit_reply *reply = kmalloc(sizeof(struct audit_reply),\n\t\t\t\t\t    GFP_KERNEL);\n\n\tif (!reply)\n\t\treturn;\n\n\tskb = audit_make_reply(seq, type, done, multi, payload, size);\n\tif (!skb)\n\t\tgoto out;\n\n\treply->net = get_net(net);\n\treply->portid = NETLINK_CB(request_skb).portid;\n\treply->skb = skb;\n\n\ttsk = kthread_run(audit_send_reply_thread, reply, \"audit_send_reply\");\n\tif (!IS_ERR(tsk))\n\t\treturn;\n\tkfree_skb(skb);\nout:\n\tkfree(reply);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_hdr",
          "args": [
            "skb"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};\n\nstatic int audit_get_feature(struct sk_buff *skb)\n{\n\tu32 seq;\n\n\tseq = nlmsg_hdr(skb)->nlmsg_seq;\n\n\taudit_send_reply(skb, seq, AUDIT_GET_FEATURE, 0, 0, &af, sizeof(af));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_audit_feature_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1075-1078",
    "snippet": "int is_audit_feature_set(int i)\n{\n\treturn af.features & AUDIT_FEATURE_TO_MASK(i);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUDIT_FEATURE_TO_MASK",
          "args": [
            "i"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};\n\nint is_audit_feature_set(int i)\n{\n\treturn af.features & AUDIT_FEATURE_TO_MASK(i);\n}"
  },
  {
    "function_name": "audit_log_common_recv_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1057-1073",
    "snippet": "static void audit_log_common_recv_msg(struct audit_buffer **ab, u16 msg_type)\n{\n\tuid_t uid = from_kuid(&init_user_ns, current_uid());\n\tpid_t pid = task_tgid_nr(current);\n\n\tif (!audit_enabled && msg_type != AUDIT_USER_AVC) {\n\t\t*ab = NULL;\n\t\treturn;\n\t}\n\n\t*ab = audit_log_start(NULL, GFP_KERNEL, msg_type);\n\tif (unlikely(!*ab))\n\t\treturn;\n\taudit_log_format(*ab, \"pid=%d uid=%u\", pid, uid);\n\taudit_log_session_info(*ab);\n\taudit_log_task_context(*ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32\t\taudit_enabled = AUDIT_OFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "*ab"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2203-2228",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_task_getsecid(current, &sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_task_getsecid(current, &sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_session_info",
          "args": [
            "*ab"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_session_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2040-2046",
          "snippet": "void audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \" auid=%u ses=%u\", auid, sessionid);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \" auid=%u ses=%u\", auid, sessionid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "*ab",
            "\"pid=%d uid=%u\"",
            "pid",
            "uid"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!*ab"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "NULL",
            "GFP_KERNEL",
            "msg_type"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "current"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "current_uid()"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic void audit_log_common_recv_msg(struct audit_buffer **ab, u16 msg_type)\n{\n\tuid_t uid = from_kuid(&init_user_ns, current_uid());\n\tpid_t pid = task_tgid_nr(current);\n\n\tif (!audit_enabled && msg_type != AUDIT_USER_AVC) {\n\t\t*ab = NULL;\n\t\treturn;\n\t}\n\n\t*ab = audit_log_start(NULL, GFP_KERNEL, msg_type);\n\tif (unlikely(!*ab))\n\t\treturn;\n\taudit_log_format(*ab, \"pid=%d uid=%u\", pid, uid);\n\taudit_log_session_info(*ab);\n\taudit_log_task_context(*ab);\n}"
  },
  {
    "function_name": "audit_netlink_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "1001-1055",
    "snippet": "static int audit_netlink_ok(struct sk_buff *skb, u16 msg_type)\n{\n\tint err = 0;\n\n\t/* Only support initial user namespace for now. */\n\t/*\n\t * We return ECONNREFUSED because it tricks userspace into thinking\n\t * that audit was not configured into the kernel.  Lots of users\n\t * configure their PAM stack (because that's what the distro does)\n\t * to reject login if unable to send messages to audit.  If we return\n\t * ECONNREFUSED the PAM stack thinks the kernel does not have audit\n\t * configured in and will let login proceed.  If we return EPERM\n\t * userspace will reject all logins.  This should be removed when we\n\t * support non init namespaces!!\n\t */\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -ECONNREFUSED;\n\n\tswitch (msg_type) {\n\tcase AUDIT_LIST:\n\tcase AUDIT_ADD:\n\tcase AUDIT_DEL:\n\t\treturn -EOPNOTSUPP;\n\tcase AUDIT_GET:\n\tcase AUDIT_SET:\n\tcase AUDIT_GET_FEATURE:\n\tcase AUDIT_SET_FEATURE:\n\tcase AUDIT_LIST_RULES:\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\tcase AUDIT_SIGNAL_INFO:\n\tcase AUDIT_TTY_GET:\n\tcase AUDIT_TTY_SET:\n\tcase AUDIT_TRIM:\n\tcase AUDIT_MAKE_EQUIV:\n\t\t/* Only support auditd and auditctl in initial pid namespace\n\t\t * for now. */\n\t\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\t\treturn -EPERM;\n\n\t\tif (!netlink_capable(skb, CAP_AUDIT_CONTROL))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!netlink_capable(skb, CAP_AUDIT_WRITE))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tdefault:  /* bad msg */\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlink_capable",
          "args": [
            "skb",
            "CAP_AUDIT_WRITE"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_capable",
          "args": [
            "skb",
            "CAP_AUDIT_CONTROL"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_netlink_ok(struct sk_buff *skb, u16 msg_type)\n{\n\tint err = 0;\n\n\t/* Only support initial user namespace for now. */\n\t/*\n\t * We return ECONNREFUSED because it tricks userspace into thinking\n\t * that audit was not configured into the kernel.  Lots of users\n\t * configure their PAM stack (because that's what the distro does)\n\t * to reject login if unable to send messages to audit.  If we return\n\t * ECONNREFUSED the PAM stack thinks the kernel does not have audit\n\t * configured in and will let login proceed.  If we return EPERM\n\t * userspace will reject all logins.  This should be removed when we\n\t * support non init namespaces!!\n\t */\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -ECONNREFUSED;\n\n\tswitch (msg_type) {\n\tcase AUDIT_LIST:\n\tcase AUDIT_ADD:\n\tcase AUDIT_DEL:\n\t\treturn -EOPNOTSUPP;\n\tcase AUDIT_GET:\n\tcase AUDIT_SET:\n\tcase AUDIT_GET_FEATURE:\n\tcase AUDIT_SET_FEATURE:\n\tcase AUDIT_LIST_RULES:\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\tcase AUDIT_SIGNAL_INFO:\n\tcase AUDIT_TTY_GET:\n\tcase AUDIT_TTY_SET:\n\tcase AUDIT_TRIM:\n\tcase AUDIT_MAKE_EQUIV:\n\t\t/* Only support auditd and auditctl in initial pid namespace\n\t\t * for now. */\n\t\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\t\treturn -EPERM;\n\n\t\tif (!netlink_capable(skb, CAP_AUDIT_CONTROL))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!netlink_capable(skb, CAP_AUDIT_WRITE))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tdefault:  /* bad msg */\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "audit_send_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "969-995",
    "snippet": "static void audit_send_reply(struct sk_buff *request_skb, int seq, int type, int done,\n\t\t\t     int multi, const void *payload, int size)\n{\n\tstruct net *net = sock_net(NETLINK_CB(request_skb).sk);\n\tstruct sk_buff *skb;\n\tstruct task_struct *tsk;\n\tstruct audit_reply *reply = kmalloc(sizeof(struct audit_reply),\n\t\t\t\t\t    GFP_KERNEL);\n\n\tif (!reply)\n\t\treturn;\n\n\tskb = audit_make_reply(seq, type, done, multi, payload, size);\n\tif (!skb)\n\t\tgoto out;\n\n\treply->net = get_net(net);\n\treply->portid = NETLINK_CB(request_skb).portid;\n\treply->skb = skb;\n\n\ttsk = kthread_run(audit_send_reply_thread, reply, \"audit_send_reply\");\n\tif (!IS_ERR(tsk))\n\t\treturn;\n\tkfree_skb(skb);\nout:\n\tkfree(reply);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "reply"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_skb",
          "args": [
            "skb"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tsk"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "audit_send_reply_thread",
            "reply",
            "\"audit_send_reply\""
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_CB",
          "args": [
            "request_skb"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_net",
          "args": [
            "net"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_make_reply",
          "args": [
            "seq",
            "type",
            "done",
            "multi",
            "payload",
            "size"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "audit_make_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "915-938",
          "snippet": "struct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct audit_reply)",
            "GFP_KERNEL"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_net",
          "args": [
            "NETLINK_CB(request_skb).sk"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_CB",
          "args": [
            "request_skb"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void audit_send_reply(struct sk_buff *request_skb, int seq, int type, int done,\n\t\t\t     int multi, const void *payload, int size)\n{\n\tstruct net *net = sock_net(NETLINK_CB(request_skb).sk);\n\tstruct sk_buff *skb;\n\tstruct task_struct *tsk;\n\tstruct audit_reply *reply = kmalloc(sizeof(struct audit_reply),\n\t\t\t\t\t    GFP_KERNEL);\n\n\tif (!reply)\n\t\treturn;\n\n\tskb = audit_make_reply(seq, type, done, multi, payload, size);\n\tif (!skb)\n\t\tgoto out;\n\n\treply->net = get_net(net);\n\treply->portid = NETLINK_CB(request_skb).portid;\n\treply->skb = skb;\n\n\ttsk = kthread_run(audit_send_reply_thread, reply, \"audit_send_reply\");\n\tif (!IS_ERR(tsk))\n\t\treturn;\n\tkfree_skb(skb);\nout:\n\tkfree(reply);\n}"
  },
  {
    "function_name": "audit_send_reply_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "940-954",
    "snippet": "static int audit_send_reply_thread(void *arg)\n{\n\tstruct audit_reply *reply = (struct audit_reply *)arg;\n\tstruct sock *sk = audit_get_sk(reply->net);\n\n\taudit_ctl_lock();\n\taudit_ctl_unlock();\n\n\t/* Ignore failure. It'll only happen if the sender goes away,\n\t   because our timeout is set to infinite. */\n\tnetlink_unicast(sk, reply->skb, reply->portid, 0);\n\tput_net(reply->net);\n\tkfree(reply);\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "reply"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "reply->net"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_unicast",
          "args": [
            "sk",
            "reply->skb",
            "reply->portid",
            "0"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ctl_unlock",
          "args": [],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "251-255",
          "snippet": "void audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_ctl_lock",
          "args": [],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "242-246",
          "snippet": "void audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_sk",
          "args": [
            "reply->net"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_sk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "299-308",
          "snippet": "static struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int audit_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_send_reply_thread(void *arg)\n{\n\tstruct audit_reply *reply = (struct audit_reply *)arg;\n\tstruct sock *sk = audit_get_sk(reply->net);\n\n\taudit_ctl_lock();\n\taudit_ctl_unlock();\n\n\t/* Ignore failure. It'll only happen if the sender goes away,\n\t   because our timeout is set to infinite. */\n\tnetlink_unicast(sk, reply->skb, reply->portid, 0);\n\tput_net(reply->net);\n\tkfree(reply);\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_make_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "915-938",
    "snippet": "struct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_skb",
          "args": [
            "skb"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "payload",
            "size"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_data",
          "args": [
            "nlh"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_put",
          "args": [
            "skb",
            "0",
            "seq",
            "t",
            "size",
            "flags"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_new",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}"
  },
  {
    "function_name": "audit_send_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "896-913",
    "snippet": "int audit_send_list(void *_dest)\n{\n\tstruct audit_netlink_list *dest = _dest;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = audit_get_sk(dest->net);\n\n\t/* wait for parent to finish and send an ACK */\n\taudit_ctl_lock();\n\taudit_ctl_unlock();\n\n\twhile ((skb = __skb_dequeue(&dest->q)) != NULL)\n\t\tnetlink_unicast(sk, skb, dest->portid, 0);\n\n\tput_net(dest->net);\n\tkfree(dest);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dest"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "dest->net"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_unicast",
          "args": [
            "sk",
            "skb",
            "dest->portid",
            "0"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__skb_dequeue",
          "args": [
            "&dest->q"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ctl_unlock",
          "args": [],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "251-255",
          "snippet": "void audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_ctl_lock",
          "args": [],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "242-246",
          "snippet": "void audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_sk",
          "args": [
            "dest->net"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_sk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "299-308",
          "snippet": "static struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int audit_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_send_list(void *_dest)\n{\n\tstruct audit_netlink_list *dest = _dest;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = audit_get_sk(dest->net);\n\n\t/* wait for parent to finish and send an ACK */\n\taudit_ctl_lock();\n\taudit_ctl_unlock();\n\n\twhile ((skb = __skb_dequeue(&dest->q)) != NULL)\n\t\tnetlink_unicast(sk, skb, dest->portid, 0);\n\n\tput_net(dest->net);\n\tkfree(dest);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kauditd_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "819-894",
    "snippet": "static int kauditd_thread(void *dummy)\n{\n\tint rc;\n\tu32 portid = 0;\n\tstruct net *net = NULL;\n\tstruct sock *sk = NULL;\n\tstruct auditd_connection *ac;\n\n#define UNICAST_RETRIES 5\n\n\tset_freezable();\n\twhile (!kthread_should_stop()) {\n\t\t/* NOTE: see the lock comments in auditd_send_unicast_skb() */\n\t\trcu_read_lock();\n\t\tac = rcu_dereference(auditd_conn);\n\t\tif (!ac) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto main_queue;\n\t\t}\n\t\tnet = get_net(ac->net);\n\t\tsk = audit_get_sk(net);\n\t\tportid = ac->portid;\n\t\trcu_read_unlock();\n\n\t\t/* attempt to flush the hold queue */\n\t\trc = kauditd_send_queue(sk, portid,\n\t\t\t\t\t&audit_hold_queue, UNICAST_RETRIES,\n\t\t\t\t\tNULL, kauditd_rehold_skb);\n\t\tif (ac && rc < 0) {\n\t\t\tsk = NULL;\n\t\t\tauditd_reset(ac);\n\t\t\tgoto main_queue;\n\t\t}\n\n\t\t/* attempt to flush the retry queue */\n\t\trc = kauditd_send_queue(sk, portid,\n\t\t\t\t\t&audit_retry_queue, UNICAST_RETRIES,\n\t\t\t\t\tNULL, kauditd_hold_skb);\n\t\tif (ac && rc < 0) {\n\t\t\tsk = NULL;\n\t\t\tauditd_reset(ac);\n\t\t\tgoto main_queue;\n\t\t}\n\nmain_queue:\n\t\t/* process the main queue - do the multicast send and attempt\n\t\t * unicast, dump failed record sends to the retry queue; if\n\t\t * sk == NULL due to previous failures we will just do the\n\t\t * multicast send and move the record to the hold queue */\n\t\trc = kauditd_send_queue(sk, portid, &audit_queue, 1,\n\t\t\t\t\tkauditd_send_multicast_skb,\n\t\t\t\t\t(sk ?\n\t\t\t\t\t kauditd_retry_skb : kauditd_hold_skb));\n\t\tif (ac && rc < 0)\n\t\t\tauditd_reset(ac);\n\t\tsk = NULL;\n\n\t\t/* drop our netns reference, no auditd sends past this line */\n\t\tif (net) {\n\t\t\tput_net(net);\n\t\t\tnet = NULL;\n\t\t}\n\n\t\t/* we have processed all the queues so wake everyone */\n\t\twake_up(&audit_backlog_wait);\n\n\t\t/* NOTE: we want to wake up if there is anything on the queue,\n\t\t *       regardless of if an auditd is connected, as we need to\n\t\t *       do the multicast send and rotate records from the\n\t\t *       main queue to the retry/hold queues */\n\t\twait_event_freezable(kauditd_wait,\n\t\t\t\t     (skb_queue_len(&audit_queue) ? 1 : 0));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define UNICAST_RETRIES 5"
    ],
    "globals_used": [
      "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;",
      "static struct sk_buff_head audit_queue;",
      "static struct sk_buff_head audit_retry_queue;",
      "static struct sk_buff_head audit_hold_queue;",
      "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
      "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event_freezable",
          "args": [
            "kauditd_wait",
            "(skb_queue_len(&audit_queue) ? 1 : 0)"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_len",
          "args": [
            "&audit_queue"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&audit_backlog_wait"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "net"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auditd_reset",
          "args": [
            "ac"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "627-652",
          "snippet": "static void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;",
            "static DEFINE_SPINLOCK(auditd_conn_lock);",
            "static struct sk_buff_head audit_retry_queue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\nstatic DEFINE_SPINLOCK(auditd_conn_lock);\nstatic struct sk_buff_head audit_retry_queue;\n\nstatic void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kauditd_send_queue",
          "args": [
            "sk",
            "portid",
            "&audit_queue",
            "1",
            "kauditd_send_multicast_skb",
            "(sk ?\n\t\t\t\t\t kauditd_retry_skb : kauditd_hold_skb)"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_send_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "721-773",
          "snippet": "static int kauditd_send_queue(struct sock *sk, u32 portid,\n\t\t\t      struct sk_buff_head *queue,\n\t\t\t      unsigned int retry_limit,\n\t\t\t      void (*skb_hook)(struct sk_buff *skb),\n\t\t\t      void (*err_hook)(struct sk_buff *skb))\n{\n\tint rc = 0;\n\tstruct sk_buff *skb;\n\tstatic unsigned int failed = 0;\n\n\t/* NOTE: kauditd_thread takes care of all our locking, we just use\n\t *       the netlink info passed to us (e.g. sk and portid) */\n\n\twhile ((skb = skb_dequeue(queue))) {\n\t\t/* call the skb_hook for each skb we touch */\n\t\tif (skb_hook)\n\t\t\t(*skb_hook)(skb);\n\n\t\t/* can we send to anyone via unicast? */\n\t\tif (!sk) {\n\t\t\tif (err_hook)\n\t\t\t\t(*err_hook)(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* grab an extra skb reference in case of error */\n\t\tskb_get(skb);\n\t\trc = netlink_unicast(sk, skb, portid, 0);\n\t\tif (rc < 0) {\n\t\t\t/* fatal failure for our queue flush attempt? */\n\t\t\tif (++failed >= retry_limit ||\n\t\t\t    rc == -ECONNREFUSED || rc == -EPERM) {\n\t\t\t\t/* yes - error processing for the queue */\n\t\t\t\tsk = NULL;\n\t\t\t\tif (err_hook)\n\t\t\t\t\t(*err_hook)(skb);\n\t\t\t\tif (!skb_hook)\n\t\t\t\t\tgoto out;\n\t\t\t\t/* keep processing with the skb_hook */\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\t/* no - requeue to preserve ordering */\n\t\t\t\tskb_queue_head(queue, skb);\n\t\t} else {\n\t\t\t/* it worked - drop the extra reference and continue */\n\t\t\tconsume_skb(skb);\n\t\t\tfailed = 0;\n\t\t}\n\t}\n\nout:\n\treturn (rc >= 0 ? 0 : rc);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int kauditd_send_queue(struct sock *sk, u32 portid,\n\t\t\t      struct sk_buff_head *queue,\n\t\t\t      unsigned int retry_limit,\n\t\t\t      void (*skb_hook)(struct sk_buff *skb),\n\t\t\t      void (*err_hook)(struct sk_buff *skb))\n{\n\tint rc = 0;\n\tstruct sk_buff *skb;\n\tstatic unsigned int failed = 0;\n\n\t/* NOTE: kauditd_thread takes care of all our locking, we just use\n\t *       the netlink info passed to us (e.g. sk and portid) */\n\n\twhile ((skb = skb_dequeue(queue))) {\n\t\t/* call the skb_hook for each skb we touch */\n\t\tif (skb_hook)\n\t\t\t(*skb_hook)(skb);\n\n\t\t/* can we send to anyone via unicast? */\n\t\tif (!sk) {\n\t\t\tif (err_hook)\n\t\t\t\t(*err_hook)(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* grab an extra skb reference in case of error */\n\t\tskb_get(skb);\n\t\trc = netlink_unicast(sk, skb, portid, 0);\n\t\tif (rc < 0) {\n\t\t\t/* fatal failure for our queue flush attempt? */\n\t\t\tif (++failed >= retry_limit ||\n\t\t\t    rc == -ECONNREFUSED || rc == -EPERM) {\n\t\t\t\t/* yes - error processing for the queue */\n\t\t\t\tsk = NULL;\n\t\t\t\tif (err_hook)\n\t\t\t\t\t(*err_hook)(skb);\n\t\t\t\tif (!skb_hook)\n\t\t\t\t\tgoto out;\n\t\t\t\t/* keep processing with the skb_hook */\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\t/* no - requeue to preserve ordering */\n\t\t\t\tskb_queue_head(queue, skb);\n\t\t} else {\n\t\t\t/* it worked - drop the extra reference and continue */\n\t\t\tconsume_skb(skb);\n\t\t\tfailed = 0;\n\t\t}\n\t}\n\nout:\n\treturn (rc >= 0 ? 0 : rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_sk",
          "args": [
            "net"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_sk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "299-308",
          "snippet": "static struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int audit_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_net",
          "args": [
            "ac->net"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "auditd_conn"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "98-101",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_freezable",
          "args": [],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "set_freezable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
          "lines": "166-180",
          "snippet": "bool set_freezable(void)\n{\n\tmight_sleep();\n\n\t/*\n\t * Modify flags while holding freezer_lock.  This ensures the\n\t * freezer notices that we aren't frozen yet or the freezing\n\t * condition is visible to try_to_freeze() below.\n\t */\n\tspin_lock_irq(&freezer_lock);\n\tcurrent->flags &= ~PF_NOFREEZE;\n\tspin_unlock_irq(&freezer_lock);\n\n\treturn try_to_freeze();\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(freezer_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nbool set_freezable(void)\n{\n\tmight_sleep();\n\n\t/*\n\t * Modify flags while holding freezer_lock.  This ensures the\n\t * freezer notices that we aren't frozen yet or the freezing\n\t * condition is visible to try_to_freeze() below.\n\t */\n\tspin_lock_irq(&freezer_lock);\n\tcurrent->flags &= ~PF_NOFREEZE;\n\tspin_unlock_irq(&freezer_lock);\n\n\treturn try_to_freeze();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define UNICAST_RETRIES 5\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\nstatic struct sk_buff_head audit_queue;\nstatic struct sk_buff_head audit_retry_queue;\nstatic struct sk_buff_head audit_hold_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\n\nstatic int kauditd_thread(void *dummy)\n{\n\tint rc;\n\tu32 portid = 0;\n\tstruct net *net = NULL;\n\tstruct sock *sk = NULL;\n\tstruct auditd_connection *ac;\n\n#define UNICAST_RETRIES 5\n\n\tset_freezable();\n\twhile (!kthread_should_stop()) {\n\t\t/* NOTE: see the lock comments in auditd_send_unicast_skb() */\n\t\trcu_read_lock();\n\t\tac = rcu_dereference(auditd_conn);\n\t\tif (!ac) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto main_queue;\n\t\t}\n\t\tnet = get_net(ac->net);\n\t\tsk = audit_get_sk(net);\n\t\tportid = ac->portid;\n\t\trcu_read_unlock();\n\n\t\t/* attempt to flush the hold queue */\n\t\trc = kauditd_send_queue(sk, portid,\n\t\t\t\t\t&audit_hold_queue, UNICAST_RETRIES,\n\t\t\t\t\tNULL, kauditd_rehold_skb);\n\t\tif (ac && rc < 0) {\n\t\t\tsk = NULL;\n\t\t\tauditd_reset(ac);\n\t\t\tgoto main_queue;\n\t\t}\n\n\t\t/* attempt to flush the retry queue */\n\t\trc = kauditd_send_queue(sk, portid,\n\t\t\t\t\t&audit_retry_queue, UNICAST_RETRIES,\n\t\t\t\t\tNULL, kauditd_hold_skb);\n\t\tif (ac && rc < 0) {\n\t\t\tsk = NULL;\n\t\t\tauditd_reset(ac);\n\t\t\tgoto main_queue;\n\t\t}\n\nmain_queue:\n\t\t/* process the main queue - do the multicast send and attempt\n\t\t * unicast, dump failed record sends to the retry queue; if\n\t\t * sk == NULL due to previous failures we will just do the\n\t\t * multicast send and move the record to the hold queue */\n\t\trc = kauditd_send_queue(sk, portid, &audit_queue, 1,\n\t\t\t\t\tkauditd_send_multicast_skb,\n\t\t\t\t\t(sk ?\n\t\t\t\t\t kauditd_retry_skb : kauditd_hold_skb));\n\t\tif (ac && rc < 0)\n\t\t\tauditd_reset(ac);\n\t\tsk = NULL;\n\n\t\t/* drop our netns reference, no auditd sends past this line */\n\t\tif (net) {\n\t\t\tput_net(net);\n\t\t\tnet = NULL;\n\t\t}\n\n\t\t/* we have processed all the queues so wake everyone */\n\t\twake_up(&audit_backlog_wait);\n\n\t\t/* NOTE: we want to wake up if there is anything on the queue,\n\t\t *       regardless of if an auditd is connected, as we need to\n\t\t *       do the multicast send and rotate records from the\n\t\t *       main queue to the retry/hold queues */\n\t\twait_event_freezable(kauditd_wait,\n\t\t\t\t     (skb_queue_len(&audit_queue) ? 1 : 0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kauditd_send_multicast_skb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "784-813",
    "snippet": "static void kauditd_send_multicast_skb(struct sk_buff *skb)\n{\n\tstruct sk_buff *copy;\n\tstruct sock *sock = audit_get_sk(&init_net);\n\tstruct nlmsghdr *nlh;\n\n\t/* NOTE: we are not taking an additional reference for init_net since\n\t *       we don't have to worry about it going away */\n\n\tif (!netlink_has_listeners(sock, AUDIT_NLGRP_READLOG))\n\t\treturn;\n\n\t/*\n\t * The seemingly wasteful skb_copy() rather than bumping the refcount\n\t * using skb_get() is necessary because non-standard mods are made to\n\t * the skb by the original kaudit unicast socket send routine.  The\n\t * existing auditd daemon assumes this breakage.  Fixing this would\n\t * require co-ordinating a change in the established protocol between\n\t * the kaudit kernel subsystem and the auditd userspace code.  There is\n\t * no reason for new multicast clients to continue with this\n\t * non-compliance.\n\t */\n\tcopy = skb_copy(skb, GFP_KERNEL);\n\tif (!copy)\n\t\treturn;\n\tnlh = nlmsg_hdr(copy);\n\tnlh->nlmsg_len = skb->len;\n\n\tnlmsg_multicast(sock, copy, 0, AUDIT_NLGRP_READLOG, GFP_KERNEL);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_multicast",
          "args": [
            "sock",
            "copy",
            "0",
            "AUDIT_NLGRP_READLOG",
            "GFP_KERNEL"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_hdr",
          "args": [
            "copy"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_copy",
          "args": [
            "skb",
            "GFP_KERNEL"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_has_listeners",
          "args": [
            "sock",
            "AUDIT_NLGRP_READLOG"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sk",
          "args": [
            "&init_net"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_sk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "299-308",
          "snippet": "static struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int audit_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_send_multicast_skb(struct sk_buff *skb)\n{\n\tstruct sk_buff *copy;\n\tstruct sock *sock = audit_get_sk(&init_net);\n\tstruct nlmsghdr *nlh;\n\n\t/* NOTE: we are not taking an additional reference for init_net since\n\t *       we don't have to worry about it going away */\n\n\tif (!netlink_has_listeners(sock, AUDIT_NLGRP_READLOG))\n\t\treturn;\n\n\t/*\n\t * The seemingly wasteful skb_copy() rather than bumping the refcount\n\t * using skb_get() is necessary because non-standard mods are made to\n\t * the skb by the original kaudit unicast socket send routine.  The\n\t * existing auditd daemon assumes this breakage.  Fixing this would\n\t * require co-ordinating a change in the established protocol between\n\t * the kaudit kernel subsystem and the auditd userspace code.  There is\n\t * no reason for new multicast clients to continue with this\n\t * non-compliance.\n\t */\n\tcopy = skb_copy(skb, GFP_KERNEL);\n\tif (!copy)\n\t\treturn;\n\tnlh = nlmsg_hdr(copy);\n\tnlh->nlmsg_len = skb->len;\n\n\tnlmsg_multicast(sock, copy, 0, AUDIT_NLGRP_READLOG, GFP_KERNEL);\n}"
  },
  {
    "function_name": "kauditd_send_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "721-773",
    "snippet": "static int kauditd_send_queue(struct sock *sk, u32 portid,\n\t\t\t      struct sk_buff_head *queue,\n\t\t\t      unsigned int retry_limit,\n\t\t\t      void (*skb_hook)(struct sk_buff *skb),\n\t\t\t      void (*err_hook)(struct sk_buff *skb))\n{\n\tint rc = 0;\n\tstruct sk_buff *skb;\n\tstatic unsigned int failed = 0;\n\n\t/* NOTE: kauditd_thread takes care of all our locking, we just use\n\t *       the netlink info passed to us (e.g. sk and portid) */\n\n\twhile ((skb = skb_dequeue(queue))) {\n\t\t/* call the skb_hook for each skb we touch */\n\t\tif (skb_hook)\n\t\t\t(*skb_hook)(skb);\n\n\t\t/* can we send to anyone via unicast? */\n\t\tif (!sk) {\n\t\t\tif (err_hook)\n\t\t\t\t(*err_hook)(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* grab an extra skb reference in case of error */\n\t\tskb_get(skb);\n\t\trc = netlink_unicast(sk, skb, portid, 0);\n\t\tif (rc < 0) {\n\t\t\t/* fatal failure for our queue flush attempt? */\n\t\t\tif (++failed >= retry_limit ||\n\t\t\t    rc == -ECONNREFUSED || rc == -EPERM) {\n\t\t\t\t/* yes - error processing for the queue */\n\t\t\t\tsk = NULL;\n\t\t\t\tif (err_hook)\n\t\t\t\t\t(*err_hook)(skb);\n\t\t\t\tif (!skb_hook)\n\t\t\t\t\tgoto out;\n\t\t\t\t/* keep processing with the skb_hook */\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\t/* no - requeue to preserve ordering */\n\t\t\t\tskb_queue_head(queue, skb);\n\t\t} else {\n\t\t\t/* it worked - drop the extra reference and continue */\n\t\t\tconsume_skb(skb);\n\t\t\tfailed = 0;\n\t\t}\n\t}\n\nout:\n\treturn (rc >= 0 ? 0 : rc);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "consume_skb",
          "args": [
            "skb"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_head",
          "args": [
            "queue",
            "skb"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "skb"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_unicast",
          "args": [
            "sk",
            "skb",
            "portid",
            "0"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_get",
          "args": [
            "skb"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "skb"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "skb"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_dequeue",
          "args": [
            "queue"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int kauditd_send_queue(struct sock *sk, u32 portid,\n\t\t\t      struct sk_buff_head *queue,\n\t\t\t      unsigned int retry_limit,\n\t\t\t      void (*skb_hook)(struct sk_buff *skb),\n\t\t\t      void (*err_hook)(struct sk_buff *skb))\n{\n\tint rc = 0;\n\tstruct sk_buff *skb;\n\tstatic unsigned int failed = 0;\n\n\t/* NOTE: kauditd_thread takes care of all our locking, we just use\n\t *       the netlink info passed to us (e.g. sk and portid) */\n\n\twhile ((skb = skb_dequeue(queue))) {\n\t\t/* call the skb_hook for each skb we touch */\n\t\tif (skb_hook)\n\t\t\t(*skb_hook)(skb);\n\n\t\t/* can we send to anyone via unicast? */\n\t\tif (!sk) {\n\t\t\tif (err_hook)\n\t\t\t\t(*err_hook)(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* grab an extra skb reference in case of error */\n\t\tskb_get(skb);\n\t\trc = netlink_unicast(sk, skb, portid, 0);\n\t\tif (rc < 0) {\n\t\t\t/* fatal failure for our queue flush attempt? */\n\t\t\tif (++failed >= retry_limit ||\n\t\t\t    rc == -ECONNREFUSED || rc == -EPERM) {\n\t\t\t\t/* yes - error processing for the queue */\n\t\t\t\tsk = NULL;\n\t\t\t\tif (err_hook)\n\t\t\t\t\t(*err_hook)(skb);\n\t\t\t\tif (!skb_hook)\n\t\t\t\t\tgoto out;\n\t\t\t\t/* keep processing with the skb_hook */\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\t/* no - requeue to preserve ordering */\n\t\t\t\tskb_queue_head(queue, skb);\n\t\t} else {\n\t\t\t/* it worked - drop the extra reference and continue */\n\t\t\tconsume_skb(skb);\n\t\t\tfailed = 0;\n\t\t}\n\t}\n\nout:\n\treturn (rc >= 0 ? 0 : rc);\n}"
  },
  {
    "function_name": "auditd_send_unicast_skb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "665-704",
    "snippet": "static int auditd_send_unicast_skb(struct sk_buff *skb)\n{\n\tint rc;\n\tu32 portid;\n\tstruct net *net;\n\tstruct sock *sk;\n\tstruct auditd_connection *ac;\n\n\t/* NOTE: we can't call netlink_unicast while in the RCU section so\n\t *       take a reference to the network namespace and grab local\n\t *       copies of the namespace, the sock, and the portid; the\n\t *       namespace and sock aren't going to go away while we hold a\n\t *       reference and if the portid does become invalid after the RCU\n\t *       section netlink_unicast() should safely return an error */\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\trc = -ECONNREFUSED;\n\t\tgoto err;\n\t}\n\tnet = get_net(ac->net);\n\tsk = audit_get_sk(net);\n\tportid = ac->portid;\n\trcu_read_unlock();\n\n\trc = netlink_unicast(sk, skb, portid, 0);\n\tput_net(net);\n\tif (rc < 0)\n\t\tgoto err;\n\n\treturn rc;\n\nerr:\n\tif (ac && rc == -ECONNREFUSED)\n\t\tauditd_reset(ac);\n\treturn rc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "auditd_reset",
          "args": [
            "ac"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "627-652",
          "snippet": "static void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;",
            "static DEFINE_SPINLOCK(auditd_conn_lock);",
            "static struct sk_buff_head audit_retry_queue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\nstatic DEFINE_SPINLOCK(auditd_conn_lock);\nstatic struct sk_buff_head audit_retry_queue;\n\nstatic void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "net"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlink_unicast",
          "args": [
            "sk",
            "skb",
            "portid",
            "0"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_sk",
          "args": [
            "net"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_sk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "299-308",
          "snippet": "static struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int audit_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_net",
          "args": [
            "ac->net"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_skb",
          "args": [
            "skb"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "auditd_conn"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\n\nstatic int auditd_send_unicast_skb(struct sk_buff *skb)\n{\n\tint rc;\n\tu32 portid;\n\tstruct net *net;\n\tstruct sock *sk;\n\tstruct auditd_connection *ac;\n\n\t/* NOTE: we can't call netlink_unicast while in the RCU section so\n\t *       take a reference to the network namespace and grab local\n\t *       copies of the namespace, the sock, and the portid; the\n\t *       namespace and sock aren't going to go away while we hold a\n\t *       reference and if the portid does become invalid after the RCU\n\t *       section netlink_unicast() should safely return an error */\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\trc = -ECONNREFUSED;\n\t\tgoto err;\n\t}\n\tnet = get_net(ac->net);\n\tsk = audit_get_sk(net);\n\tportid = ac->portid;\n\trcu_read_unlock();\n\n\trc = netlink_unicast(sk, skb, portid, 0);\n\tput_net(net);\n\tif (rc < 0)\n\t\tgoto err;\n\n\treturn rc;\n\nerr:\n\tif (ac && rc == -ECONNREFUSED)\n\t\tauditd_reset(ac);\n\treturn rc;\n}"
  },
  {
    "function_name": "auditd_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "627-652",
    "snippet": "static void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;",
      "static DEFINE_SPINLOCK(auditd_conn_lock);",
      "static struct sk_buff_head audit_retry_queue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kauditd_hold_skb",
          "args": [
            "skb"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_hold_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "575-597",
          "snippet": "static void kauditd_hold_skb(struct sk_buff *skb)\n{\n\t/* at this point it is uncertain if we will ever send this to auditd so\n\t * try to send the message via printk before we go any further */\n\tkauditd_printk_skb(skb);\n\n\t/* can we just silently drop the message? */\n\tif (!audit_default) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* if we have room, queue the message */\n\tif (!audit_backlog_limit ||\n\t    skb_queue_len(&audit_hold_queue) < audit_backlog_limit) {\n\t\tskb_queue_tail(&audit_hold_queue, skb);\n\t\treturn;\n\t}\n\n\t/* we have no other options - drop the message */\n\taudit_log_lost(\"kauditd hold queue overflow\");\n\tkfree_skb(skb);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_default = AUDIT_OFF;",
            "static u32\taudit_backlog_limit = 64;",
            "static struct sk_buff_head audit_hold_queue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_default = AUDIT_OFF;\nstatic u32\taudit_backlog_limit = 64;\nstatic struct sk_buff_head audit_hold_queue;\n\nstatic void kauditd_hold_skb(struct sk_buff *skb)\n{\n\t/* at this point it is uncertain if we will ever send this to auditd so\n\t * try to send the message via printk before we go any further */\n\tkauditd_printk_skb(skb);\n\n\t/* can we just silently drop the message? */\n\tif (!audit_default) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* if we have room, queue the message */\n\tif (!audit_backlog_limit ||\n\t    skb_queue_len(&audit_hold_queue) < audit_backlog_limit) {\n\t\tskb_queue_tail(&audit_hold_queue, skb);\n\t\treturn;\n\t}\n\n\t/* we have no other options - drop the message */\n\taudit_log_lost(\"kauditd hold queue overflow\");\n\tkfree_skb(skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_dequeue",
          "args": [
            "&audit_retry_queue"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&ac_old->rcu",
            "auditd_conn_free"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&auditd_conn_lock",
            "flags"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "auditd_conn",
            "NULL"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "auditd_conn",
            "lockdep_is_held(&auditd_conn_lock)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&auditd_conn_lock"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&auditd_conn_lock",
            "flags"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\nstatic DEFINE_SPINLOCK(auditd_conn_lock);\nstatic struct sk_buff_head audit_retry_queue;\n\nstatic void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t/* if it isn't already broken, break the connection */\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t/* someone already registered a new auditd connection */\n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t/* flush the retry queue to the hold queue, but don't touch the main\n\t * queue since we need to process that normally for multicast */\n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb);\n}"
  },
  {
    "function_name": "kauditd_retry_skb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "608-614",
    "snippet": "static void kauditd_retry_skb(struct sk_buff *skb)\n{\n\t/* NOTE: because records should only live in the retry queue for a\n\t * short period of time, before either being sent or moved to the hold\n\t * queue, we don't currently enforce a limit on this queue */\n\tskb_queue_tail(&audit_retry_queue, skb);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sk_buff_head audit_retry_queue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skb_queue_tail",
          "args": [
            "&audit_retry_queue",
            "skb"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_retry_queue;\n\nstatic void kauditd_retry_skb(struct sk_buff *skb)\n{\n\t/* NOTE: because records should only live in the retry queue for a\n\t * short period of time, before either being sent or moved to the hold\n\t * queue, we don't currently enforce a limit on this queue */\n\tskb_queue_tail(&audit_retry_queue, skb);\n}"
  },
  {
    "function_name": "kauditd_hold_skb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "575-597",
    "snippet": "static void kauditd_hold_skb(struct sk_buff *skb)\n{\n\t/* at this point it is uncertain if we will ever send this to auditd so\n\t * try to send the message via printk before we go any further */\n\tkauditd_printk_skb(skb);\n\n\t/* can we just silently drop the message? */\n\tif (!audit_default) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* if we have room, queue the message */\n\tif (!audit_backlog_limit ||\n\t    skb_queue_len(&audit_hold_queue) < audit_backlog_limit) {\n\t\tskb_queue_tail(&audit_hold_queue, skb);\n\t\treturn;\n\t}\n\n\t/* we have no other options - drop the message */\n\taudit_log_lost(\"kauditd hold queue overflow\");\n\tkfree_skb(skb);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_default = AUDIT_OFF;",
      "static u32\taudit_backlog_limit = 64;",
      "static struct sk_buff_head audit_hold_queue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_skb",
          "args": [
            "skb"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_lost",
          "args": [
            "\"kauditd hold queue overflow\""
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_lost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "362-392",
          "snippet": "void audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
            "static u32\taudit_rate_limit;",
            "static u32\taudit_backlog_limit = 64;",
            "static atomic_t\taudit_lost = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_queue_tail",
          "args": [
            "&audit_hold_queue",
            "skb"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_len",
          "args": [
            "&audit_hold_queue"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_skb",
          "args": [
            "skb"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kauditd_printk_skb",
          "args": [
            "skb"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_default = AUDIT_OFF;\nstatic u32\taudit_backlog_limit = 64;\nstatic struct sk_buff_head audit_hold_queue;\n\nstatic void kauditd_hold_skb(struct sk_buff *skb)\n{\n\t/* at this point it is uncertain if we will ever send this to auditd so\n\t * try to send the message via printk before we go any further */\n\tkauditd_printk_skb(skb);\n\n\t/* can we just silently drop the message? */\n\tif (!audit_default) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* if we have room, queue the message */\n\tif (!audit_backlog_limit ||\n\t    skb_queue_len(&audit_hold_queue) < audit_backlog_limit) {\n\t\tskb_queue_tail(&audit_hold_queue, skb);\n\t\treturn;\n\t}\n\n\t/* we have no other options - drop the message */\n\taudit_log_lost(\"kauditd hold queue overflow\");\n\tkfree_skb(skb);\n}"
  },
  {
    "function_name": "kauditd_rehold_skb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "557-561",
    "snippet": "static void kauditd_rehold_skb(struct sk_buff *skb)\n{\n\t/* put the record back in the queue at the same place */\n\tskb_queue_head(&audit_hold_queue, skb);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sk_buff_head audit_hold_queue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skb_queue_head",
          "args": [
            "&audit_hold_queue",
            "skb"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_hold_queue;\n\nstatic void kauditd_rehold_skb(struct sk_buff *skb)\n{\n\t/* put the record back in the queue at the same place */\n\tskb_queue_head(&audit_hold_queue, skb);\n}"
  },
  {
    "function_name": "kauditd_printk_skb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "540-547",
    "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"type=%d %s\\n\"",
            "nlh->nlmsg_type",
            "data"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_data",
          "args": [
            "nlh"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_hdr",
          "args": [
            "skb"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
  },
  {
    "function_name": "auditd_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "506-531",
    "snippet": "static int auditd_set(struct pid *pid, u32 portid, struct net *net)\n{\n\tunsigned long flags;\n\tstruct auditd_connection *ac_old, *ac_new;\n\n\tif (!pid || !net)\n\t\treturn -EINVAL;\n\n\tac_new = kzalloc(sizeof(*ac_new), GFP_KERNEL);\n\tif (!ac_new)\n\t\treturn -ENOMEM;\n\tac_new->pid = get_pid(pid);\n\tac_new->portid = portid;\n\tac_new->net = get_net(net);\n\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\trcu_assign_pointer(auditd_conn, ac_new);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;",
      "static DEFINE_SPINLOCK(auditd_conn_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&ac_old->rcu",
            "auditd_conn_free"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&auditd_conn_lock",
            "flags"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "auditd_conn",
            "ac_new"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "auditd_conn",
            "lockdep_is_held(&auditd_conn_lock)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&auditd_conn_lock"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&auditd_conn_lock",
            "flags"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_net",
          "args": [
            "net"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "pid"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "388-397",
          "snippet": "struct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ac_new)",
            "GFP_KERNEL"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\nstatic DEFINE_SPINLOCK(auditd_conn_lock);\n\nstatic int auditd_set(struct pid *pid, u32 portid, struct net *net)\n{\n\tunsigned long flags;\n\tstruct auditd_connection *ac_old, *ac_new;\n\n\tif (!pid || !net)\n\t\treturn -EINVAL;\n\n\tac_new = kzalloc(sizeof(*ac_new), GFP_KERNEL);\n\tif (!ac_new)\n\t\treturn -ENOMEM;\n\tac_new->pid = get_pid(pid);\n\tac_new->portid = portid;\n\tac_new->net = get_net(net);\n\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\trcu_assign_pointer(auditd_conn, ac_new);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "auditd_conn_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "486-494",
    "snippet": "static void auditd_conn_free(struct rcu_head *rcu)\n{\n\tstruct auditd_connection *ac;\n\n\tac = container_of(rcu, struct auditd_connection, rcu);\n\tput_pid(ac->pid);\n\tput_net(ac->net);\n\tkfree(ac);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ac"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "ac->net"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "ac->pid"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "117-121",
          "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structauditd_connection",
            "rcu"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void auditd_conn_free(struct rcu_head *rcu)\n{\n\tstruct auditd_connection *ac;\n\n\tac = container_of(rcu, struct auditd_connection, rcu);\n\tput_pid(ac->pid);\n\tput_net(ac->net);\n\tkfree(ac);\n}"
  },
  {
    "function_name": "audit_set_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "468-476",
    "snippet": "static int audit_set_failure(u32 state)\n{\n\tif (state != AUDIT_FAIL_SILENT\n\t    && state != AUDIT_FAIL_PRINTK\n\t    && state != AUDIT_FAIL_PANIC)\n\t\treturn -EINVAL;\n\n\treturn audit_do_config_change(\"audit_failure\", &audit_failure, state);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_do_config_change",
          "args": [
            "\"audit_failure\"",
            "&audit_failure",
            "state"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "audit_do_config_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "413-437",
          "snippet": "static int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nstatic int audit_set_failure(u32 state)\n{\n\tif (state != AUDIT_FAIL_SILENT\n\t    && state != AUDIT_FAIL_PRINTK\n\t    && state != AUDIT_FAIL_PANIC)\n\t\treturn -EINVAL;\n\n\treturn audit_do_config_change(\"audit_failure\", &audit_failure, state);\n}"
  },
  {
    "function_name": "audit_set_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "455-466",
    "snippet": "static int audit_set_enabled(u32 state)\n{\n\tint rc;\n\tif (state > AUDIT_LOCKED)\n\t\treturn -EINVAL;\n\n\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);\n\tif (!rc)\n\t\taudit_ever_enabled |= !!state;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32\t\taudit_enabled = AUDIT_OFF;",
      "bool\t\taudit_ever_enabled = !!AUDIT_OFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_do_config_change",
          "args": [
            "\"audit_enabled\"",
            "&audit_enabled",
            "state"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "audit_do_config_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "413-437",
          "snippet": "static int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\nbool\t\taudit_ever_enabled = !!AUDIT_OFF;\n\nstatic int audit_set_enabled(u32 state)\n{\n\tint rc;\n\tif (state > AUDIT_LOCKED)\n\t\treturn -EINVAL;\n\n\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);\n\tif (!rc)\n\t\taudit_ever_enabled |= !!state;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "audit_set_backlog_wait_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "449-453",
    "snippet": "static int audit_set_backlog_wait_time(u32 timeout)\n{\n\treturn audit_do_config_change(\"audit_backlog_wait_time\",\n\t\t\t\t      &audit_backlog_wait_time, timeout);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_do_config_change",
          "args": [
            "\"audit_backlog_wait_time\"",
            "&audit_backlog_wait_time",
            "timeout"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "audit_do_config_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "413-437",
          "snippet": "static int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\n\nstatic int audit_set_backlog_wait_time(u32 timeout)\n{\n\treturn audit_do_config_change(\"audit_backlog_wait_time\",\n\t\t\t\t      &audit_backlog_wait_time, timeout);\n}"
  },
  {
    "function_name": "audit_set_backlog_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "444-447",
    "snippet": "static int audit_set_backlog_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_backlog_limit\", &audit_backlog_limit, limit);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_backlog_limit = 64;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_do_config_change",
          "args": [
            "\"audit_backlog_limit\"",
            "&audit_backlog_limit",
            "limit"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "audit_do_config_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "413-437",
          "snippet": "static int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_backlog_limit = 64;\n\nstatic int audit_set_backlog_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_backlog_limit\", &audit_backlog_limit, limit);\n}"
  },
  {
    "function_name": "audit_set_rate_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "439-442",
    "snippet": "static int audit_set_rate_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_rate_limit\", &audit_rate_limit, limit);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_rate_limit;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_do_config_change",
          "args": [
            "\"audit_rate_limit\"",
            "&audit_rate_limit",
            "limit"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "audit_do_config_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "413-437",
          "snippet": "static int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32\t\taudit_enabled = AUDIT_OFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_rate_limit;\n\nstatic int audit_set_rate_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_rate_limit\", &audit_rate_limit, limit);\n}"
  },
  {
    "function_name": "audit_do_config_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "413-437",
    "snippet": "static int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32\t\taudit_enabled = AUDIT_OFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_config_change",
          "args": [
            "function_name",
            "new",
            "old",
            "allow_changes"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_config_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "394-411",
          "snippet": "static int audit_log_config_change(char *function_name, u32 new, u32 old,\n\t\t\t\t   int allow_changes)\n{\n\tstruct audit_buffer *ab;\n\tint rc = 0;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn rc;\n\taudit_log_format(ab, \"%s=%u old=%u\", function_name, new, old);\n\taudit_log_session_info(ab);\n\trc = audit_log_task_context(ab);\n\tif (rc)\n\t\tallow_changes = 0; /* Something weird, deny request */\n\taudit_log_format(ab, \" res=%d\", allow_changes);\n\taudit_log_end(ab);\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_log_config_change(char *function_name, u32 new, u32 old,\n\t\t\t\t   int allow_changes)\n{\n\tstruct audit_buffer *ab;\n\tint rc = 0;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn rc;\n\taudit_log_format(ab, \"%s=%u old=%u\", function_name, new, old);\n\taudit_log_session_info(ab);\n\trc = audit_log_task_context(ab);\n\tif (rc)\n\t\tallow_changes = 0; /* Something weird, deny request */\n\taudit_log_format(ab, \" res=%d\", allow_changes);\n\taudit_log_end(ab);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nu32\t\taudit_enabled = AUDIT_OFF;\n\nstatic int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t/* check if we are locked */\n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t/* If we are allowed, make the change */\n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t/* Not allowed, update reason */\n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}"
  },
  {
    "function_name": "audit_log_config_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "394-411",
    "snippet": "static int audit_log_config_change(char *function_name, u32 new, u32 old,\n\t\t\t\t   int allow_changes)\n{\n\tstruct audit_buffer *ab;\n\tint rc = 0;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn rc;\n\taudit_log_format(ab, \"%s=%u old=%u\", function_name, new, old);\n\taudit_log_session_info(ab);\n\trc = audit_log_task_context(ab);\n\tif (rc)\n\t\tallow_changes = 0; /* Something weird, deny request */\n\taudit_log_format(ab, \" res=%d\", allow_changes);\n\taudit_log_end(ab);\n\treturn rc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" res=%d\"",
            "allow_changes"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "ab"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2203-2228",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_task_getsecid(current, &sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_task_getsecid(current, &sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_session_info",
          "args": [
            "ab"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_session_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2040-2046",
          "snippet": "void audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \" auid=%u ses=%u\", auid, sessionid);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \" auid=%u ses=%u\", auid, sessionid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ab"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "NULL",
            "GFP_KERNEL",
            "AUDIT_CONFIG_CHANGE"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic int audit_log_config_change(char *function_name, u32 new, u32 old,\n\t\t\t\t   int allow_changes)\n{\n\tstruct audit_buffer *ab;\n\tint rc = 0;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn rc;\n\taudit_log_format(ab, \"%s=%u old=%u\", function_name, new, old);\n\taudit_log_session_info(ab);\n\trc = audit_log_task_context(ab);\n\tif (rc)\n\t\tallow_changes = 0; /* Something weird, deny request */\n\taudit_log_format(ab, \" res=%d\", allow_changes);\n\taudit_log_end(ab);\n\treturn rc;\n}"
  },
  {
    "function_name": "audit_log_lost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "362-392",
    "snippet": "void audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
      "static u32\taudit_rate_limit;",
      "static u32\taudit_backlog_limit = 64;",
      "static atomic_t\taudit_lost = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "message"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "310-323",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\"",
            "atomic_read(&audit_lost)",
            "audit_rate_limit",
            "audit_backlog_limit"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&audit_lost"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lock",
            "flags"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lock",
            "flags"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&audit_lost"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}"
  },
  {
    "function_name": "audit_rate_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "325-352",
    "snippet": "static inline int audit_rate_check(void)\n{\n\tstatic unsigned long\tlast_check = 0;\n\tstatic int\t\tmessages   = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tunsigned long\t\telapsed;\n\tint\t\t\tretval\t   = 0;\n\n\tif (!audit_rate_limit) return 1;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (++messages < audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow     = jiffies;\n\t\telapsed = now - last_check;\n\t\tif (elapsed > HZ) {\n\t\t\tlast_check = now;\n\t\t\tmessages   = 0;\n\t\t\tretval     = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lock, flags);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_rate_limit;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lock",
            "flags"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&lock",
            "flags"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_rate_limit;\n\nstatic inline int audit_rate_check(void)\n{\n\tstatic unsigned long\tlast_check = 0;\n\tstatic int\t\tmessages   = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tunsigned long\t\telapsed;\n\tint\t\t\tretval\t   = 0;\n\n\tif (!audit_rate_limit) return 1;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (++messages < audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow     = jiffies;\n\t\telapsed = now - last_check;\n\t\tif (elapsed > HZ) {\n\t\t\tlast_check = now;\n\t\t\tmessages   = 0;\n\t\t\tretval     = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lock, flags);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "audit_panic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "310-323",
    "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"audit: %s\\n\"",
            "message"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "135-307",
          "snippet": "void panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\tprintk_safe_flush_on_panic();\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\t/* Call flush even twice. It tries harder with a single online CPU */\n\tprintk_safe_flush_on_panic();\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n\tbust_spinlocks(0);\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\t{\n\t\tunsigned long caller;\n\n\t\tcaller = (unsigned long)__builtin_return_address(0);\n\t\tdisabled_wait(caller);\n\t}\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define PANIC_BLINK_SPD 18",
            "#define PANIC_TIMER_STEP 100"
          ],
          "globals_used": [
            "bool crash_kexec_post_notifiers;",
            "int panic_timeout = CONFIG_PANIC_TIMEOUT;",
            "long (*panic_blink)(int state);",
            "atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_BLINK_SPD 18\n#define PANIC_TIMER_STEP 100\n\nbool crash_kexec_post_notifiers;\nint panic_timeout = CONFIG_PANIC_TIMEOUT;\nlong (*panic_blink)(int state);\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\nvoid panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\tprintk_safe_flush_on_panic();\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\t/* Call flush even twice. It tries harder with a single online CPU */\n\tprintk_safe_flush_on_panic();\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n\tbust_spinlocks(0);\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\t{\n\t\tunsigned long caller;\n\n\t\tcaller = (unsigned long)__builtin_return_address(0);\n\t\tdisabled_wait(caller);\n\t}\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s\\n\"",
            "message"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "audit_get_sk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "299-308",
    "snippet": "static struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int audit_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "audit_net_id"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic unsigned int audit_net_id;\n\nstatic struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}"
  },
  {
    "function_name": "auditd_pid_vnr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "275-289",
    "snippet": "static pid_t auditd_pid_vnr(void)\n{\n\tpid_t pid;\n\tconst struct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac || !ac->pid)\n\t\tpid = 0;\n\telse\n\t\tpid = pid_vnr(ac->pid);\n\trcu_read_unlock();\n\n\treturn pid;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_vnr",
          "args": [
            "ac->pid"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "pid_vnr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "414-417",
          "snippet": "pid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\npid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "auditd_conn"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\n\nstatic pid_t auditd_pid_vnr(void)\n{\n\tpid_t pid;\n\tconst struct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac || !ac->pid)\n\t\tpid = 0;\n\telse\n\t\tpid = pid_vnr(ac->pid);\n\trcu_read_unlock();\n\n\treturn pid;\n}"
  },
  {
    "function_name": "audit_ctl_owner_current",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "264-267",
    "snippet": "static bool audit_ctl_owner_current(void)\n{\n\treturn (current == audit_cmd_mutex.owner);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstatic bool audit_ctl_owner_current(void)\n{\n\treturn (current == audit_cmd_mutex.owner);\n}"
  },
  {
    "function_name": "audit_ctl_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "251-255",
    "snippet": "void audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_cmd_mutex.lock"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}"
  },
  {
    "function_name": "audit_ctl_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "242-246",
    "snippet": "void audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_cmd_mutex.lock"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}"
  },
  {
    "function_name": "auditd_test_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
    "lines": "226-237",
    "snippet": "int auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/netns/generic.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/security.h>",
      "#include <linux/skbuff.h>",
      "#include <net/netlink.h>",
      "#include <net/sock.h>",
      "#include <linux/audit.h>",
      "#include <linux/slab.h>",
      "#include <linux/pid.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/atomic.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "task"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "auditd_conn"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\n\nint auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}"
  }
]