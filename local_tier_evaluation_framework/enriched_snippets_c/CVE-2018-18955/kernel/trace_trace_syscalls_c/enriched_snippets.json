[
  {
    "function_name": "syscall_exit_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "791-817",
    "snippet": "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn reg_event_syscall_exit(file, event);\n\tcase TRACE_REG_UNREGISTER:\n\t\tunreg_event_syscall_exit(file, event);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn perf_sysexit_enable(event);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tperf_sysexit_disable(event);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_sysexit_disable",
          "args": [
            "event"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "perf_sysexit_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "747-759",
          "snippet": "static void perf_sysexit_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_exit--;\n\tclear_bit(num, enabled_perf_exit_syscalls);\n\tif (!sys_perf_refcount_exit)\n\t\tunregister_trace_sys_exit(perf_syscall_exit, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(syscall_trace_lock);",
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void perf_sysexit_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_exit--;\n\tclear_bit(num, enabled_perf_exit_syscalls);\n\tif (!sys_perf_refcount_exit)\n\t\tunregister_trace_sys_exit(perf_syscall_exit, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_sysexit_enable",
          "args": [
            "event"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "perf_sysexit_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "727-745",
          "snippet": "static int perf_sysexit_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_exit)\n\t\tret = register_trace_sys_exit(perf_syscall_exit, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall exit trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_exit_syscalls);\n\t\tsys_perf_refcount_exit++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(syscall_trace_lock);",
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int perf_sysexit_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_exit)\n\t\tret = register_trace_sys_exit(perf_syscall_exit, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall exit trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_exit_syscalls);\n\t\tsys_perf_refcount_exit++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unreg_event_syscall_exit",
          "args": [
            "file",
            "event"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "unreg_event_syscall_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "461-476",
          "snippet": "static void unreg_event_syscall_exit(struct trace_event_file *file,\n\t\t\t\t     struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_exit--;\n\tRCU_INIT_POINTER(tr->exit_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_exit)\n\t\tunregister_trace_sys_exit(ftrace_syscall_exit, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(syscall_trace_lock);",
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void unreg_event_syscall_exit(struct trace_event_file *file,\n\t\t\t\t     struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_exit--;\n\tRCU_INIT_POINTER(tr->exit_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_exit)\n\t\tunregister_trace_sys_exit(ftrace_syscall_exit, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn reg_event_syscall_exit(file, event);\n\tcase TRACE_REG_UNREGISTER:\n\t\tunreg_event_syscall_exit(file, event);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn perf_sysexit_enable(event);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tperf_sysexit_disable(event);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "syscall_enter_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "763-789",
    "snippet": "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn reg_event_syscall_enter(file, event);\n\tcase TRACE_REG_UNREGISTER:\n\t\tunreg_event_syscall_enter(file, event);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn perf_sysenter_enable(event);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tperf_sysenter_disable(event);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_sysenter_disable",
          "args": [
            "event"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "perf_sysenter_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "651-663",
          "snippet": "static void perf_sysenter_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_enter--;\n\tclear_bit(num, enabled_perf_enter_syscalls);\n\tif (!sys_perf_refcount_enter)\n\t\tunregister_trace_sys_enter(perf_syscall_enter, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(syscall_trace_lock);",
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void perf_sysenter_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_enter--;\n\tclear_bit(num, enabled_perf_enter_syscalls);\n\tif (!sys_perf_refcount_enter)\n\t\tunregister_trace_sys_enter(perf_syscall_enter, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_sysenter_enable",
          "args": [
            "event"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "perf_sysenter_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "631-649",
          "snippet": "static int perf_sysenter_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_enter)\n\t\tret = register_trace_sys_enter(perf_syscall_enter, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall entry trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_enter_syscalls);\n\t\tsys_perf_refcount_enter++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(syscall_trace_lock);",
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int perf_sysenter_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_enter)\n\t\tret = register_trace_sys_enter(perf_syscall_enter, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall entry trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_enter_syscalls);\n\t\tsys_perf_refcount_enter++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unreg_event_syscall_enter",
          "args": [
            "file",
            "event"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "unreg_event_syscall_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "423-438",
          "snippet": "static void unreg_event_syscall_enter(struct trace_event_file *file,\n\t\t\t\t      struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_enter--;\n\tRCU_INIT_POINTER(tr->enter_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_enter)\n\t\tunregister_trace_sys_enter(ftrace_syscall_enter, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(syscall_trace_lock);",
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void unreg_event_syscall_enter(struct trace_event_file *file,\n\t\t\t\t      struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_enter--;\n\tRCU_INIT_POINTER(tr->enter_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_enter)\n\t\tunregister_trace_sys_enter(ftrace_syscall_enter, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn reg_event_syscall_enter(file, event);\n\tcase TRACE_REG_UNREGISTER:\n\t\tunreg_event_syscall_enter(file, event);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn perf_sysenter_enable(event);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tperf_sysenter_disable(event);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "perf_sysexit_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "747-759",
    "snippet": "static void perf_sysexit_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_exit--;\n\tclear_bit(num, enabled_perf_exit_syscalls);\n\tif (!sys_perf_refcount_exit)\n\t\tunregister_trace_sys_exit(perf_syscall_exit, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_sys_exit",
          "args": [
            "perf_syscall_exit",
            "NULL"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "num",
            "enabled_perf_exit_syscalls"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void perf_sysexit_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_exit--;\n\tclear_bit(num, enabled_perf_exit_syscalls);\n\tif (!sys_perf_refcount_exit)\n\t\tunregister_trace_sys_exit(perf_syscall_exit, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}"
  },
  {
    "function_name": "perf_sysexit_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "727-745",
    "snippet": "static int perf_sysexit_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_exit)\n\t\tret = register_trace_sys_exit(perf_syscall_exit, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall exit trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_exit_syscalls);\n\t\tsys_perf_refcount_exit++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "num",
            "enabled_perf_exit_syscalls"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"event trace: Could not activate syscall exit trace point\""
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sys_exit",
          "args": [
            "perf_syscall_exit",
            "NULL"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int perf_sysexit_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_exit)\n\t\tret = register_trace_sys_exit(perf_syscall_exit, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall exit trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_exit_syscalls);\n\t\tsys_perf_refcount_exit++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_syscall_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "680-725",
    "snippet": "static void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_exit *rec;\n\tstruct hlist_head *head;\n\tbool valid_prog_array;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_exit_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->exit_event->perf_events);\n\tvalid_prog_array = bpf_prog_array_valid(sys_data->exit_event);\n\tif (!valid_prog_array && hlist_empty(head))\n\t\treturn;\n\n\t/* We can probably do that at build time */\n\tsize = ALIGN(sizeof(*rec) + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\trec->ret = syscall_get_return_value(current, regs);\n\n\tif ((valid_prog_array &&\n\t     !perf_call_bpf_exit(sys_data->exit_event, regs, rec)) ||\n\t    hlist_empty(head)) {\n\t\tperf_swevent_put_recursion_context(rctx);\n\t\treturn;\n\t}\n\n\tperf_trace_buf_submit(rec, size, rctx, sys_data->exit_event->event.type,\n\t\t\t      1, regs, head, NULL);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_trace_buf_submit",
          "args": [
            "rec",
            "size",
            "rctx",
            "sys_data->exit_event->event.type",
            "1",
            "regs",
            "head",
            "NULL"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_swevent_put_recursion_context",
          "args": [
            "rctx"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "perf_swevent_put_recursion_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "8001-8006",
          "snippet": "void perf_swevent_put_recursion_context(int rctx)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\tput_recursion_context(swhash->recursion, rctx);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct",
            "static DEFINE_PER_CPU(struct swevent_htable, swevent_htable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\nstatic DEFINE_PER_CPU(struct swevent_htable, swevent_htable);\n\nvoid perf_swevent_put_recursion_context(int rctx)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\tput_recursion_context(swhash->recursion, rctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_call_bpf_exit",
          "args": [
            "sys_data->exit_event",
            "regs",
            "rec"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "perf_call_bpf_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "665-678",
          "snippet": "static int perf_call_bpf_exit(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t      struct syscall_trace_exit *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long ret;\n\t} param;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tparam.ret = rec->ret;\n\treturn trace_call_bpf(call, &param);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic int perf_call_bpf_exit(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t      struct syscall_trace_exit *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long ret;\n\t} param;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tparam.ret = rec->ret;\n\treturn trace_call_bpf(call, &param);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_return_value",
          "args": [
            "current",
            "regs"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_alloc",
          "args": [
            "size",
            "NULL",
            "&rctx"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_buf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "388-410",
          "snippet": "void *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "sizeof(*rec) + sizeof(u32)",
            "sizeof(u64)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_valid",
          "args": [
            "sys_data->exit_event"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "sys_data->exit_event->perf_events"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_nr_to_meta",
          "args": [
            "syscall_nr"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_nr_to_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "102-108",
          "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct syscall_metadata **syscalls_metadata;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "syscall_nr",
            "enabled_perf_exit_syscalls"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_syscall_nr",
          "args": [
            "current",
            "regs"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_syscall_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "73-77",
          "snippet": "static inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_exit *rec;\n\tstruct hlist_head *head;\n\tbool valid_prog_array;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_exit_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->exit_event->perf_events);\n\tvalid_prog_array = bpf_prog_array_valid(sys_data->exit_event);\n\tif (!valid_prog_array && hlist_empty(head))\n\t\treturn;\n\n\t/* We can probably do that at build time */\n\tsize = ALIGN(sizeof(*rec) + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\trec->ret = syscall_get_return_value(current, regs);\n\n\tif ((valid_prog_array &&\n\t     !perf_call_bpf_exit(sys_data->exit_event, regs, rec)) ||\n\t    hlist_empty(head)) {\n\t\tperf_swevent_put_recursion_context(rctx);\n\t\treturn;\n\t}\n\n\tperf_trace_buf_submit(rec, size, rctx, sys_data->exit_event->event.type,\n\t\t\t      1, regs, head, NULL);\n}"
  },
  {
    "function_name": "perf_call_bpf_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "665-678",
    "snippet": "static int perf_call_bpf_exit(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t      struct syscall_trace_exit *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long ret;\n\t} param;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tparam.ret = rec->ret;\n\treturn trace_call_bpf(call, &param);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_call_bpf",
          "args": [
            "call",
            "&param"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "trace_call_bpf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "37-79",
          "snippet": "unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tif (in_nmi()) /* not supported yet */\n\t\treturn 1;\n\n\tpreempt_disable();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heurisitc to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY_CHECK(call->prog_array, ctx, BPF_PROG_RUN);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nunsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tif (in_nmi()) /* not supported yet */\n\t\treturn 1;\n\n\tpreempt_disable();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heurisitc to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY_CHECK(call->prog_array, ctx, BPF_PROG_RUN);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic int perf_call_bpf_exit(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t      struct syscall_trace_exit *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long ret;\n\t} param;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tparam.ret = rec->ret;\n\treturn trace_call_bpf(call, &param);\n}"
  },
  {
    "function_name": "perf_sysenter_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "651-663",
    "snippet": "static void perf_sysenter_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_enter--;\n\tclear_bit(num, enabled_perf_enter_syscalls);\n\tif (!sys_perf_refcount_enter)\n\t\tunregister_trace_sys_enter(perf_syscall_enter, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_sys_enter",
          "args": [
            "perf_syscall_enter",
            "NULL"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "num",
            "enabled_perf_enter_syscalls"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void perf_sysenter_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_enter--;\n\tclear_bit(num, enabled_perf_enter_syscalls);\n\tif (!sys_perf_refcount_enter)\n\t\tunregister_trace_sys_enter(perf_syscall_enter, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}"
  },
  {
    "function_name": "perf_sysenter_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "631-649",
    "snippet": "static int perf_sysenter_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_enter)\n\t\tret = register_trace_sys_enter(perf_syscall_enter, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall entry trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_enter_syscalls);\n\t\tsys_perf_refcount_enter++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "num",
            "enabled_perf_enter_syscalls"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"event trace: Could not activate syscall entry trace point\""
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sys_enter",
          "args": [
            "perf_syscall_enter",
            "NULL"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int perf_sysenter_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_enter)\n\t\tret = register_trace_sys_enter(perf_syscall_enter, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall entry trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_enter_syscalls);\n\t\tsys_perf_refcount_enter++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_syscall_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "581-629",
    "snippet": "static void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_enter *rec;\n\tstruct hlist_head *head;\n\tbool valid_prog_array;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->enter_event->perf_events);\n\tvalid_prog_array = bpf_prog_array_valid(sys_data->enter_event);\n\tif (!valid_prog_array && hlist_empty(head))\n\t\treturn;\n\n\t/* get the size after alignment with the u32 buffer size field */\n\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args,\n\t\t\t       (unsigned long *)&rec->args);\n\n\tif ((valid_prog_array &&\n\t     !perf_call_bpf_enter(sys_data->enter_event, regs, sys_data, rec)) ||\n\t    hlist_empty(head)) {\n\t\tperf_swevent_put_recursion_context(rctx);\n\t\treturn;\n\t}\n\n\tperf_trace_buf_submit(rec, size, rctx,\n\t\t\t      sys_data->enter_event->event.type, 1, regs,\n\t\t\t      head, NULL);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_trace_buf_submit",
          "args": [
            "rec",
            "size",
            "rctx",
            "sys_data->enter_event->event.type",
            "1",
            "regs",
            "head",
            "NULL"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_swevent_put_recursion_context",
          "args": [
            "rctx"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "perf_swevent_put_recursion_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "8001-8006",
          "snippet": "void perf_swevent_put_recursion_context(int rctx)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\tput_recursion_context(swhash->recursion, rctx);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct",
            "static DEFINE_PER_CPU(struct swevent_htable, swevent_htable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\nstatic DEFINE_PER_CPU(struct swevent_htable, swevent_htable);\n\nvoid perf_swevent_put_recursion_context(int rctx)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\tput_recursion_context(swhash->recursion, rctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_call_bpf_enter",
          "args": [
            "sys_data->enter_event",
            "regs",
            "sys_data",
            "rec"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "perf_call_bpf_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "563-579",
          "snippet": "static int perf_call_bpf_enter(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t       struct syscall_metadata *sys_data,\n\t\t\t       struct syscall_trace_enter *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long args[SYSCALL_DEFINE_MAXARGS];\n\t} param;\n\tint i;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tfor (i = 0; i < sys_data->nb_args; i++)\n\t\tparam.args[i] = rec->args[i];\n\treturn trace_call_bpf(call, &param);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic int perf_call_bpf_enter(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t       struct syscall_metadata *sys_data,\n\t\t\t       struct syscall_trace_enter *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long args[SYSCALL_DEFINE_MAXARGS];\n\t} param;\n\tint i;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tfor (i = 0; i < sys_data->nb_args; i++)\n\t\tparam.args[i] = rec->args[i];\n\treturn trace_call_bpf(call, &param);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_arguments",
          "args": [
            "current",
            "regs",
            "0",
            "sys_data->nb_args",
            "(unsigned long *)&rec->args"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_alloc",
          "args": [
            "size",
            "NULL",
            "&rctx"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_buf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "388-410",
          "snippet": "void *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size + sizeof(u32)",
            "sizeof(u64)"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_valid",
          "args": [
            "sys_data->enter_event"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "sys_data->enter_event->perf_events"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_nr_to_meta",
          "args": [
            "syscall_nr"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_nr_to_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "102-108",
          "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct syscall_metadata **syscalls_metadata;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "syscall_nr",
            "enabled_perf_enter_syscalls"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_syscall_nr",
          "args": [
            "current",
            "regs"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_syscall_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "73-77",
          "snippet": "static inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_enter *rec;\n\tstruct hlist_head *head;\n\tbool valid_prog_array;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->enter_event->perf_events);\n\tvalid_prog_array = bpf_prog_array_valid(sys_data->enter_event);\n\tif (!valid_prog_array && hlist_empty(head))\n\t\treturn;\n\n\t/* get the size after alignment with the u32 buffer size field */\n\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args,\n\t\t\t       (unsigned long *)&rec->args);\n\n\tif ((valid_prog_array &&\n\t     !perf_call_bpf_enter(sys_data->enter_event, regs, sys_data, rec)) ||\n\t    hlist_empty(head)) {\n\t\tperf_swevent_put_recursion_context(rctx);\n\t\treturn;\n\t}\n\n\tperf_trace_buf_submit(rec, size, rctx,\n\t\t\t      sys_data->enter_event->event.type, 1, regs,\n\t\t\t      head, NULL);\n}"
  },
  {
    "function_name": "perf_call_bpf_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "563-579",
    "snippet": "static int perf_call_bpf_enter(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t       struct syscall_metadata *sys_data,\n\t\t\t       struct syscall_trace_enter *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long args[SYSCALL_DEFINE_MAXARGS];\n\t} param;\n\tint i;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tfor (i = 0; i < sys_data->nb_args; i++)\n\t\tparam.args[i] = rec->args[i];\n\treturn trace_call_bpf(call, &param);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_call_bpf",
          "args": [
            "call",
            "&param"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "trace_call_bpf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "37-79",
          "snippet": "unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tif (in_nmi()) /* not supported yet */\n\t\treturn 1;\n\n\tpreempt_disable();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heurisitc to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY_CHECK(call->prog_array, ctx, BPF_PROG_RUN);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nunsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tif (in_nmi()) /* not supported yet */\n\t\treturn 1;\n\n\tpreempt_disable();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heurisitc to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY_CHECK(call->prog_array, ctx, BPF_PROG_RUN);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic int perf_call_bpf_enter(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t       struct syscall_metadata *sys_data,\n\t\t\t       struct syscall_trace_enter *rec)\n{\n\tstruct syscall_tp_t {\n\t\tunsigned long long regs;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long args[SYSCALL_DEFINE_MAXARGS];\n\t} param;\n\tint i;\n\n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tfor (i = 0; i < sys_data->nb_args; i++)\n\t\tparam.args[i] = rec->args[i];\n\treturn trace_call_bpf(call, &param);\n}"
  },
  {
    "function_name": "init_ftrace_syscalls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "532-554",
    "snippet": "void __init init_ftrace_syscalls(void)\n{\n\tstruct syscall_metadata *meta;\n\tunsigned long addr;\n\tint i;\n\n\tsyscalls_metadata = kcalloc(NR_syscalls, sizeof(*syscalls_metadata),\n\t\t\t\t    GFP_KERNEL);\n\tif (!syscalls_metadata) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < NR_syscalls; i++) {\n\t\taddr = arch_syscall_addr(i);\n\t\tmeta = find_syscall_meta(addr);\n\t\tif (!meta)\n\t\t\tcontinue;\n\n\t\tmeta->syscall_nr = i;\n\t\tsyscalls_metadata[i] = meta;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct syscall_metadata **syscalls_metadata;",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_syscall_meta",
          "args": [
            "addr"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "find_syscall_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "80-100",
          "snippet": "syscall_metadata *\nfind_syscall_meta(unsigned long syscall)\n{\n\tstruct syscall_metadata **start;\n\tstruct syscall_metadata **stop;\n\tchar str[KSYM_SYMBOL_LEN];\n\n\n\tstart = __start_syscalls_metadata;\n\tstop = __stop_syscalls_metadata;\n\tkallsyms_lookup(syscall, NULL, NULL, NULL, str);\n\n\tif (arch_syscall_match_sym_name(str, \"sys_ni_syscall\"))\n\t\treturn NULL;\n\n\tfor ( ; start < stop; start++) {\n\t\tif ((*start)->name && arch_syscall_match_sym_name(str, (*start)->name))\n\t\t\treturn *start;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct syscall_metadata *__start_syscalls_metadata[];",
            "extern struct syscall_metadata *__stop_syscalls_metadata[];",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nextern struct syscall_metadata *__start_syscalls_metadata[];\nextern struct syscall_metadata *__stop_syscalls_metadata[];\nstatic __init struct;\n\nsyscall_metadata *\nfind_syscall_meta(unsigned long syscall)\n{\n\tstruct syscall_metadata **start;\n\tstruct syscall_metadata **stop;\n\tchar str[KSYM_SYMBOL_LEN];\n\n\n\tstart = __start_syscalls_metadata;\n\tstop = __stop_syscalls_metadata;\n\tkallsyms_lookup(syscall, NULL, NULL, NULL, str);\n\n\tif (arch_syscall_match_sym_name(str, \"sys_ni_syscall\"))\n\t\treturn NULL;\n\n\tfor ( ; start < stop; start++) {\n\t\tif ((*start)->name && arch_syscall_match_sym_name(str, (*start)->name))\n\t\t\treturn *start;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_syscall_addr",
          "args": [
            "i"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "arch_syscall_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "527-530",
          "snippet": "unsigned long __init __weak arch_syscall_addr(int nr)\n{\n\treturn (unsigned long)sys_call_table[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nunsigned long __init __weak arch_syscall_addr(int nr)\n{\n\treturn (unsigned long)sys_call_table[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "NR_syscalls",
            "sizeof(*syscalls_metadata)",
            "GFP_KERNEL"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nvoid __init init_ftrace_syscalls(void)\n{\n\tstruct syscall_metadata *meta;\n\tunsigned long addr;\n\tint i;\n\n\tsyscalls_metadata = kcalloc(NR_syscalls, sizeof(*syscalls_metadata),\n\t\t\t\t    GFP_KERNEL);\n\tif (!syscalls_metadata) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < NR_syscalls; i++) {\n\t\taddr = arch_syscall_addr(i);\n\t\tmeta = find_syscall_meta(addr);\n\t\tif (!meta)\n\t\t\tcontinue;\n\n\t\tmeta->syscall_nr = i;\n\t\tsyscalls_metadata[i] = meta;\n\t}\n}"
  },
  {
    "function_name": "arch_syscall_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "527-530",
    "snippet": "unsigned long __init __weak arch_syscall_addr(int nr)\n{\n\treturn (unsigned long)sys_call_table[nr];\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nunsigned long __init __weak arch_syscall_addr(int nr)\n{\n\treturn (unsigned long)sys_call_table[nr];\n}"
  },
  {
    "function_name": "init_syscall_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "478-501",
    "snippet": "static int __init init_syscall_trace(struct trace_event_call *call)\n{\n\tint id;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (num < 0 || num >= NR_syscalls) {\n\t\tpr_debug(\"syscall %s metadata not mapped, disabling ftrace event\\n\",\n\t\t\t\t((struct syscall_metadata *)call->data)->name);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (set_syscall_print_fmt(call) < 0)\n\t\treturn -ENOMEM;\n\n\tid = trace_event_raw_init(call);\n\n\tif (id < 0) {\n\t\tfree_syscall_print_fmt(call);\n\t\treturn id;\n\t}\n\n\treturn id;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_syscall_print_fmt",
          "args": [
            "call"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "free_syscall_print_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "260-266",
          "snippet": "static void __init free_syscall_print_fmt(struct trace_event_call *call)\n{\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event == call)\n\t\tkfree(call->print_fmt);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void __init free_syscall_print_fmt(struct trace_event_call *call)\n{\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event == call)\n\t\tkfree(call->print_fmt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_raw_init",
          "args": [
            "call"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_raw_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "225-234",
          "snippet": "int trace_event_raw_init(struct trace_event_call *call)\n{\n\tint id;\n\n\tid = register_trace_event(&call->event);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_event_raw_init(struct trace_event_call *call)\n{\n\tint id;\n\n\tid = register_trace_event(&call->event);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_syscall_print_fmt",
          "args": [
            "call"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "set_syscall_print_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "235-258",
          "snippet": "static int __init set_syscall_print_fmt(struct trace_event_call *call)\n{\n\tchar *print_fmt;\n\tint len;\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event != call) {\n\t\tcall->print_fmt = \"\\\"0x%lx\\\", REC->ret\";\n\t\treturn 0;\n\t}\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_enter_print_fmt(entry, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_enter_print_fmt(entry, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int __init set_syscall_print_fmt(struct trace_event_call *call)\n{\n\tchar *print_fmt;\n\tint len;\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event != call) {\n\t\tcall->print_fmt = \"\\\"0x%lx\\\", REC->ret\";\n\t\treturn 0;\n\t}\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_enter_print_fmt(entry, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_enter_print_fmt(entry, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"syscall %s metadata not mapped, disabling ftrace event\\n\"",
            "((struct syscall_metadata *)call->data)->name"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int __init init_syscall_trace(struct trace_event_call *call)\n{\n\tint id;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (num < 0 || num >= NR_syscalls) {\n\t\tpr_debug(\"syscall %s metadata not mapped, disabling ftrace event\\n\",\n\t\t\t\t((struct syscall_metadata *)call->data)->name);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (set_syscall_print_fmt(call) < 0)\n\t\treturn -ENOMEM;\n\n\tid = trace_event_raw_init(call);\n\n\tif (id < 0) {\n\t\tfree_syscall_print_fmt(call);\n\t\treturn id;\n\t}\n\n\treturn id;\n}"
  },
  {
    "function_name": "unreg_event_syscall_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "461-476",
    "snippet": "static void unreg_event_syscall_exit(struct trace_event_file *file,\n\t\t\t\t     struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_exit--;\n\tRCU_INIT_POINTER(tr->exit_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_exit)\n\t\tunregister_trace_sys_exit(ftrace_syscall_exit, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_sys_exit",
          "args": [
            "ftrace_syscall_exit",
            "tr"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "tr->exit_syscall_files[num]",
            "NULL"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "num < 0 || num >= NR_syscalls"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void unreg_event_syscall_exit(struct trace_event_file *file,\n\t\t\t\t     struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_exit--;\n\tRCU_INIT_POINTER(tr->exit_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_exit)\n\t\tunregister_trace_sys_exit(ftrace_syscall_exit, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}"
  },
  {
    "function_name": "reg_event_syscall_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "440-459",
    "snippet": "static int reg_event_syscall_exit(struct trace_event_file *file,\n\t\t\t\t  struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn -ENOSYS;\n\tmutex_lock(&syscall_trace_lock);\n\tif (!tr->sys_refcount_exit)\n\t\tret = register_trace_sys_exit(ftrace_syscall_exit, tr);\n\tif (!ret) {\n\t\trcu_assign_pointer(tr->exit_syscall_files[num], file);\n\t\ttr->sys_refcount_exit++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->exit_syscall_files[num]",
            "file"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sys_exit",
          "args": [
            "ftrace_syscall_exit",
            "tr"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "num < 0 || num >= NR_syscalls"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int reg_event_syscall_exit(struct trace_event_file *file,\n\t\t\t\t  struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn -ENOSYS;\n\tmutex_lock(&syscall_trace_lock);\n\tif (!tr->sys_refcount_exit)\n\t\tret = register_trace_sys_exit(ftrace_syscall_exit, tr);\n\tif (!ret) {\n\t\trcu_assign_pointer(tr->exit_syscall_files[num], file);\n\t\ttr->sys_refcount_exit++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "unreg_event_syscall_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "423-438",
    "snippet": "static void unreg_event_syscall_enter(struct trace_event_file *file,\n\t\t\t\t      struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_enter--;\n\tRCU_INIT_POINTER(tr->enter_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_enter)\n\t\tunregister_trace_sys_enter(ftrace_syscall_enter, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_sys_enter",
          "args": [
            "ftrace_syscall_enter",
            "tr"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "tr->enter_syscall_files[num]",
            "NULL"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "num < 0 || num >= NR_syscalls"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void unreg_event_syscall_enter(struct trace_event_file *file,\n\t\t\t\t      struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_enter--;\n\tRCU_INIT_POINTER(tr->enter_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_enter)\n\t\tunregister_trace_sys_enter(ftrace_syscall_enter, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}"
  },
  {
    "function_name": "reg_event_syscall_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "402-421",
    "snippet": "static int reg_event_syscall_enter(struct trace_event_file *file,\n\t\t\t\t   struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn -ENOSYS;\n\tmutex_lock(&syscall_trace_lock);\n\tif (!tr->sys_refcount_enter)\n\t\tret = register_trace_sys_enter(ftrace_syscall_enter, tr);\n\tif (!ret) {\n\t\trcu_assign_pointer(tr->enter_syscall_files[num], file);\n\t\ttr->sys_refcount_enter++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(syscall_trace_lock);",
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->enter_syscall_files[num]",
            "file"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sys_enter",
          "args": [
            "ftrace_syscall_enter",
            "tr"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&syscall_trace_lock"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "num < 0 || num >= NR_syscalls"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int reg_event_syscall_enter(struct trace_event_file *file,\n\t\t\t\t   struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn -ENOSYS;\n\tmutex_lock(&syscall_trace_lock);\n\tif (!tr->sys_refcount_enter)\n\t\tret = register_trace_sys_enter(ftrace_syscall_enter, tr);\n\tif (!ret) {\n\t\trcu_assign_pointer(tr->enter_syscall_files[num], file);\n\t\ttr->sys_refcount_enter++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_syscall_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "356-400",
    "snippet": "static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_event_file *trace_file;\n\tstruct syscall_trace_exit *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE()) */\n\ttrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);\n\tif (!trace_file)\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->exit_event->event.type, sizeof(*entry),\n\t\t\tirq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tentry->ret = syscall_get_return_value(current, regs);\n\n\tevent_trigger_unlock_commit(trace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_unlock_commit",
          "args": [
            "trace_file",
            "buffer",
            "event",
            "entry",
            "irq_flags",
            "pc"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_unlock_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1323-1336",
          "snippet": "static inline void\nevent_trigger_unlock_commit(struct trace_event_file *file,\n\t\t\t    struct ring_buffer *buffer,\n\t\t\t    struct ring_buffer_event *event,\n\t\t\t    void *entry, unsigned long irq_flags, int pc)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit(file->tr, buffer, event, irq_flags, pc);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void\nevent_trigger_unlock_commit(struct trace_event_file *file,\n\t\t\t    struct ring_buffer *buffer,\n\t\t\t    struct ring_buffer_event *event,\n\t\t\t    void *entry, unsigned long irq_flags, int pc)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit(file->tr, buffer, event, irq_flags, pc);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_return_value",
          "args": [
            "current",
            "regs"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "sys_data->exit_event->event.type",
            "sizeof(*entry)",
            "irq_flags",
            "pc"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2152-2159",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "irq_flags"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_nr_to_meta",
          "args": [
            "syscall_nr"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_nr_to_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "102-108",
          "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct syscall_metadata **syscalls_metadata;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_trigger_soft_disabled",
          "args": [
            "trace_file"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->exit_syscall_files[syscall_nr]"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_syscall_nr",
          "args": [
            "current",
            "regs"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_syscall_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "73-77",
          "snippet": "static inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_event_file *trace_file;\n\tstruct syscall_trace_exit *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE()) */\n\ttrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);\n\tif (!trace_file)\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->exit_event->event.type, sizeof(*entry),\n\t\t\tirq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tentry->ret = syscall_get_return_value(current, regs);\n\n\tevent_trigger_unlock_commit(trace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}"
  },
  {
    "function_name": "ftrace_syscall_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "308-354",
    "snippet": "static void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_event_file *trace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\ttrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!trace_file)\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->enter_event->event.type, size, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\n\n\tevent_trigger_unlock_commit(trace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_unlock_commit",
          "args": [
            "trace_file",
            "buffer",
            "event",
            "entry",
            "irq_flags",
            "pc"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_unlock_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1323-1336",
          "snippet": "static inline void\nevent_trigger_unlock_commit(struct trace_event_file *file,\n\t\t\t    struct ring_buffer *buffer,\n\t\t\t    struct ring_buffer_event *event,\n\t\t\t    void *entry, unsigned long irq_flags, int pc)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit(file->tr, buffer, event, irq_flags, pc);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void\nevent_trigger_unlock_commit(struct trace_event_file *file,\n\t\t\t    struct ring_buffer *buffer,\n\t\t\t    struct ring_buffer_event *event,\n\t\t\t    void *entry, unsigned long irq_flags, int pc)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit(file->tr, buffer, event, irq_flags, pc);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_arguments",
          "args": [
            "current",
            "regs",
            "0",
            "sys_data->nb_args",
            "entry->args"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "sys_data->enter_event->event.type",
            "size",
            "irq_flags",
            "pc"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2152-2159",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "irq_flags"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_nr_to_meta",
          "args": [
            "syscall_nr"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_nr_to_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "102-108",
          "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct syscall_metadata **syscalls_metadata;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_trigger_soft_disabled",
          "args": [
            "trace_file"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->enter_syscall_files[syscall_nr]"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_syscall_nr",
          "args": [
            "current",
            "regs"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_syscall_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "73-77",
          "snippet": "static inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_event_file *trace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\ttrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!trace_file)\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->enter_event->event.type, size, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\n\n\tevent_trigger_unlock_commit(trace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}"
  },
  {
    "function_name": "syscall_exit_define_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "292-306",
    "snippet": "static int __init syscall_exit_define_fields(struct trace_event_call *call)\n{\n\tstruct syscall_trace_exit trace;\n\tint ret;\n\n\tret = trace_define_field(call, SYSCALL_FIELD(int, nr, __syscall_nr),\n\t\t\t\t FILTER_OTHER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = trace_define_field(call, SYSCALL_FIELD(long, ret, ret),\n\t\t\t\t FILTER_OTHER);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_define_field",
          "args": [
            "call",
            "SYSCALL_FIELD(long, ret, ret)",
            "FILTER_OTHER"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSCALL_FIELD",
          "args": [
            "long",
            "ret",
            "ret"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_define_field",
          "args": [
            "call",
            "SYSCALL_FIELD(int, nr, __syscall_nr)",
            "FILTER_OTHER"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSCALL_FIELD",
          "args": [
            "int",
            "nr",
            "__syscall_nr"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic int __init syscall_exit_define_fields(struct trace_event_call *call)\n{\n\tstruct syscall_trace_exit trace;\n\tint ret;\n\n\tret = trace_define_field(call, SYSCALL_FIELD(int, nr, __syscall_nr),\n\t\t\t\t FILTER_OTHER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = trace_define_field(call, SYSCALL_FIELD(long, ret, ret),\n\t\t\t\t FILTER_OTHER);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "syscall_enter_define_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "268-290",
    "snippet": "static int __init syscall_enter_define_fields(struct trace_event_call *call)\n{\n\tstruct syscall_trace_enter trace;\n\tstruct syscall_metadata *meta = call->data;\n\tint ret;\n\tint i;\n\tint offset = offsetof(typeof(trace), args);\n\n\tret = trace_define_field(call, SYSCALL_FIELD(int, nr, __syscall_nr),\n\t\t\t\t FILTER_OTHER);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < meta->nb_args; i++) {\n\t\tret = trace_define_field(call, meta->types[i],\n\t\t\t\t\t meta->args[i], offset,\n\t\t\t\t\t sizeof(unsigned long), 0,\n\t\t\t\t\t FILTER_OTHER);\n\t\toffset += sizeof(unsigned long);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_define_field",
          "args": [
            "call",
            "meta->types[i]",
            "meta->args[i]",
            "offset",
            "sizeof(unsigned long)",
            "0",
            "FILTER_OTHER"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "trace_define_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "139-151",
          "snippet": "int trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_define_field",
          "args": [
            "call",
            "SYSCALL_FIELD(int, nr, __syscall_nr)",
            "FILTER_OTHER"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSCALL_FIELD",
          "args": [
            "int",
            "nr",
            "__syscall_nr"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int __init syscall_enter_define_fields(struct trace_event_call *call)\n{\n\tstruct syscall_trace_enter trace;\n\tstruct syscall_metadata *meta = call->data;\n\tint ret;\n\tint i;\n\tint offset = offsetof(typeof(trace), args);\n\n\tret = trace_define_field(call, SYSCALL_FIELD(int, nr, __syscall_nr),\n\t\t\t\t FILTER_OTHER);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < meta->nb_args; i++) {\n\t\tret = trace_define_field(call, meta->types[i],\n\t\t\t\t\t meta->args[i], offset,\n\t\t\t\t\t sizeof(unsigned long), 0,\n\t\t\t\t\t FILTER_OTHER);\n\t\toffset += sizeof(unsigned long);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "free_syscall_print_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "260-266",
    "snippet": "static void __init free_syscall_print_fmt(struct trace_event_call *call)\n{\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event == call)\n\t\tkfree(call->print_fmt);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "call->print_fmt"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic void __init free_syscall_print_fmt(struct trace_event_call *call)\n{\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event == call)\n\t\tkfree(call->print_fmt);\n}"
  },
  {
    "function_name": "set_syscall_print_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "235-258",
    "snippet": "static int __init set_syscall_print_fmt(struct trace_event_call *call)\n{\n\tchar *print_fmt;\n\tint len;\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event != call) {\n\t\tcall->print_fmt = \"\\\"0x%lx\\\", REC->ret\";\n\t\treturn 0;\n\t}\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_enter_print_fmt(entry, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_enter_print_fmt(entry, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_enter_print_fmt",
          "args": [
            "entry",
            "print_fmt",
            "len + 1"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "__set_enter_print_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "207-233",
          "snippet": "static int __init\n__set_enter_print_fmt(struct syscall_metadata *entry, char *buf, int len)\n{\n\tint i;\n\tint pos = 0;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s: 0x%%0%zulx%s\",\n\t\t\t\tentry->args[i], sizeof(unsigned long),\n\t\t\t\ti == entry->nb_args - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", ((unsigned long)(REC->%s))\", entry->args[i]);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [
            "#define LEN_OR_ZERO (len ? len - pos : 0)"
          ],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\nstatic __init struct;\n\nstatic int __init\n__set_enter_print_fmt(struct syscall_metadata *entry, char *buf, int len)\n{\n\tint i;\n\tint pos = 0;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s: 0x%%0%zulx%s\",\n\t\t\t\tentry->args[i], sizeof(unsigned long),\n\t\t\t\ti == entry->nb_args - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", ((unsigned long)(REC->%s))\", entry->args[i]);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic int __init set_syscall_print_fmt(struct trace_event_call *call)\n{\n\tchar *print_fmt;\n\tint len;\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event != call) {\n\t\tcall->print_fmt = \"\\\"0x%lx\\\", REC->ret\";\n\t\treturn 0;\n\t}\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_enter_print_fmt(entry, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_enter_print_fmt(entry, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__set_enter_print_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "207-233",
    "snippet": "static int __init\n__set_enter_print_fmt(struct syscall_metadata *entry, char *buf, int len)\n{\n\tint i;\n\tint pos = 0;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s: 0x%%0%zulx%s\",\n\t\t\t\tentry->args[i], sizeof(unsigned long),\n\t\t\t\ti == entry->nb_args - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", ((unsigned long)(REC->%s))\", entry->args[i]);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [
      "#define LEN_OR_ZERO (len ? len - pos : 0)"
    ],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\", ((unsigned long)(REC->%s))\"",
            "entry->args[i]"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"\\\"\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"%s: 0x%%0%zulx%s\"",
            "entry->args[i]",
            "sizeof(unsigned long)",
            "i == entry->nb_args - 1 ? \"\" : \", \""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"\\\"\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\nstatic __init struct;\n\nstatic int __init\n__set_enter_print_fmt(struct syscall_metadata *entry, char *buf, int len)\n{\n\tint i;\n\tint pos = 0;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s: 0x%%0%zulx%s\",\n\t\t\t\tentry->args[i], sizeof(unsigned long),\n\t\t\t\ti == entry->nb_args - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", ((unsigned long)(REC->%s))\", entry->args[i]);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}"
  },
  {
    "function_name": "print_syscall_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "168-197",
    "snippet": "static enum print_line_t\nprint_syscall_exit(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct syscall_trace_exit *trace;\n\tint syscall;\n\tstruct syscall_metadata *entry;\n\n\ttrace = (typeof(trace))ent;\n\tsyscall = trace->nr;\n\tentry = syscall_nr_to_meta(syscall);\n\n\tif (!entry) {\n\t\ttrace_seq_putc(s, '\\n');\n\t\tgoto out;\n\t}\n\n\tif (entry->exit_event->event.type != ent->type) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn TRACE_TYPE_UNHANDLED;\n\t}\n\n\ttrace_seq_printf(s, \"%s -> 0x%lx\\n\", entry->name,\n\t\t\t\ttrace->ret);\n\n out:\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2123-2127",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s -> 0x%lx\\n\"",
            "entry->name",
            "trace->ret"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_nr_to_meta",
          "args": [
            "syscall"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_nr_to_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "102-108",
          "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct syscall_metadata **syscalls_metadata;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic enum print_line_t\nprint_syscall_exit(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct syscall_trace_exit *trace;\n\tint syscall;\n\tstruct syscall_metadata *entry;\n\n\ttrace = (typeof(trace))ent;\n\tsyscall = trace->nr;\n\tentry = syscall_nr_to_meta(syscall);\n\n\tif (!entry) {\n\t\ttrace_seq_putc(s, '\\n');\n\t\tgoto out;\n\t}\n\n\tif (entry->exit_event->event.type != ent->type) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn TRACE_TYPE_UNHANDLED;\n\t}\n\n\ttrace_seq_printf(s, \"%s -> 0x%lx\\n\", entry->name,\n\t\t\t\ttrace->ret);\n\n out:\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "print_syscall_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "121-166",
    "snippet": "static enum print_line_t\nprint_syscall_enter(struct trace_iterator *iter, int flags,\n\t\t    struct trace_event *event)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct syscall_trace_enter *trace;\n\tstruct syscall_metadata *entry;\n\tint i, syscall;\n\n\ttrace = (typeof(trace))ent;\n\tsyscall = trace->nr;\n\tentry = syscall_nr_to_meta(syscall);\n\n\tif (!entry)\n\t\tgoto end;\n\n\tif (entry->enter_event->event.type != ent->type) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto end;\n\t}\n\n\ttrace_seq_printf(s, \"%s(\", entry->name);\n\n\tfor (i = 0; i < entry->nb_args; i++) {\n\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tgoto end;\n\n\t\t/* parameter types */\n\t\tif (tr->trace_flags & TRACE_ITER_VERBOSE)\n\t\t\ttrace_seq_printf(s, \"%s \", entry->types[i]);\n\n\t\t/* parameter values */\n\t\ttrace_seq_printf(s, \"%s: %lx%s\", entry->args[i],\n\t\t\t\t trace->args[i],\n\t\t\t\t i == entry->nb_args - 1 ? \"\" : \", \");\n\t}\n\n\ttrace_seq_putc(s, ')');\nend:\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2123-2127",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s: %lx%s\"",
            "entry->args[i]",
            "trace->args[i]",
            "i == entry->nb_args - 1 ? \"\" : \", \""
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_nr_to_meta",
          "args": [
            "syscall"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_nr_to_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "102-108",
          "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct syscall_metadata **syscalls_metadata;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic enum print_line_t\nprint_syscall_enter(struct trace_iterator *iter, int flags,\n\t\t    struct trace_event *event)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct syscall_trace_enter *trace;\n\tstruct syscall_metadata *entry;\n\tint i, syscall;\n\n\ttrace = (typeof(trace))ent;\n\tsyscall = trace->nr;\n\tentry = syscall_nr_to_meta(syscall);\n\n\tif (!entry)\n\t\tgoto end;\n\n\tif (entry->enter_event->event.type != ent->type) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto end;\n\t}\n\n\ttrace_seq_printf(s, \"%s(\", entry->name);\n\n\tfor (i = 0; i < entry->nb_args; i++) {\n\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tgoto end;\n\n\t\t/* parameter types */\n\t\tif (tr->trace_flags & TRACE_ITER_VERBOSE)\n\t\t\ttrace_seq_printf(s, \"%s \", entry->types[i]);\n\n\t\t/* parameter values */\n\t\ttrace_seq_printf(s, \"%s: %lx%s\", entry->args[i],\n\t\t\t\t trace->args[i],\n\t\t\t\t i == entry->nb_args - 1 ? \"\" : \", \");\n\t}\n\n\ttrace_seq_putc(s, ')');\nend:\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "get_syscall_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "110-119",
    "snippet": "const char *get_syscall_name(int syscall)\n{\n\tstruct syscall_metadata *entry;\n\n\tentry = syscall_nr_to_meta(syscall);\n\tif (!entry)\n\t\treturn NULL;\n\n\treturn entry->name;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall_nr_to_meta",
          "args": [
            "syscall"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "syscall_nr_to_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "102-108",
          "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct syscall_metadata **syscalls_metadata;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nconst char *get_syscall_name(int syscall)\n{\n\tstruct syscall_metadata *entry;\n\n\tentry = syscall_nr_to_meta(syscall);\n\tif (!entry)\n\t\treturn NULL;\n\n\treturn entry->name;\n}"
  },
  {
    "function_name": "syscall_nr_to_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "102-108",
    "snippet": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct syscall_metadata **syscalls_metadata;",
      "static __init struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic struct syscall_metadata **syscalls_metadata;\nstatic __init struct;\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}"
  },
  {
    "function_name": "find_syscall_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "80-100",
    "snippet": "syscall_metadata *\nfind_syscall_meta(unsigned long syscall)\n{\n\tstruct syscall_metadata **start;\n\tstruct syscall_metadata **stop;\n\tchar str[KSYM_SYMBOL_LEN];\n\n\n\tstart = __start_syscalls_metadata;\n\tstop = __stop_syscalls_metadata;\n\tkallsyms_lookup(syscall, NULL, NULL, NULL, str);\n\n\tif (arch_syscall_match_sym_name(str, \"sys_ni_syscall\"))\n\t\treturn NULL;\n\n\tfor ( ; start < stop; start++) {\n\t\tif ((*start)->name && arch_syscall_match_sym_name(str, (*start)->name))\n\t\t\treturn *start;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct syscall_metadata *__start_syscalls_metadata[];",
      "extern struct syscall_metadata *__stop_syscalls_metadata[];",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_syscall_match_sym_name",
          "args": [
            "str",
            "(*start)->name"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "arch_syscall_match_sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
          "lines": "36-45",
          "snippet": "static inline bool arch_syscall_match_sym_name(const char *sym, const char *name)\n{\n\t/*\n\t * Only compare after the \"sys\" prefix. Archs that use\n\t * syscall wrappers may have syscalls symbols aliases prefixed\n\t * with \".SyS\" or \".sys\" instead of \"sys\", leading to an unwanted\n\t * mismatch.\n\t */\n\treturn !strcmp(sym + 3, name + 3);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <trace/events/syscalls.h>",
            "#include <trace/syscall.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic inline bool arch_syscall_match_sym_name(const char *sym, const char *name)\n{\n\t/*\n\t * Only compare after the \"sys\" prefix. Archs that use\n\t * syscall wrappers may have syscalls symbols aliases prefixed\n\t * with \".SyS\" or \".sys\" instead of \"sys\", leading to an unwanted\n\t * mismatch.\n\t */\n\treturn !strcmp(sym + 3, name + 3);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "syscall",
            "NULL",
            "NULL",
            "NULL",
            "str"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "278-311",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\treturn namebuf;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nextern struct syscall_metadata *__start_syscalls_metadata[];\nextern struct syscall_metadata *__stop_syscalls_metadata[];\nstatic __init struct;\n\nsyscall_metadata *\nfind_syscall_meta(unsigned long syscall)\n{\n\tstruct syscall_metadata **start;\n\tstruct syscall_metadata **stop;\n\tchar str[KSYM_SYMBOL_LEN];\n\n\n\tstart = __start_syscalls_metadata;\n\tstop = __stop_syscalls_metadata;\n\tkallsyms_lookup(syscall, NULL, NULL, NULL, str);\n\n\tif (arch_syscall_match_sym_name(str, \"sys_ni_syscall\"))\n\t\treturn NULL;\n\n\tfor ( ; start < stop; start++) {\n\t\tif ((*start)->name && arch_syscall_match_sym_name(str, (*start)->name))\n\t\t\treturn *start;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "trace_get_syscall_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "73-77",
    "snippet": "static inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall_get_nr",
          "args": [
            "task",
            "regs"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}"
  },
  {
    "function_name": "trace_get_syscall_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "64-71",
    "snippet": "static int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\tif (unlikely(arch_trace_is_compat_syscall(regs)))\n\t\treturn -1;\n\n\treturn syscall_get_nr(task, regs);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall_get_nr",
          "args": [
            "task",
            "regs"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "arch_trace_is_compat_syscall(regs)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_trace_is_compat_syscall",
          "args": [
            "regs"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic __init struct;\n\nstatic int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\tif (unlikely(arch_trace_is_compat_syscall(regs)))\n\t\treturn -1;\n\n\treturn syscall_get_nr(task, regs);\n}"
  },
  {
    "function_name": "arch_syscall_match_sym_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "36-45",
    "snippet": "static inline bool arch_syscall_match_sym_name(const char *sym, const char *name)\n{\n\t/*\n\t * Only compare after the \"sys\" prefix. Archs that use\n\t * syscall wrappers may have syscalls symbols aliases prefixed\n\t * with \".SyS\" or \".sys\" instead of \"sys\", leading to an unwanted\n\t * mismatch.\n\t */\n\treturn !strcmp(sym + 3, name + 3);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sym + 3",
            "name + 3"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic inline bool arch_syscall_match_sym_name(const char *sym, const char *name)\n{\n\t/*\n\t * Only compare after the \"sys\" prefix. Archs that use\n\t * syscall wrappers may have syscalls symbols aliases prefixed\n\t * with \".SyS\" or \".sys\" instead of \"sys\", leading to an unwanted\n\t * mismatch.\n\t */\n\treturn !strcmp(sym + 3, name + 3);\n}"
  },
  {
    "function_name": "syscall_get_enter_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_syscalls.c",
    "lines": "22-28",
    "snippet": "static struct list_head *\nsyscall_get_enter_fields(struct trace_event_call *call)\n{\n\tstruct syscall_metadata *entry = call->data;\n\n\treturn &entry->enter_fields;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_output.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <trace/events/syscalls.h>",
      "#include <trace/syscall.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);",
      "static __init struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_output.h\"\n#include <asm/syscall.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\t/* for MODULE_NAME_LEN via KSYM_SYMBOL_LEN */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <trace/events/syscalls.h>\n#include <trace/syscall.h>\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic __init struct;\n\nstatic struct list_head *\nsyscall_get_enter_fields(struct trace_event_call *call)\n{\n\tstruct syscall_metadata *entry = call->data;\n\n\treturn &entry->enter_fields;\n}"
  }
]