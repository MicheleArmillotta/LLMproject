[
  {
    "function_name": "hung_task_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
    "lines": "299-309",
    "snippet": "static int __init hung_task_init(void)\n{\n\tatomic_notifier_chain_register(&panic_notifier_list, &panic_block);\n\n\t/* Disable hung task detector on suspend */\n\tpm_notifier(hungtask_pm_notify, 0);\n\n\twatchdog_task = kthread_run(watchdog, NULL, \"khungtaskd\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *watchdog_task;",
      "static struct notifier_block panic_block = {\n\t.notifier_call = hung_task_panic,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "watchdog",
            "NULL",
            "\"khungtaskd\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_notifier",
          "args": [
            "hungtask_pm_notify",
            "0"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_notifier_chain_register",
          "args": [
            "&panic_notifier_list",
            "&panic_block"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_chain_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "121-131",
          "snippet": "int atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *watchdog_task;\nstatic struct notifier_block panic_block = {\n\t.notifier_call = hung_task_panic,\n};\n\nstatic int __init hung_task_init(void)\n{\n\tatomic_notifier_chain_register(&panic_notifier_list, &panic_block);\n\n\t/* Disable hung task detector on suspend */\n\tpm_notifier(hungtask_pm_notify, 0);\n\n\twatchdog_task = kthread_run(watchdog, NULL, \"khungtaskd\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
    "lines": "271-297",
    "snippet": "static int watchdog(void *dummy)\n{\n\tunsigned long hung_last_checked = jiffies;\n\n\tset_user_nice(current, 0);\n\n\tfor ( ; ; ) {\n\t\tunsigned long timeout = sysctl_hung_task_timeout_secs;\n\t\tunsigned long interval = sysctl_hung_task_check_interval_secs;\n\t\tlong t;\n\n\t\tif (interval == 0)\n\t\t\tinterval = timeout;\n\t\tinterval = min_t(unsigned long, interval, timeout);\n\t\tt = hung_timeout_jiffies(hung_last_checked, interval);\n\t\tif (t <= 0) {\n\t\t\tif (!atomic_xchg(&reset_hung_task, 0) &&\n\t\t\t    !hung_detector_suspended)\n\t\t\t\tcheck_hung_uninterruptible_tasks(timeout);\n\t\t\thung_last_checked = jiffies;\n\t\t\tcontinue;\n\t\t}\n\t\tschedule_timeout_interruptible(t);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long __read_mostly sysctl_hung_task_timeout_secs = CONFIG_DEFAULT_HUNG_TASK_TIMEOUT;",
      "unsigned long __read_mostly sysctl_hung_task_check_interval_secs;",
      "static atomic_t reset_hung_task = ATOMIC_INIT(0);",
      "static bool hung_detector_suspended;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "t"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_hung_uninterruptible_tasks",
          "args": [
            "timeout"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "check_hung_uninterruptible_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
          "lines": "173-208",
          "snippet": "static void check_hung_uninterruptible_tasks(unsigned long timeout)\n{\n\tint max_count = sysctl_hung_task_check_count;\n\tint batch_count = HUNG_TASK_BATCHING;\n\tstruct task_struct *g, *t;\n\n\t/*\n\t * If the system crashed already then all bets are off,\n\t * do not report extra hung tasks:\n\t */\n\tif (test_taint(TAINT_DIE) || did_panic)\n\t\treturn;\n\n\thung_task_show_lock = false;\n\trcu_read_lock();\n\tfor_each_process_thread(g, t) {\n\t\tif (!max_count--)\n\t\t\tgoto unlock;\n\t\tif (!--batch_count) {\n\t\t\tbatch_count = HUNG_TASK_BATCHING;\n\t\t\tif (!rcu_lock_break(g, t))\n\t\t\t\tgoto unlock;\n\t\t}\n\t\t/* use \"==\" to skip the TASK_KILLABLE tasks waiting on NFS */\n\t\tif (t->state == TASK_UNINTERRUPTIBLE)\n\t\t\tcheck_hung_task(t, timeout);\n\t}\n unlock:\n\trcu_read_unlock();\n\tif (hung_task_show_lock)\n\t\tdebug_show_all_locks();\n\tif (hung_task_call_panic) {\n\t\ttrigger_all_cpu_backtrace();\n\t\tpanic(\"hung_task: blocked tasks\");\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/export.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define HUNG_TASK_BATCHING 1024"
          ],
          "globals_used": [
            "static int __read_mostly did_panic;",
            "static bool hung_task_show_lock;",
            "static bool hung_task_call_panic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define HUNG_TASK_BATCHING 1024\n\nstatic int __read_mostly did_panic;\nstatic bool hung_task_show_lock;\nstatic bool hung_task_call_panic;\n\nstatic void check_hung_uninterruptible_tasks(unsigned long timeout)\n{\n\tint max_count = sysctl_hung_task_check_count;\n\tint batch_count = HUNG_TASK_BATCHING;\n\tstruct task_struct *g, *t;\n\n\t/*\n\t * If the system crashed already then all bets are off,\n\t * do not report extra hung tasks:\n\t */\n\tif (test_taint(TAINT_DIE) || did_panic)\n\t\treturn;\n\n\thung_task_show_lock = false;\n\trcu_read_lock();\n\tfor_each_process_thread(g, t) {\n\t\tif (!max_count--)\n\t\t\tgoto unlock;\n\t\tif (!--batch_count) {\n\t\t\tbatch_count = HUNG_TASK_BATCHING;\n\t\t\tif (!rcu_lock_break(g, t))\n\t\t\t\tgoto unlock;\n\t\t}\n\t\t/* use \"==\" to skip the TASK_KILLABLE tasks waiting on NFS */\n\t\tif (t->state == TASK_UNINTERRUPTIBLE)\n\t\t\tcheck_hung_task(t, timeout);\n\t}\n unlock:\n\trcu_read_unlock();\n\tif (hung_task_show_lock)\n\t\tdebug_show_all_locks();\n\tif (hung_task_call_panic) {\n\t\ttrigger_all_cpu_backtrace();\n\t\tpanic(\"hung_task: blocked tasks\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&reset_hung_task",
            "0"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hung_timeout_jiffies",
          "args": [
            "hung_last_checked",
            "interval"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "hung_timeout_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
          "lines": "210-216",
          "snippet": "static long hung_timeout_jiffies(unsigned long last_checked,\n\t\t\t\t unsigned long timeout)\n{\n\t/* timeout of 0 will disable the watchdog */\n\treturn timeout ? last_checked - jiffies + timeout * HZ :\n\t\tMAX_SCHEDULE_TIMEOUT;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/export.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic long hung_timeout_jiffies(unsigned long last_checked,\n\t\t\t\t unsigned long timeout)\n{\n\t/* timeout of 0 will disable the watchdog */\n\treturn timeout ? last_checked - jiffies + timeout * HZ :\n\t\tMAX_SCHEDULE_TIMEOUT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "interval",
            "timeout"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "0"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3865-3917",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly sysctl_hung_task_timeout_secs = CONFIG_DEFAULT_HUNG_TASK_TIMEOUT;\nunsigned long __read_mostly sysctl_hung_task_check_interval_secs;\nstatic atomic_t reset_hung_task = ATOMIC_INIT(0);\nstatic bool hung_detector_suspended;\n\nstatic int watchdog(void *dummy)\n{\n\tunsigned long hung_last_checked = jiffies;\n\n\tset_user_nice(current, 0);\n\n\tfor ( ; ; ) {\n\t\tunsigned long timeout = sysctl_hung_task_timeout_secs;\n\t\tunsigned long interval = sysctl_hung_task_check_interval_secs;\n\t\tlong t;\n\n\t\tif (interval == 0)\n\t\t\tinterval = timeout;\n\t\tinterval = min_t(unsigned long, interval, timeout);\n\t\tt = hung_timeout_jiffies(hung_last_checked, interval);\n\t\tif (t <= 0) {\n\t\t\tif (!atomic_xchg(&reset_hung_task, 0) &&\n\t\t\t    !hung_detector_suspended)\n\t\t\t\tcheck_hung_uninterruptible_tasks(timeout);\n\t\t\thung_last_checked = jiffies;\n\t\t\tcontinue;\n\t\t}\n\t\tschedule_timeout_interruptible(t);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hungtask_pm_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
    "lines": "248-266",
    "snippet": "static int hungtask_pm_notify(struct notifier_block *self,\n\t\t\t      unsigned long action, void *hcpu)\n{\n\tswitch (action) {\n\tcase PM_SUSPEND_PREPARE:\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_RESTORE_PREPARE:\n\t\thung_detector_suspended = true;\n\t\tbreak;\n\tcase PM_POST_SUSPEND:\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_RESTORE:\n\t\thung_detector_suspended = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool hung_detector_suspended;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic bool hung_detector_suspended;\n\nstatic int hungtask_pm_notify(struct notifier_block *self,\n\t\t\t      unsigned long action, void *hcpu)\n{\n\tswitch (action) {\n\tcase PM_SUSPEND_PREPARE:\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_RESTORE_PREPARE:\n\t\thung_detector_suspended = true;\n\t\tbreak;\n\tcase PM_POST_SUSPEND:\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_RESTORE:\n\t\thung_detector_suspended = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "reset_hung_task_detector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
    "lines": "240-243",
    "snippet": "void reset_hung_task_detector(void)\n{\n\tatomic_set(&reset_hung_task, 1);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t reset_hung_task = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&reset_hung_task",
            "1"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic atomic_t reset_hung_task = ATOMIC_INIT(0);\n\nvoid reset_hung_task_detector(void)\n{\n\tatomic_set(&reset_hung_task, 1);\n}"
  },
  {
    "function_name": "proc_dohung_task_timeout_secs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
    "lines": "221-236",
    "snippet": "int proc_dohung_task_timeout_secs(struct ctl_table *table, int write,\n\t\t\t\t  void __user *buffer,\n\t\t\t\t  size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write)\n\t\tgoto out;\n\n\twake_up_process(watchdog_task);\n\n out:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *watchdog_task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "watchdog_task"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_doulongvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "proc_doulongvec_minmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3230-3234",
          "snippet": "int proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *watchdog_task;\n\nint proc_dohung_task_timeout_secs(struct ctl_table *table, int write,\n\t\t\t\t  void __user *buffer,\n\t\t\t\t  size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write)\n\t\tgoto out;\n\n\twake_up_process(watchdog_task);\n\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "hung_timeout_jiffies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
    "lines": "210-216",
    "snippet": "static long hung_timeout_jiffies(unsigned long last_checked,\n\t\t\t\t unsigned long timeout)\n{\n\t/* timeout of 0 will disable the watchdog */\n\treturn timeout ? last_checked - jiffies + timeout * HZ :\n\t\tMAX_SCHEDULE_TIMEOUT;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic long hung_timeout_jiffies(unsigned long last_checked,\n\t\t\t\t unsigned long timeout)\n{\n\t/* timeout of 0 will disable the watchdog */\n\treturn timeout ? last_checked - jiffies + timeout * HZ :\n\t\tMAX_SCHEDULE_TIMEOUT;\n}"
  },
  {
    "function_name": "check_hung_uninterruptible_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
    "lines": "173-208",
    "snippet": "static void check_hung_uninterruptible_tasks(unsigned long timeout)\n{\n\tint max_count = sysctl_hung_task_check_count;\n\tint batch_count = HUNG_TASK_BATCHING;\n\tstruct task_struct *g, *t;\n\n\t/*\n\t * If the system crashed already then all bets are off,\n\t * do not report extra hung tasks:\n\t */\n\tif (test_taint(TAINT_DIE) || did_panic)\n\t\treturn;\n\n\thung_task_show_lock = false;\n\trcu_read_lock();\n\tfor_each_process_thread(g, t) {\n\t\tif (!max_count--)\n\t\t\tgoto unlock;\n\t\tif (!--batch_count) {\n\t\t\tbatch_count = HUNG_TASK_BATCHING;\n\t\t\tif (!rcu_lock_break(g, t))\n\t\t\t\tgoto unlock;\n\t\t}\n\t\t/* use \"==\" to skip the TASK_KILLABLE tasks waiting on NFS */\n\t\tif (t->state == TASK_UNINTERRUPTIBLE)\n\t\t\tcheck_hung_task(t, timeout);\n\t}\n unlock:\n\trcu_read_unlock();\n\tif (hung_task_show_lock)\n\t\tdebug_show_all_locks();\n\tif (hung_task_call_panic) {\n\t\ttrigger_all_cpu_backtrace();\n\t\tpanic(\"hung_task: blocked tasks\");\n\t}\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define HUNG_TASK_BATCHING 1024"
    ],
    "globals_used": [
      "static int __read_mostly did_panic;",
      "static bool hung_task_show_lock;",
      "static bool hung_task_call_panic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"hung_task: blocked tasks\""
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "hung_task_panic_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
          "lines": "64-71",
          "snippet": "static int __init hung_task_panic_setup(char *str)\n{\n\tint rc = kstrtouint(str, 0, &sysctl_hung_task_panic);\n\n\tif (rc)\n\t\treturn rc;\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/export.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init hung_task_panic_setup(char *str)\n{\n\tint rc = kstrtouint(str, 0, &sysctl_hung_task_panic);\n\n\tif (rc)\n\t\treturn rc;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trigger_all_cpu_backtrace",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_show_all_locks",
          "args": [],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "debug_show_all_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4373-4395",
          "snippet": "void debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_hung_task",
          "args": [
            "t",
            "timeout"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "check_hung_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
          "lines": "86-143",
          "snippet": "static void check_hung_task(struct task_struct *t, unsigned long timeout)\n{\n\tunsigned long switch_count = t->nvcsw + t->nivcsw;\n\n\t/*\n\t * Ensure the task is not frozen.\n\t * Also, skip vfork and any other user process that freezer should skip.\n\t */\n\tif (unlikely(t->flags & (PF_FROZEN | PF_FREEZER_SKIP)))\n\t    return;\n\n\t/*\n\t * When a freshly created task is scheduled once, changes its state to\n\t * TASK_UNINTERRUPTIBLE without having ever been switched out once, it\n\t * musn't be checked.\n\t */\n\tif (unlikely(!switch_count))\n\t\treturn;\n\n\tif (switch_count != t->last_switch_count) {\n\t\tt->last_switch_count = switch_count;\n\t\tt->last_switch_time = jiffies;\n\t\treturn;\n\t}\n\tif (time_is_after_jiffies(t->last_switch_time + timeout * HZ))\n\t\treturn;\n\n\ttrace_sched_process_hang(t);\n\n\tif (!sysctl_hung_task_warnings && !sysctl_hung_task_panic)\n\t\treturn;\n\n\t/*\n\t * Ok, the task did not get scheduled for more than 2 minutes,\n\t * complain:\n\t */\n\tif (sysctl_hung_task_warnings) {\n\t\tif (sysctl_hung_task_warnings > 0)\n\t\t\tsysctl_hung_task_warnings--;\n\t\tpr_err(\"INFO: task %s:%d blocked for more than %ld seconds.\\n\",\n\t\t\tt->comm, t->pid, timeout);\n\t\tpr_err(\"      %s %s %.*s\\n\",\n\t\t\tprint_tainted(), init_utsname()->release,\n\t\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\t\tinit_utsname()->version);\n\t\tpr_err(\"\\\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\\\"\"\n\t\t\t\" disables this message.\\n\");\n\t\tsched_show_task(t);\n\t\thung_task_show_lock = true;\n\t}\n\n\ttouch_nmi_watchdog();\n\n\tif (sysctl_hung_task_panic) {\n\t\thung_task_show_lock = true;\n\t\thung_task_call_panic = true;\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/export.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool hung_task_show_lock;",
            "static bool hung_task_call_panic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic bool hung_task_show_lock;\nstatic bool hung_task_call_panic;\n\nstatic void check_hung_task(struct task_struct *t, unsigned long timeout)\n{\n\tunsigned long switch_count = t->nvcsw + t->nivcsw;\n\n\t/*\n\t * Ensure the task is not frozen.\n\t * Also, skip vfork and any other user process that freezer should skip.\n\t */\n\tif (unlikely(t->flags & (PF_FROZEN | PF_FREEZER_SKIP)))\n\t    return;\n\n\t/*\n\t * When a freshly created task is scheduled once, changes its state to\n\t * TASK_UNINTERRUPTIBLE without having ever been switched out once, it\n\t * musn't be checked.\n\t */\n\tif (unlikely(!switch_count))\n\t\treturn;\n\n\tif (switch_count != t->last_switch_count) {\n\t\tt->last_switch_count = switch_count;\n\t\tt->last_switch_time = jiffies;\n\t\treturn;\n\t}\n\tif (time_is_after_jiffies(t->last_switch_time + timeout * HZ))\n\t\treturn;\n\n\ttrace_sched_process_hang(t);\n\n\tif (!sysctl_hung_task_warnings && !sysctl_hung_task_panic)\n\t\treturn;\n\n\t/*\n\t * Ok, the task did not get scheduled for more than 2 minutes,\n\t * complain:\n\t */\n\tif (sysctl_hung_task_warnings) {\n\t\tif (sysctl_hung_task_warnings > 0)\n\t\t\tsysctl_hung_task_warnings--;\n\t\tpr_err(\"INFO: task %s:%d blocked for more than %ld seconds.\\n\",\n\t\t\tt->comm, t->pid, timeout);\n\t\tpr_err(\"      %s %s %.*s\\n\",\n\t\t\tprint_tainted(), init_utsname()->release,\n\t\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\t\tinit_utsname()->version);\n\t\tpr_err(\"\\\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\\\"\"\n\t\t\t\" disables this message.\\n\");\n\t\tsched_show_task(t);\n\t\thung_task_show_lock = true;\n\t}\n\n\ttouch_nmi_watchdog();\n\n\tif (sysctl_hung_task_panic) {\n\t\thung_task_show_lock = true;\n\t\thung_task_call_panic = true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_lock_break",
          "args": [
            "g",
            "t"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lock_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
          "lines": "152-166",
          "snippet": "static bool rcu_lock_break(struct task_struct *g, struct task_struct *t)\n{\n\tbool can_cont;\n\n\tget_task_struct(g);\n\tget_task_struct(t);\n\trcu_read_unlock();\n\tcond_resched();\n\trcu_read_lock();\n\tcan_cont = pid_alive(g) && pid_alive(t);\n\tput_task_struct(t);\n\tput_task_struct(g);\n\n\treturn can_cont;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/export.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic bool rcu_lock_break(struct task_struct *g, struct task_struct *t)\n{\n\tbool can_cont;\n\n\tget_task_struct(g);\n\tget_task_struct(t);\n\trcu_read_unlock();\n\tcond_resched();\n\trcu_read_lock();\n\tcan_cont = pid_alive(g) && pid_alive(t);\n\tput_task_struct(t);\n\tput_task_struct(g);\n\n\treturn can_cont;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "t"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_taint",
          "args": [
            "TAINT_DIE"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "test_taint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "367-370",
          "snippet": "int test_taint(unsigned flag)\n{\n\treturn test_bit(flag, &tainted_mask);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\n\nint test_taint(unsigned flag)\n{\n\treturn test_bit(flag, &tainted_mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define HUNG_TASK_BATCHING 1024\n\nstatic int __read_mostly did_panic;\nstatic bool hung_task_show_lock;\nstatic bool hung_task_call_panic;\n\nstatic void check_hung_uninterruptible_tasks(unsigned long timeout)\n{\n\tint max_count = sysctl_hung_task_check_count;\n\tint batch_count = HUNG_TASK_BATCHING;\n\tstruct task_struct *g, *t;\n\n\t/*\n\t * If the system crashed already then all bets are off,\n\t * do not report extra hung tasks:\n\t */\n\tif (test_taint(TAINT_DIE) || did_panic)\n\t\treturn;\n\n\thung_task_show_lock = false;\n\trcu_read_lock();\n\tfor_each_process_thread(g, t) {\n\t\tif (!max_count--)\n\t\t\tgoto unlock;\n\t\tif (!--batch_count) {\n\t\t\tbatch_count = HUNG_TASK_BATCHING;\n\t\t\tif (!rcu_lock_break(g, t))\n\t\t\t\tgoto unlock;\n\t\t}\n\t\t/* use \"==\" to skip the TASK_KILLABLE tasks waiting on NFS */\n\t\tif (t->state == TASK_UNINTERRUPTIBLE)\n\t\t\tcheck_hung_task(t, timeout);\n\t}\n unlock:\n\trcu_read_unlock();\n\tif (hung_task_show_lock)\n\t\tdebug_show_all_locks();\n\tif (hung_task_call_panic) {\n\t\ttrigger_all_cpu_backtrace();\n\t\tpanic(\"hung_task: blocked tasks\");\n\t}\n}"
  },
  {
    "function_name": "rcu_lock_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
    "lines": "152-166",
    "snippet": "static bool rcu_lock_break(struct task_struct *g, struct task_struct *t)\n{\n\tbool can_cont;\n\n\tget_task_struct(g);\n\tget_task_struct(t);\n\trcu_read_unlock();\n\tcond_resched();\n\trcu_read_lock();\n\tcan_cont = pid_alive(g) && pid_alive(t);\n\tput_task_struct(t);\n\tput_task_struct(g);\n\n\treturn can_cont;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "g"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_alive",
          "args": [
            "t"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_alive",
          "args": [
            "g"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "t"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "g"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic bool rcu_lock_break(struct task_struct *g, struct task_struct *t)\n{\n\tbool can_cont;\n\n\tget_task_struct(g);\n\tget_task_struct(t);\n\trcu_read_unlock();\n\tcond_resched();\n\trcu_read_lock();\n\tcan_cont = pid_alive(g) && pid_alive(t);\n\tput_task_struct(t);\n\tput_task_struct(g);\n\n\treturn can_cont;\n}"
  },
  {
    "function_name": "check_hung_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
    "lines": "86-143",
    "snippet": "static void check_hung_task(struct task_struct *t, unsigned long timeout)\n{\n\tunsigned long switch_count = t->nvcsw + t->nivcsw;\n\n\t/*\n\t * Ensure the task is not frozen.\n\t * Also, skip vfork and any other user process that freezer should skip.\n\t */\n\tif (unlikely(t->flags & (PF_FROZEN | PF_FREEZER_SKIP)))\n\t    return;\n\n\t/*\n\t * When a freshly created task is scheduled once, changes its state to\n\t * TASK_UNINTERRUPTIBLE without having ever been switched out once, it\n\t * musn't be checked.\n\t */\n\tif (unlikely(!switch_count))\n\t\treturn;\n\n\tif (switch_count != t->last_switch_count) {\n\t\tt->last_switch_count = switch_count;\n\t\tt->last_switch_time = jiffies;\n\t\treturn;\n\t}\n\tif (time_is_after_jiffies(t->last_switch_time + timeout * HZ))\n\t\treturn;\n\n\ttrace_sched_process_hang(t);\n\n\tif (!sysctl_hung_task_warnings && !sysctl_hung_task_panic)\n\t\treturn;\n\n\t/*\n\t * Ok, the task did not get scheduled for more than 2 minutes,\n\t * complain:\n\t */\n\tif (sysctl_hung_task_warnings) {\n\t\tif (sysctl_hung_task_warnings > 0)\n\t\t\tsysctl_hung_task_warnings--;\n\t\tpr_err(\"INFO: task %s:%d blocked for more than %ld seconds.\\n\",\n\t\t\tt->comm, t->pid, timeout);\n\t\tpr_err(\"      %s %s %.*s\\n\",\n\t\t\tprint_tainted(), init_utsname()->release,\n\t\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\t\tinit_utsname()->version);\n\t\tpr_err(\"\\\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\\\"\"\n\t\t\t\" disables this message.\\n\");\n\t\tsched_show_task(t);\n\t\thung_task_show_lock = true;\n\t}\n\n\ttouch_nmi_watchdog();\n\n\tif (sysctl_hung_task_panic) {\n\t\thung_task_show_lock = true;\n\t\thung_task_call_panic = true;\n\t}\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool hung_task_show_lock;",
      "static bool hung_task_call_panic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_show_task",
          "args": [
            "t"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "sched_show_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5268-5295",
          "snippet": "void sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\\\"\"\n\t\t\t\" disables this message.\\n\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"      %s %s %.*s\\n\"",
            "print_tainted()",
            "init_utsname()->release",
            "(int)strcspn(init_utsname()->version, \" \")",
            "init_utsname()->version"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "init_utsname()->version",
            "\" \""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_tainted",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "print_tainted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "344-365",
          "snippet": "const char *print_tainted(void)\n{\n\tstatic char buf[TAINT_FLAGS_COUNT + sizeof(\"Tainted: \")];\n\n\tBUILD_BUG_ON(ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT);\n\n\tif (tainted_mask) {\n\t\tchar *s;\n\t\tint i;\n\n\t\ts = buf + sprintf(buf, \"Tainted: \");\n\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++) {\n\t\t\tconst struct taint_flag *t = &taint_flags[i];\n\t\t\t*s++ = test_bit(i, &tainted_mask) ?\n\t\t\t\t\tt->c_true : t->c_false;\n\t\t}\n\t\t*s = 0;\n\t} else\n\t\tsnprintf(buf, sizeof(buf), \"Not tainted\");\n\n\treturn buf;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;",
            "const struct taint_flag taint_flags[TAINT_FLAGS_COUNT] = {\n\t[ TAINT_PROPRIETARY_MODULE ]\t= { 'P', 'G', true },\n\t[ TAINT_FORCED_MODULE ]\t\t= { 'F', ' ', true },\n\t[ TAINT_CPU_OUT_OF_SPEC ]\t= { 'S', ' ', false },\n\t[ TAINT_FORCED_RMMOD ]\t\t= { 'R', ' ', false },\n\t[ TAINT_MACHINE_CHECK ]\t\t= { 'M', ' ', false },\n\t[ TAINT_BAD_PAGE ]\t\t= { 'B', ' ', false },\n\t[ TAINT_USER ]\t\t\t= { 'U', ' ', false },\n\t[ TAINT_DIE ]\t\t\t= { 'D', ' ', false },\n\t[ TAINT_OVERRIDDEN_ACPI_TABLE ]\t= { 'A', ' ', false },\n\t[ TAINT_WARN ]\t\t\t= { 'W', ' ', false },\n\t[ TAINT_CRAP ]\t\t\t= { 'C', ' ', true },\n\t[ TAINT_FIRMWARE_WORKAROUND ]\t= { 'I', ' ', false },\n\t[ TAINT_OOT_MODULE ]\t\t= { 'O', ' ', true },\n\t[ TAINT_UNSIGNED_MODULE ]\t= { 'E', ' ', true },\n\t[ TAINT_SOFTLOCKUP ]\t\t= { 'L', ' ', false },\n\t[ TAINT_LIVEPATCH ]\t\t= { 'K', ' ', true },\n\t[ TAINT_AUX ]\t\t\t= { 'X', ' ', true },\n\t[ TAINT_RANDSTRUCT ]\t\t= { 'T', ' ', true },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\nconst struct taint_flag taint_flags[TAINT_FLAGS_COUNT] = {\n\t[ TAINT_PROPRIETARY_MODULE ]\t= { 'P', 'G', true },\n\t[ TAINT_FORCED_MODULE ]\t\t= { 'F', ' ', true },\n\t[ TAINT_CPU_OUT_OF_SPEC ]\t= { 'S', ' ', false },\n\t[ TAINT_FORCED_RMMOD ]\t\t= { 'R', ' ', false },\n\t[ TAINT_MACHINE_CHECK ]\t\t= { 'M', ' ', false },\n\t[ TAINT_BAD_PAGE ]\t\t= { 'B', ' ', false },\n\t[ TAINT_USER ]\t\t\t= { 'U', ' ', false },\n\t[ TAINT_DIE ]\t\t\t= { 'D', ' ', false },\n\t[ TAINT_OVERRIDDEN_ACPI_TABLE ]\t= { 'A', ' ', false },\n\t[ TAINT_WARN ]\t\t\t= { 'W', ' ', false },\n\t[ TAINT_CRAP ]\t\t\t= { 'C', ' ', true },\n\t[ TAINT_FIRMWARE_WORKAROUND ]\t= { 'I', ' ', false },\n\t[ TAINT_OOT_MODULE ]\t\t= { 'O', ' ', true },\n\t[ TAINT_UNSIGNED_MODULE ]\t= { 'E', ' ', true },\n\t[ TAINT_SOFTLOCKUP ]\t\t= { 'L', ' ', false },\n\t[ TAINT_LIVEPATCH ]\t\t= { 'K', ' ', true },\n\t[ TAINT_AUX ]\t\t\t= { 'X', ' ', true },\n\t[ TAINT_RANDSTRUCT ]\t\t= { 'T', ' ', true },\n};\n\nconst char *print_tainted(void)\n{\n\tstatic char buf[TAINT_FLAGS_COUNT + sizeof(\"Tainted: \")];\n\n\tBUILD_BUG_ON(ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT);\n\n\tif (tainted_mask) {\n\t\tchar *s;\n\t\tint i;\n\n\t\ts = buf + sprintf(buf, \"Tainted: \");\n\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++) {\n\t\t\tconst struct taint_flag *t = &taint_flags[i];\n\t\t\t*s++ = test_bit(i, &tainted_mask) ?\n\t\t\t\t\tt->c_true : t->c_false;\n\t\t}\n\t\t*s = 0;\n\t} else\n\t\tsnprintf(buf, sizeof(buf), \"Not tainted\");\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: task %s:%d blocked for more than %ld seconds.\\n\"",
            "t->comm",
            "t->pid",
            "timeout"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sched_process_hang",
          "args": [
            "t"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_is_after_jiffies",
          "args": [
            "t->last_switch_time + timeout * HZ"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!switch_count"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "t->flags & (PF_FROZEN | PF_FREEZER_SKIP)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic bool hung_task_show_lock;\nstatic bool hung_task_call_panic;\n\nstatic void check_hung_task(struct task_struct *t, unsigned long timeout)\n{\n\tunsigned long switch_count = t->nvcsw + t->nivcsw;\n\n\t/*\n\t * Ensure the task is not frozen.\n\t * Also, skip vfork and any other user process that freezer should skip.\n\t */\n\tif (unlikely(t->flags & (PF_FROZEN | PF_FREEZER_SKIP)))\n\t    return;\n\n\t/*\n\t * When a freshly created task is scheduled once, changes its state to\n\t * TASK_UNINTERRUPTIBLE without having ever been switched out once, it\n\t * musn't be checked.\n\t */\n\tif (unlikely(!switch_count))\n\t\treturn;\n\n\tif (switch_count != t->last_switch_count) {\n\t\tt->last_switch_count = switch_count;\n\t\tt->last_switch_time = jiffies;\n\t\treturn;\n\t}\n\tif (time_is_after_jiffies(t->last_switch_time + timeout * HZ))\n\t\treturn;\n\n\ttrace_sched_process_hang(t);\n\n\tif (!sysctl_hung_task_warnings && !sysctl_hung_task_panic)\n\t\treturn;\n\n\t/*\n\t * Ok, the task did not get scheduled for more than 2 minutes,\n\t * complain:\n\t */\n\tif (sysctl_hung_task_warnings) {\n\t\tif (sysctl_hung_task_warnings > 0)\n\t\t\tsysctl_hung_task_warnings--;\n\t\tpr_err(\"INFO: task %s:%d blocked for more than %ld seconds.\\n\",\n\t\t\tt->comm, t->pid, timeout);\n\t\tpr_err(\"      %s %s %.*s\\n\",\n\t\t\tprint_tainted(), init_utsname()->release,\n\t\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\t\tinit_utsname()->version);\n\t\tpr_err(\"\\\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\\\"\"\n\t\t\t\" disables this message.\\n\");\n\t\tsched_show_task(t);\n\t\thung_task_show_lock = true;\n\t}\n\n\ttouch_nmi_watchdog();\n\n\tif (sysctl_hung_task_panic) {\n\t\thung_task_show_lock = true;\n\t\thung_task_call_panic = true;\n\t}\n}"
  },
  {
    "function_name": "hung_task_panic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
    "lines": "74-80",
    "snippet": "static int\nhung_task_panic(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tdid_panic = 1;\n\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __read_mostly did_panic;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __read_mostly did_panic;\n\nstatic int\nhung_task_panic(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tdid_panic = 1;\n\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "hung_task_panic_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/hung_task.c",
    "lines": "64-71",
    "snippet": "static int __init hung_task_panic_setup(char *str)\n{\n\tint rc = kstrtouint(str, 0, &sysctl_hung_task_panic);\n\n\tif (rc)\n\t\treturn rc;\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/utsname.h>",
      "#include <linux/suspend.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/export.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "str",
            "0",
            "&sysctl_hung_task_panic"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/suspend.h>\n#include <linux/sysctl.h>\n#include <linux/export.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init hung_task_panic_setup(char *str)\n{\n\tint rc = kstrtouint(str, 0, &sysctl_hung_task_panic);\n\n\tif (rc)\n\t\treturn rc;\n\treturn 1;\n}"
  }
]