[
  {
    "function_name": "kmsg_dump_rewind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "3275-3282",
    "snippet": "void kmsg_dump_rewind(struct kmsg_dumper *dumper)\n{\n\tunsigned long flags;\n\n\tlogbuf_lock_irqsave(flags);\n\tkmsg_dump_rewind_nolock(dumper);\n\tlogbuf_unlock_irqrestore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logbuf_unlock_irqrestore",
          "args": [
            "flags"
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump_rewind_nolock",
          "args": [
            "dumper"
          ],
          "line": 3280
        },
        "resolved": true,
        "details": {
          "function_name": "kmsg_dump_rewind_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "3259-3265",
          "snippet": "void kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)\n{\n\tdumper->cur_seq = clear_seq;\n\tdumper->cur_idx = clear_idx;\n\tdumper->next_seq = log_next_seq;\n\tdumper->next_idx = log_next_idx;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)\n{\n\tdumper->cur_seq = clear_seq;\n\tdumper->cur_idx = clear_idx;\n\tdumper->next_seq = log_next_seq;\n\tdumper->next_idx = log_next_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irqsave",
          "args": [
            "flags"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid kmsg_dump_rewind(struct kmsg_dumper *dumper)\n{\n\tunsigned long flags;\n\n\tlogbuf_lock_irqsave(flags);\n\tkmsg_dump_rewind_nolock(dumper);\n\tlogbuf_unlock_irqrestore(flags);\n}"
  },
  {
    "function_name": "kmsg_dump_rewind_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "3259-3265",
    "snippet": "void kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)\n{\n\tdumper->cur_seq = clear_seq;\n\tdumper->cur_idx = clear_idx;\n\tdumper->next_seq = log_next_seq;\n\tdumper->next_idx = log_next_idx;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)\n{\n\tdumper->cur_seq = clear_seq;\n\tdumper->cur_idx = clear_idx;\n\tdumper->next_seq = log_next_seq;\n\tdumper->next_idx = log_next_idx;\n}"
  },
  {
    "function_name": "kmsg_dump_get_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "3176-3246",
    "snippet": "bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,\n\t\t\t  char *buf, size_t size, size_t *len)\n{\n\tunsigned long flags;\n\tu64 seq;\n\tu32 idx;\n\tu64 next_seq;\n\tu32 next_idx;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (!dumper->active)\n\t\tgoto out;\n\n\tlogbuf_lock_irqsave(flags);\n\tif (dumper->cur_seq < log_first_seq) {\n\t\t/* messages are gone, move to first available one */\n\t\tdumper->cur_seq = log_first_seq;\n\t\tdumper->cur_idx = log_first_idx;\n\t}\n\n\t/* last entry */\n\tif (dumper->cur_seq >= dumper->next_seq) {\n\t\tlogbuf_unlock_irqrestore(flags);\n\t\tgoto out;\n\t}\n\n\t/* calculate length of entire buffer */\n\tseq = dumper->cur_seq;\n\tidx = dumper->cur_idx;\n\twhile (seq < dumper->next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tl += msg_print_text(msg, true, NULL, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t}\n\n\t/* move first record forward until length fits into the buffer */\n\tseq = dumper->cur_seq;\n\tidx = dumper->cur_idx;\n\twhile (l > size && seq < dumper->next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tl -= msg_print_text(msg, true, NULL, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t}\n\n\t/* last message in next interation */\n\tnext_seq = seq;\n\tnext_idx = idx;\n\n\tl = 0;\n\twhile (seq < dumper->next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tl += msg_print_text(msg, syslog, buf + l, size - l);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t}\n\n\tdumper->next_seq = next_seq;\n\tdumper->next_idx = next_idx;\n\tret = true;\n\tlogbuf_unlock_irqrestore(flags);\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logbuf_unlock_irqrestore",
          "args": [
            "flags"
          ],
          "line": 3241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_next",
          "args": [
            "idx"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "log_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2020-2020",
          "snippet": "static u32 log_next(u32 idx) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic u32 log_next(u32 idx) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "msg_print_text",
          "args": [
            "msg",
            "syslog",
            "buf + l",
            "size - l"
          ],
          "line": 3233
        },
        "resolved": true,
        "details": {
          "function_name": "msg_print_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2031-2032",
          "snippet": "static size_t msg_print_text(const struct printk_log *msg,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic size_t msg_print_text(const struct printk_log *msg,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "log_from_idx",
          "args": [
            "idx"
          ],
          "line": 3231
        },
        "resolved": true,
        "details": {
          "function_name": "log_from_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2019-2019",
          "snippet": "static struct printk_log *log_from_idx(u32 idx) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct printk_log *log_from_idx(u32 idx) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_unlock_irqrestore",
          "args": [
            "flags"
          ],
          "line": 3199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irqsave",
          "args": [
            "flags"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nbool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,\n\t\t\t  char *buf, size_t size, size_t *len)\n{\n\tunsigned long flags;\n\tu64 seq;\n\tu32 idx;\n\tu64 next_seq;\n\tu32 next_idx;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (!dumper->active)\n\t\tgoto out;\n\n\tlogbuf_lock_irqsave(flags);\n\tif (dumper->cur_seq < log_first_seq) {\n\t\t/* messages are gone, move to first available one */\n\t\tdumper->cur_seq = log_first_seq;\n\t\tdumper->cur_idx = log_first_idx;\n\t}\n\n\t/* last entry */\n\tif (dumper->cur_seq >= dumper->next_seq) {\n\t\tlogbuf_unlock_irqrestore(flags);\n\t\tgoto out;\n\t}\n\n\t/* calculate length of entire buffer */\n\tseq = dumper->cur_seq;\n\tidx = dumper->cur_idx;\n\twhile (seq < dumper->next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tl += msg_print_text(msg, true, NULL, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t}\n\n\t/* move first record forward until length fits into the buffer */\n\tseq = dumper->cur_seq;\n\tidx = dumper->cur_idx;\n\twhile (l > size && seq < dumper->next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tl -= msg_print_text(msg, true, NULL, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t}\n\n\t/* last message in next interation */\n\tnext_seq = seq;\n\tnext_idx = idx;\n\n\tl = 0;\n\twhile (seq < dumper->next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tl += msg_print_text(msg, syslog, buf + l, size - l);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t}\n\n\tdumper->next_seq = next_seq;\n\tdumper->next_idx = next_idx;\n\tret = true;\n\tlogbuf_unlock_irqrestore(flags);\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}"
  },
  {
    "function_name": "kmsg_dump_get_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "3143-3154",
    "snippet": "bool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,\n\t\t\tchar *line, size_t size, size_t *len)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\tlogbuf_lock_irqsave(flags);\n\tret = kmsg_dump_get_line_nolock(dumper, syslog, line, size, len);\n\tlogbuf_unlock_irqrestore(flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logbuf_unlock_irqrestore",
          "args": [
            "flags"
          ],
          "line": 3151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump_get_line_nolock",
          "args": [
            "dumper",
            "syslog",
            "line",
            "size",
            "len"
          ],
          "line": 3150
        },
        "resolved": true,
        "details": {
          "function_name": "kmsg_dump_get_line_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "3094-3124",
          "snippet": "bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,\n\t\t\t       char *line, size_t size, size_t *len)\n{\n\tstruct printk_log *msg;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (!dumper->active)\n\t\tgoto out;\n\n\tif (dumper->cur_seq < log_first_seq) {\n\t\t/* messages are gone, move to first available one */\n\t\tdumper->cur_seq = log_first_seq;\n\t\tdumper->cur_idx = log_first_idx;\n\t}\n\n\t/* last entry */\n\tif (dumper->cur_seq >= log_next_seq)\n\t\tgoto out;\n\n\tmsg = log_from_idx(dumper->cur_idx);\n\tl = msg_print_text(msg, syslog, line, size);\n\n\tdumper->cur_idx = log_next(dumper->cur_idx);\n\tdumper->cur_seq++;\n\tret = true;\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nbool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,\n\t\t\t       char *line, size_t size, size_t *len)\n{\n\tstruct printk_log *msg;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (!dumper->active)\n\t\tgoto out;\n\n\tif (dumper->cur_seq < log_first_seq) {\n\t\t/* messages are gone, move to first available one */\n\t\tdumper->cur_seq = log_first_seq;\n\t\tdumper->cur_idx = log_first_idx;\n\t}\n\n\t/* last entry */\n\tif (dumper->cur_seq >= log_next_seq)\n\t\tgoto out;\n\n\tmsg = log_from_idx(dumper->cur_idx);\n\tl = msg_print_text(msg, syslog, line, size);\n\n\tdumper->cur_idx = log_next(dumper->cur_idx);\n\tdumper->cur_seq++;\n\tret = true;\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irqsave",
          "args": [
            "flags"
          ],
          "line": 3149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nbool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,\n\t\t\tchar *line, size_t size, size_t *len)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\tlogbuf_lock_irqsave(flags);\n\tret = kmsg_dump_get_line_nolock(dumper, syslog, line, size, len);\n\tlogbuf_unlock_irqrestore(flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kmsg_dump_get_line_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "3094-3124",
    "snippet": "bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,\n\t\t\t       char *line, size_t size, size_t *len)\n{\n\tstruct printk_log *msg;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (!dumper->active)\n\t\tgoto out;\n\n\tif (dumper->cur_seq < log_first_seq) {\n\t\t/* messages are gone, move to first available one */\n\t\tdumper->cur_seq = log_first_seq;\n\t\tdumper->cur_idx = log_first_idx;\n\t}\n\n\t/* last entry */\n\tif (dumper->cur_seq >= log_next_seq)\n\t\tgoto out;\n\n\tmsg = log_from_idx(dumper->cur_idx);\n\tl = msg_print_text(msg, syslog, line, size);\n\n\tdumper->cur_idx = log_next(dumper->cur_idx);\n\tdumper->cur_seq++;\n\tret = true;\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_next",
          "args": [
            "dumper->cur_idx"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "log_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2020-2020",
          "snippet": "static u32 log_next(u32 idx) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic u32 log_next(u32 idx) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "msg_print_text",
          "args": [
            "msg",
            "syslog",
            "line",
            "size"
          ],
          "line": 3115
        },
        "resolved": true,
        "details": {
          "function_name": "msg_print_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2031-2032",
          "snippet": "static size_t msg_print_text(const struct printk_log *msg,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic size_t msg_print_text(const struct printk_log *msg,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "log_from_idx",
          "args": [
            "dumper->cur_idx"
          ],
          "line": 3114
        },
        "resolved": true,
        "details": {
          "function_name": "log_from_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2019-2019",
          "snippet": "static struct printk_log *log_from_idx(u32 idx) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct printk_log *log_from_idx(u32 idx) { return NULL; }"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nbool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,\n\t\t\t       char *line, size_t size, size_t *len)\n{\n\tstruct printk_log *msg;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (!dumper->active)\n\t\tgoto out;\n\n\tif (dumper->cur_seq < log_first_seq) {\n\t\t/* messages are gone, move to first available one */\n\t\tdumper->cur_seq = log_first_seq;\n\t\tdumper->cur_idx = log_first_idx;\n\t}\n\n\t/* last entry */\n\tif (dumper->cur_seq >= log_next_seq)\n\t\tgoto out;\n\n\tmsg = log_from_idx(dumper->cur_idx);\n\tl = msg_print_text(msg, syslog, line, size);\n\n\tdumper->cur_idx = log_next(dumper->cur_idx);\n\tdumper->cur_seq++;\n\tret = true;\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}"
  },
  {
    "function_name": "kmsg_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "3043-3073",
    "snippet": "void kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tstruct kmsg_dumper *dumper;\n\tunsigned long flags;\n\n\tif ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list) {\n\t\tif (dumper->max_reason && reason > dumper->max_reason)\n\t\t\tcontinue;\n\n\t\t/* initialize iterator with data about the stored records */\n\t\tdumper->active = true;\n\n\t\tlogbuf_lock_irqsave(flags);\n\t\tdumper->cur_seq = clear_seq;\n\t\tdumper->cur_idx = clear_idx;\n\t\tdumper->next_seq = log_next_seq;\n\t\tdumper->next_idx = log_next_idx;\n\t\tlogbuf_unlock_irqrestore(flags);\n\n\t\t/* invoke dumper which will iterate over records */\n\t\tdumper->dump(dumper, reason);\n\n\t\t/* reset iterator */\n\t\tdumper->active = false;\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3072
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dumper->dump",
          "args": [
            "dumper",
            "reason"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_unlock_irqrestore",
          "args": [
            "flags"
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irqsave",
          "args": [
            "flags"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "dumper",
            "&dump_list",
            "list"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tstruct kmsg_dumper *dumper;\n\tunsigned long flags;\n\n\tif ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list) {\n\t\tif (dumper->max_reason && reason > dumper->max_reason)\n\t\t\tcontinue;\n\n\t\t/* initialize iterator with data about the stored records */\n\t\tdumper->active = true;\n\n\t\tlogbuf_lock_irqsave(flags);\n\t\tdumper->cur_seq = clear_seq;\n\t\tdumper->cur_idx = clear_idx;\n\t\tdumper->next_seq = log_next_seq;\n\t\tdumper->next_idx = log_next_idx;\n\t\tlogbuf_unlock_irqrestore(flags);\n\n\t\t/* invoke dumper which will iterate over records */\n\t\tdumper->dump(dumper, reason);\n\n\t\t/* reset iterator */\n\t\tdumper->active = false;\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "kmsg_dump_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "3014-3029",
    "snippet": "int kmsg_dump_unregister(struct kmsg_dumper *dumper)\n{\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tspin_lock_irqsave(&dump_list_lock, flags);\n\tif (dumper->registered) {\n\t\tdumper->registered = 0;\n\t\tlist_del_rcu(&dumper->list);\n\t\terr = 0;\n\t}\n\tspin_unlock_irqrestore(&dump_list_lock, flags);\n\tsynchronize_rcu();\n\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 3026
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "603-611",
          "snippet": "void synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&dump_list_lock",
            "flags"
          ],
          "line": 3025
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&dumper->list"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&dump_list_lock",
            "flags"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint kmsg_dump_unregister(struct kmsg_dumper *dumper)\n{\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tspin_lock_irqsave(&dump_list_lock, flags);\n\tif (dumper->registered) {\n\t\tdumper->registered = 0;\n\t\tlist_del_rcu(&dumper->list);\n\t\terr = 0;\n\t}\n\tspin_unlock_irqrestore(&dump_list_lock, flags);\n\tsynchronize_rcu();\n\n\treturn err;\n}"
  },
  {
    "function_name": "kmsg_dump_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2985-3004",
    "snippet": "int kmsg_dump_register(struct kmsg_dumper *dumper)\n{\n\tunsigned long flags;\n\tint err = -EBUSY;\n\n\t/* The dump callback needs to be set */\n\tif (!dumper->dump)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dump_list_lock, flags);\n\t/* Don't allow registering multiple times */\n\tif (!dumper->registered) {\n\t\tdumper->registered = 1;\n\t\tlist_add_tail_rcu(&dumper->list, &dump_list);\n\t\terr = 0;\n\t}\n\tspin_unlock_irqrestore(&dump_list_lock, flags);\n\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&dump_list_lock",
            "flags"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&dumper->list",
            "&dump_list"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&dump_list_lock",
            "flags"
          ],
          "line": 2994
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint kmsg_dump_register(struct kmsg_dumper *dumper)\n{\n\tunsigned long flags;\n\tint err = -EBUSY;\n\n\t/* The dump callback needs to be set */\n\tif (!dumper->dump)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dump_list_lock, flags);\n\t/* Don't allow registering multiple times */\n\tif (!dumper->registered) {\n\t\tdumper->registered = 1;\n\t\tlist_add_tail_rcu(&dumper->list, &dump_list);\n\t\terr = 0;\n\t}\n\tspin_unlock_irqrestore(&dump_list_lock, flags);\n\n\treturn err;\n}"
  },
  {
    "function_name": "printk_timed_ratelimit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2961-2971",
    "snippet": "bool printk_timed_ratelimit(unsigned long *caller_jiffies,\n\t\t\tunsigned int interval_msecs)\n{\n\tunsigned long elapsed = jiffies - *caller_jiffies;\n\n\tif (*caller_jiffies && elapsed <= msecs_to_jiffies(interval_msecs))\n\t\treturn false;\n\n\t*caller_jiffies = jiffies;\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "interval_msecs"
          ],
          "line": 2966
        },
        "resolved": true,
        "details": {
          "function_name": "__msecs_to_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "565-573",
          "snippet": "unsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nbool printk_timed_ratelimit(unsigned long *caller_jiffies,\n\t\t\tunsigned int interval_msecs)\n{\n\tunsigned long elapsed = jiffies - *caller_jiffies;\n\n\tif (*caller_jiffies && elapsed <= msecs_to_jiffies(interval_msecs))\n\t\treturn false;\n\n\t*caller_jiffies = jiffies;\n\treturn true;\n}"
  },
  {
    "function_name": "__printk_ratelimit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2946-2949",
    "snippet": "int __printk_ratelimit(const char *func)\n{\n\treturn ___ratelimit(&printk_ratelimit_state, func);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "___ratelimit",
          "args": [
            "&printk_ratelimit_state",
            "func"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint __printk_ratelimit(const char *func)\n{\n\treturn ___ratelimit(&printk_ratelimit_state, func);\n}"
  },
  {
    "function_name": "printk_deferred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2926-2936",
    "snippet": "int printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 2933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vprintk_deferred",
          "args": [
            "fmt",
            "args"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2916-2924",
          "snippet": "int vprintk_deferred(const char *fmt, va_list args)\n{\n\tint r;\n\n\tr = vprintk_emit(0, LOGLEVEL_SCHED, NULL, 0, fmt, args);\n\tdefer_console_output();\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint vprintk_deferred(const char *fmt, va_list args)\n{\n\tint r;\n\n\tr = vprintk_emit(0, LOGLEVEL_SCHED, NULL, 0, fmt, args);\n\tdefer_console_output();\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
  },
  {
    "function_name": "vprintk_deferred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2916-2924",
    "snippet": "int vprintk_deferred(const char *fmt, va_list args)\n{\n\tint r;\n\n\tr = vprintk_emit(0, LOGLEVEL_SCHED, NULL, 0, fmt, args);\n\tdefer_console_output();\n\n\treturn r;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "defer_console_output",
          "args": [],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "defer_console_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2908-2914",
          "snippet": "void defer_console_output(void)\n{\n\tpreempt_disable();\n\t__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);\n\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PRINTK_PENDING_OUTPUT\t0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PRINTK_PENDING_OUTPUT\t0x02\n\nvoid defer_console_output(void)\n{\n\tpreempt_disable();\n\t__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);\n\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "vprintk_emit",
          "args": [
            "0",
            "LOGLEVEL_SCHED",
            "NULL",
            "0",
            "fmt",
            "args"
          ],
          "line": 2920
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_emit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1884-1929",
          "snippet": "asmlinkage int vprintk_emit(int facility, int level,\n\t\t\t    const char *dict, size_t dictlen,\n\t\t\t    const char *fmt, va_list args)\n{\n\tint printed_len;\n\tbool in_sched = false, pending_output;\n\tunsigned long flags;\n\tu64 curr_log_seq;\n\n\tif (level == LOGLEVEL_SCHED) {\n\t\tlevel = LOGLEVEL_DEFAULT;\n\t\tin_sched = true;\n\t}\n\n\tboot_delay_msec(level);\n\tprintk_delay();\n\n\t/* This stops the holder of console_sem just where we want him */\n\tlogbuf_lock_irqsave(flags);\n\tcurr_log_seq = log_next_seq;\n\tprinted_len = vprintk_store(facility, level, dict, dictlen, fmt, args);\n\tpending_output = (curr_log_seq != log_next_seq);\n\tlogbuf_unlock_irqrestore(flags);\n\n\t/* If called from the scheduler, we can not call up(). */\n\tif (!in_sched && pending_output) {\n\t\t/*\n\t\t * Disable preemption to avoid being preempted while holding\n\t\t * console_sem which would prevent anyone from printing to\n\t\t * console\n\t\t */\n\t\tpreempt_disable();\n\t\t/*\n\t\t * Try to acquire and then immediately release the console\n\t\t * semaphore.  The release will print out buffers and wake up\n\t\t * /dev/kmsg and syslog() users.\n\t\t */\n\t\tif (console_trylock_spinning())\n\t\t\tconsole_unlock();\n\t\tpreempt_enable();\n\t}\n\n\tif (pending_output)\n\t\twake_up_klogd();\n\treturn printed_len;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SEMAPHORE(console_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SEMAPHORE(console_sem);\n\nasmlinkage int vprintk_emit(int facility, int level,\n\t\t\t    const char *dict, size_t dictlen,\n\t\t\t    const char *fmt, va_list args)\n{\n\tint printed_len;\n\tbool in_sched = false, pending_output;\n\tunsigned long flags;\n\tu64 curr_log_seq;\n\n\tif (level == LOGLEVEL_SCHED) {\n\t\tlevel = LOGLEVEL_DEFAULT;\n\t\tin_sched = true;\n\t}\n\n\tboot_delay_msec(level);\n\tprintk_delay();\n\n\t/* This stops the holder of console_sem just where we want him */\n\tlogbuf_lock_irqsave(flags);\n\tcurr_log_seq = log_next_seq;\n\tprinted_len = vprintk_store(facility, level, dict, dictlen, fmt, args);\n\tpending_output = (curr_log_seq != log_next_seq);\n\tlogbuf_unlock_irqrestore(flags);\n\n\t/* If called from the scheduler, we can not call up(). */\n\tif (!in_sched && pending_output) {\n\t\t/*\n\t\t * Disable preemption to avoid being preempted while holding\n\t\t * console_sem which would prevent anyone from printing to\n\t\t * console\n\t\t */\n\t\tpreempt_disable();\n\t\t/*\n\t\t * Try to acquire and then immediately release the console\n\t\t * semaphore.  The release will print out buffers and wake up\n\t\t * /dev/kmsg and syslog() users.\n\t\t */\n\t\tif (console_trylock_spinning())\n\t\t\tconsole_unlock();\n\t\tpreempt_enable();\n\t}\n\n\tif (pending_output)\n\t\twake_up_klogd();\n\treturn printed_len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint vprintk_deferred(const char *fmt, va_list args)\n{\n\tint r;\n\n\tr = vprintk_emit(0, LOGLEVEL_SCHED, NULL, 0, fmt, args);\n\tdefer_console_output();\n\n\treturn r;\n}"
  },
  {
    "function_name": "defer_console_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2908-2914",
    "snippet": "void defer_console_output(void)\n{\n\tpreempt_disable();\n\t__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);\n\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PRINTK_PENDING_OUTPUT\t0x02"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "this_cpu_ptr(&wake_up_klogd_work)"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "90-112",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&wake_up_klogd_work"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_or",
          "args": [
            "printk_pending",
            "PRINTK_PENDING_OUTPUT"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PRINTK_PENDING_OUTPUT\t0x02\n\nvoid defer_console_output(void)\n{\n\tpreempt_disable();\n\t__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);\n\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "wake_up_klogd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2898-2906",
    "snippet": "void wake_up_klogd(void)\n{\n\tpreempt_disable();\n\tif (waitqueue_active(&log_wait)) {\n\t\tthis_cpu_or(printk_pending, PRINTK_PENDING_WAKEUP);\n\t\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\t}\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PRINTK_PENDING_WAKEUP\t0x01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "this_cpu_ptr(&wake_up_klogd_work)"
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "90-112",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&wake_up_klogd_work"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_or",
          "args": [
            "printk_pending",
            "PRINTK_PENDING_WAKEUP"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&log_wait"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PRINTK_PENDING_WAKEUP\t0x01\n\nvoid wake_up_klogd(void)\n{\n\tpreempt_disable();\n\tif (waitqueue_active(&log_wait)) {\n\t\tthis_cpu_or(printk_pending, PRINTK_PENDING_WAKEUP);\n\t\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\t}\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "wake_up_klogd_work_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2879-2891",
    "snippet": "static void wake_up_klogd_work_func(struct irq_work *irq_work)\n{\n\tint pending = __this_cpu_xchg(printk_pending, 0);\n\n\tif (pending & PRINTK_PENDING_OUTPUT) {\n\t\t/* If trylock fails, someone else is doing the printing */\n\t\tif (console_trylock())\n\t\t\tconsole_unlock();\n\t}\n\n\tif (pending & PRINTK_PENDING_WAKEUP)\n\t\twake_up_interruptible(&log_wait);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PRINTK_PENDING_OUTPUT\t0x02",
      "#define PRINTK_PENDING_WAKEUP\t0x01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&log_wait"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_unlock",
          "args": [],
          "line": 2886
        },
        "resolved": true,
        "details": {
          "function_name": "console_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2307-2447",
          "snippet": "void console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREFIX_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
            "#define PREFIX_MAX\t\t32"
          ],
          "globals_used": [
            "static DEFINE_SEMAPHORE(console_sem);",
            "static int nr_ext_console_drivers;",
            "static int console_locked, console_suspended;",
            "static struct console *exclusive_console;",
            "static int console_may_schedule;",
            "static int console_msg_format = MSG_FORMAT_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic DEFINE_SEMAPHORE(console_sem);\nstatic int nr_ext_console_drivers;\nstatic int console_locked, console_suspended;\nstatic struct console *exclusive_console;\nstatic int console_may_schedule;\nstatic int console_msg_format = MSG_FORMAT_DEFAULT;\n\nvoid console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "console_trylock",
          "args": [],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "console_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2245-2256",
          "snippet": "int console_trylock(void)\n{\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "static int console_may_schedule;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nstatic int console_may_schedule;\n\nint console_trylock(void)\n{\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_xchg",
          "args": [
            "printk_pending",
            "0"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PRINTK_PENDING_OUTPUT\t0x02\n#define PRINTK_PENDING_WAKEUP\t0x01\n\nstatic void wake_up_klogd_work_func(struct irq_work *irq_work)\n{\n\tint pending = __this_cpu_xchg(printk_pending, 0);\n\n\tif (pending & PRINTK_PENDING_OUTPUT) {\n\t\t/* If trylock fails, someone else is doing the printing */\n\t\tif (console_trylock())\n\t\t\tconsole_unlock();\n\t}\n\n\tif (pending & PRINTK_PENDING_WAKEUP)\n\t\twake_up_interruptible(&log_wait);\n}"
  },
  {
    "function_name": "printk_late_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2835-2867",
    "snippet": "static int __init printk_late_init(void)\n{\n\tstruct console *con;\n\tint ret;\n\n\tfor_each_console(con) {\n\t\tif (!(con->flags & CON_BOOT))\n\t\t\tcontinue;\n\n\t\t/* Check addresses that might be used for enabled consoles. */\n\t\tif (init_section_intersects(con, sizeof(*con)) ||\n\t\t    init_section_contains(con->write, 0) ||\n\t\t    init_section_contains(con->read, 0) ||\n\t\t    init_section_contains(con->device, 0) ||\n\t\t    init_section_contains(con->unblank, 0) ||\n\t\t    init_section_contains(con->data, 0)) {\n\t\t\t/*\n\t\t\t * Please, consider moving the reported consoles out\n\t\t\t * of the init section.\n\t\t\t */\n\t\t\tpr_warn(\"bootconsole [%s%d] uses init memory and must be disabled even before the real one is ready\\n\",\n\t\t\t\tcon->name, con->index);\n\t\t\tunregister_console(con);\n\t\t}\n\t}\n\tret = cpuhp_setup_state_nocalls(CPUHP_PRINTK_DEAD, \"printk:dead\", NULL,\n\t\t\t\t\tconsole_cpu_notify);\n\tWARN_ON(ret < 0);\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN, \"printk:online\",\n\t\t\t\t\tconsole_cpu_notify, NULL);\n\tWARN_ON(ret < 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_nocalls",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"printk:online\"",
            "console_cpu_notify",
            "NULL"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_nocalls",
          "args": [
            "CPUHP_PRINTK_DEAD",
            "\"printk:dead\"",
            "NULL",
            "console_cpu_notify"
          ],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_console",
          "args": [
            "con"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2745-2788",
          "snippet": "int unregister_console(struct console *console)\n{\n        struct console *a, *b;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res)\n\t\treturn res;\n\n\tres = 1;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else if (console_drivers) {\n\t\tfor (a=console_drivers->next, b=console_drivers ;\n\t\t     a; b=a, a=b->next) {\n\t\t\tif (a == console) {\n\t\t\t\tb->next = a->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!res && (console->flags & CON_EXTENDED))\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct console *console_drivers;",
            "static int nr_ext_console_drivers;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstruct console *console_drivers;\nstatic int nr_ext_console_drivers;\n\nint unregister_console(struct console *console)\n{\n        struct console *a, *b;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res)\n\t\treturn res;\n\n\tres = 1;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else if (console_drivers) {\n\t\tfor (a=console_drivers->next, b=console_drivers ;\n\t\t     a; b=a, a=b->next) {\n\t\t\tif (a == console) {\n\t\t\t\tb->next = a->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!res && (console->flags & CON_EXTENDED))\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"bootconsole [%s%d] uses init memory and must be disabled even before the real one is ready\\n\"",
            "con->name",
            "con->index"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_section_contains",
          "args": [
            "con->data",
            "0"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_section_contains",
          "args": [
            "con->unblank",
            "0"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_section_contains",
          "args": [
            "con->device",
            "0"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_section_contains",
          "args": [
            "con->read",
            "0"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_section_contains",
          "args": [
            "con->write",
            "0"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_section_intersects",
          "args": [
            "con",
            "sizeof(*con)"
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int __init printk_late_init(void)\n{\n\tstruct console *con;\n\tint ret;\n\n\tfor_each_console(con) {\n\t\tif (!(con->flags & CON_BOOT))\n\t\t\tcontinue;\n\n\t\t/* Check addresses that might be used for enabled consoles. */\n\t\tif (init_section_intersects(con, sizeof(*con)) ||\n\t\t    init_section_contains(con->write, 0) ||\n\t\t    init_section_contains(con->read, 0) ||\n\t\t    init_section_contains(con->device, 0) ||\n\t\t    init_section_contains(con->unblank, 0) ||\n\t\t    init_section_contains(con->data, 0)) {\n\t\t\t/*\n\t\t\t * Please, consider moving the reported consoles out\n\t\t\t * of the init section.\n\t\t\t */\n\t\t\tpr_warn(\"bootconsole [%s%d] uses init memory and must be disabled even before the real one is ready\\n\",\n\t\t\t\tcon->name, con->index);\n\t\t\tunregister_console(con);\n\t\t}\n\t}\n\tret = cpuhp_setup_state_nocalls(CPUHP_PRINTK_DEAD, \"printk:dead\", NULL,\n\t\t\t\t\tconsole_cpu_notify);\n\tWARN_ON(ret < 0);\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN, \"printk:online\",\n\t\t\t\t\tconsole_cpu_notify, NULL);\n\tWARN_ON(ret < 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "console_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2797-2819",
    "snippet": "void __init console_init(void)\n{\n\tint ret;\n\tinitcall_t call;\n\tinitcall_entry_t *ce;\n\n\t/* Setup the default TTY line discipline. */\n\tn_tty_init();\n\n\t/*\n\t * set up the console device so that later boot sequences can\n\t * inform about problems etc..\n\t */\n\tce = __con_initcall_start;\n\ttrace_initcall_level(\"console\");\n\twhile (ce < __con_initcall_end) {\n\t\tcall = initcall_from_entry(ce);\n\t\ttrace_initcall_start(call);\n\t\tret = call();\n\t\ttrace_initcall_finish(call, ret);\n\t\tce++;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_initcall_finish",
          "args": [
            "call",
            "ret"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call",
          "args": [],
          "line": 2815
        },
        "resolved": true,
        "details": {
          "function_name": "have_callable_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2269-2279",
          "snippet": "static int have_callable_console(void)\n{\n\tstruct console *con;\n\n\tfor_each_console(con)\n\t\tif ((con->flags & CON_ENABLED) &&\n\t\t\t\t(con->flags & CON_ANYTIME))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int have_callable_console(void)\n{\n\tstruct console *con;\n\n\tfor_each_console(con)\n\t\tif ((con->flags & CON_ENABLED) &&\n\t\t\t\t(con->flags & CON_ANYTIME))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_initcall_start",
          "args": [
            "call"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initcall_from_entry",
          "args": [
            "ce"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_initcall_level",
          "args": [
            "\"console\""
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_tty_init",
          "args": [],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid __init console_init(void)\n{\n\tint ret;\n\tinitcall_t call;\n\tinitcall_entry_t *ce;\n\n\t/* Setup the default TTY line discipline. */\n\tn_tty_init();\n\n\t/*\n\t * set up the console device so that later boot sequences can\n\t * inform about problems etc..\n\t */\n\tce = __con_initcall_start;\n\ttrace_initcall_level(\"console\");\n\twhile (ce < __con_initcall_end) {\n\t\tcall = initcall_from_entry(ce);\n\t\ttrace_initcall_start(call);\n\t\tret = call();\n\t\ttrace_initcall_finish(call, ret);\n\t\tce++;\n\t}\n}"
  },
  {
    "function_name": "unregister_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2745-2788",
    "snippet": "int unregister_console(struct console *console)\n{\n        struct console *a, *b;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res)\n\t\treturn res;\n\n\tres = 1;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else if (console_drivers) {\n\t\tfor (a=console_drivers->next, b=console_drivers ;\n\t\t     a; b=a, a=b->next) {\n\t\t\tif (a == console) {\n\t\t\t\tb->next = a->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!res && (console->flags & CON_EXTENDED))\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct console *console_drivers;",
      "static int nr_ext_console_drivers;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "console_sysfs_notify",
          "args": [],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_unlock",
          "args": [],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "console_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2307-2447",
          "snippet": "void console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREFIX_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
            "#define PREFIX_MAX\t\t32"
          ],
          "globals_used": [
            "static DEFINE_SEMAPHORE(console_sem);",
            "static int nr_ext_console_drivers;",
            "static int console_locked, console_suspended;",
            "static struct console *exclusive_console;",
            "static int console_may_schedule;",
            "static int console_msg_format = MSG_FORMAT_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic DEFINE_SEMAPHORE(console_sem);\nstatic int nr_ext_console_drivers;\nstatic int console_locked, console_suspended;\nstatic struct console *exclusive_console;\nstatic int console_may_schedule;\nstatic int console_msg_format = MSG_FORMAT_DEFAULT;\n\nvoid console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "console_lock",
          "args": [],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "is_console_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2259-2262",
          "snippet": "int is_console_locked(void)\n{\n\treturn console_locked;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint is_console_locked(void)\n{\n\treturn console_locked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_braille_unregister_console",
          "args": [
            "console"
          ],
          "line": 2754
        },
        "resolved": true,
        "details": {
          "function_name": "_braille_unregister_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/braille.h",
          "lines": "48-52",
          "snippet": "static inline int\n_braille_unregister_console(struct console *console)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\n_braille_unregister_console(struct console *console)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%sconsole [%s%d] disabled\\n\"",
            "(console->flags & CON_BOOT) ? \"boot\" : \"\"",
            "console->name",
            "console->index"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstruct console *console_drivers;\nstatic int nr_ext_console_drivers;\n\nint unregister_console(struct console *console)\n{\n        struct console *a, *b;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res)\n\t\treturn res;\n\n\tres = 1;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else if (console_drivers) {\n\t\tfor (a=console_drivers->next, b=console_drivers ;\n\t\t     a; b=a, a=b->next) {\n\t\t\tif (a == console) {\n\t\t\t\tb->next = a->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!res && (console->flags & CON_EXTENDED))\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\treturn res;\n}"
  },
  {
    "function_name": "register_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2579-2742",
    "snippet": "void register_console(struct console *newcon)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct console *bcon = NULL;\n\tstruct console_cmdline *c;\n\tstatic bool has_preferred;\n\n\tif (console_drivers)\n\t\tfor_each_console(bcon)\n\t\t\tif (WARN(bcon == newcon,\n\t\t\t\t\t\"console '%s%d' already registered\\n\",\n\t\t\t\t\tbcon->name, bcon->index))\n\t\t\t\treturn;\n\n\t/*\n\t * before we register a new CON_BOOT console, make sure we don't\n\t * already have a valid console\n\t */\n\tif (console_drivers && newcon->flags & CON_BOOT) {\n\t\t/* find the last or real console */\n\t\tfor_each_console(bcon) {\n\t\t\tif (!(bcon->flags & CON_BOOT)) {\n\t\t\t\tpr_info(\"Too late to register bootconsole %s%d\\n\",\n\t\t\t\t\tnewcon->name, newcon->index);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (console_drivers && console_drivers->flags & CON_BOOT)\n\t\tbcon = console_drivers;\n\n\tif (!has_preferred || bcon || !console_drivers)\n\t\thas_preferred = preferred_console >= 0;\n\n\t/*\n\t *\tSee if we want to use this console driver. If we\n\t *\tdidn't select a console we take the first one\n\t *\tthat registers here.\n\t */\n\tif (!has_preferred) {\n\t\tif (newcon->index < 0)\n\t\t\tnewcon->index = 0;\n\t\tif (newcon->setup == NULL ||\n\t\t    newcon->setup(newcon, NULL) == 0) {\n\t\t\tnewcon->flags |= CON_ENABLED;\n\t\t\tif (newcon->device) {\n\t\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\t\t\thas_preferred = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tSee if this console matches one we selected on\n\t *\tthe command line.\n\t */\n\tfor (i = 0, c = console_cmdline;\n\t     i < MAX_CMDLINECONSOLES && c->name[0];\n\t     i++, c++) {\n\t\tif (!newcon->match ||\n\t\t    newcon->match(newcon, c->name, c->index, c->options) != 0) {\n\t\t\t/* default matching */\n\t\t\tBUILD_BUG_ON(sizeof(c->name) != sizeof(newcon->name));\n\t\t\tif (strcmp(c->name, newcon->name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (newcon->index >= 0 &&\n\t\t\t    newcon->index != c->index)\n\t\t\t\tcontinue;\n\t\t\tif (newcon->index < 0)\n\t\t\t\tnewcon->index = c->index;\n\n\t\t\tif (_braille_register_console(newcon, c))\n\t\t\t\treturn;\n\n\t\t\tif (newcon->setup &&\n\t\t\t    newcon->setup(newcon, c->options) != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tnewcon->flags |= CON_ENABLED;\n\t\tif (i == preferred_console) {\n\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\t\thas_preferred = true;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!(newcon->flags & CON_ENABLED))\n\t\treturn;\n\n\t/*\n\t * If we have a bootconsole, and are switching to a real console,\n\t * don't print everything out again, since when the boot console, and\n\t * the real console are the same physical device, it's annoying to\n\t * see the beginning boot messages twice\n\t */\n\tif (bcon && ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV))\n\t\tnewcon->flags &= ~CON_PRINTBUFFER;\n\n\t/*\n\t *\tPut this console in the list - keep the\n\t *\tpreferred driver at the head of the list.\n\t */\n\tconsole_lock();\n\tif ((newcon->flags & CON_CONSDEV) || console_drivers == NULL) {\n\t\tnewcon->next = console_drivers;\n\t\tconsole_drivers = newcon;\n\t\tif (newcon->next)\n\t\t\tnewcon->next->flags &= ~CON_CONSDEV;\n\t} else {\n\t\tnewcon->next = console_drivers->next;\n\t\tconsole_drivers->next = newcon;\n\t}\n\n\tif (newcon->flags & CON_EXTENDED)\n\t\tnr_ext_console_drivers++;\n\n\tif (newcon->flags & CON_PRINTBUFFER) {\n\t\t/*\n\t\t * console_unlock(); will print out the buffered messages\n\t\t * for us.\n\t\t */\n\t\tlogbuf_lock_irqsave(flags);\n\t\tconsole_seq = syslog_seq;\n\t\tconsole_idx = syslog_idx;\n\t\t/*\n\t\t * We're about to replay the log buffer.  Only do this to the\n\t\t * just-registered console to avoid excessive message spam to\n\t\t * the already-registered consoles.\n\t\t *\n\t\t * Set exclusive_console with disabled interrupts to reduce\n\t\t * race window with eventual console_flush_on_panic() that\n\t\t * ignores console_lock.\n\t\t */\n\t\texclusive_console = newcon;\n\t\texclusive_console_stop_seq = console_seq;\n\t\tlogbuf_unlock_irqrestore(flags);\n\t}\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\t/*\n\t * By unregistering the bootconsoles after we enable the real console\n\t * we get the \"console xxx enabled\" message on all the consoles -\n\t * boot consoles, real consoles, etc - this is to ensure that end\n\t * users know there might be something in the kernel's log buffer that\n\t * went to the bootconsole (that they do not see on the real console)\n\t */\n\tpr_info(\"%sconsole [%s%d] enabled\\n\",\n\t\t(newcon->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tnewcon->name, newcon->index);\n\tif (bcon &&\n\t    ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &&\n\t    !keep_bootcon) {\n\t\t/* We need to iterate through all boot consoles, to make\n\t\t * sure we print everything out, before we unregister them.\n\t\t */\n\t\tfor_each_console(bcon)\n\t\t\tif (bcon->flags & CON_BOOT)\n\t\t\t\tunregister_console(bcon);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MAX_CMDLINECONSOLES 8"
    ],
    "globals_used": [
      "struct console *console_drivers;",
      "static int nr_ext_console_drivers;",
      "static struct console *exclusive_console;",
      "static struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];",
      "static int preferred_console = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_console",
          "args": [
            "bcon"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2745-2788",
          "snippet": "int unregister_console(struct console *console)\n{\n        struct console *a, *b;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res)\n\t\treturn res;\n\n\tres = 1;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else if (console_drivers) {\n\t\tfor (a=console_drivers->next, b=console_drivers ;\n\t\t     a; b=a, a=b->next) {\n\t\t\tif (a == console) {\n\t\t\t\tb->next = a->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!res && (console->flags & CON_EXTENDED))\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct console *console_drivers;",
            "static int nr_ext_console_drivers;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstruct console *console_drivers;\nstatic int nr_ext_console_drivers;\n\nint unregister_console(struct console *console)\n{\n        struct console *a, *b;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res)\n\t\treturn res;\n\n\tres = 1;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else if (console_drivers) {\n\t\tfor (a=console_drivers->next, b=console_drivers ;\n\t\t     a; b=a, a=b->next) {\n\t\t\tif (a == console) {\n\t\t\t\tb->next = a->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!res && (console->flags & CON_EXTENDED))\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%sconsole [%s%d] enabled\\n\"",
            "(newcon->flags & CON_BOOT) ? \"boot\" : \"\"",
            "newcon->name",
            "newcon->index"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_sysfs_notify",
          "args": [],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_unlock",
          "args": [],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "console_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2307-2447",
          "snippet": "void console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREFIX_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
            "#define PREFIX_MAX\t\t32"
          ],
          "globals_used": [
            "static DEFINE_SEMAPHORE(console_sem);",
            "static int nr_ext_console_drivers;",
            "static int console_locked, console_suspended;",
            "static struct console *exclusive_console;",
            "static int console_may_schedule;",
            "static int console_msg_format = MSG_FORMAT_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic DEFINE_SEMAPHORE(console_sem);\nstatic int nr_ext_console_drivers;\nstatic int console_locked, console_suspended;\nstatic struct console *exclusive_console;\nstatic int console_may_schedule;\nstatic int console_msg_format = MSG_FORMAT_DEFAULT;\n\nvoid console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_unlock_irqrestore",
          "args": [
            "flags"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irqsave",
          "args": [
            "flags"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_lock",
          "args": [],
          "line": 2684
        },
        "resolved": true,
        "details": {
          "function_name": "is_console_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2259-2262",
          "snippet": "int is_console_locked(void)\n{\n\treturn console_locked;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint is_console_locked(void)\n{\n\treturn console_locked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "newcon->setup",
          "args": [
            "newcon",
            "c->options"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_braille_register_console",
          "args": [
            "newcon",
            "c"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "_braille_register_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/braille.h",
          "lines": "42-46",
          "snippet": "static inline int\n_braille_register_console(struct console *console, struct console_cmdline *c)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\n_braille_register_console(struct console *console, struct console_cmdline *c)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "c->name",
            "newcon->name"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(c->name) != sizeof(newcon->name)"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newcon->match",
          "args": [
            "newcon",
            "c->name",
            "c->index",
            "c->options"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newcon->setup",
          "args": [
            "newcon",
            "NULL"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Too late to register bootconsole %s%d\\n\"",
            "newcon->name",
            "newcon->index"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "bcon == newcon",
            "\"console '%s%d' already registered\\n\"",
            "bcon->name",
            "bcon->index"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_console",
          "args": [
            "bcon"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define MAX_CMDLINECONSOLES 8\n\nstruct console *console_drivers;\nstatic int nr_ext_console_drivers;\nstatic struct console *exclusive_console;\nstatic struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];\nstatic int preferred_console = -1;\n\nvoid register_console(struct console *newcon)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct console *bcon = NULL;\n\tstruct console_cmdline *c;\n\tstatic bool has_preferred;\n\n\tif (console_drivers)\n\t\tfor_each_console(bcon)\n\t\t\tif (WARN(bcon == newcon,\n\t\t\t\t\t\"console '%s%d' already registered\\n\",\n\t\t\t\t\tbcon->name, bcon->index))\n\t\t\t\treturn;\n\n\t/*\n\t * before we register a new CON_BOOT console, make sure we don't\n\t * already have a valid console\n\t */\n\tif (console_drivers && newcon->flags & CON_BOOT) {\n\t\t/* find the last or real console */\n\t\tfor_each_console(bcon) {\n\t\t\tif (!(bcon->flags & CON_BOOT)) {\n\t\t\t\tpr_info(\"Too late to register bootconsole %s%d\\n\",\n\t\t\t\t\tnewcon->name, newcon->index);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (console_drivers && console_drivers->flags & CON_BOOT)\n\t\tbcon = console_drivers;\n\n\tif (!has_preferred || bcon || !console_drivers)\n\t\thas_preferred = preferred_console >= 0;\n\n\t/*\n\t *\tSee if we want to use this console driver. If we\n\t *\tdidn't select a console we take the first one\n\t *\tthat registers here.\n\t */\n\tif (!has_preferred) {\n\t\tif (newcon->index < 0)\n\t\t\tnewcon->index = 0;\n\t\tif (newcon->setup == NULL ||\n\t\t    newcon->setup(newcon, NULL) == 0) {\n\t\t\tnewcon->flags |= CON_ENABLED;\n\t\t\tif (newcon->device) {\n\t\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\t\t\thas_preferred = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tSee if this console matches one we selected on\n\t *\tthe command line.\n\t */\n\tfor (i = 0, c = console_cmdline;\n\t     i < MAX_CMDLINECONSOLES && c->name[0];\n\t     i++, c++) {\n\t\tif (!newcon->match ||\n\t\t    newcon->match(newcon, c->name, c->index, c->options) != 0) {\n\t\t\t/* default matching */\n\t\t\tBUILD_BUG_ON(sizeof(c->name) != sizeof(newcon->name));\n\t\t\tif (strcmp(c->name, newcon->name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (newcon->index >= 0 &&\n\t\t\t    newcon->index != c->index)\n\t\t\t\tcontinue;\n\t\t\tif (newcon->index < 0)\n\t\t\t\tnewcon->index = c->index;\n\n\t\t\tif (_braille_register_console(newcon, c))\n\t\t\t\treturn;\n\n\t\t\tif (newcon->setup &&\n\t\t\t    newcon->setup(newcon, c->options) != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tnewcon->flags |= CON_ENABLED;\n\t\tif (i == preferred_console) {\n\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\t\thas_preferred = true;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!(newcon->flags & CON_ENABLED))\n\t\treturn;\n\n\t/*\n\t * If we have a bootconsole, and are switching to a real console,\n\t * don't print everything out again, since when the boot console, and\n\t * the real console are the same physical device, it's annoying to\n\t * see the beginning boot messages twice\n\t */\n\tif (bcon && ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV))\n\t\tnewcon->flags &= ~CON_PRINTBUFFER;\n\n\t/*\n\t *\tPut this console in the list - keep the\n\t *\tpreferred driver at the head of the list.\n\t */\n\tconsole_lock();\n\tif ((newcon->flags & CON_CONSDEV) || console_drivers == NULL) {\n\t\tnewcon->next = console_drivers;\n\t\tconsole_drivers = newcon;\n\t\tif (newcon->next)\n\t\t\tnewcon->next->flags &= ~CON_CONSDEV;\n\t} else {\n\t\tnewcon->next = console_drivers->next;\n\t\tconsole_drivers->next = newcon;\n\t}\n\n\tif (newcon->flags & CON_EXTENDED)\n\t\tnr_ext_console_drivers++;\n\n\tif (newcon->flags & CON_PRINTBUFFER) {\n\t\t/*\n\t\t * console_unlock(); will print out the buffered messages\n\t\t * for us.\n\t\t */\n\t\tlogbuf_lock_irqsave(flags);\n\t\tconsole_seq = syslog_seq;\n\t\tconsole_idx = syslog_idx;\n\t\t/*\n\t\t * We're about to replay the log buffer.  Only do this to the\n\t\t * just-registered console to avoid excessive message spam to\n\t\t * the already-registered consoles.\n\t\t *\n\t\t * Set exclusive_console with disabled interrupts to reduce\n\t\t * race window with eventual console_flush_on_panic() that\n\t\t * ignores console_lock.\n\t\t */\n\t\texclusive_console = newcon;\n\t\texclusive_console_stop_seq = console_seq;\n\t\tlogbuf_unlock_irqrestore(flags);\n\t}\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\t/*\n\t * By unregistering the bootconsoles after we enable the real console\n\t * we get the \"console xxx enabled\" message on all the consoles -\n\t * boot consoles, real consoles, etc - this is to ensure that end\n\t * users know there might be something in the kernel's log buffer that\n\t * went to the bootconsole (that they do not see on the real console)\n\t */\n\tpr_info(\"%sconsole [%s%d] enabled\\n\",\n\t\t(newcon->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tnewcon->name, newcon->index);\n\tif (bcon &&\n\t    ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &&\n\t    !keep_bootcon) {\n\t\t/* We need to iterate through all boot consoles, to make\n\t\t * sure we print everything out, before we unregister them.\n\t\t */\n\t\tfor_each_console(bcon)\n\t\t\tif (bcon->flags & CON_BOOT)\n\t\t\t\tunregister_console(bcon);\n\t}\n}"
  },
  {
    "function_name": "keep_bootcon_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2550-2556",
    "snippet": "static int __init keep_bootcon_setup(char *str)\n{\n\tkeep_bootcon = 1;\n\tpr_info(\"debug: skip boot console de-registration.\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"debug: skip boot console de-registration.\\n\""
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int __init keep_bootcon_setup(char *str)\n{\n\tkeep_bootcon = 1;\n\tpr_info(\"debug: skip boot console de-registration.\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "console_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2540-2545",
    "snippet": "void console_start(struct console *console)\n{\n\tconsole_lock();\n\tconsole->flags |= CON_ENABLED;\n\tconsole_unlock();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "console_unlock",
          "args": [],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "console_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2307-2447",
          "snippet": "void console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREFIX_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
            "#define PREFIX_MAX\t\t32"
          ],
          "globals_used": [
            "static DEFINE_SEMAPHORE(console_sem);",
            "static int nr_ext_console_drivers;",
            "static int console_locked, console_suspended;",
            "static struct console *exclusive_console;",
            "static int console_may_schedule;",
            "static int console_msg_format = MSG_FORMAT_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic DEFINE_SEMAPHORE(console_sem);\nstatic int nr_ext_console_drivers;\nstatic int console_locked, console_suspended;\nstatic struct console *exclusive_console;\nstatic int console_may_schedule;\nstatic int console_msg_format = MSG_FORMAT_DEFAULT;\n\nvoid console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "console_lock",
          "args": [],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "is_console_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2259-2262",
          "snippet": "int is_console_locked(void)\n{\n\treturn console_locked;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint is_console_locked(void)\n{\n\treturn console_locked;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid console_start(struct console *console)\n{\n\tconsole_lock();\n\tconsole->flags |= CON_ENABLED;\n\tconsole_unlock();\n}"
  },
  {
    "function_name": "console_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2532-2537",
    "snippet": "void console_stop(struct console *console)\n{\n\tconsole_lock();\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "console_unlock",
          "args": [],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "console_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2307-2447",
          "snippet": "void console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREFIX_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
            "#define PREFIX_MAX\t\t32"
          ],
          "globals_used": [
            "static DEFINE_SEMAPHORE(console_sem);",
            "static int nr_ext_console_drivers;",
            "static int console_locked, console_suspended;",
            "static struct console *exclusive_console;",
            "static int console_may_schedule;",
            "static int console_msg_format = MSG_FORMAT_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic DEFINE_SEMAPHORE(console_sem);\nstatic int nr_ext_console_drivers;\nstatic int console_locked, console_suspended;\nstatic struct console *exclusive_console;\nstatic int console_may_schedule;\nstatic int console_msg_format = MSG_FORMAT_DEFAULT;\n\nvoid console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "console_lock",
          "args": [],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "is_console_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2259-2262",
          "snippet": "int is_console_locked(void)\n{\n\treturn console_locked;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint is_console_locked(void)\n{\n\treturn console_locked;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid console_stop(struct console *console)\n{\n\tconsole_lock();\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n}"
  },
  {
    "function_name": "console_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2510-2525",
    "snippet": "struct tty_driver *console_device(int *index)\n{\n\tstruct console *c;\n\tstruct tty_driver *driver = NULL;\n\n\tconsole_lock();\n\tfor_each_console(c) {\n\t\tif (!c->device)\n\t\t\tcontinue;\n\t\tdriver = c->device(c, index);\n\t\tif (driver)\n\t\t\tbreak;\n\t}\n\tconsole_unlock();\n\treturn driver;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "console_unlock",
          "args": [],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "console_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2307-2447",
          "snippet": "void console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREFIX_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
            "#define PREFIX_MAX\t\t32"
          ],
          "globals_used": [
            "static DEFINE_SEMAPHORE(console_sem);",
            "static int nr_ext_console_drivers;",
            "static int console_locked, console_suspended;",
            "static struct console *exclusive_console;",
            "static int console_may_schedule;",
            "static int console_msg_format = MSG_FORMAT_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic DEFINE_SEMAPHORE(console_sem);\nstatic int nr_ext_console_drivers;\nstatic int console_locked, console_suspended;\nstatic struct console *exclusive_console;\nstatic int console_may_schedule;\nstatic int console_msg_format = MSG_FORMAT_DEFAULT;\n\nvoid console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->device",
          "args": [
            "c",
            "index"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_lock",
          "args": [],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "is_console_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2259-2262",
          "snippet": "int is_console_locked(void)\n{\n\treturn console_locked;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint is_console_locked(void)\n{\n\treturn console_locked;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstruct tty_driver *console_device(int *index)\n{\n\tstruct console *c;\n\tstruct tty_driver *driver = NULL;\n\n\tconsole_lock();\n\tfor_each_console(c) {\n\t\tif (!c->device)\n\t\t\tcontinue;\n\t\tdriver = c->device(c, index);\n\t\tif (driver)\n\t\t\tbreak;\n\t}\n\tconsole_unlock();\n\treturn driver;\n}"
  },
  {
    "function_name": "console_flush_on_panic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2493-2505",
    "snippet": "void console_flush_on_panic(void)\n{\n\t/*\n\t * If someone else is holding the console lock, trylock will fail\n\t * and may_schedule may be set.  Ignore and proceed to unlock so\n\t * that messages are flushed out.  As this can be called from any\n\t * context and we don't want to get preempted while flushing,\n\t * ensure may_schedule is cleared.\n\t */\n\tconsole_trylock();\n\tconsole_may_schedule = 0;\n\tconsole_unlock();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int console_may_schedule;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "console_unlock",
          "args": [],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "console_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2307-2447",
          "snippet": "void console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREFIX_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
            "#define PREFIX_MAX\t\t32"
          ],
          "globals_used": [
            "static DEFINE_SEMAPHORE(console_sem);",
            "static int nr_ext_console_drivers;",
            "static int console_locked, console_suspended;",
            "static struct console *exclusive_console;",
            "static int console_may_schedule;",
            "static int console_msg_format = MSG_FORMAT_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic DEFINE_SEMAPHORE(console_sem);\nstatic int nr_ext_console_drivers;\nstatic int console_locked, console_suspended;\nstatic struct console *exclusive_console;\nstatic int console_may_schedule;\nstatic int console_msg_format = MSG_FORMAT_DEFAULT;\n\nvoid console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "console_trylock",
          "args": [],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "console_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2245-2256",
          "snippet": "int console_trylock(void)\n{\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "static int console_may_schedule;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nstatic int console_may_schedule;\n\nint console_trylock(void)\n{\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_may_schedule;\n\nvoid console_flush_on_panic(void)\n{\n\t/*\n\t * If someone else is holding the console lock, trylock will fail\n\t * and may_schedule may be set.  Ignore and proceed to unlock so\n\t * that messages are flushed out.  As this can be called from any\n\t * context and we don't want to get preempted while flushing,\n\t * ensure may_schedule is cleared.\n\t */\n\tconsole_trylock();\n\tconsole_may_schedule = 0;\n\tconsole_unlock();\n}"
  },
  {
    "function_name": "console_unblank",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2466-2486",
    "snippet": "void console_unblank(void)\n{\n\tstruct console *c;\n\n\t/*\n\t * console_unblank can no longer be called in interrupt context unless\n\t * oops_in_progress is set to 1..\n\t */\n\tif (oops_in_progress) {\n\t\tif (down_trylock_console_sem() != 0)\n\t\t\treturn;\n\t} else\n\t\tconsole_lock();\n\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\tfor_each_console(c)\n\t\tif ((c->flags & CON_ENABLED) && c->unblank)\n\t\t\tc->unblank();\n\tconsole_unlock();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int oops_in_progress;",
      "static int console_may_schedule;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "console_unlock",
          "args": [],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "console_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2307-2447",
          "snippet": "void console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREFIX_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
            "#define PREFIX_MAX\t\t32"
          ],
          "globals_used": [
            "static DEFINE_SEMAPHORE(console_sem);",
            "static int nr_ext_console_drivers;",
            "static int console_locked, console_suspended;",
            "static struct console *exclusive_console;",
            "static int console_may_schedule;",
            "static int console_msg_format = MSG_FORMAT_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic DEFINE_SEMAPHORE(console_sem);\nstatic int nr_ext_console_drivers;\nstatic int console_locked, console_suspended;\nstatic struct console *exclusive_console;\nstatic int console_may_schedule;\nstatic int console_msg_format = MSG_FORMAT_DEFAULT;\n\nvoid console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "console_lock",
          "args": [],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "is_console_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2259-2262",
          "snippet": "int is_console_locked(void)\n{\n\treturn console_locked;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint is_console_locked(void)\n{\n\treturn console_locked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_trylock_console_sem",
          "args": [],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint oops_in_progress;\nstatic int console_may_schedule;\n\nvoid console_unblank(void)\n{\n\tstruct console *c;\n\n\t/*\n\t * console_unblank can no longer be called in interrupt context unless\n\t * oops_in_progress is set to 1..\n\t */\n\tif (oops_in_progress) {\n\t\tif (down_trylock_console_sem() != 0)\n\t\t\treturn;\n\t} else\n\t\tconsole_lock();\n\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\tfor_each_console(c)\n\t\tif ((c->flags & CON_ENABLED) && c->unblank)\n\t\t\tc->unblank();\n\tconsole_unlock();\n}"
  },
  {
    "function_name": "console_conditional_schedule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2459-2463",
    "snippet": "void __sched console_conditional_schedule(void)\n{\n\tif (console_may_schedule)\n\t\tcond_resched();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int console_may_schedule;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_may_schedule;\n\nvoid __sched console_conditional_schedule(void)\n{\n\tif (console_may_schedule)\n\t\tcond_resched();\n}"
  },
  {
    "function_name": "console_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2307-2447",
    "snippet": "void console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PREFIX_MAX\t\t0",
      "#define LOG_LINE_MAX\t\t0",
      "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
      "#define PREFIX_MAX\t\t32"
    ],
    "globals_used": [
      "static DEFINE_SEMAPHORE(console_sem);",
      "static int nr_ext_console_drivers;",
      "static int console_locked, console_suspended;",
      "static struct console *exclusive_console;",
      "static int console_may_schedule;",
      "static int console_msg_format = MSG_FORMAT_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "console_trylock",
          "args": [],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "console_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2245-2256",
          "snippet": "int console_trylock(void)\n{\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "static int console_may_schedule;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nstatic int console_may_schedule;\n\nint console_trylock(void)\n{\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_safe_exit_irqrestore",
          "args": [
            "flags"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&logbuf_lock"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&logbuf_lock"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_console_sem",
          "args": [],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_safe_exit_irqrestore",
          "args": [
            "flags"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_safe_exit_irqrestore",
          "args": [
            "flags"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_lock_spinning_disable_and_check",
          "args": [],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "console_lock_spinning_disable_and_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2028-2028",
          "snippet": "static int console_lock_spinning_disable_and_check(void) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_lock_spinning_disable_and_check(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "start_critical_timings",
          "args": [],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "start_critical_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_irqsoff.c",
          "lines": "439-445",
          "snippet": "void start_critical_timings(void)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) || irq_trace())\n\t\tstart_critical_timing(CALLER_ADDR0, CALLER_ADDR1, pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid start_critical_timings(void)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) || irq_trace())\n\t\tstart_critical_timing(CALLER_ADDR0, CALLER_ADDR1, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_console_drivers",
          "args": [
            "ext_text",
            "ext_len",
            "text",
            "len"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "call_console_drivers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2029-2030",
          "snippet": "static void call_console_drivers(const char *ext_text, size_t ext_len,\n\t\t\t\t const char *text, size_t len) {}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void call_console_drivers(const char *ext_text, size_t ext_len,\n\t\t\t\t const char *text, size_t len) {}"
        }
      },
      {
        "call_info": {
          "callee": "stop_critical_timings",
          "args": [],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "stop_critical_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_irqsoff.c",
          "lines": "448-454",
          "snippet": "void stop_critical_timings(void)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) || irq_trace())\n\t\tstop_critical_timing(CALLER_ADDR0, CALLER_ADDR1, pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid stop_critical_timings(void)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) || irq_trace())\n\t\tstop_critical_timing(CALLER_ADDR0, CALLER_ADDR1, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "console_lock_spinning_enable",
          "args": [],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "console_lock_spinning_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2027-2027",
          "snippet": "static void console_lock_spinning_enable(void) { }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void console_lock_spinning_enable(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "log_next",
          "args": [
            "console_idx"
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "log_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2020-2020",
          "snippet": "static u32 log_next(u32 idx) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic u32 log_next(u32 idx) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "msg_print_ext_body",
          "args": [
            "ext_text + ext_len",
            "sizeof(ext_text) - ext_len",
            "log_dict(msg)",
            "msg->dict_len",
            "log_text(msg)",
            "msg->text_len"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "msg_print_ext_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2024-2026",
          "snippet": "static ssize_t msg_print_ext_body(char *buf, size_t size,\n\t\t\t\t  char *dict, size_t dict_len,\n\t\t\t\t  char *text, size_t text_len) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic ssize_t msg_print_ext_body(char *buf, size_t size,\n\t\t\t\t  char *dict, size_t dict_len,\n\t\t\t\t  char *text, size_t text_len) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "log_text",
          "args": [
            "msg"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "log_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2017-2017",
          "snippet": "static char *log_text(const struct printk_log *msg) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic char *log_text(const struct printk_log *msg) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "log_dict",
          "args": [
            "msg"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "log_dict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2018-2018",
          "snippet": "static char *log_dict(const struct printk_log *msg) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic char *log_dict(const struct printk_log *msg) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "msg_print_ext_header",
          "args": [
            "ext_text",
            "sizeof(ext_text)",
            "msg",
            "console_seq"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "msg_print_ext_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2021-2023",
          "snippet": "static ssize_t msg_print_ext_header(char *buf, size_t size,\n\t\t\t\t    struct printk_log *msg,\n\t\t\t\t    u64 seq) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic ssize_t msg_print_ext_header(char *buf, size_t size,\n\t\t\t\t    struct printk_log *msg,\n\t\t\t\t    u64 seq) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "msg_print_text",
          "args": [
            "msg",
            "console_msg_format & MSG_FORMAT_SYSLOG",
            "text + len",
            "sizeof(text) - len"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "msg_print_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2031-2032",
          "snippet": "static size_t msg_print_text(const struct printk_log *msg,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic size_t msg_print_text(const struct printk_log *msg,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suppress_message_printing",
          "args": [
            "msg->level"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "suppress_message_printing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2033-2033",
          "snippet": "static bool suppress_message_printing(int level) { return false; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic bool suppress_message_printing(int level) { return false; }"
        }
      },
      {
        "call_info": {
          "callee": "log_from_idx",
          "args": [
            "console_idx"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "log_from_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2019-2019",
          "snippet": "static struct printk_log *log_from_idx(u32 idx) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct printk_log *log_from_idx(u32 idx) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "text",
            "\"** %llu printk messages dropped **\\n\"",
            "log_first_seq - console_seq"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_safe_enter_irqsave",
          "args": [
            "flags"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_console_sem",
          "args": [],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_use_console",
          "args": [],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "can_use_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2288-2291",
          "snippet": "static inline int can_use_console(void)\n{\n\treturn cpu_online(raw_smp_processor_id()) || have_callable_console();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic inline int can_use_console(void)\n{\n\treturn cpu_online(raw_smp_processor_id()) || have_callable_console();\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_console_sem",
          "args": [],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic DEFINE_SEMAPHORE(console_sem);\nstatic int nr_ext_console_drivers;\nstatic int console_locked, console_suspended;\nstatic struct console *exclusive_console;\nstatic int console_may_schedule;\nstatic int console_msg_format = MSG_FORMAT_DEFAULT;\n\nvoid console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}"
  },
  {
    "function_name": "can_use_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2288-2291",
    "snippet": "static inline int can_use_console(void)\n{\n\treturn cpu_online(raw_smp_processor_id()) || have_callable_console();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "have_callable_console",
          "args": [],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "have_callable_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2269-2279",
          "snippet": "static int have_callable_console(void)\n{\n\tstruct console *con;\n\n\tfor_each_console(con)\n\t\tif ((con->flags & CON_ENABLED) &&\n\t\t\t\t(con->flags & CON_ANYTIME))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int have_callable_console(void)\n{\n\tstruct console *con;\n\n\tfor_each_console(con)\n\t\tif ((con->flags & CON_ENABLED) &&\n\t\t\t\t(con->flags & CON_ANYTIME))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic inline int can_use_console(void)\n{\n\treturn cpu_online(raw_smp_processor_id()) || have_callable_console();\n}"
  },
  {
    "function_name": "have_callable_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2269-2279",
    "snippet": "static int have_callable_console(void)\n{\n\tstruct console *con;\n\n\tfor_each_console(con)\n\t\tif ((con->flags & CON_ENABLED) &&\n\t\t\t\t(con->flags & CON_ANYTIME))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int have_callable_console(void)\n{\n\tstruct console *con;\n\n\tfor_each_console(con)\n\t\tif ((con->flags & CON_ENABLED) &&\n\t\t\t\t(con->flags & CON_ANYTIME))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_console_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2259-2262",
    "snippet": "int is_console_locked(void)\n{\n\treturn console_locked;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint is_console_locked(void)\n{\n\treturn console_locked;\n}"
  },
  {
    "function_name": "console_trylock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2245-2256",
    "snippet": "int console_trylock(void)\n{\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int console_locked, console_suspended;",
      "static int console_may_schedule;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_console_sem",
          "args": [],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_trylock_console_sem",
          "args": [],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nstatic int console_may_schedule;\n\nint console_trylock(void)\n{\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "console_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2225-2234",
    "snippet": "void console_lock(void)\n{\n\tmight_sleep();\n\n\tdown_console_sem();\n\tif (console_suspended)\n\t\treturn;\n\tconsole_locked = 1;\n\tconsole_may_schedule = 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int console_locked, console_suspended;",
      "static int console_may_schedule;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_console_sem",
          "args": [],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nstatic int console_may_schedule;\n\nvoid console_lock(void)\n{\n\tmight_sleep();\n\n\tdown_console_sem();\n\tif (console_suspended)\n\t\treturn;\n\tconsole_locked = 1;\n\tconsole_may_schedule = 1;\n}"
  },
  {
    "function_name": "console_cpu_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2207-2215",
    "snippet": "static int console_cpu_notify(unsigned int cpu)\n{\n\tif (!cpuhp_tasks_frozen) {\n\t\t/* If trylock fails, someone else is doing the printing */\n\t\tif (console_trylock())\n\t\t\tconsole_unlock();\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "console_unlock",
          "args": [],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "console_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2307-2447",
          "snippet": "void console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREFIX_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
            "#define PREFIX_MAX\t\t32"
          ],
          "globals_used": [
            "static DEFINE_SEMAPHORE(console_sem);",
            "static int nr_ext_console_drivers;",
            "static int console_locked, console_suspended;",
            "static struct console *exclusive_console;",
            "static int console_may_schedule;",
            "static int console_msg_format = MSG_FORMAT_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic DEFINE_SEMAPHORE(console_sem);\nstatic int nr_ext_console_drivers;\nstatic int console_locked, console_suspended;\nstatic struct console *exclusive_console;\nstatic int console_may_schedule;\nstatic int console_msg_format = MSG_FORMAT_DEFAULT;\n\nvoid console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "console_trylock",
          "args": [],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "console_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2245-2256",
          "snippet": "int console_trylock(void)\n{\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "static int console_may_schedule;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nstatic int console_may_schedule;\n\nint console_trylock(void)\n{\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_cpu_notify(unsigned int cpu)\n{\n\tif (!cpuhp_tasks_frozen) {\n\t\t/* If trylock fails, someone else is doing the printing */\n\t\tif (console_trylock())\n\t\t\tconsole_unlock();\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "resume_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2189-2196",
    "snippet": "void resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int console_locked, console_suspended;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "console_unlock",
          "args": [],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "console_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2307-2447",
          "snippet": "void console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREFIX_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
            "#define PREFIX_MAX\t\t32"
          ],
          "globals_used": [
            "static DEFINE_SEMAPHORE(console_sem);",
            "static int nr_ext_console_drivers;",
            "static int console_locked, console_suspended;",
            "static struct console *exclusive_console;",
            "static int console_may_schedule;",
            "static int console_msg_format = MSG_FORMAT_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic DEFINE_SEMAPHORE(console_sem);\nstatic int nr_ext_console_drivers;\nstatic int console_locked, console_suspended;\nstatic struct console *exclusive_console;\nstatic int console_may_schedule;\nstatic int console_msg_format = MSG_FORMAT_DEFAULT;\n\nvoid console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_console_sem",
          "args": [],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\n\nvoid resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}"
  },
  {
    "function_name": "suspend_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2179-2187",
    "snippet": "void suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int console_locked, console_suspended;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_console_sem",
          "args": [],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_lock",
          "args": [],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "is_console_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2259-2262",
          "snippet": "int is_console_locked(void)\n{\n\treturn console_locked;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint is_console_locked(void)\n{\n\treturn console_locked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Suspending console(s) (use no_console_suspend to debug)\\n\""
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\n\nvoid suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}"
  },
  {
    "function_name": "console_suspend_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2163-2167",
    "snippet": "static int __init console_suspend_disable(char *str)\n{\n\tconsole_suspend_enabled = false;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int __init console_suspend_disable(char *str)\n{\n\tconsole_suspend_enabled = false;\n\treturn 1;\n}"
  },
  {
    "function_name": "add_preferred_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2155-2158",
    "snippet": "int add_preferred_console(char *name, int idx, char *options)\n{\n\treturn __add_preferred_console(name, idx, options, NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_preferred_console",
          "args": [
            "name",
            "idx",
            "options",
            "NULL"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "__add_preferred_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2057-2086",
          "snippet": "static int __add_preferred_console(char *name, int idx, char *options,\n\t\t\t\t   char *brl_options)\n{\n\tstruct console_cmdline *c;\n\tint i;\n\n\t/*\n\t *\tSee if this tty is not yet registered, and\n\t *\tif we have a slot free.\n\t */\n\tfor (i = 0, c = console_cmdline;\n\t     i < MAX_CMDLINECONSOLES && c->name[0];\n\t     i++, c++) {\n\t\tif (strcmp(c->name, name) == 0 && c->index == idx) {\n\t\t\tif (!brl_options)\n\t\t\t\tpreferred_console = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (i == MAX_CMDLINECONSOLES)\n\t\treturn -E2BIG;\n\tif (!brl_options)\n\t\tpreferred_console = i;\n\tstrlcpy(c->name, name, sizeof(c->name));\n\tc->options = options;\n\tbraille_set_options(c, brl_options);\n\n\tc->index = idx;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_CMDLINECONSOLES 8"
          ],
          "globals_used": [
            "static struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];",
            "static int preferred_console = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define MAX_CMDLINECONSOLES 8\n\nstatic struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];\nstatic int preferred_console = -1;\n\nstatic int __add_preferred_console(char *name, int idx, char *options,\n\t\t\t\t   char *brl_options)\n{\n\tstruct console_cmdline *c;\n\tint i;\n\n\t/*\n\t *\tSee if this tty is not yet registered, and\n\t *\tif we have a slot free.\n\t */\n\tfor (i = 0, c = console_cmdline;\n\t     i < MAX_CMDLINECONSOLES && c->name[0];\n\t     i++, c++) {\n\t\tif (strcmp(c->name, name) == 0 && c->index == idx) {\n\t\t\tif (!brl_options)\n\t\t\t\tpreferred_console = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (i == MAX_CMDLINECONSOLES)\n\t\treturn -E2BIG;\n\tif (!brl_options)\n\t\tpreferred_console = i;\n\tstrlcpy(c->name, name, sizeof(c->name));\n\tc->options = options;\n\tbraille_set_options(c, brl_options);\n\n\tc->index = idx;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint add_preferred_console(char *name, int idx, char *options)\n{\n\treturn __add_preferred_console(name, idx, options, NULL);\n}"
  },
  {
    "function_name": "console_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2102-2139",
    "snippet": "static int __init console_setup(char *str)\n{\n\tchar buf[sizeof(console_cmdline[0].name) + 4]; /* 4 for \"ttyS\" */\n\tchar *s, *options, *brl_options = NULL;\n\tint idx;\n\n\tif (_braille_console_setup(&str, &brl_options))\n\t\treturn 1;\n\n\t/*\n\t * Decode str into name, index, options.\n\t */\n\tif (str[0] >= '0' && str[0] <= '9') {\n\t\tstrcpy(buf, \"ttyS\");\n\t\tstrncpy(buf + 4, str, sizeof(buf) - 5);\n\t} else {\n\t\tstrncpy(buf, str, sizeof(buf) - 1);\n\t}\n\tbuf[sizeof(buf) - 1] = 0;\n\toptions = strchr(str, ',');\n\tif (options)\n\t\t*(options++) = 0;\n#ifdef __sparc__\n\tif (!strcmp(str, \"ttya\"))\n\t\tstrcpy(buf, \"ttyS0\");\n\tif (!strcmp(str, \"ttyb\"))\n\t\tstrcpy(buf, \"ttyS1\");\n#endif\n\tfor (s = buf; *s; s++)\n\t\tif (isdigit(*s) || *s == ',')\n\t\t\tbreak;\n\tidx = simple_strtoul(s, NULL, 10);\n\t*s = 0;\n\n\t__add_preferred_console(buf, idx, options, brl_options);\n\tconsole_set_on_cmdline = 1;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];",
      "int console_set_on_cmdline;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_preferred_console",
          "args": [
            "buf",
            "idx",
            "options",
            "brl_options"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "__add_preferred_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2057-2086",
          "snippet": "static int __add_preferred_console(char *name, int idx, char *options,\n\t\t\t\t   char *brl_options)\n{\n\tstruct console_cmdline *c;\n\tint i;\n\n\t/*\n\t *\tSee if this tty is not yet registered, and\n\t *\tif we have a slot free.\n\t */\n\tfor (i = 0, c = console_cmdline;\n\t     i < MAX_CMDLINECONSOLES && c->name[0];\n\t     i++, c++) {\n\t\tif (strcmp(c->name, name) == 0 && c->index == idx) {\n\t\t\tif (!brl_options)\n\t\t\t\tpreferred_console = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (i == MAX_CMDLINECONSOLES)\n\t\treturn -E2BIG;\n\tif (!brl_options)\n\t\tpreferred_console = i;\n\tstrlcpy(c->name, name, sizeof(c->name));\n\tc->options = options;\n\tbraille_set_options(c, brl_options);\n\n\tc->index = idx;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_CMDLINECONSOLES 8"
          ],
          "globals_used": [
            "static struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];",
            "static int preferred_console = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define MAX_CMDLINECONSOLES 8\n\nstatic struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];\nstatic int preferred_console = -1;\n\nstatic int __add_preferred_console(char *name, int idx, char *options,\n\t\t\t\t   char *brl_options)\n{\n\tstruct console_cmdline *c;\n\tint i;\n\n\t/*\n\t *\tSee if this tty is not yet registered, and\n\t *\tif we have a slot free.\n\t */\n\tfor (i = 0, c = console_cmdline;\n\t     i < MAX_CMDLINECONSOLES && c->name[0];\n\t     i++, c++) {\n\t\tif (strcmp(c->name, name) == 0 && c->index == idx) {\n\t\t\tif (!brl_options)\n\t\t\t\tpreferred_console = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (i == MAX_CMDLINECONSOLES)\n\t\treturn -E2BIG;\n\tif (!brl_options)\n\t\tpreferred_console = i;\n\tstrlcpy(c->name, name, sizeof(c->name));\n\tc->options = options;\n\tbraille_set_options(c, brl_options);\n\n\tc->index = idx;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "s",
            "NULL",
            "10"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*s"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buf",
            "\"ttyS1\""
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"ttyb\""
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buf",
            "\"ttyS0\""
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"ttya\""
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "','"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "buf",
            "str",
            "sizeof(buf) - 1"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "buf + 4",
            "str",
            "sizeof(buf) - 5"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buf",
            "\"ttyS\""
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_braille_console_setup",
          "args": [
            "&str",
            "&brl_options"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "_braille_console_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/braille.h",
          "lines": "36-40",
          "snippet": "static inline int\n_braille_console_setup(char **str, char **brl_options)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\n_braille_console_setup(char **str, char **brl_options)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];\nint console_set_on_cmdline;\n\nstatic int __init console_setup(char *str)\n{\n\tchar buf[sizeof(console_cmdline[0].name) + 4]; /* 4 for \"ttyS\" */\n\tchar *s, *options, *brl_options = NULL;\n\tint idx;\n\n\tif (_braille_console_setup(&str, &brl_options))\n\t\treturn 1;\n\n\t/*\n\t * Decode str into name, index, options.\n\t */\n\tif (str[0] >= '0' && str[0] <= '9') {\n\t\tstrcpy(buf, \"ttyS\");\n\t\tstrncpy(buf + 4, str, sizeof(buf) - 5);\n\t} else {\n\t\tstrncpy(buf, str, sizeof(buf) - 1);\n\t}\n\tbuf[sizeof(buf) - 1] = 0;\n\toptions = strchr(str, ',');\n\tif (options)\n\t\t*(options++) = 0;\n#ifdef __sparc__\n\tif (!strcmp(str, \"ttya\"))\n\t\tstrcpy(buf, \"ttyS0\");\n\tif (!strcmp(str, \"ttyb\"))\n\t\tstrcpy(buf, \"ttyS1\");\n#endif\n\tfor (s = buf; *s; s++)\n\t\tif (isdigit(*s) || *s == ',')\n\t\t\tbreak;\n\tidx = simple_strtoul(s, NULL, 10);\n\t*s = 0;\n\n\t__add_preferred_console(buf, idx, options, brl_options);\n\tconsole_set_on_cmdline = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "console_msg_format_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2088-2095",
    "snippet": "static int __init console_msg_format_setup(char *str)\n{\n\tif (!strcmp(str, \"syslog\"))\n\t\tconsole_msg_format = MSG_FORMAT_SYSLOG;\n\tif (!strcmp(str, \"default\"))\n\t\tconsole_msg_format = MSG_FORMAT_DEFAULT;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int console_msg_format = MSG_FORMAT_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"default\""
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"syslog\""
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_msg_format = MSG_FORMAT_DEFAULT;\n\nstatic int __init console_msg_format_setup(char *str)\n{\n\tif (!strcmp(str, \"syslog\"))\n\t\tconsole_msg_format = MSG_FORMAT_SYSLOG;\n\tif (!strcmp(str, \"default\"))\n\t\tconsole_msg_format = MSG_FORMAT_DEFAULT;\n\treturn 1;\n}"
  },
  {
    "function_name": "__add_preferred_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2057-2086",
    "snippet": "static int __add_preferred_console(char *name, int idx, char *options,\n\t\t\t\t   char *brl_options)\n{\n\tstruct console_cmdline *c;\n\tint i;\n\n\t/*\n\t *\tSee if this tty is not yet registered, and\n\t *\tif we have a slot free.\n\t */\n\tfor (i = 0, c = console_cmdline;\n\t     i < MAX_CMDLINECONSOLES && c->name[0];\n\t     i++, c++) {\n\t\tif (strcmp(c->name, name) == 0 && c->index == idx) {\n\t\t\tif (!brl_options)\n\t\t\t\tpreferred_console = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (i == MAX_CMDLINECONSOLES)\n\t\treturn -E2BIG;\n\tif (!brl_options)\n\t\tpreferred_console = i;\n\tstrlcpy(c->name, name, sizeof(c->name));\n\tc->options = options;\n\tbraille_set_options(c, brl_options);\n\n\tc->index = idx;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MAX_CMDLINECONSOLES 8"
    ],
    "globals_used": [
      "static struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];",
      "static int preferred_console = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "braille_set_options",
          "args": [
            "c",
            "brl_options"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "braille_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/braille.h",
          "lines": "31-34",
          "snippet": "static inline void\nbraille_set_options(struct console_cmdline *c, char *brl_options)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nbraille_set_options(struct console_cmdline *c, char *brl_options)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "c->name",
            "name",
            "sizeof(c->name)"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "c->name",
            "name"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define MAX_CMDLINECONSOLES 8\n\nstatic struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];\nstatic int preferred_console = -1;\n\nstatic int __add_preferred_console(char *name, int idx, char *options,\n\t\t\t\t   char *brl_options)\n{\n\tstruct console_cmdline *c;\n\tint i;\n\n\t/*\n\t *\tSee if this tty is not yet registered, and\n\t *\tif we have a slot free.\n\t */\n\tfor (i = 0, c = console_cmdline;\n\t     i < MAX_CMDLINECONSOLES && c->name[0];\n\t     i++, c++) {\n\t\tif (strcmp(c->name, name) == 0 && c->index == idx) {\n\t\t\tif (!brl_options)\n\t\t\t\tpreferred_console = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (i == MAX_CMDLINECONSOLES)\n\t\treturn -E2BIG;\n\tif (!brl_options)\n\t\tpreferred_console = i;\n\tstrlcpy(c->name, name, sizeof(c->name));\n\tc->options = options;\n\tbraille_set_options(c, brl_options);\n\n\tc->index = idx;\n\treturn 0;\n}"
  },
  {
    "function_name": "early_printk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2040-2054",
    "snippet": "void early_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[512];\n\tint n;\n\n\tif (!early_console)\n\t\treturn;\n\n\tva_start(ap, fmt);\n\tn = vscnprintf(buf, sizeof(buf), fmt, ap);\n\tva_end(ap);\n\n\tearly_console->write(early_console, buf, n);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "early_console->write",
          "args": [
            "early_console",
            "buf",
            "n"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vscnprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "fmt",
            "ap"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid early_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[512];\n\tint n;\n\n\tif (!early_console)\n\t\treturn;\n\n\tva_start(ap, fmt);\n\tn = vscnprintf(buf, sizeof(buf), fmt, ap);\n\tva_end(ap);\n\n\tearly_console->write(early_console, buf, n);\n}"
  },
  {
    "function_name": "suppress_message_printing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2033-2033",
    "snippet": "static bool suppress_message_printing(int level) { return false; }",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic bool suppress_message_printing(int level) { return false; }"
  },
  {
    "function_name": "msg_print_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2031-2032",
    "snippet": "static size_t msg_print_text(const struct printk_log *msg,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic size_t msg_print_text(const struct printk_log *msg,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }"
  },
  {
    "function_name": "call_console_drivers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2029-2030",
    "snippet": "static void call_console_drivers(const char *ext_text, size_t ext_len,\n\t\t\t\t const char *text, size_t len) {}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void call_console_drivers(const char *ext_text, size_t ext_len,\n\t\t\t\t const char *text, size_t len) {}"
  },
  {
    "function_name": "console_lock_spinning_disable_and_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2028-2028",
    "snippet": "static int console_lock_spinning_disable_and_check(void) { return 0; }",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_lock_spinning_disable_and_check(void) { return 0; }"
  },
  {
    "function_name": "console_lock_spinning_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2027-2027",
    "snippet": "static void console_lock_spinning_enable(void) { }",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void console_lock_spinning_enable(void) { }"
  },
  {
    "function_name": "msg_print_ext_body",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2024-2026",
    "snippet": "static ssize_t msg_print_ext_body(char *buf, size_t size,\n\t\t\t\t  char *dict, size_t dict_len,\n\t\t\t\t  char *text, size_t text_len) { return 0; }",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic ssize_t msg_print_ext_body(char *buf, size_t size,\n\t\t\t\t  char *dict, size_t dict_len,\n\t\t\t\t  char *text, size_t text_len) { return 0; }"
  },
  {
    "function_name": "msg_print_ext_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2021-2023",
    "snippet": "static ssize_t msg_print_ext_header(char *buf, size_t size,\n\t\t\t\t    struct printk_log *msg,\n\t\t\t\t    u64 seq) { return 0; }",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic ssize_t msg_print_ext_header(char *buf, size_t size,\n\t\t\t\t    struct printk_log *msg,\n\t\t\t\t    u64 seq) { return 0; }"
  },
  {
    "function_name": "log_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2020-2020",
    "snippet": "static u32 log_next(u32 idx) { return 0; }",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic u32 log_next(u32 idx) { return 0; }"
  },
  {
    "function_name": "log_from_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2019-2019",
    "snippet": "static struct printk_log *log_from_idx(u32 idx) { return NULL; }",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct printk_log *log_from_idx(u32 idx) { return NULL; }"
  },
  {
    "function_name": "log_dict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2018-2018",
    "snippet": "static char *log_dict(const struct printk_log *msg) { return NULL; }",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic char *log_dict(const struct printk_log *msg) { return NULL; }"
  },
  {
    "function_name": "log_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "2017-2017",
    "snippet": "static char *log_text(const struct printk_log *msg) { return NULL; }",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic char *log_text(const struct printk_log *msg) { return NULL; }"
  },
  {
    "function_name": "printk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1991-2001",
    "snippet": "int printk(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_func(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vprintk_func",
          "args": [
            "fmt",
            "args"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/internal.h",
          "lines": "66-66",
          "snippet": "int vprintk_func(const char *fmt, va_list args) { return 0; }",
          "includes": [
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu.h>\n\nint vprintk_func(const char *fmt, va_list args) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint printk(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_func(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
  },
  {
    "function_name": "vprintk_default",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1953-1967",
    "snippet": "int vprintk_default(const char *fmt, va_list args)\n{\n\tint r;\n\n#ifdef CONFIG_KGDB_KDB\n\t/* Allow to pass printk() to kdb but avoid a recursion. */\n\tif (unlikely(kdb_trap_printk && kdb_printf_cpu < 0)) {\n\t\tr = vkdb_printf(KDB_MSGSRC_PRINTK, fmt, args);\n\t\treturn r;\n\t}\n#endif\n\tr = vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);\n\n\treturn r;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vprintk_emit",
          "args": [
            "0",
            "LOGLEVEL_DEFAULT",
            "NULL",
            "0",
            "fmt",
            "args"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_emit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1884-1929",
          "snippet": "asmlinkage int vprintk_emit(int facility, int level,\n\t\t\t    const char *dict, size_t dictlen,\n\t\t\t    const char *fmt, va_list args)\n{\n\tint printed_len;\n\tbool in_sched = false, pending_output;\n\tunsigned long flags;\n\tu64 curr_log_seq;\n\n\tif (level == LOGLEVEL_SCHED) {\n\t\tlevel = LOGLEVEL_DEFAULT;\n\t\tin_sched = true;\n\t}\n\n\tboot_delay_msec(level);\n\tprintk_delay();\n\n\t/* This stops the holder of console_sem just where we want him */\n\tlogbuf_lock_irqsave(flags);\n\tcurr_log_seq = log_next_seq;\n\tprinted_len = vprintk_store(facility, level, dict, dictlen, fmt, args);\n\tpending_output = (curr_log_seq != log_next_seq);\n\tlogbuf_unlock_irqrestore(flags);\n\n\t/* If called from the scheduler, we can not call up(). */\n\tif (!in_sched && pending_output) {\n\t\t/*\n\t\t * Disable preemption to avoid being preempted while holding\n\t\t * console_sem which would prevent anyone from printing to\n\t\t * console\n\t\t */\n\t\tpreempt_disable();\n\t\t/*\n\t\t * Try to acquire and then immediately release the console\n\t\t * semaphore.  The release will print out buffers and wake up\n\t\t * /dev/kmsg and syslog() users.\n\t\t */\n\t\tif (console_trylock_spinning())\n\t\t\tconsole_unlock();\n\t\tpreempt_enable();\n\t}\n\n\tif (pending_output)\n\t\twake_up_klogd();\n\treturn printed_len;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SEMAPHORE(console_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SEMAPHORE(console_sem);\n\nasmlinkage int vprintk_emit(int facility, int level,\n\t\t\t    const char *dict, size_t dictlen,\n\t\t\t    const char *fmt, va_list args)\n{\n\tint printed_len;\n\tbool in_sched = false, pending_output;\n\tunsigned long flags;\n\tu64 curr_log_seq;\n\n\tif (level == LOGLEVEL_SCHED) {\n\t\tlevel = LOGLEVEL_DEFAULT;\n\t\tin_sched = true;\n\t}\n\n\tboot_delay_msec(level);\n\tprintk_delay();\n\n\t/* This stops the holder of console_sem just where we want him */\n\tlogbuf_lock_irqsave(flags);\n\tcurr_log_seq = log_next_seq;\n\tprinted_len = vprintk_store(facility, level, dict, dictlen, fmt, args);\n\tpending_output = (curr_log_seq != log_next_seq);\n\tlogbuf_unlock_irqrestore(flags);\n\n\t/* If called from the scheduler, we can not call up(). */\n\tif (!in_sched && pending_output) {\n\t\t/*\n\t\t * Disable preemption to avoid being preempted while holding\n\t\t * console_sem which would prevent anyone from printing to\n\t\t * console\n\t\t */\n\t\tpreempt_disable();\n\t\t/*\n\t\t * Try to acquire and then immediately release the console\n\t\t * semaphore.  The release will print out buffers and wake up\n\t\t * /dev/kmsg and syslog() users.\n\t\t */\n\t\tif (console_trylock_spinning())\n\t\t\tconsole_unlock();\n\t\tpreempt_enable();\n\t}\n\n\tif (pending_output)\n\t\twake_up_klogd();\n\treturn printed_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vkdb_printf",
          "args": [
            "KDB_MSGSRC_PRINTK",
            "fmt",
            "args"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "vkdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "552-850",
          "snippet": "int vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tint this_cpu, old_cpu;\n\tchar *cp, *cp2, *cphold = NULL, replaced_byte = ' ';\n\tchar *moreprompt = \"more> \";\n\tstruct console *c = console_drivers;\n\tunsigned long uninitialized_var(flags);\n\n\t/* Serialize kdb_printf if multiple cpus try to write at once.\n\t * But if any cpu goes recursive in kdb, just print the output,\n\t * even if it is interleaved with any other text.\n\t */\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\tfor (;;) {\n\t\told_cpu = cmpxchg(&kdb_printf_cpu, -1, this_cpu);\n\t\tif (old_cpu == -1 || old_cpu == this_cpu)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tdiag = kdbgetintenv(\"LINES\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"COLUMNS\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t/* normally, every vsnprintf starts a new buffer */\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t/*\n\t * If kdb_parse() found that the command was cmd xxx | grep yyy\n\t * then kdb_grepping_flag is set, and kdb_grep_string contains yyy\n\t *\n\t * Accumulate the print data up to a newline before searching it.\n\t * (vsnprintf does null-terminate the string that it generates)\n\t */\n\n\t/* skip the search if prints are temporarily unconditional */\n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t/*\n\t\t\t * Special cases that don't end with newlines\n\t\t\t * but should be written without one:\n\t\t\t *   The \"[nn]kdb> \" prompt should\n\t\t\t *   appear at the front of the buffer.\n\t\t\t *\n\t\t\t *   The \"[nn]more \" prompt should also be\n\t\t\t *     (MOREPROMPT -> moreprompt)\n\t\t\t *   written *   but we print that ourselves,\n\t\t\t *   we set the suspend_grep flag to make\n\t\t\t *   it unconditional.\n\t\t\t *\n\t\t\t */\n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t/*\n\t\t\t\t * these should occur after a newline,\n\t\t\t\t * so they will be at the front of the\n\t\t\t\t * buffer\n\t\t\t\t */\n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We're about to start a new\n\t\t\t\t\t * command, so we can go back\n\t\t\t\t\t * to normal mode.\n\t\t\t\t\t */\n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* no newline; don't search/write the buffer\n\t\t\t   until one is there */\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t/*\n\t\t * The newline is present; print through it or discard\n\t\t * it, depending on the results of the search.\n\t\t */\n\t\tcp++;\t \t     /* to byte after the newline */\n\t\treplaced_byte = *cp; /* remember what/where it was */\n\t\tcphold = cp;\n\t\t*cp = '\\0';\t     /* end the string for our search */\n\n\t\t/*\n\t\t * We now have a newline at the end of the string\n\t\t * Only continue with this output if it contains the\n\t\t * search string.\n\t\t */\n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t/*\n\t\t\t * At this point the complete line at the start\n\t\t\t * of kdb_buffer can be discarded, as it does\n\t\t\t * not contain what the user is looking for.\n\t\t\t * Shift the buffer left.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= KDB_GREPPING_FLAG_SEARCH)\n\t\t\t/*\n\t\t\t * This was a interactive search (using '/' at more\n\t\t\t * prompt) and it has completed. Clear the flag.\n\t\t\t */\n\t\t\tkdb_grepping_flag = 0;\n\t\t/*\n\t\t * at this point the string is a full line and\n\t\t * should be printed, up to the null.\n\t\t */\n\t}\nkdb_printit:\n\n\t/*\n\t * Write to all consoles.\n\t */\n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_headers(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected) {\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\t} else {\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = retlen - (cp - kdb_buffer);\n\t\t\tcp2 = cp;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp2);\n\t\t\t\tcp2++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, cp, retlen - (cp - kdb_buffer));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\t}\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n\t\tif (printk_get_level(kdb_buffer) || src == KDB_MSGSRC_PRINTK)\n\t\t\tprintk(\"%s\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"%s\", kdb_buffer);\n\t}\n\n\tif (KDB_STATE(PAGER)) {\n\t\t/*\n\t\t * Check printed string to decide how to bump the\n\t\t * kdb_nextline to control when the more prompt should\n\t\t * show up.\n\t\t */\n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t/* check for having reached the LINES number of printed lines */\n\tif (kdb_nextline >= linecount) {\n\t\tchar buf1[16] = \"\";\n\n\t\t/* Watch out for recursion here.  Any routine that calls\n\t\t * kdb_printf will come back through here.  And kdb_read\n\t\t * uses kdb_printf to echo on serial consoles ...\n\t\t */\n\t\tkdb_nextline = 1;\t/* In case of recursion */\n\n\t\t/*\n\t\t * Pause until cr.\n\t\t */\n\t\tmoreprompt = kdbgetenv(\"MOREPROMPT\");\n\t\tif (moreprompt == NULL)\n\t\t\tmoreprompt = \"more> \";\n\n\t\tkdb_input_flush();\n\t\tc = console_drivers;\n\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = strlen(moreprompt);\n\t\t\tcp = moreprompt;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, moreprompt, strlen(moreprompt));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\n\t\tif (logging)\n\t\t\tprintk(\"%s\", moreprompt);\n\n\t\tkdb_read(buf1, 2); /* '2' indicates to return\n\t\t\t\t    * immediately after getting one key. */\n\t\tkdb_nextline = 1;\t/* Really set output line 1 */\n\n\t\t/* empty and reset the buffer: */\n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((buf1[0] == 'q') || (buf1[0] == 'Q')) {\n\t\t\t/* user hit q or Q */\n\t\t\tKDB_FLAG_SET(CMD_INTERRUPT); /* command interrupted */\n\t\t\tKDB_STATE_CLEAR(PAGER);\n\t\t\t/* end of command output; back to normal mode */\n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t} else if (buf1[0] == ' ') {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] == '\\n') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_getstr(kdb_grep_string, KDB_GREP_STRLEN,\n\t\t\t\t   kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += KDB_GREPPING_FLAG_SEARCH;\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] && buf1[0] != '\\n') {\n\t\t\t/* user hit something other than enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tif (buf1[0] != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"\\nOnly 'q', 'Q' or '/' are processed at \"\n\t\t\t\t    \"more prompt, input ignored\\n\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"\\n'/' cannot be used during | \"\n\t\t\t\t\t   \"grep filtering, input ignored\\n\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t/* user hit enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t/*\n\t * For grep searches, shift the printed string left.\n\t *  replaced_byte contains the character that was overwritten with\n\t *  the terminating null, and cphold points to the null.\n\t * Then adjust the notion of available space in the buffer.\n\t */\n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0; /* end of what may have been a recursive call */\n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\t/* kdb_printf_cpu locked the code above. */\n\tsmp_store_release(&kdb_printf_cpu, old_cpu);\n\tlocal_irq_restore(flags);\n\treturn retlen;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char kdb_prompt_str[CMD_BUFLEN];",
            "int kdb_printf_cpu = -1;",
            "static char kdb_buffer[256];",
            "static char *next_avail = kdb_buffer;",
            "static int  size_avail;",
            "static int  suspend_grep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nchar kdb_prompt_str[CMD_BUFLEN];\nint kdb_printf_cpu = -1;\nstatic char kdb_buffer[256];\nstatic char *next_avail = kdb_buffer;\nstatic int  size_avail;\nstatic int  suspend_grep;\n\nint vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tint this_cpu, old_cpu;\n\tchar *cp, *cp2, *cphold = NULL, replaced_byte = ' ';\n\tchar *moreprompt = \"more> \";\n\tstruct console *c = console_drivers;\n\tunsigned long uninitialized_var(flags);\n\n\t/* Serialize kdb_printf if multiple cpus try to write at once.\n\t * But if any cpu goes recursive in kdb, just print the output,\n\t * even if it is interleaved with any other text.\n\t */\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\tfor (;;) {\n\t\told_cpu = cmpxchg(&kdb_printf_cpu, -1, this_cpu);\n\t\tif (old_cpu == -1 || old_cpu == this_cpu)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tdiag = kdbgetintenv(\"LINES\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"COLUMNS\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t/* normally, every vsnprintf starts a new buffer */\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t/*\n\t * If kdb_parse() found that the command was cmd xxx | grep yyy\n\t * then kdb_grepping_flag is set, and kdb_grep_string contains yyy\n\t *\n\t * Accumulate the print data up to a newline before searching it.\n\t * (vsnprintf does null-terminate the string that it generates)\n\t */\n\n\t/* skip the search if prints are temporarily unconditional */\n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t/*\n\t\t\t * Special cases that don't end with newlines\n\t\t\t * but should be written without one:\n\t\t\t *   The \"[nn]kdb> \" prompt should\n\t\t\t *   appear at the front of the buffer.\n\t\t\t *\n\t\t\t *   The \"[nn]more \" prompt should also be\n\t\t\t *     (MOREPROMPT -> moreprompt)\n\t\t\t *   written *   but we print that ourselves,\n\t\t\t *   we set the suspend_grep flag to make\n\t\t\t *   it unconditional.\n\t\t\t *\n\t\t\t */\n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t/*\n\t\t\t\t * these should occur after a newline,\n\t\t\t\t * so they will be at the front of the\n\t\t\t\t * buffer\n\t\t\t\t */\n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We're about to start a new\n\t\t\t\t\t * command, so we can go back\n\t\t\t\t\t * to normal mode.\n\t\t\t\t\t */\n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* no newline; don't search/write the buffer\n\t\t\t   until one is there */\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t/*\n\t\t * The newline is present; print through it or discard\n\t\t * it, depending on the results of the search.\n\t\t */\n\t\tcp++;\t \t     /* to byte after the newline */\n\t\treplaced_byte = *cp; /* remember what/where it was */\n\t\tcphold = cp;\n\t\t*cp = '\\0';\t     /* end the string for our search */\n\n\t\t/*\n\t\t * We now have a newline at the end of the string\n\t\t * Only continue with this output if it contains the\n\t\t * search string.\n\t\t */\n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t/*\n\t\t\t * At this point the complete line at the start\n\t\t\t * of kdb_buffer can be discarded, as it does\n\t\t\t * not contain what the user is looking for.\n\t\t\t * Shift the buffer left.\n\t\t\t */\n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= KDB_GREPPING_FLAG_SEARCH)\n\t\t\t/*\n\t\t\t * This was a interactive search (using '/' at more\n\t\t\t * prompt) and it has completed. Clear the flag.\n\t\t\t */\n\t\t\tkdb_grepping_flag = 0;\n\t\t/*\n\t\t * at this point the string is a full line and\n\t\t * should be printed, up to the null.\n\t\t */\n\t}\nkdb_printit:\n\n\t/*\n\t * Write to all consoles.\n\t */\n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_headers(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected) {\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\t} else {\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = retlen - (cp - kdb_buffer);\n\t\t\tcp2 = cp;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp2);\n\t\t\t\tcp2++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, cp, retlen - (cp - kdb_buffer));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\t}\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n\t\tif (printk_get_level(kdb_buffer) || src == KDB_MSGSRC_PRINTK)\n\t\t\tprintk(\"%s\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"%s\", kdb_buffer);\n\t}\n\n\tif (KDB_STATE(PAGER)) {\n\t\t/*\n\t\t * Check printed string to decide how to bump the\n\t\t * kdb_nextline to control when the more prompt should\n\t\t * show up.\n\t\t */\n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t/* check for having reached the LINES number of printed lines */\n\tif (kdb_nextline >= linecount) {\n\t\tchar buf1[16] = \"\";\n\n\t\t/* Watch out for recursion here.  Any routine that calls\n\t\t * kdb_printf will come back through here.  And kdb_read\n\t\t * uses kdb_printf to echo on serial consoles ...\n\t\t */\n\t\tkdb_nextline = 1;\t/* In case of recursion */\n\n\t\t/*\n\t\t * Pause until cr.\n\t\t */\n\t\tmoreprompt = kdbgetenv(\"MOREPROMPT\");\n\t\tif (moreprompt == NULL)\n\t\t\tmoreprompt = \"more> \";\n\n\t\tkdb_input_flush();\n\t\tc = console_drivers;\n\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = strlen(moreprompt);\n\t\t\tcp = moreprompt;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, moreprompt, strlen(moreprompt));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\n\t\tif (logging)\n\t\t\tprintk(\"%s\", moreprompt);\n\n\t\tkdb_read(buf1, 2); /* '2' indicates to return\n\t\t\t\t    * immediately after getting one key. */\n\t\tkdb_nextline = 1;\t/* Really set output line 1 */\n\n\t\t/* empty and reset the buffer: */\n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((buf1[0] == 'q') || (buf1[0] == 'Q')) {\n\t\t\t/* user hit q or Q */\n\t\t\tKDB_FLAG_SET(CMD_INTERRUPT); /* command interrupted */\n\t\t\tKDB_STATE_CLEAR(PAGER);\n\t\t\t/* end of command output; back to normal mode */\n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t} else if (buf1[0] == ' ') {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] == '\\n') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_getstr(kdb_grep_string, KDB_GREP_STRLEN,\n\t\t\t\t   kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += KDB_GREPPING_FLAG_SEARCH;\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t} else if (buf1[0] && buf1[0] != '\\n') {\n\t\t\t/* user hit something other than enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tif (buf1[0] != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"\\nOnly 'q', 'Q' or '/' are processed at \"\n\t\t\t\t    \"more prompt, input ignored\\n\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"\\n'/' cannot be used during | \"\n\t\t\t\t\t   \"grep filtering, input ignored\\n\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t/* user hit enter */\n\t\t\tsuspend_grep = 1; /* for this recursion */\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t/*\n\t * For grep searches, shift the printed string left.\n\t *  replaced_byte contains the character that was overwritten with\n\t *  the terminating null, and cphold points to the null.\n\t * Then adjust the notion of available space in the buffer.\n\t */\n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0; /* end of what may have been a recursive call */\n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\t/* kdb_printf_cpu locked the code above. */\n\tsmp_store_release(&kdb_printf_cpu, old_cpu);\n\tlocal_irq_restore(flags);\n\treturn retlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kdb_trap_printk && kdb_printf_cpu < 0"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint vprintk_default(const char *fmt, va_list args)\n{\n\tint r;\n\n#ifdef CONFIG_KGDB_KDB\n\t/* Allow to pass printk() to kdb but avoid a recursion. */\n\tif (unlikely(kdb_trap_printk && kdb_printf_cpu < 0)) {\n\t\tr = vkdb_printf(KDB_MSGSRC_PRINTK, fmt, args);\n\t\treturn r;\n\t}\n#endif\n\tr = vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);\n\n\treturn r;\n}"
  },
  {
    "function_name": "printk_emit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1938-1950",
    "snippet": "asmlinkage int printk_emit(int facility, int level,\n\t\t\t   const char *dict, size_t dictlen,\n\t\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_emit(facility, level, dict, dictlen, fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vprintk_emit",
          "args": [
            "facility",
            "level",
            "dict",
            "dictlen",
            "fmt",
            "args"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_emit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1884-1929",
          "snippet": "asmlinkage int vprintk_emit(int facility, int level,\n\t\t\t    const char *dict, size_t dictlen,\n\t\t\t    const char *fmt, va_list args)\n{\n\tint printed_len;\n\tbool in_sched = false, pending_output;\n\tunsigned long flags;\n\tu64 curr_log_seq;\n\n\tif (level == LOGLEVEL_SCHED) {\n\t\tlevel = LOGLEVEL_DEFAULT;\n\t\tin_sched = true;\n\t}\n\n\tboot_delay_msec(level);\n\tprintk_delay();\n\n\t/* This stops the holder of console_sem just where we want him */\n\tlogbuf_lock_irqsave(flags);\n\tcurr_log_seq = log_next_seq;\n\tprinted_len = vprintk_store(facility, level, dict, dictlen, fmt, args);\n\tpending_output = (curr_log_seq != log_next_seq);\n\tlogbuf_unlock_irqrestore(flags);\n\n\t/* If called from the scheduler, we can not call up(). */\n\tif (!in_sched && pending_output) {\n\t\t/*\n\t\t * Disable preemption to avoid being preempted while holding\n\t\t * console_sem which would prevent anyone from printing to\n\t\t * console\n\t\t */\n\t\tpreempt_disable();\n\t\t/*\n\t\t * Try to acquire and then immediately release the console\n\t\t * semaphore.  The release will print out buffers and wake up\n\t\t * /dev/kmsg and syslog() users.\n\t\t */\n\t\tif (console_trylock_spinning())\n\t\t\tconsole_unlock();\n\t\tpreempt_enable();\n\t}\n\n\tif (pending_output)\n\t\twake_up_klogd();\n\treturn printed_len;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SEMAPHORE(console_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SEMAPHORE(console_sem);\n\nasmlinkage int vprintk_emit(int facility, int level,\n\t\t\t    const char *dict, size_t dictlen,\n\t\t\t    const char *fmt, va_list args)\n{\n\tint printed_len;\n\tbool in_sched = false, pending_output;\n\tunsigned long flags;\n\tu64 curr_log_seq;\n\n\tif (level == LOGLEVEL_SCHED) {\n\t\tlevel = LOGLEVEL_DEFAULT;\n\t\tin_sched = true;\n\t}\n\n\tboot_delay_msec(level);\n\tprintk_delay();\n\n\t/* This stops the holder of console_sem just where we want him */\n\tlogbuf_lock_irqsave(flags);\n\tcurr_log_seq = log_next_seq;\n\tprinted_len = vprintk_store(facility, level, dict, dictlen, fmt, args);\n\tpending_output = (curr_log_seq != log_next_seq);\n\tlogbuf_unlock_irqrestore(flags);\n\n\t/* If called from the scheduler, we can not call up(). */\n\tif (!in_sched && pending_output) {\n\t\t/*\n\t\t * Disable preemption to avoid being preempted while holding\n\t\t * console_sem which would prevent anyone from printing to\n\t\t * console\n\t\t */\n\t\tpreempt_disable();\n\t\t/*\n\t\t * Try to acquire and then immediately release the console\n\t\t * semaphore.  The release will print out buffers and wake up\n\t\t * /dev/kmsg and syslog() users.\n\t\t */\n\t\tif (console_trylock_spinning())\n\t\t\tconsole_unlock();\n\t\tpreempt_enable();\n\t}\n\n\tif (pending_output)\n\t\twake_up_klogd();\n\treturn printed_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nasmlinkage int printk_emit(int facility, int level,\n\t\t\t   const char *dict, size_t dictlen,\n\t\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_emit(facility, level, dict, dictlen, fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
  },
  {
    "function_name": "vprintk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1932-1935",
    "snippet": "asmlinkage int vprintk(const char *fmt, va_list args)\n{\n\treturn vprintk_func(fmt, args);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vprintk_func",
          "args": [
            "fmt",
            "args"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/internal.h",
          "lines": "66-66",
          "snippet": "int vprintk_func(const char *fmt, va_list args) { return 0; }",
          "includes": [
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu.h>\n\nint vprintk_func(const char *fmt, va_list args) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nasmlinkage int vprintk(const char *fmt, va_list args)\n{\n\treturn vprintk_func(fmt, args);\n}"
  },
  {
    "function_name": "vprintk_emit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1884-1929",
    "snippet": "asmlinkage int vprintk_emit(int facility, int level,\n\t\t\t    const char *dict, size_t dictlen,\n\t\t\t    const char *fmt, va_list args)\n{\n\tint printed_len;\n\tbool in_sched = false, pending_output;\n\tunsigned long flags;\n\tu64 curr_log_seq;\n\n\tif (level == LOGLEVEL_SCHED) {\n\t\tlevel = LOGLEVEL_DEFAULT;\n\t\tin_sched = true;\n\t}\n\n\tboot_delay_msec(level);\n\tprintk_delay();\n\n\t/* This stops the holder of console_sem just where we want him */\n\tlogbuf_lock_irqsave(flags);\n\tcurr_log_seq = log_next_seq;\n\tprinted_len = vprintk_store(facility, level, dict, dictlen, fmt, args);\n\tpending_output = (curr_log_seq != log_next_seq);\n\tlogbuf_unlock_irqrestore(flags);\n\n\t/* If called from the scheduler, we can not call up(). */\n\tif (!in_sched && pending_output) {\n\t\t/*\n\t\t * Disable preemption to avoid being preempted while holding\n\t\t * console_sem which would prevent anyone from printing to\n\t\t * console\n\t\t */\n\t\tpreempt_disable();\n\t\t/*\n\t\t * Try to acquire and then immediately release the console\n\t\t * semaphore.  The release will print out buffers and wake up\n\t\t * /dev/kmsg and syslog() users.\n\t\t */\n\t\tif (console_trylock_spinning())\n\t\t\tconsole_unlock();\n\t\tpreempt_enable();\n\t}\n\n\tif (pending_output)\n\t\twake_up_klogd();\n\treturn printed_len;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SEMAPHORE(console_sem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_klogd",
          "args": [],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_klogd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2898-2906",
          "snippet": "void wake_up_klogd(void)\n{\n\tpreempt_disable();\n\tif (waitqueue_active(&log_wait)) {\n\t\tthis_cpu_or(printk_pending, PRINTK_PENDING_WAKEUP);\n\t\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\t}\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PRINTK_PENDING_WAKEUP\t0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PRINTK_PENDING_WAKEUP\t0x01\n\nvoid wake_up_klogd(void)\n{\n\tpreempt_disable();\n\tif (waitqueue_active(&log_wait)) {\n\t\tthis_cpu_or(printk_pending, PRINTK_PENDING_WAKEUP);\n\t\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\t}\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_unlock",
          "args": [],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "console_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2307-2447",
          "snippet": "void console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREFIX_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
            "#define PREFIX_MAX\t\t32"
          ],
          "globals_used": [
            "static DEFINE_SEMAPHORE(console_sem);",
            "static int nr_ext_console_drivers;",
            "static int console_locked, console_suspended;",
            "static struct console *exclusive_console;",
            "static int console_may_schedule;",
            "static int console_msg_format = MSG_FORMAT_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic DEFINE_SEMAPHORE(console_sem);\nstatic int nr_ext_console_drivers;\nstatic int console_locked, console_suspended;\nstatic struct console *exclusive_console;\nstatic int console_may_schedule;\nstatic int console_msg_format = MSG_FORMAT_DEFAULT;\n\nvoid console_unlock(void)\n{\n\tstatic char ext_text[CONSOLE_EXT_LOG_MAX];\n\tstatic char text[LOG_LINE_MAX + PREFIX_MAX];\n\tunsigned long flags;\n\tbool do_cond_resched, retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\t/*\n\t * Console drivers are called with interrupts disabled, so\n\t * @console_may_schedule should be cleared before; however, we may\n\t * end up dumping a lot of lines, for example, if called from\n\t * console registration path, and should invoke cond_resched()\n\t * between lines if allowable.  Not doing so can cause a very long\n\t * scheduling stall on a slow console leading to RCU stall and\n\t * softlockup warnings which exacerbate the issue with more\n\t * messages practically incapacitating the system.\n\t *\n\t * console_trylock() is not able to detect the preemptive\n\t * context reliably. Therefore the value must be stored before\n\t * and cleared after the the \"again\" goto label.\n\t */\n\tdo_cond_resched = console_may_schedule;\nagain:\n\tconsole_may_schedule = 0;\n\n\t/*\n\t * We released the console_sem lock, so we need to recheck if\n\t * cpu is online and (if not) is there at least one CON_ANYTIME\n\t * console.\n\t */\n\tif (!can_use_console()) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t ext_len = 0;\n\t\tsize_t len;\n\n\t\tprintk_safe_enter_irqsave(flags);\n\t\traw_spin_lock(&logbuf_lock);\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text,\n\t\t\t\t      \"** %llu printk messages dropped **\\n\",\n\t\t\t\t      log_first_seq - console_seq);\n\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (suppress_message_printing(msg->level)) {\n\t\t\t/*\n\t\t\t * Skip record we have buffered and already printed\n\t\t\t * directly to the console when we received it, and\n\t\t\t * record that has level above the console loglevel.\n\t\t\t */\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Output to all consoles once old messages replayed. */\n\t\tif (unlikely(exclusive_console &&\n\t\t\t     console_seq >= exclusive_console_stop_seq)) {\n\t\t\texclusive_console = NULL;\n\t\t}\n\n\t\tlen += msg_print_text(msg,\n\t\t\t\tconsole_msg_format & MSG_FORMAT_SYSLOG,\n\t\t\t\ttext + len,\n\t\t\t\tsizeof(text) - len);\n\t\tif (nr_ext_console_drivers) {\n\t\t\text_len = msg_print_ext_header(ext_text,\n\t\t\t\t\t\tsizeof(ext_text),\n\t\t\t\t\t\tmsg, console_seq);\n\t\t\text_len += msg_print_ext_body(ext_text + ext_len,\n\t\t\t\t\t\tsizeof(ext_text) - ext_len,\n\t\t\t\t\t\tlog_dict(msg), msg->dict_len,\n\t\t\t\t\t\tlog_text(msg), msg->text_len);\n\t\t}\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\t/*\n\t\t * While actively printing out messages, if another printk()\n\t\t * were to occur on another CPU, it may wait for this one to\n\t\t * finish. This task can not be preempted if there is a\n\t\t * waiter waiting to take over.\n\t\t */\n\t\tconsole_lock_spinning_enable();\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(ext_text, ext_len, text, len);\n\t\tstart_critical_timings();\n\n\t\tif (console_lock_spinning_disable_and_check()) {\n\t\t\tprintk_safe_exit_irqrestore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk_safe_exit_irqrestore(flags);\n\n\t\tif (do_cond_resched)\n\t\t\tcond_resched();\n\t}\n\n\tconsole_locked = 0;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock(&logbuf_lock);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "console_trylock_spinning",
          "args": [],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "console_trylock_spinning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1646-1698",
          "snippet": "static int console_trylock_spinning(void)\n{\n\tstruct task_struct *owner = NULL;\n\tbool waiter;\n\tbool spin = false;\n\tunsigned long flags;\n\n\tif (console_trylock())\n\t\treturn 1;\n\n\tprintk_safe_enter_irqsave(flags);\n\n\traw_spin_lock(&console_owner_lock);\n\towner = READ_ONCE(console_owner);\n\twaiter = READ_ONCE(console_waiter);\n\tif (!waiter && owner && owner != current) {\n\t\tWRITE_ONCE(console_waiter, true);\n\t\tspin = true;\n\t}\n\traw_spin_unlock(&console_owner_lock);\n\n\t/*\n\t * If there is an active printk() writing to the\n\t * consoles, instead of having it write our data too,\n\t * see if we can offload that load from the active\n\t * printer, and do some printing ourselves.\n\t * Go into a spin only if there isn't already a waiter\n\t * spinning, and there is an active printer, and\n\t * that active printer isn't us (recursive printk?).\n\t */\n\tif (!spin) {\n\t\tprintk_safe_exit_irqrestore(flags);\n\t\treturn 0;\n\t}\n\n\t/* We spin waiting for the owner to release us */\n\tspin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);\n\t/* Owner will clear console_waiter on hand off */\n\twhile (READ_ONCE(console_waiter))\n\t\tcpu_relax();\n\tspin_release(&console_owner_dep_map, 1, _THIS_IP_);\n\n\tprintk_safe_exit_irqrestore(flags);\n\t/*\n\t * The owner passed the console lock to us.\n\t * Since we did not spin on console lock, annotate\n\t * this as a trylock. Otherwise lockdep will\n\t * complain.\n\t */\n\tmutex_acquire(&console_lock_dep_map, 0, 1, _THIS_IP_);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_trylock_spinning(void)\n{\n\tstruct task_struct *owner = NULL;\n\tbool waiter;\n\tbool spin = false;\n\tunsigned long flags;\n\n\tif (console_trylock())\n\t\treturn 1;\n\n\tprintk_safe_enter_irqsave(flags);\n\n\traw_spin_lock(&console_owner_lock);\n\towner = READ_ONCE(console_owner);\n\twaiter = READ_ONCE(console_waiter);\n\tif (!waiter && owner && owner != current) {\n\t\tWRITE_ONCE(console_waiter, true);\n\t\tspin = true;\n\t}\n\traw_spin_unlock(&console_owner_lock);\n\n\t/*\n\t * If there is an active printk() writing to the\n\t * consoles, instead of having it write our data too,\n\t * see if we can offload that load from the active\n\t * printer, and do some printing ourselves.\n\t * Go into a spin only if there isn't already a waiter\n\t * spinning, and there is an active printer, and\n\t * that active printer isn't us (recursive printk?).\n\t */\n\tif (!spin) {\n\t\tprintk_safe_exit_irqrestore(flags);\n\t\treturn 0;\n\t}\n\n\t/* We spin waiting for the owner to release us */\n\tspin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);\n\t/* Owner will clear console_waiter on hand off */\n\twhile (READ_ONCE(console_waiter))\n\t\tcpu_relax();\n\tspin_release(&console_owner_dep_map, 1, _THIS_IP_);\n\n\tprintk_safe_exit_irqrestore(flags);\n\t/*\n\t * The owner passed the console lock to us.\n\t * Since we did not spin on console lock, annotate\n\t * this as a trylock. Otherwise lockdep will\n\t * complain.\n\t */\n\tmutex_acquire(&console_lock_dep_map, 0, 1, _THIS_IP_);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_unlock_irqrestore",
          "args": [
            "flags"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vprintk_store",
          "args": [
            "facility",
            "level",
            "dict",
            "dictlen",
            "fmt",
            "args"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1831-1882",
          "snippet": "int vprintk_store(int facility, int level,\n\t\t  const char *dict, size_t dictlen,\n\t\t  const char *fmt, va_list args)\n{\n\tstatic char textbuf[LOG_LINE_MAX];\n\tchar *text = textbuf;\n\tsize_t text_len;\n\tenum log_flags lflags = 0;\n\n\t/*\n\t * The printf needs to come first; we need the syslog\n\t * prefix which might be passed-in as a parameter.\n\t */\n\ttext_len = vscnprintf(text, sizeof(textbuf), fmt, args);\n\n\t/* mark and strip a trailing newline */\n\tif (text_len && text[text_len-1] == '\\n') {\n\t\ttext_len--;\n\t\tlflags |= LOG_NEWLINE;\n\t}\n\n\t/* strip kernel syslog prefix and extract log level or control flags */\n\tif (facility == 0) {\n\t\tint kern_level;\n\n\t\twhile ((kern_level = printk_get_level(text)) != 0) {\n\t\t\tswitch (kern_level) {\n\t\t\tcase '0' ... '7':\n\t\t\t\tif (level == LOGLEVEL_DEFAULT)\n\t\t\t\t\tlevel = kern_level - '0';\n\t\t\t\t/* fallthrough */\n\t\t\tcase 'd':\t/* KERN_DEFAULT */\n\t\t\t\tlflags |= LOG_PREFIX;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\t/* KERN_CONT */\n\t\t\t\tlflags |= LOG_CONT;\n\t\t\t}\n\n\t\t\ttext_len -= 2;\n\t\t\ttext += 2;\n\t\t}\n\t}\n\n\tif (level == LOGLEVEL_DEFAULT)\n\t\tlevel = default_message_loglevel;\n\n\tif (dict)\n\t\tlflags |= LOG_PREFIX|LOG_NEWLINE;\n\n\treturn log_output(facility, level, lflags,\n\t\t\t  dict, dictlen, text, text_len);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n\nint vprintk_store(int facility, int level,\n\t\t  const char *dict, size_t dictlen,\n\t\t  const char *fmt, va_list args)\n{\n\tstatic char textbuf[LOG_LINE_MAX];\n\tchar *text = textbuf;\n\tsize_t text_len;\n\tenum log_flags lflags = 0;\n\n\t/*\n\t * The printf needs to come first; we need the syslog\n\t * prefix which might be passed-in as a parameter.\n\t */\n\ttext_len = vscnprintf(text, sizeof(textbuf), fmt, args);\n\n\t/* mark and strip a trailing newline */\n\tif (text_len && text[text_len-1] == '\\n') {\n\t\ttext_len--;\n\t\tlflags |= LOG_NEWLINE;\n\t}\n\n\t/* strip kernel syslog prefix and extract log level or control flags */\n\tif (facility == 0) {\n\t\tint kern_level;\n\n\t\twhile ((kern_level = printk_get_level(text)) != 0) {\n\t\t\tswitch (kern_level) {\n\t\t\tcase '0' ... '7':\n\t\t\t\tif (level == LOGLEVEL_DEFAULT)\n\t\t\t\t\tlevel = kern_level - '0';\n\t\t\t\t/* fallthrough */\n\t\t\tcase 'd':\t/* KERN_DEFAULT */\n\t\t\t\tlflags |= LOG_PREFIX;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\t/* KERN_CONT */\n\t\t\t\tlflags |= LOG_CONT;\n\t\t\t}\n\n\t\t\ttext_len -= 2;\n\t\t\ttext += 2;\n\t\t}\n\t}\n\n\tif (level == LOGLEVEL_DEFAULT)\n\t\tlevel = default_message_loglevel;\n\n\tif (dict)\n\t\tlflags |= LOG_PREFIX|LOG_NEWLINE;\n\n\treturn log_output(facility, level, lflags,\n\t\t\t  dict, dictlen, text, text_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irqsave",
          "args": [
            "flags"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_delay",
          "args": [],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "printk_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1734-1744",
          "snippet": "static inline void printk_delay(void)\n{\n\tif (unlikely(printk_delay_msec)) {\n\t\tint m = printk_delay_msec;\n\n\t\twhile (m--) {\n\t\t\tmdelay(1);\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic inline void printk_delay(void)\n{\n\tif (unlikely(printk_delay_msec)) {\n\t\tint m = printk_delay_msec;\n\n\t\twhile (m--) {\n\t\t\tmdelay(1);\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_delay_msec",
          "args": [
            "level"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "boot_delay_msec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1208-1210",
          "snippet": "static inline void boot_delay_msec(int level)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic inline void boot_delay_msec(int level)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SEMAPHORE(console_sem);\n\nasmlinkage int vprintk_emit(int facility, int level,\n\t\t\t    const char *dict, size_t dictlen,\n\t\t\t    const char *fmt, va_list args)\n{\n\tint printed_len;\n\tbool in_sched = false, pending_output;\n\tunsigned long flags;\n\tu64 curr_log_seq;\n\n\tif (level == LOGLEVEL_SCHED) {\n\t\tlevel = LOGLEVEL_DEFAULT;\n\t\tin_sched = true;\n\t}\n\n\tboot_delay_msec(level);\n\tprintk_delay();\n\n\t/* This stops the holder of console_sem just where we want him */\n\tlogbuf_lock_irqsave(flags);\n\tcurr_log_seq = log_next_seq;\n\tprinted_len = vprintk_store(facility, level, dict, dictlen, fmt, args);\n\tpending_output = (curr_log_seq != log_next_seq);\n\tlogbuf_unlock_irqrestore(flags);\n\n\t/* If called from the scheduler, we can not call up(). */\n\tif (!in_sched && pending_output) {\n\t\t/*\n\t\t * Disable preemption to avoid being preempted while holding\n\t\t * console_sem which would prevent anyone from printing to\n\t\t * console\n\t\t */\n\t\tpreempt_disable();\n\t\t/*\n\t\t * Try to acquire and then immediately release the console\n\t\t * semaphore.  The release will print out buffers and wake up\n\t\t * /dev/kmsg and syslog() users.\n\t\t */\n\t\tif (console_trylock_spinning())\n\t\t\tconsole_unlock();\n\t\tpreempt_enable();\n\t}\n\n\tif (pending_output)\n\t\twake_up_klogd();\n\treturn printed_len;\n}"
  },
  {
    "function_name": "vprintk_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1831-1882",
    "snippet": "int vprintk_store(int facility, int level,\n\t\t  const char *dict, size_t dictlen,\n\t\t  const char *fmt, va_list args)\n{\n\tstatic char textbuf[LOG_LINE_MAX];\n\tchar *text = textbuf;\n\tsize_t text_len;\n\tenum log_flags lflags = 0;\n\n\t/*\n\t * The printf needs to come first; we need the syslog\n\t * prefix which might be passed-in as a parameter.\n\t */\n\ttext_len = vscnprintf(text, sizeof(textbuf), fmt, args);\n\n\t/* mark and strip a trailing newline */\n\tif (text_len && text[text_len-1] == '\\n') {\n\t\ttext_len--;\n\t\tlflags |= LOG_NEWLINE;\n\t}\n\n\t/* strip kernel syslog prefix and extract log level or control flags */\n\tif (facility == 0) {\n\t\tint kern_level;\n\n\t\twhile ((kern_level = printk_get_level(text)) != 0) {\n\t\t\tswitch (kern_level) {\n\t\t\tcase '0' ... '7':\n\t\t\t\tif (level == LOGLEVEL_DEFAULT)\n\t\t\t\t\tlevel = kern_level - '0';\n\t\t\t\t/* fallthrough */\n\t\t\tcase 'd':\t/* KERN_DEFAULT */\n\t\t\t\tlflags |= LOG_PREFIX;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\t/* KERN_CONT */\n\t\t\t\tlflags |= LOG_CONT;\n\t\t\t}\n\n\t\t\ttext_len -= 2;\n\t\t\ttext += 2;\n\t\t}\n\t}\n\n\tif (level == LOGLEVEL_DEFAULT)\n\t\tlevel = default_message_loglevel;\n\n\tif (dict)\n\t\tlflags |= LOG_PREFIX|LOG_NEWLINE;\n\n\treturn log_output(facility, level, lflags,\n\t\t\t  dict, dictlen, text, text_len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define LOG_LINE_MAX\t\t0",
      "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_output",
          "args": [
            "facility",
            "level",
            "lflags",
            "dict",
            "dictlen",
            "text",
            "text_len"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "log_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1801-1828",
          "snippet": "static size_t log_output(int facility, int level, enum log_flags lflags, const char *dict, size_t dictlen, char *text, size_t text_len)\n{\n\t/*\n\t * If an earlier line was buffered, and we're a continuation\n\t * write from the same process, try to add it to the buffer.\n\t */\n\tif (cont.len) {\n\t\tif (cont.owner == current && (lflags & LOG_CONT)) {\n\t\t\tif (cont_add(facility, level, lflags, text, text_len))\n\t\t\t\treturn text_len;\n\t\t}\n\t\t/* Otherwise, make sure it's flushed */\n\t\tcont_flush();\n\t}\n\n\t/* Skip empty continuation lines that couldn't be added - they just flush */\n\tif (!text_len && (lflags & LOG_CONT))\n\t\treturn 0;\n\n\t/* If it doesn't end in a newline, try to buffer the current line */\n\tif (!(lflags & LOG_NEWLINE)) {\n\t\tif (cont_add(facility, level, lflags, text, text_len))\n\t\t\treturn text_len;\n\t}\n\n\t/* Store it in the record log */\n\treturn log_store(facility, level, lflags, 0, dict, dictlen, text, text_len);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic size_t log_output(int facility, int level, enum log_flags lflags, const char *dict, size_t dictlen, char *text, size_t text_len)\n{\n\t/*\n\t * If an earlier line was buffered, and we're a continuation\n\t * write from the same process, try to add it to the buffer.\n\t */\n\tif (cont.len) {\n\t\tif (cont.owner == current && (lflags & LOG_CONT)) {\n\t\t\tif (cont_add(facility, level, lflags, text, text_len))\n\t\t\t\treturn text_len;\n\t\t}\n\t\t/* Otherwise, make sure it's flushed */\n\t\tcont_flush();\n\t}\n\n\t/* Skip empty continuation lines that couldn't be added - they just flush */\n\tif (!text_len && (lflags & LOG_CONT))\n\t\treturn 0;\n\n\t/* If it doesn't end in a newline, try to buffer the current line */\n\tif (!(lflags & LOG_NEWLINE)) {\n\t\tif (cont_add(facility, level, lflags, text, text_len))\n\t\t\treturn text_len;\n\t}\n\n\t/* Store it in the record log */\n\treturn log_store(facility, level, lflags, 0, dict, dictlen, text, text_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_get_level",
          "args": [
            "text"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vscnprintf",
          "args": [
            "text",
            "sizeof(textbuf)",
            "fmt",
            "args"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n\nint vprintk_store(int facility, int level,\n\t\t  const char *dict, size_t dictlen,\n\t\t  const char *fmt, va_list args)\n{\n\tstatic char textbuf[LOG_LINE_MAX];\n\tchar *text = textbuf;\n\tsize_t text_len;\n\tenum log_flags lflags = 0;\n\n\t/*\n\t * The printf needs to come first; we need the syslog\n\t * prefix which might be passed-in as a parameter.\n\t */\n\ttext_len = vscnprintf(text, sizeof(textbuf), fmt, args);\n\n\t/* mark and strip a trailing newline */\n\tif (text_len && text[text_len-1] == '\\n') {\n\t\ttext_len--;\n\t\tlflags |= LOG_NEWLINE;\n\t}\n\n\t/* strip kernel syslog prefix and extract log level or control flags */\n\tif (facility == 0) {\n\t\tint kern_level;\n\n\t\twhile ((kern_level = printk_get_level(text)) != 0) {\n\t\t\tswitch (kern_level) {\n\t\t\tcase '0' ... '7':\n\t\t\t\tif (level == LOGLEVEL_DEFAULT)\n\t\t\t\t\tlevel = kern_level - '0';\n\t\t\t\t/* fallthrough */\n\t\t\tcase 'd':\t/* KERN_DEFAULT */\n\t\t\t\tlflags |= LOG_PREFIX;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\t/* KERN_CONT */\n\t\t\t\tlflags |= LOG_CONT;\n\t\t\t}\n\n\t\t\ttext_len -= 2;\n\t\t\ttext += 2;\n\t\t}\n\t}\n\n\tif (level == LOGLEVEL_DEFAULT)\n\t\tlevel = default_message_loglevel;\n\n\tif (dict)\n\t\tlflags |= LOG_PREFIX|LOG_NEWLINE;\n\n\treturn log_output(facility, level, lflags,\n\t\t\t  dict, dictlen, text, text_len);\n}"
  },
  {
    "function_name": "log_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1801-1828",
    "snippet": "static size_t log_output(int facility, int level, enum log_flags lflags, const char *dict, size_t dictlen, char *text, size_t text_len)\n{\n\t/*\n\t * If an earlier line was buffered, and we're a continuation\n\t * write from the same process, try to add it to the buffer.\n\t */\n\tif (cont.len) {\n\t\tif (cont.owner == current && (lflags & LOG_CONT)) {\n\t\t\tif (cont_add(facility, level, lflags, text, text_len))\n\t\t\t\treturn text_len;\n\t\t}\n\t\t/* Otherwise, make sure it's flushed */\n\t\tcont_flush();\n\t}\n\n\t/* Skip empty continuation lines that couldn't be added - they just flush */\n\tif (!text_len && (lflags & LOG_CONT))\n\t\treturn 0;\n\n\t/* If it doesn't end in a newline, try to buffer the current line */\n\tif (!(lflags & LOG_NEWLINE)) {\n\t\tif (cont_add(facility, level, lflags, text, text_len))\n\t\t\treturn text_len;\n\t}\n\n\t/* Store it in the record log */\n\treturn log_store(facility, level, lflags, 0, dict, dictlen, text, text_len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_store",
          "args": [
            "facility",
            "level",
            "lflags",
            "0",
            "dict",
            "dictlen",
            "text",
            "text_len"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "log_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "579-635",
          "snippet": "static int log_store(int facility, int level,\n\t\t     enum log_flags flags, u64 ts_nsec,\n\t\t     const char *dict, u16 dict_len,\n\t\t     const char *text, u16 text_len)\n{\n\tstruct printk_log *msg;\n\tu32 size, pad_len;\n\tu16 trunc_msg_len = 0;\n\n\t/* number of '\\0' padding bytes to next message */\n\tsize = msg_used_size(text_len, dict_len, &pad_len);\n\n\tif (log_make_free_space(size)) {\n\t\t/* truncate the message if it is too long for empty buffer */\n\t\tsize = truncate_msg(&text_len, &trunc_msg_len,\n\t\t\t\t    &dict_len, &pad_len);\n\t\t/* survive when the log buffer is too small for trunc_msg */\n\t\tif (log_make_free_space(size))\n\t\t\treturn 0;\n\t}\n\n\tif (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {\n\t\t/*\n\t\t * This message + an additional empty header does not fit\n\t\t * at the end of the buffer. Add an empty header with len == 0\n\t\t * to signify a wrap around.\n\t\t */\n\t\tmemset(log_buf + log_next_idx, 0, sizeof(struct printk_log));\n\t\tlog_next_idx = 0;\n\t}\n\n\t/* fill message */\n\tmsg = (struct printk_log *)(log_buf + log_next_idx);\n\tmemcpy(log_text(msg), text, text_len);\n\tmsg->text_len = text_len;\n\tif (trunc_msg_len) {\n\t\tmemcpy(log_text(msg) + text_len, trunc_msg, trunc_msg_len);\n\t\tmsg->text_len += trunc_msg_len;\n\t}\n\tmemcpy(log_dict(msg), dict, dict_len);\n\tmsg->dict_len = dict_len;\n\tmsg->facility = facility;\n\tmsg->level = level & 7;\n\tmsg->flags = flags & 0x1f;\n\tif (ts_nsec > 0)\n\t\tmsg->ts_nsec = ts_nsec;\n\telse\n\t\tmsg->ts_nsec = local_clock();\n\tmemset(log_dict(msg) + dict_len, 0, pad_len);\n\tmsg->len = size;\n\n\t/* insert message */\n\tlog_next_idx += msg->len;\n\tlog_next_seq++;\n\n\treturn msg->text_len;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int log_store(int facility, int level,\n\t\t     enum log_flags flags, u64 ts_nsec,\n\t\t     const char *dict, u16 dict_len,\n\t\t     const char *text, u16 text_len)\n{\n\tstruct printk_log *msg;\n\tu32 size, pad_len;\n\tu16 trunc_msg_len = 0;\n\n\t/* number of '\\0' padding bytes to next message */\n\tsize = msg_used_size(text_len, dict_len, &pad_len);\n\n\tif (log_make_free_space(size)) {\n\t\t/* truncate the message if it is too long for empty buffer */\n\t\tsize = truncate_msg(&text_len, &trunc_msg_len,\n\t\t\t\t    &dict_len, &pad_len);\n\t\t/* survive when the log buffer is too small for trunc_msg */\n\t\tif (log_make_free_space(size))\n\t\t\treturn 0;\n\t}\n\n\tif (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {\n\t\t/*\n\t\t * This message + an additional empty header does not fit\n\t\t * at the end of the buffer. Add an empty header with len == 0\n\t\t * to signify a wrap around.\n\t\t */\n\t\tmemset(log_buf + log_next_idx, 0, sizeof(struct printk_log));\n\t\tlog_next_idx = 0;\n\t}\n\n\t/* fill message */\n\tmsg = (struct printk_log *)(log_buf + log_next_idx);\n\tmemcpy(log_text(msg), text, text_len);\n\tmsg->text_len = text_len;\n\tif (trunc_msg_len) {\n\t\tmemcpy(log_text(msg) + text_len, trunc_msg, trunc_msg_len);\n\t\tmsg->text_len += trunc_msg_len;\n\t}\n\tmemcpy(log_dict(msg), dict, dict_len);\n\tmsg->dict_len = dict_len;\n\tmsg->facility = facility;\n\tmsg->level = level & 7;\n\tmsg->flags = flags & 0x1f;\n\tif (ts_nsec > 0)\n\t\tmsg->ts_nsec = ts_nsec;\n\telse\n\t\tmsg->ts_nsec = local_clock();\n\tmemset(log_dict(msg) + dict_len, 0, pad_len);\n\tmsg->len = size;\n\n\t/* insert message */\n\tlog_next_idx += msg->len;\n\tlog_next_seq++;\n\n\treturn msg->text_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cont_add",
          "args": [
            "facility",
            "level",
            "lflags",
            "text",
            "text_len"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "cont_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1772-1799",
          "snippet": "static bool cont_add(int facility, int level, enum log_flags flags, const char *text, size_t len)\n{\n\t/* If the line gets too long, split it up in separate records. */\n\tif (cont.len + len > sizeof(cont.buf)) {\n\t\tcont_flush();\n\t\treturn false;\n\t}\n\n\tif (!cont.len) {\n\t\tcont.facility = facility;\n\t\tcont.level = level;\n\t\tcont.owner = current;\n\t\tcont.ts_nsec = local_clock();\n\t\tcont.flags = flags;\n\t}\n\n\tmemcpy(cont.buf + cont.len, text, len);\n\tcont.len += len;\n\n\t// The original flags come from the first line,\n\t// but later continuations can add a newline.\n\tif (flags & LOG_NEWLINE) {\n\t\tcont.flags |= LOG_NEWLINE;\n\t\tcont_flush();\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic bool cont_add(int facility, int level, enum log_flags flags, const char *text, size_t len)\n{\n\t/* If the line gets too long, split it up in separate records. */\n\tif (cont.len + len > sizeof(cont.buf)) {\n\t\tcont_flush();\n\t\treturn false;\n\t}\n\n\tif (!cont.len) {\n\t\tcont.facility = facility;\n\t\tcont.level = level;\n\t\tcont.owner = current;\n\t\tcont.ts_nsec = local_clock();\n\t\tcont.flags = flags;\n\t}\n\n\tmemcpy(cont.buf + cont.len, text, len);\n\tcont.len += len;\n\n\t// The original flags come from the first line,\n\t// but later continuations can add a newline.\n\tif (flags & LOG_NEWLINE) {\n\t\tcont.flags |= LOG_NEWLINE;\n\t\tcont_flush();\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cont_flush",
          "args": [],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "cont_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1762-1770",
          "snippet": "static void cont_flush(void)\n{\n\tif (cont.len == 0)\n\t\treturn;\n\n\tlog_store(cont.facility, cont.level, cont.flags, cont.ts_nsec,\n\t\t  NULL, 0, cont.buf, cont.len);\n\tcont.len = 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void cont_flush(void)\n{\n\tif (cont.len == 0)\n\t\treturn;\n\n\tlog_store(cont.facility, cont.level, cont.flags, cont.ts_nsec,\n\t\t  NULL, 0, cont.buf, cont.len);\n\tcont.len = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic size_t log_output(int facility, int level, enum log_flags lflags, const char *dict, size_t dictlen, char *text, size_t text_len)\n{\n\t/*\n\t * If an earlier line was buffered, and we're a continuation\n\t * write from the same process, try to add it to the buffer.\n\t */\n\tif (cont.len) {\n\t\tif (cont.owner == current && (lflags & LOG_CONT)) {\n\t\t\tif (cont_add(facility, level, lflags, text, text_len))\n\t\t\t\treturn text_len;\n\t\t}\n\t\t/* Otherwise, make sure it's flushed */\n\t\tcont_flush();\n\t}\n\n\t/* Skip empty continuation lines that couldn't be added - they just flush */\n\tif (!text_len && (lflags & LOG_CONT))\n\t\treturn 0;\n\n\t/* If it doesn't end in a newline, try to buffer the current line */\n\tif (!(lflags & LOG_NEWLINE)) {\n\t\tif (cont_add(facility, level, lflags, text, text_len))\n\t\t\treturn text_len;\n\t}\n\n\t/* Store it in the record log */\n\treturn log_store(facility, level, lflags, 0, dict, dictlen, text, text_len);\n}"
  },
  {
    "function_name": "cont_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1772-1799",
    "snippet": "static bool cont_add(int facility, int level, enum log_flags flags, const char *text, size_t len)\n{\n\t/* If the line gets too long, split it up in separate records. */\n\tif (cont.len + len > sizeof(cont.buf)) {\n\t\tcont_flush();\n\t\treturn false;\n\t}\n\n\tif (!cont.len) {\n\t\tcont.facility = facility;\n\t\tcont.level = level;\n\t\tcont.owner = current;\n\t\tcont.ts_nsec = local_clock();\n\t\tcont.flags = flags;\n\t}\n\n\tmemcpy(cont.buf + cont.len, text, len);\n\tcont.len += len;\n\n\t// The original flags come from the first line,\n\t// but later continuations can add a newline.\n\tif (flags & LOG_NEWLINE) {\n\t\tcont.flags |= LOG_NEWLINE;\n\t\tcont_flush();\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cont_flush",
          "args": [],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "cont_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1762-1770",
          "snippet": "static void cont_flush(void)\n{\n\tif (cont.len == 0)\n\t\treturn;\n\n\tlog_store(cont.facility, cont.level, cont.flags, cont.ts_nsec,\n\t\t  NULL, 0, cont.buf, cont.len);\n\tcont.len = 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void cont_flush(void)\n{\n\tif (cont.len == 0)\n\t\treturn;\n\n\tlog_store(cont.facility, cont.level, cont.flags, cont.ts_nsec,\n\t\t  NULL, 0, cont.buf, cont.len);\n\tcont.len = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cont.buf + cont.len",
            "text",
            "len"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_clock",
          "args": [],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic bool cont_add(int facility, int level, enum log_flags flags, const char *text, size_t len)\n{\n\t/* If the line gets too long, split it up in separate records. */\n\tif (cont.len + len > sizeof(cont.buf)) {\n\t\tcont_flush();\n\t\treturn false;\n\t}\n\n\tif (!cont.len) {\n\t\tcont.facility = facility;\n\t\tcont.level = level;\n\t\tcont.owner = current;\n\t\tcont.ts_nsec = local_clock();\n\t\tcont.flags = flags;\n\t}\n\n\tmemcpy(cont.buf + cont.len, text, len);\n\tcont.len += len;\n\n\t// The original flags come from the first line,\n\t// but later continuations can add a newline.\n\tif (flags & LOG_NEWLINE) {\n\t\tcont.flags |= LOG_NEWLINE;\n\t\tcont_flush();\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "cont_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1762-1770",
    "snippet": "static void cont_flush(void)\n{\n\tif (cont.len == 0)\n\t\treturn;\n\n\tlog_store(cont.facility, cont.level, cont.flags, cont.ts_nsec,\n\t\t  NULL, 0, cont.buf, cont.len);\n\tcont.len = 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_store",
          "args": [
            "cont.facility",
            "cont.level",
            "cont.flags",
            "cont.ts_nsec",
            "NULL",
            "0",
            "cont.buf",
            "cont.len"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "log_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "579-635",
          "snippet": "static int log_store(int facility, int level,\n\t\t     enum log_flags flags, u64 ts_nsec,\n\t\t     const char *dict, u16 dict_len,\n\t\t     const char *text, u16 text_len)\n{\n\tstruct printk_log *msg;\n\tu32 size, pad_len;\n\tu16 trunc_msg_len = 0;\n\n\t/* number of '\\0' padding bytes to next message */\n\tsize = msg_used_size(text_len, dict_len, &pad_len);\n\n\tif (log_make_free_space(size)) {\n\t\t/* truncate the message if it is too long for empty buffer */\n\t\tsize = truncate_msg(&text_len, &trunc_msg_len,\n\t\t\t\t    &dict_len, &pad_len);\n\t\t/* survive when the log buffer is too small for trunc_msg */\n\t\tif (log_make_free_space(size))\n\t\t\treturn 0;\n\t}\n\n\tif (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {\n\t\t/*\n\t\t * This message + an additional empty header does not fit\n\t\t * at the end of the buffer. Add an empty header with len == 0\n\t\t * to signify a wrap around.\n\t\t */\n\t\tmemset(log_buf + log_next_idx, 0, sizeof(struct printk_log));\n\t\tlog_next_idx = 0;\n\t}\n\n\t/* fill message */\n\tmsg = (struct printk_log *)(log_buf + log_next_idx);\n\tmemcpy(log_text(msg), text, text_len);\n\tmsg->text_len = text_len;\n\tif (trunc_msg_len) {\n\t\tmemcpy(log_text(msg) + text_len, trunc_msg, trunc_msg_len);\n\t\tmsg->text_len += trunc_msg_len;\n\t}\n\tmemcpy(log_dict(msg), dict, dict_len);\n\tmsg->dict_len = dict_len;\n\tmsg->facility = facility;\n\tmsg->level = level & 7;\n\tmsg->flags = flags & 0x1f;\n\tif (ts_nsec > 0)\n\t\tmsg->ts_nsec = ts_nsec;\n\telse\n\t\tmsg->ts_nsec = local_clock();\n\tmemset(log_dict(msg) + dict_len, 0, pad_len);\n\tmsg->len = size;\n\n\t/* insert message */\n\tlog_next_idx += msg->len;\n\tlog_next_seq++;\n\n\treturn msg->text_len;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int log_store(int facility, int level,\n\t\t     enum log_flags flags, u64 ts_nsec,\n\t\t     const char *dict, u16 dict_len,\n\t\t     const char *text, u16 text_len)\n{\n\tstruct printk_log *msg;\n\tu32 size, pad_len;\n\tu16 trunc_msg_len = 0;\n\n\t/* number of '\\0' padding bytes to next message */\n\tsize = msg_used_size(text_len, dict_len, &pad_len);\n\n\tif (log_make_free_space(size)) {\n\t\t/* truncate the message if it is too long for empty buffer */\n\t\tsize = truncate_msg(&text_len, &trunc_msg_len,\n\t\t\t\t    &dict_len, &pad_len);\n\t\t/* survive when the log buffer is too small for trunc_msg */\n\t\tif (log_make_free_space(size))\n\t\t\treturn 0;\n\t}\n\n\tif (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {\n\t\t/*\n\t\t * This message + an additional empty header does not fit\n\t\t * at the end of the buffer. Add an empty header with len == 0\n\t\t * to signify a wrap around.\n\t\t */\n\t\tmemset(log_buf + log_next_idx, 0, sizeof(struct printk_log));\n\t\tlog_next_idx = 0;\n\t}\n\n\t/* fill message */\n\tmsg = (struct printk_log *)(log_buf + log_next_idx);\n\tmemcpy(log_text(msg), text, text_len);\n\tmsg->text_len = text_len;\n\tif (trunc_msg_len) {\n\t\tmemcpy(log_text(msg) + text_len, trunc_msg, trunc_msg_len);\n\t\tmsg->text_len += trunc_msg_len;\n\t}\n\tmemcpy(log_dict(msg), dict, dict_len);\n\tmsg->dict_len = dict_len;\n\tmsg->facility = facility;\n\tmsg->level = level & 7;\n\tmsg->flags = flags & 0x1f;\n\tif (ts_nsec > 0)\n\t\tmsg->ts_nsec = ts_nsec;\n\telse\n\t\tmsg->ts_nsec = local_clock();\n\tmemset(log_dict(msg) + dict_len, 0, pad_len);\n\tmsg->len = size;\n\n\t/* insert message */\n\tlog_next_idx += msg->len;\n\tlog_next_seq++;\n\n\treturn msg->text_len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void cont_flush(void)\n{\n\tif (cont.len == 0)\n\t\treturn;\n\n\tlog_store(cont.facility, cont.level, cont.flags, cont.ts_nsec,\n\t\t  NULL, 0, cont.buf, cont.len);\n\tcont.len = 0;\n}"
  },
  {
    "function_name": "printk_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1734-1744",
    "snippet": "static inline void printk_delay(void)\n{\n\tif (unlikely(printk_delay_msec)) {\n\t\tint m = printk_delay_msec;\n\n\t\twhile (m--) {\n\t\t\tmdelay(1);\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "1"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "printk_delay_msec"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic inline void printk_delay(void)\n{\n\tif (unlikely(printk_delay_msec)) {\n\t\tint m = printk_delay_msec;\n\n\t\twhile (m--) {\n\t\t\tmdelay(1);\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "call_console_drivers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1705-1730",
    "snippet": "static void call_console_drivers(const char *ext_text, size_t ext_len,\n\t\t\t\t const char *text, size_t len)\n{\n\tstruct console *con;\n\n\ttrace_console_rcuidle(text, len);\n\n\tif (!console_drivers)\n\t\treturn;\n\n\tfor_each_console(con) {\n\t\tif (exclusive_console && con != exclusive_console)\n\t\t\tcontinue;\n\t\tif (!(con->flags & CON_ENABLED))\n\t\t\tcontinue;\n\t\tif (!con->write)\n\t\t\tcontinue;\n\t\tif (!cpu_online(smp_processor_id()) &&\n\t\t    !(con->flags & CON_ANYTIME))\n\t\t\tcontinue;\n\t\tif (con->flags & CON_EXTENDED)\n\t\t\tcon->write(con, ext_text, ext_len);\n\t\telse\n\t\t\tcon->write(con, text, len);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct console *console_drivers;",
      "static struct console *exclusive_console;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "con->write",
          "args": [
            "con",
            "text",
            "len"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "con->write",
          "args": [
            "con",
            "ext_text",
            "ext_len"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "smp_processor_id()"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_console_rcuidle",
          "args": [
            "text",
            "len"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstruct console *console_drivers;\nstatic struct console *exclusive_console;\n\nstatic void call_console_drivers(const char *ext_text, size_t ext_len,\n\t\t\t\t const char *text, size_t len)\n{\n\tstruct console *con;\n\n\ttrace_console_rcuidle(text, len);\n\n\tif (!console_drivers)\n\t\treturn;\n\n\tfor_each_console(con) {\n\t\tif (exclusive_console && con != exclusive_console)\n\t\t\tcontinue;\n\t\tif (!(con->flags & CON_ENABLED))\n\t\t\tcontinue;\n\t\tif (!con->write)\n\t\t\tcontinue;\n\t\tif (!cpu_online(smp_processor_id()) &&\n\t\t    !(con->flags & CON_ANYTIME))\n\t\t\tcontinue;\n\t\tif (con->flags & CON_EXTENDED)\n\t\t\tcon->write(con, ext_text, ext_len);\n\t\telse\n\t\t\tcon->write(con, text, len);\n\t}\n}"
  },
  {
    "function_name": "console_trylock_spinning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1646-1698",
    "snippet": "static int console_trylock_spinning(void)\n{\n\tstruct task_struct *owner = NULL;\n\tbool waiter;\n\tbool spin = false;\n\tunsigned long flags;\n\n\tif (console_trylock())\n\t\treturn 1;\n\n\tprintk_safe_enter_irqsave(flags);\n\n\traw_spin_lock(&console_owner_lock);\n\towner = READ_ONCE(console_owner);\n\twaiter = READ_ONCE(console_waiter);\n\tif (!waiter && owner && owner != current) {\n\t\tWRITE_ONCE(console_waiter, true);\n\t\tspin = true;\n\t}\n\traw_spin_unlock(&console_owner_lock);\n\n\t/*\n\t * If there is an active printk() writing to the\n\t * consoles, instead of having it write our data too,\n\t * see if we can offload that load from the active\n\t * printer, and do some printing ourselves.\n\t * Go into a spin only if there isn't already a waiter\n\t * spinning, and there is an active printer, and\n\t * that active printer isn't us (recursive printk?).\n\t */\n\tif (!spin) {\n\t\tprintk_safe_exit_irqrestore(flags);\n\t\treturn 0;\n\t}\n\n\t/* We spin waiting for the owner to release us */\n\tspin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);\n\t/* Owner will clear console_waiter on hand off */\n\twhile (READ_ONCE(console_waiter))\n\t\tcpu_relax();\n\tspin_release(&console_owner_dep_map, 1, _THIS_IP_);\n\n\tprintk_safe_exit_irqrestore(flags);\n\t/*\n\t * The owner passed the console lock to us.\n\t * Since we did not spin on console lock, annotate\n\t * this as a trylock. Otherwise lockdep will\n\t * complain.\n\t */\n\tmutex_acquire(&console_lock_dep_map, 0, 1, _THIS_IP_);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_acquire",
          "args": [
            "&console_lock_dep_map",
            "0",
            "1",
            "_THIS_IP_"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_safe_exit_irqrestore",
          "args": [
            "flags"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_release",
          "args": [
            "&console_owner_dep_map",
            "1",
            "_THIS_IP_"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "console_waiter"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_acquire",
          "args": [
            "&console_owner_dep_map",
            "0",
            "0",
            "_THIS_IP_"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_safe_exit_irqrestore",
          "args": [
            "flags"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&console_owner_lock"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "console_waiter",
            "true"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "console_waiter"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "console_owner"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&console_owner_lock"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_safe_enter_irqsave",
          "args": [
            "flags"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_trylock",
          "args": [],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "console_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2245-2256",
          "snippet": "int console_trylock(void)\n{\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "static int console_may_schedule;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nstatic int console_may_schedule;\n\nint console_trylock(void)\n{\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_trylock_spinning(void)\n{\n\tstruct task_struct *owner = NULL;\n\tbool waiter;\n\tbool spin = false;\n\tunsigned long flags;\n\n\tif (console_trylock())\n\t\treturn 1;\n\n\tprintk_safe_enter_irqsave(flags);\n\n\traw_spin_lock(&console_owner_lock);\n\towner = READ_ONCE(console_owner);\n\twaiter = READ_ONCE(console_waiter);\n\tif (!waiter && owner && owner != current) {\n\t\tWRITE_ONCE(console_waiter, true);\n\t\tspin = true;\n\t}\n\traw_spin_unlock(&console_owner_lock);\n\n\t/*\n\t * If there is an active printk() writing to the\n\t * consoles, instead of having it write our data too,\n\t * see if we can offload that load from the active\n\t * printer, and do some printing ourselves.\n\t * Go into a spin only if there isn't already a waiter\n\t * spinning, and there is an active printer, and\n\t * that active printer isn't us (recursive printk?).\n\t */\n\tif (!spin) {\n\t\tprintk_safe_exit_irqrestore(flags);\n\t\treturn 0;\n\t}\n\n\t/* We spin waiting for the owner to release us */\n\tspin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);\n\t/* Owner will clear console_waiter on hand off */\n\twhile (READ_ONCE(console_waiter))\n\t\tcpu_relax();\n\tspin_release(&console_owner_dep_map, 1, _THIS_IP_);\n\n\tprintk_safe_exit_irqrestore(flags);\n\t/*\n\t * The owner passed the console lock to us.\n\t * Since we did not spin on console lock, annotate\n\t * this as a trylock. Otherwise lockdep will\n\t * complain.\n\t */\n\tmutex_acquire(&console_lock_dep_map, 0, 1, _THIS_IP_);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "console_lock_spinning_disable_and_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1609-1634",
    "snippet": "static int console_lock_spinning_disable_and_check(void)\n{\n\tint waiter;\n\n\traw_spin_lock(&console_owner_lock);\n\twaiter = READ_ONCE(console_waiter);\n\tconsole_owner = NULL;\n\traw_spin_unlock(&console_owner_lock);\n\n\tif (!waiter) {\n\t\tspin_release(&console_owner_dep_map, 1, _THIS_IP_);\n\t\treturn 0;\n\t}\n\n\t/* The waiter is now free to continue */\n\tWRITE_ONCE(console_waiter, false);\n\n\tspin_release(&console_owner_dep_map, 1, _THIS_IP_);\n\n\t/*\n\t * Hand off console_lock to waiter. The waiter will perform\n\t * the up(). After this, the waiter is the console_lock owner.\n\t */\n\tmutex_release(&console_lock_dep_map, 1, _THIS_IP_);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_release",
          "args": [
            "&console_lock_dep_map",
            "1",
            "_THIS_IP_"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_release",
          "args": [
            "&console_owner_dep_map",
            "1",
            "_THIS_IP_"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "console_waiter",
            "false"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_release",
          "args": [
            "&console_owner_dep_map",
            "1",
            "_THIS_IP_"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&console_owner_lock"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "console_waiter"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&console_owner_lock"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_lock_spinning_disable_and_check(void)\n{\n\tint waiter;\n\n\traw_spin_lock(&console_owner_lock);\n\twaiter = READ_ONCE(console_waiter);\n\tconsole_owner = NULL;\n\traw_spin_unlock(&console_owner_lock);\n\n\tif (!waiter) {\n\t\tspin_release(&console_owner_dep_map, 1, _THIS_IP_);\n\t\treturn 0;\n\t}\n\n\t/* The waiter is now free to continue */\n\tWRITE_ONCE(console_waiter, false);\n\n\tspin_release(&console_owner_dep_map, 1, _THIS_IP_);\n\n\t/*\n\t * Hand off console_lock to waiter. The waiter will perform\n\t * the up(). After this, the waiter is the console_lock owner.\n\t */\n\tmutex_release(&console_lock_dep_map, 1, _THIS_IP_);\n\treturn 1;\n}"
  },
  {
    "function_name": "console_lock_spinning_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1584-1592",
    "snippet": "static void console_lock_spinning_enable(void)\n{\n\traw_spin_lock(&console_owner_lock);\n\tconsole_owner = current;\n\traw_spin_unlock(&console_owner_lock);\n\n\t/* The waiter may spin on us after setting console_owner */\n\tspin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_acquire",
          "args": [
            "&console_owner_dep_map",
            "0",
            "0",
            "_THIS_IP_"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&console_owner_lock"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&console_owner_lock"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void console_lock_spinning_enable(void)\n{\n\traw_spin_lock(&console_owner_lock);\n\tconsole_owner = current;\n\traw_spin_unlock(&console_owner_lock);\n\n\t/* The waiter may spin on us after setting console_owner */\n\tspin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);\n}"
  },
  {
    "function_name": "do_syslog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1443-1553",
    "snippet": "int do_syslog(int type, char __user *buf, int len, int source)\n{\n\tbool clear = false;\n\tstatic int saved_console_loglevel = LOGLEVEL_DEFAULT;\n\tint error;\n\n\terror = check_syslog_permissions(type, source);\n\tif (error)\n\t\treturn error;\n\n\tswitch (type) {\n\tcase SYSLOG_ACTION_CLOSE:\t/* Close log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_OPEN:\t/* Open log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_READ:\t/* Read from log */\n\t\tif (!buf || len < 0)\n\t\t\treturn -EINVAL;\n\t\tif (!len)\n\t\t\treturn 0;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len))\n\t\t\treturn -EFAULT;\n\t\terror = wait_event_interruptible(log_wait,\n\t\t\t\t\t\t syslog_seq != log_next_seq);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = syslog_print(buf, len);\n\t\tbreak;\n\t/* Read/clear last kernel messages */\n\tcase SYSLOG_ACTION_READ_CLEAR:\n\t\tclear = true;\n\t\t/* FALL THRU */\n\t/* Read last kernel messages */\n\tcase SYSLOG_ACTION_READ_ALL:\n\t\tif (!buf || len < 0)\n\t\t\treturn -EINVAL;\n\t\tif (!len)\n\t\t\treturn 0;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len))\n\t\t\treturn -EFAULT;\n\t\terror = syslog_print_all(buf, len, clear);\n\t\tbreak;\n\t/* Clear ring buffer */\n\tcase SYSLOG_ACTION_CLEAR:\n\t\tsyslog_clear();\n\t\tbreak;\n\t/* Disable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_OFF:\n\t\tif (saved_console_loglevel == LOGLEVEL_DEFAULT)\n\t\t\tsaved_console_loglevel = console_loglevel;\n\t\tconsole_loglevel = minimum_console_loglevel;\n\t\tbreak;\n\t/* Enable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_ON:\n\t\tif (saved_console_loglevel != LOGLEVEL_DEFAULT) {\n\t\t\tconsole_loglevel = saved_console_loglevel;\n\t\t\tsaved_console_loglevel = LOGLEVEL_DEFAULT;\n\t\t}\n\t\tbreak;\n\t/* Set level of messages printed to console */\n\tcase SYSLOG_ACTION_CONSOLE_LEVEL:\n\t\tif (len < 1 || len > 8)\n\t\t\treturn -EINVAL;\n\t\tif (len < minimum_console_loglevel)\n\t\t\tlen = minimum_console_loglevel;\n\t\tconsole_loglevel = len;\n\t\t/* Implicitly re-enable logging to console */\n\t\tsaved_console_loglevel = LOGLEVEL_DEFAULT;\n\t\tbreak;\n\t/* Number of chars in the log buffer */\n\tcase SYSLOG_ACTION_SIZE_UNREAD:\n\t\tlogbuf_lock_irq();\n\t\tif (syslog_seq < log_first_seq) {\n\t\t\t/* messages are gone, move to first one */\n\t\t\tsyslog_seq = log_first_seq;\n\t\t\tsyslog_idx = log_first_idx;\n\t\t\tsyslog_partial = 0;\n\t\t}\n\t\tif (source == SYSLOG_FROM_PROC) {\n\t\t\t/*\n\t\t\t * Short-cut for poll(/\"proc/kmsg\") which simply checks\n\t\t\t * for pending data, not the size; return the count of\n\t\t\t * records, not the length.\n\t\t\t */\n\t\t\terror = log_next_seq - syslog_seq;\n\t\t} else {\n\t\t\tu64 seq = syslog_seq;\n\t\t\tu32 idx = syslog_idx;\n\n\t\t\twhile (seq < log_next_seq) {\n\t\t\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\t\t\terror += msg_print_text(msg, true, NULL, 0);\n\t\t\t\tidx = log_next(idx);\n\t\t\t\tseq++;\n\t\t\t}\n\t\t\terror -= syslog_partial;\n\t\t}\n\t\tlogbuf_unlock_irq();\n\t\tbreak;\n\t/* Size of the log buffer */\n\tcase SYSLOG_ACTION_SIZE_BUFFER:\n\t\terror = log_buf_len;\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logbuf_unlock_irq",
          "args": [],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_next",
          "args": [
            "idx"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "log_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2020-2020",
          "snippet": "static u32 log_next(u32 idx) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic u32 log_next(u32 idx) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "msg_print_text",
          "args": [
            "msg",
            "true",
            "NULL",
            "0"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "msg_print_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2031-2032",
          "snippet": "static size_t msg_print_text(const struct printk_log *msg,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic size_t msg_print_text(const struct printk_log *msg,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "log_from_idx",
          "args": [
            "idx"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "log_from_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2019-2019",
          "snippet": "static struct printk_log *log_from_idx(u32 idx) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct printk_log *log_from_idx(u32 idx) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irq",
          "args": [],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog_clear",
          "args": [],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "syslog_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1435-1441",
          "snippet": "static void syslog_clear(void)\n{\n\tlogbuf_lock_irq();\n\tclear_seq = log_next_seq;\n\tclear_idx = log_next_idx;\n\tlogbuf_unlock_irq();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void syslog_clear(void)\n{\n\tlogbuf_lock_irq();\n\tclear_seq = log_next_seq;\n\tclear_idx = log_next_idx;\n\tlogbuf_unlock_irq();\n}"
        }
      },
      {
        "call_info": {
          "callee": "syslog_print_all",
          "args": [
            "buf",
            "len",
            "clear"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "syslog_print_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1356-1433",
          "snippet": "static int syslog_print_all(char __user *buf, int size, bool clear)\n{\n\tchar *text;\n\tint len = 0;\n\tu64 next_seq;\n\tu64 seq;\n\tu32 idx;\n\n\ttext = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);\n\tif (!text)\n\t\treturn -ENOMEM;\n\n\tlogbuf_lock_irq();\n\t/*\n\t * Find first record that fits, including all following records,\n\t * into the user-provided buffer for this dump.\n\t */\n\tseq = clear_seq;\n\tidx = clear_idx;\n\twhile (seq < log_next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tlen += msg_print_text(msg, true, NULL, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t}\n\n\t/* move first record forward until length fits into the buffer */\n\tseq = clear_seq;\n\tidx = clear_idx;\n\twhile (len > size && seq < log_next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tlen -= msg_print_text(msg, true, NULL, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t}\n\n\t/* last message fitting into this dump */\n\tnext_seq = log_next_seq;\n\n\tlen = 0;\n\twhile (len >= 0 && seq < next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\t\tint textlen;\n\n\t\ttextlen = msg_print_text(msg, true, text,\n\t\t\t\t\t LOG_LINE_MAX + PREFIX_MAX);\n\t\tif (textlen < 0) {\n\t\t\tlen = textlen;\n\t\t\tbreak;\n\t\t}\n\t\tidx = log_next(idx);\n\t\tseq++;\n\n\t\tlogbuf_unlock_irq();\n\t\tif (copy_to_user(buf + len, text, textlen))\n\t\t\tlen = -EFAULT;\n\t\telse\n\t\t\tlen += textlen;\n\t\tlogbuf_lock_irq();\n\n\t\tif (seq < log_first_seq) {\n\t\t\t/* messages are gone, move to next one */\n\t\t\tseq = log_first_seq;\n\t\t\tidx = log_first_idx;\n\t\t}\n\t}\n\n\tif (clear) {\n\t\tclear_seq = log_next_seq;\n\t\tclear_idx = log_next_idx;\n\t}\n\tlogbuf_unlock_irq();\n\n\tkfree(text);\n\treturn len;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREFIX_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
            "#define PREFIX_MAX\t\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic int syslog_print_all(char __user *buf, int size, bool clear)\n{\n\tchar *text;\n\tint len = 0;\n\tu64 next_seq;\n\tu64 seq;\n\tu32 idx;\n\n\ttext = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);\n\tif (!text)\n\t\treturn -ENOMEM;\n\n\tlogbuf_lock_irq();\n\t/*\n\t * Find first record that fits, including all following records,\n\t * into the user-provided buffer for this dump.\n\t */\n\tseq = clear_seq;\n\tidx = clear_idx;\n\twhile (seq < log_next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tlen += msg_print_text(msg, true, NULL, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t}\n\n\t/* move first record forward until length fits into the buffer */\n\tseq = clear_seq;\n\tidx = clear_idx;\n\twhile (len > size && seq < log_next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tlen -= msg_print_text(msg, true, NULL, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t}\n\n\t/* last message fitting into this dump */\n\tnext_seq = log_next_seq;\n\n\tlen = 0;\n\twhile (len >= 0 && seq < next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\t\tint textlen;\n\n\t\ttextlen = msg_print_text(msg, true, text,\n\t\t\t\t\t LOG_LINE_MAX + PREFIX_MAX);\n\t\tif (textlen < 0) {\n\t\t\tlen = textlen;\n\t\t\tbreak;\n\t\t}\n\t\tidx = log_next(idx);\n\t\tseq++;\n\n\t\tlogbuf_unlock_irq();\n\t\tif (copy_to_user(buf + len, text, textlen))\n\t\t\tlen = -EFAULT;\n\t\telse\n\t\t\tlen += textlen;\n\t\tlogbuf_lock_irq();\n\n\t\tif (seq < log_first_seq) {\n\t\t\t/* messages are gone, move to next one */\n\t\t\tseq = log_first_seq;\n\t\t\tidx = log_first_idx;\n\t\t}\n\t}\n\n\tif (clear) {\n\t\tclear_seq = log_next_seq;\n\t\tclear_idx = log_next_idx;\n\t}\n\tlogbuf_unlock_irq();\n\n\tkfree(text);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "buf",
            "len"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog_print",
          "args": [
            "buf",
            "len"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "syslog_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1295-1354",
          "snippet": "static int syslog_print(char __user *buf, int size)\n{\n\tchar *text;\n\tstruct printk_log *msg;\n\tint len = 0;\n\n\ttext = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);\n\tif (!text)\n\t\treturn -ENOMEM;\n\n\twhile (size > 0) {\n\t\tsize_t n;\n\t\tsize_t skip;\n\n\t\tlogbuf_lock_irq();\n\t\tif (syslog_seq < log_first_seq) {\n\t\t\t/* messages are gone, move to first one */\n\t\t\tsyslog_seq = log_first_seq;\n\t\t\tsyslog_idx = log_first_idx;\n\t\t\tsyslog_partial = 0;\n\t\t}\n\t\tif (syslog_seq == log_next_seq) {\n\t\t\tlogbuf_unlock_irq();\n\t\t\tbreak;\n\t\t}\n\n\t\tskip = syslog_partial;\n\t\tmsg = log_from_idx(syslog_idx);\n\t\tn = msg_print_text(msg, true, text, LOG_LINE_MAX + PREFIX_MAX);\n\t\tif (n - syslog_partial <= size) {\n\t\t\t/* message fits into buffer, move forward */\n\t\t\tsyslog_idx = log_next(syslog_idx);\n\t\t\tsyslog_seq++;\n\t\t\tn -= syslog_partial;\n\t\t\tsyslog_partial = 0;\n\t\t} else if (!len){\n\t\t\t/* partial read(), remember position */\n\t\t\tn = size;\n\t\t\tsyslog_partial += n;\n\t\t} else\n\t\t\tn = 0;\n\t\tlogbuf_unlock_irq();\n\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(buf, text + skip, n)) {\n\t\t\tif (!len)\n\t\t\t\tlen = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen += n;\n\t\tsize -= n;\n\t\tbuf += n;\n\t}\n\n\tkfree(text);\n\treturn len;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREFIX_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t0",
            "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
            "#define PREFIX_MAX\t\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic int syslog_print(char __user *buf, int size)\n{\n\tchar *text;\n\tstruct printk_log *msg;\n\tint len = 0;\n\n\ttext = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);\n\tif (!text)\n\t\treturn -ENOMEM;\n\n\twhile (size > 0) {\n\t\tsize_t n;\n\t\tsize_t skip;\n\n\t\tlogbuf_lock_irq();\n\t\tif (syslog_seq < log_first_seq) {\n\t\t\t/* messages are gone, move to first one */\n\t\t\tsyslog_seq = log_first_seq;\n\t\t\tsyslog_idx = log_first_idx;\n\t\t\tsyslog_partial = 0;\n\t\t}\n\t\tif (syslog_seq == log_next_seq) {\n\t\t\tlogbuf_unlock_irq();\n\t\t\tbreak;\n\t\t}\n\n\t\tskip = syslog_partial;\n\t\tmsg = log_from_idx(syslog_idx);\n\t\tn = msg_print_text(msg, true, text, LOG_LINE_MAX + PREFIX_MAX);\n\t\tif (n - syslog_partial <= size) {\n\t\t\t/* message fits into buffer, move forward */\n\t\t\tsyslog_idx = log_next(syslog_idx);\n\t\t\tsyslog_seq++;\n\t\t\tn -= syslog_partial;\n\t\t\tsyslog_partial = 0;\n\t\t} else if (!len){\n\t\t\t/* partial read(), remember position */\n\t\t\tn = size;\n\t\t\tsyslog_partial += n;\n\t\t} else\n\t\t\tn = 0;\n\t\tlogbuf_unlock_irq();\n\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(buf, text + skip, n)) {\n\t\t\tif (!len)\n\t\t\t\tlen = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen += n;\n\t\tsize -= n;\n\t\tbuf += n;\n\t}\n\n\tkfree(text);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "log_wait",
            "syslog_seq != log_next_seq"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "buf",
            "len"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_syslog_permissions",
          "args": [
            "type",
            "source"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "check_syslog_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "651-678",
          "snippet": "static int check_syslog_permissions(int type, int source)\n{\n\t/*\n\t * If this is from /proc/kmsg and we've already opened it, then we've\n\t * already done the capabilities checks at open time.\n\t */\n\tif (source == SYSLOG_FROM_PROC && type != SYSLOG_ACTION_OPEN)\n\t\tgoto ok;\n\n\tif (syslog_action_restricted(type)) {\n\t\tif (capable(CAP_SYSLOG))\n\t\t\tgoto ok;\n\t\t/*\n\t\t * For historical reasons, accept CAP_SYS_ADMIN too, with\n\t\t * a warning.\n\t\t */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tpr_warn_once(\"%s (%d): Attempt to access syslog with \"\n\t\t\t\t     \"CAP_SYS_ADMIN but no CAP_SYSLOG \"\n\t\t\t\t     \"(deprecated).\\n\",\n\t\t\t\t current->comm, task_pid_nr(current));\n\t\t\tgoto ok;\n\t\t}\n\t\treturn -EPERM;\n\t}\nok:\n\treturn security_syslog(type);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int check_syslog_permissions(int type, int source)\n{\n\t/*\n\t * If this is from /proc/kmsg and we've already opened it, then we've\n\t * already done the capabilities checks at open time.\n\t */\n\tif (source == SYSLOG_FROM_PROC && type != SYSLOG_ACTION_OPEN)\n\t\tgoto ok;\n\n\tif (syslog_action_restricted(type)) {\n\t\tif (capable(CAP_SYSLOG))\n\t\t\tgoto ok;\n\t\t/*\n\t\t * For historical reasons, accept CAP_SYS_ADMIN too, with\n\t\t * a warning.\n\t\t */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tpr_warn_once(\"%s (%d): Attempt to access syslog with \"\n\t\t\t\t     \"CAP_SYS_ADMIN but no CAP_SYSLOG \"\n\t\t\t\t     \"(deprecated).\\n\",\n\t\t\t\t current->comm, task_pid_nr(current));\n\t\t\tgoto ok;\n\t\t}\n\t\treturn -EPERM;\n\t}\nok:\n\treturn security_syslog(type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint do_syslog(int type, char __user *buf, int len, int source)\n{\n\tbool clear = false;\n\tstatic int saved_console_loglevel = LOGLEVEL_DEFAULT;\n\tint error;\n\n\terror = check_syslog_permissions(type, source);\n\tif (error)\n\t\treturn error;\n\n\tswitch (type) {\n\tcase SYSLOG_ACTION_CLOSE:\t/* Close log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_OPEN:\t/* Open log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_READ:\t/* Read from log */\n\t\tif (!buf || len < 0)\n\t\t\treturn -EINVAL;\n\t\tif (!len)\n\t\t\treturn 0;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len))\n\t\t\treturn -EFAULT;\n\t\terror = wait_event_interruptible(log_wait,\n\t\t\t\t\t\t syslog_seq != log_next_seq);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = syslog_print(buf, len);\n\t\tbreak;\n\t/* Read/clear last kernel messages */\n\tcase SYSLOG_ACTION_READ_CLEAR:\n\t\tclear = true;\n\t\t/* FALL THRU */\n\t/* Read last kernel messages */\n\tcase SYSLOG_ACTION_READ_ALL:\n\t\tif (!buf || len < 0)\n\t\t\treturn -EINVAL;\n\t\tif (!len)\n\t\t\treturn 0;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len))\n\t\t\treturn -EFAULT;\n\t\terror = syslog_print_all(buf, len, clear);\n\t\tbreak;\n\t/* Clear ring buffer */\n\tcase SYSLOG_ACTION_CLEAR:\n\t\tsyslog_clear();\n\t\tbreak;\n\t/* Disable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_OFF:\n\t\tif (saved_console_loglevel == LOGLEVEL_DEFAULT)\n\t\t\tsaved_console_loglevel = console_loglevel;\n\t\tconsole_loglevel = minimum_console_loglevel;\n\t\tbreak;\n\t/* Enable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_ON:\n\t\tif (saved_console_loglevel != LOGLEVEL_DEFAULT) {\n\t\t\tconsole_loglevel = saved_console_loglevel;\n\t\t\tsaved_console_loglevel = LOGLEVEL_DEFAULT;\n\t\t}\n\t\tbreak;\n\t/* Set level of messages printed to console */\n\tcase SYSLOG_ACTION_CONSOLE_LEVEL:\n\t\tif (len < 1 || len > 8)\n\t\t\treturn -EINVAL;\n\t\tif (len < minimum_console_loglevel)\n\t\t\tlen = minimum_console_loglevel;\n\t\tconsole_loglevel = len;\n\t\t/* Implicitly re-enable logging to console */\n\t\tsaved_console_loglevel = LOGLEVEL_DEFAULT;\n\t\tbreak;\n\t/* Number of chars in the log buffer */\n\tcase SYSLOG_ACTION_SIZE_UNREAD:\n\t\tlogbuf_lock_irq();\n\t\tif (syslog_seq < log_first_seq) {\n\t\t\t/* messages are gone, move to first one */\n\t\t\tsyslog_seq = log_first_seq;\n\t\t\tsyslog_idx = log_first_idx;\n\t\t\tsyslog_partial = 0;\n\t\t}\n\t\tif (source == SYSLOG_FROM_PROC) {\n\t\t\t/*\n\t\t\t * Short-cut for poll(/\"proc/kmsg\") which simply checks\n\t\t\t * for pending data, not the size; return the count of\n\t\t\t * records, not the length.\n\t\t\t */\n\t\t\terror = log_next_seq - syslog_seq;\n\t\t} else {\n\t\t\tu64 seq = syslog_seq;\n\t\t\tu32 idx = syslog_idx;\n\n\t\t\twhile (seq < log_next_seq) {\n\t\t\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\t\t\terror += msg_print_text(msg, true, NULL, 0);\n\t\t\t\tidx = log_next(idx);\n\t\t\t\tseq++;\n\t\t\t}\n\t\t\terror -= syslog_partial;\n\t\t}\n\t\tlogbuf_unlock_irq();\n\t\tbreak;\n\t/* Size of the log buffer */\n\tcase SYSLOG_ACTION_SIZE_BUFFER:\n\t\terror = log_buf_len;\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "syslog_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1435-1441",
    "snippet": "static void syslog_clear(void)\n{\n\tlogbuf_lock_irq();\n\tclear_seq = log_next_seq;\n\tclear_idx = log_next_idx;\n\tlogbuf_unlock_irq();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logbuf_unlock_irq",
          "args": [],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irq",
          "args": [],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void syslog_clear(void)\n{\n\tlogbuf_lock_irq();\n\tclear_seq = log_next_seq;\n\tclear_idx = log_next_idx;\n\tlogbuf_unlock_irq();\n}"
  },
  {
    "function_name": "syslog_print_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1356-1433",
    "snippet": "static int syslog_print_all(char __user *buf, int size, bool clear)\n{\n\tchar *text;\n\tint len = 0;\n\tu64 next_seq;\n\tu64 seq;\n\tu32 idx;\n\n\ttext = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);\n\tif (!text)\n\t\treturn -ENOMEM;\n\n\tlogbuf_lock_irq();\n\t/*\n\t * Find first record that fits, including all following records,\n\t * into the user-provided buffer for this dump.\n\t */\n\tseq = clear_seq;\n\tidx = clear_idx;\n\twhile (seq < log_next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tlen += msg_print_text(msg, true, NULL, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t}\n\n\t/* move first record forward until length fits into the buffer */\n\tseq = clear_seq;\n\tidx = clear_idx;\n\twhile (len > size && seq < log_next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tlen -= msg_print_text(msg, true, NULL, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t}\n\n\t/* last message fitting into this dump */\n\tnext_seq = log_next_seq;\n\n\tlen = 0;\n\twhile (len >= 0 && seq < next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\t\tint textlen;\n\n\t\ttextlen = msg_print_text(msg, true, text,\n\t\t\t\t\t LOG_LINE_MAX + PREFIX_MAX);\n\t\tif (textlen < 0) {\n\t\t\tlen = textlen;\n\t\t\tbreak;\n\t\t}\n\t\tidx = log_next(idx);\n\t\tseq++;\n\n\t\tlogbuf_unlock_irq();\n\t\tif (copy_to_user(buf + len, text, textlen))\n\t\t\tlen = -EFAULT;\n\t\telse\n\t\t\tlen += textlen;\n\t\tlogbuf_lock_irq();\n\n\t\tif (seq < log_first_seq) {\n\t\t\t/* messages are gone, move to next one */\n\t\t\tseq = log_first_seq;\n\t\t\tidx = log_first_idx;\n\t\t}\n\t}\n\n\tif (clear) {\n\t\tclear_seq = log_next_seq;\n\t\tclear_idx = log_next_idx;\n\t}\n\tlogbuf_unlock_irq();\n\n\tkfree(text);\n\treturn len;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PREFIX_MAX\t\t0",
      "#define LOG_LINE_MAX\t\t0",
      "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
      "#define PREFIX_MAX\t\t32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "text"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_unlock_irq",
          "args": [],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irq",
          "args": [],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf + len",
            "text",
            "textlen"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_unlock_irq",
          "args": [],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_next",
          "args": [
            "idx"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "log_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2020-2020",
          "snippet": "static u32 log_next(u32 idx) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic u32 log_next(u32 idx) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "msg_print_text",
          "args": [
            "msg",
            "true",
            "text",
            "LOG_LINE_MAX + PREFIX_MAX"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "msg_print_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2031-2032",
          "snippet": "static size_t msg_print_text(const struct printk_log *msg,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic size_t msg_print_text(const struct printk_log *msg,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "log_from_idx",
          "args": [
            "idx"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "log_from_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2019-2019",
          "snippet": "static struct printk_log *log_from_idx(u32 idx) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct printk_log *log_from_idx(u32 idx) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irq",
          "args": [],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "LOG_LINE_MAX + PREFIX_MAX",
            "GFP_KERNEL"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic int syslog_print_all(char __user *buf, int size, bool clear)\n{\n\tchar *text;\n\tint len = 0;\n\tu64 next_seq;\n\tu64 seq;\n\tu32 idx;\n\n\ttext = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);\n\tif (!text)\n\t\treturn -ENOMEM;\n\n\tlogbuf_lock_irq();\n\t/*\n\t * Find first record that fits, including all following records,\n\t * into the user-provided buffer for this dump.\n\t */\n\tseq = clear_seq;\n\tidx = clear_idx;\n\twhile (seq < log_next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tlen += msg_print_text(msg, true, NULL, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t}\n\n\t/* move first record forward until length fits into the buffer */\n\tseq = clear_seq;\n\tidx = clear_idx;\n\twhile (len > size && seq < log_next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tlen -= msg_print_text(msg, true, NULL, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t}\n\n\t/* last message fitting into this dump */\n\tnext_seq = log_next_seq;\n\n\tlen = 0;\n\twhile (len >= 0 && seq < next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\t\tint textlen;\n\n\t\ttextlen = msg_print_text(msg, true, text,\n\t\t\t\t\t LOG_LINE_MAX + PREFIX_MAX);\n\t\tif (textlen < 0) {\n\t\t\tlen = textlen;\n\t\t\tbreak;\n\t\t}\n\t\tidx = log_next(idx);\n\t\tseq++;\n\n\t\tlogbuf_unlock_irq();\n\t\tif (copy_to_user(buf + len, text, textlen))\n\t\t\tlen = -EFAULT;\n\t\telse\n\t\t\tlen += textlen;\n\t\tlogbuf_lock_irq();\n\n\t\tif (seq < log_first_seq) {\n\t\t\t/* messages are gone, move to next one */\n\t\t\tseq = log_first_seq;\n\t\t\tidx = log_first_idx;\n\t\t}\n\t}\n\n\tif (clear) {\n\t\tclear_seq = log_next_seq;\n\t\tclear_idx = log_next_idx;\n\t}\n\tlogbuf_unlock_irq();\n\n\tkfree(text);\n\treturn len;\n}"
  },
  {
    "function_name": "syslog_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1295-1354",
    "snippet": "static int syslog_print(char __user *buf, int size)\n{\n\tchar *text;\n\tstruct printk_log *msg;\n\tint len = 0;\n\n\ttext = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);\n\tif (!text)\n\t\treturn -ENOMEM;\n\n\twhile (size > 0) {\n\t\tsize_t n;\n\t\tsize_t skip;\n\n\t\tlogbuf_lock_irq();\n\t\tif (syslog_seq < log_first_seq) {\n\t\t\t/* messages are gone, move to first one */\n\t\t\tsyslog_seq = log_first_seq;\n\t\t\tsyslog_idx = log_first_idx;\n\t\t\tsyslog_partial = 0;\n\t\t}\n\t\tif (syslog_seq == log_next_seq) {\n\t\t\tlogbuf_unlock_irq();\n\t\t\tbreak;\n\t\t}\n\n\t\tskip = syslog_partial;\n\t\tmsg = log_from_idx(syslog_idx);\n\t\tn = msg_print_text(msg, true, text, LOG_LINE_MAX + PREFIX_MAX);\n\t\tif (n - syslog_partial <= size) {\n\t\t\t/* message fits into buffer, move forward */\n\t\t\tsyslog_idx = log_next(syslog_idx);\n\t\t\tsyslog_seq++;\n\t\t\tn -= syslog_partial;\n\t\t\tsyslog_partial = 0;\n\t\t} else if (!len){\n\t\t\t/* partial read(), remember position */\n\t\t\tn = size;\n\t\t\tsyslog_partial += n;\n\t\t} else\n\t\t\tn = 0;\n\t\tlogbuf_unlock_irq();\n\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(buf, text + skip, n)) {\n\t\t\tif (!len)\n\t\t\t\tlen = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen += n;\n\t\tsize -= n;\n\t\tbuf += n;\n\t}\n\n\tkfree(text);\n\treturn len;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PREFIX_MAX\t\t0",
      "#define LOG_LINE_MAX\t\t0",
      "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)",
      "#define PREFIX_MAX\t\t32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "text"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "text + skip",
            "n"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_unlock_irq",
          "args": [],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_next",
          "args": [
            "syslog_idx"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "log_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2020-2020",
          "snippet": "static u32 log_next(u32 idx) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic u32 log_next(u32 idx) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "msg_print_text",
          "args": [
            "msg",
            "true",
            "text",
            "LOG_LINE_MAX + PREFIX_MAX"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "msg_print_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2031-2032",
          "snippet": "static size_t msg_print_text(const struct printk_log *msg,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic size_t msg_print_text(const struct printk_log *msg,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "log_from_idx",
          "args": [
            "syslog_idx"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "log_from_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2019-2019",
          "snippet": "static struct printk_log *log_from_idx(u32 idx) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct printk_log *log_from_idx(u32 idx) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_unlock_irq",
          "args": [],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irq",
          "args": [],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "LOG_LINE_MAX + PREFIX_MAX",
            "GFP_KERNEL"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PREFIX_MAX\t\t0\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n#define PREFIX_MAX\t\t32\n\nstatic int syslog_print(char __user *buf, int size)\n{\n\tchar *text;\n\tstruct printk_log *msg;\n\tint len = 0;\n\n\ttext = kmalloc(LOG_LINE_MAX + PREFIX_MAX, GFP_KERNEL);\n\tif (!text)\n\t\treturn -ENOMEM;\n\n\twhile (size > 0) {\n\t\tsize_t n;\n\t\tsize_t skip;\n\n\t\tlogbuf_lock_irq();\n\t\tif (syslog_seq < log_first_seq) {\n\t\t\t/* messages are gone, move to first one */\n\t\t\tsyslog_seq = log_first_seq;\n\t\t\tsyslog_idx = log_first_idx;\n\t\t\tsyslog_partial = 0;\n\t\t}\n\t\tif (syslog_seq == log_next_seq) {\n\t\t\tlogbuf_unlock_irq();\n\t\t\tbreak;\n\t\t}\n\n\t\tskip = syslog_partial;\n\t\tmsg = log_from_idx(syslog_idx);\n\t\tn = msg_print_text(msg, true, text, LOG_LINE_MAX + PREFIX_MAX);\n\t\tif (n - syslog_partial <= size) {\n\t\t\t/* message fits into buffer, move forward */\n\t\t\tsyslog_idx = log_next(syslog_idx);\n\t\t\tsyslog_seq++;\n\t\t\tn -= syslog_partial;\n\t\t\tsyslog_partial = 0;\n\t\t} else if (!len){\n\t\t\t/* partial read(), remember position */\n\t\t\tn = size;\n\t\t\tsyslog_partial += n;\n\t\t} else\n\t\t\tn = 0;\n\t\tlogbuf_unlock_irq();\n\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(buf, text + skip, n)) {\n\t\t\tif (!len)\n\t\t\t\tlen = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen += n;\n\t\tsize -= n;\n\t\tbuf += n;\n\t}\n\n\tkfree(text);\n\treturn len;\n}"
  },
  {
    "function_name": "msg_print_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1255-1293",
    "snippet": "static size_t msg_print_text(const struct printk_log *msg, bool syslog, char *buf, size_t size)\n{\n\tconst char *text = log_text(msg);\n\tsize_t text_size = msg->text_len;\n\tsize_t len = 0;\n\n\tdo {\n\t\tconst char *next = memchr(text, '\\n', text_size);\n\t\tsize_t text_len;\n\n\t\tif (next) {\n\t\t\ttext_len = next - text;\n\t\t\tnext++;\n\t\t\ttext_size -= next - text;\n\t\t} else {\n\t\t\ttext_len = text_size;\n\t\t}\n\n\t\tif (buf) {\n\t\t\tif (print_prefix(msg, syslog, NULL) +\n\t\t\t    text_len + 1 >= size - len)\n\t\t\t\tbreak;\n\n\t\t\tlen += print_prefix(msg, syslog, buf + len);\n\t\t\tmemcpy(buf + len, text, text_len);\n\t\t\tlen += text_len;\n\t\t\tbuf[len++] = '\\n';\n\t\t} else {\n\t\t\t/* SYSLOG_ACTION_* buffer size only calculation */\n\t\t\tlen += print_prefix(msg, syslog, NULL);\n\t\t\tlen += text_len;\n\t\t\tlen++;\n\t\t}\n\n\t\ttext = next;\n\t} while (text);\n\n\treturn len;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_prefix",
          "args": [
            "msg",
            "syslog",
            "NULL"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "print_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1232-1253",
          "snippet": "static size_t print_prefix(const struct printk_log *msg, bool syslog, char *buf)\n{\n\tsize_t len = 0;\n\tunsigned int prefix = (msg->facility << 3) | msg->level;\n\n\tif (syslog) {\n\t\tif (buf) {\n\t\t\tlen += sprintf(buf, \"<%u>\", prefix);\n\t\t} else {\n\t\t\tlen += 3;\n\t\t\tif (prefix > 999)\n\t\t\t\tlen += 3;\n\t\t\telse if (prefix > 99)\n\t\t\t\tlen += 2;\n\t\t\telse if (prefix > 9)\n\t\t\t\tlen++;\n\t\t}\n\t}\n\n\tlen += print_time(msg->ts_nsec, buf ? buf + len : NULL);\n\treturn len;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic size_t print_prefix(const struct printk_log *msg, bool syslog, char *buf)\n{\n\tsize_t len = 0;\n\tunsigned int prefix = (msg->facility << 3) | msg->level;\n\n\tif (syslog) {\n\t\tif (buf) {\n\t\t\tlen += sprintf(buf, \"<%u>\", prefix);\n\t\t} else {\n\t\t\tlen += 3;\n\t\t\tif (prefix > 999)\n\t\t\t\tlen += 3;\n\t\t\telse if (prefix > 99)\n\t\t\t\tlen += 2;\n\t\t\telse if (prefix > 9)\n\t\t\t\tlen++;\n\t\t}\n\t}\n\n\tlen += print_time(msg->ts_nsec, buf ? buf + len : NULL);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + len",
            "text",
            "text_len"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "text",
            "'\\n'",
            "text_size"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_text",
          "args": [
            "msg"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "log_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2017-2017",
          "snippet": "static char *log_text(const struct printk_log *msg) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic char *log_text(const struct printk_log *msg) { return NULL; }"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic size_t msg_print_text(const struct printk_log *msg, bool syslog, char *buf, size_t size)\n{\n\tconst char *text = log_text(msg);\n\tsize_t text_size = msg->text_len;\n\tsize_t len = 0;\n\n\tdo {\n\t\tconst char *next = memchr(text, '\\n', text_size);\n\t\tsize_t text_len;\n\n\t\tif (next) {\n\t\t\ttext_len = next - text;\n\t\t\tnext++;\n\t\t\ttext_size -= next - text;\n\t\t} else {\n\t\t\ttext_len = text_size;\n\t\t}\n\n\t\tif (buf) {\n\t\t\tif (print_prefix(msg, syslog, NULL) +\n\t\t\t    text_len + 1 >= size - len)\n\t\t\t\tbreak;\n\n\t\t\tlen += print_prefix(msg, syslog, buf + len);\n\t\t\tmemcpy(buf + len, text, text_len);\n\t\t\tlen += text_len;\n\t\t\tbuf[len++] = '\\n';\n\t\t} else {\n\t\t\t/* SYSLOG_ACTION_* buffer size only calculation */\n\t\t\tlen += print_prefix(msg, syslog, NULL);\n\t\t\tlen += text_len;\n\t\t\tlen++;\n\t\t}\n\n\t\ttext = next;\n\t} while (text);\n\n\treturn len;\n}"
  },
  {
    "function_name": "print_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1232-1253",
    "snippet": "static size_t print_prefix(const struct printk_log *msg, bool syslog, char *buf)\n{\n\tsize_t len = 0;\n\tunsigned int prefix = (msg->facility << 3) | msg->level;\n\n\tif (syslog) {\n\t\tif (buf) {\n\t\t\tlen += sprintf(buf, \"<%u>\", prefix);\n\t\t} else {\n\t\t\tlen += 3;\n\t\t\tif (prefix > 999)\n\t\t\t\tlen += 3;\n\t\t\telse if (prefix > 99)\n\t\t\t\tlen += 2;\n\t\t\telse if (prefix > 9)\n\t\t\t\tlen++;\n\t\t}\n\t}\n\n\tlen += print_time(msg->ts_nsec, buf ? buf + len : NULL);\n\treturn len;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_time",
          "args": [
            "msg->ts_nsec",
            "buf ? buf + len : NULL"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "print_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1216-1230",
          "snippet": "static size_t print_time(u64 ts, char *buf)\n{\n\tunsigned long rem_nsec;\n\n\tif (!printk_time)\n\t\treturn 0;\n\n\trem_nsec = do_div(ts, 1000000000);\n\n\tif (!buf)\n\t\treturn snprintf(NULL, 0, \"[%5lu.000000] \", (unsigned long)ts);\n\n\treturn sprintf(buf, \"[%5lu.%06lu] \",\n\t\t       (unsigned long)ts, rem_nsec / 1000);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic size_t print_time(u64 ts, char *buf)\n{\n\tunsigned long rem_nsec;\n\n\tif (!printk_time)\n\t\treturn 0;\n\n\trem_nsec = do_div(ts, 1000000000);\n\n\tif (!buf)\n\t\treturn snprintf(NULL, 0, \"[%5lu.000000] \", (unsigned long)ts);\n\n\treturn sprintf(buf, \"[%5lu.%06lu] \",\n\t\t       (unsigned long)ts, rem_nsec / 1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"<%u>\"",
            "prefix"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic size_t print_prefix(const struct printk_log *msg, bool syslog, char *buf)\n{\n\tsize_t len = 0;\n\tunsigned int prefix = (msg->facility << 3) | msg->level;\n\n\tif (syslog) {\n\t\tif (buf) {\n\t\t\tlen += sprintf(buf, \"<%u>\", prefix);\n\t\t} else {\n\t\t\tlen += 3;\n\t\t\tif (prefix > 999)\n\t\t\t\tlen += 3;\n\t\t\telse if (prefix > 99)\n\t\t\t\tlen += 2;\n\t\t\telse if (prefix > 9)\n\t\t\t\tlen++;\n\t\t}\n\t}\n\n\tlen += print_time(msg->ts_nsec, buf ? buf + len : NULL);\n\treturn len;\n}"
  },
  {
    "function_name": "print_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1216-1230",
    "snippet": "static size_t print_time(u64 ts, char *buf)\n{\n\tunsigned long rem_nsec;\n\n\tif (!printk_time)\n\t\treturn 0;\n\n\trem_nsec = do_div(ts, 1000000000);\n\n\tif (!buf)\n\t\treturn snprintf(NULL, 0, \"[%5lu.000000] \", (unsigned long)ts);\n\n\treturn sprintf(buf, \"[%5lu.%06lu] \",\n\t\t       (unsigned long)ts, rem_nsec / 1000);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"[%5lu.%06lu] \"",
            "(unsigned long)ts",
            "rem_nsec / 1000"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "NULL",
            "0",
            "\"[%5lu.000000] \"",
            "(unsigned long)ts"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ts",
            "1000000000"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic size_t print_time(u64 ts, char *buf)\n{\n\tunsigned long rem_nsec;\n\n\tif (!printk_time)\n\t\treturn 0;\n\n\trem_nsec = do_div(ts, 1000000000);\n\n\tif (!buf)\n\t\treturn snprintf(NULL, 0, \"[%5lu.000000] \", (unsigned long)ts);\n\n\treturn sprintf(buf, \"[%5lu.%06lu] \",\n\t\t       (unsigned long)ts, rem_nsec / 1000);\n}"
  },
  {
    "function_name": "boot_delay_msec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1208-1210",
    "snippet": "static inline void boot_delay_msec(int level)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic inline void boot_delay_msec(int level)\n{\n}"
  },
  {
    "function_name": "boot_delay_msec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1181-1206",
    "snippet": "static void boot_delay_msec(int level)\n{\n\tunsigned long long k;\n\tunsigned long timeout;\n\n\tif ((boot_delay == 0 || system_state >= SYSTEM_RUNNING)\n\t\t|| suppress_message_printing(level)) {\n\t\treturn;\n\t}\n\n\tk = (unsigned long long)loops_per_msec * boot_delay;\n\n\ttimeout = jiffies + msecs_to_jiffies(boot_delay);\n\twhile (k) {\n\t\tk--;\n\t\tcpu_relax();\n\t\t/*\n\t\t * use (volatile) jiffies to prevent\n\t\t * compiler reduction; loop termination via jiffies\n\t\t * is secondary and may or may not happen.\n\t\t */\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t\ttouch_nmi_watchdog();\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "timeout"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "boot_delay"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "__msecs_to_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "565-573",
          "snippet": "unsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "suppress_message_printing",
          "args": [
            "level"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "suppress_message_printing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2033-2033",
          "snippet": "static bool suppress_message_printing(int level) { return false; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic bool suppress_message_printing(int level) { return false; }"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void boot_delay_msec(int level)\n{\n\tunsigned long long k;\n\tunsigned long timeout;\n\n\tif ((boot_delay == 0 || system_state >= SYSTEM_RUNNING)\n\t\t|| suppress_message_printing(level)) {\n\t\treturn;\n\t}\n\n\tk = (unsigned long long)loops_per_msec * boot_delay;\n\n\ttimeout = jiffies + msecs_to_jiffies(boot_delay);\n\twhile (k) {\n\t\tk--;\n\t\tcpu_relax();\n\t\t/*\n\t\t * use (volatile) jiffies to prevent\n\t\t * compiler reduction; loop termination via jiffies\n\t\t * is secondary and may or may not happen.\n\t\t */\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t\ttouch_nmi_watchdog();\n\t}\n}"
  },
  {
    "function_name": "boot_delay_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1163-1178",
    "snippet": "static int __init boot_delay_setup(char *str)\n{\n\tunsigned long lpj;\n\n\tlpj = preset_lpj ? preset_lpj : 1000000;\t/* some guess */\n\tloops_per_msec = (unsigned long long)lpj / 1000 * HZ;\n\n\tget_option(&str, &boot_delay);\n\tif (boot_delay > 10 * 1000)\n\t\tboot_delay = 0;\n\n\tpr_debug(\"boot_delay: %u, preset_lpj: %ld, lpj: %lu, \"\n\t\t\"HZ: %d, loops_per_msec: %llu\\n\",\n\t\tboot_delay, preset_lpj, lpj, HZ, loops_per_msec);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"boot_delay: %u, preset_lpj: %ld, lpj: %lu, \"\n\t\t\"HZ: %d, loops_per_msec: %llu\\n\"",
            "boot_delay",
            "preset_lpj",
            "lpj",
            "HZ",
            "loops_per_msec"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&boot_delay"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int __init boot_delay_setup(char *str)\n{\n\tunsigned long lpj;\n\n\tlpj = preset_lpj ? preset_lpj : 1000000;\t/* some guess */\n\tloops_per_msec = (unsigned long long)lpj / 1000 * HZ;\n\n\tget_option(&str, &boot_delay);\n\tif (boot_delay > 10 * 1000)\n\t\tboot_delay = 0;\n\n\tpr_debug(\"boot_delay: %u, preset_lpj: %ld, lpj: %lu, \"\n\t\t\"HZ: %d, loops_per_msec: %llu\\n\",\n\t\tboot_delay, preset_lpj, lpj, HZ, loops_per_msec);\n\treturn 0;\n}"
  },
  {
    "function_name": "suppress_message_printing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1153-1156",
    "snippet": "static bool suppress_message_printing(int level)\n{\n\treturn (level >= console_loglevel && !ignore_loglevel);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic bool suppress_message_printing(int level)\n{\n\treturn (level >= console_loglevel && !ignore_loglevel);\n}"
  },
  {
    "function_name": "ignore_loglevel_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1140-1146",
    "snippet": "static int __init ignore_loglevel_setup(char *str)\n{\n\tignore_loglevel = true;\n\tpr_info(\"debug: ignoring loglevel setting.\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"debug: ignoring loglevel setting.\\n\""
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int __init ignore_loglevel_setup(char *str)\n{\n\tignore_loglevel = true;\n\tpr_info(\"debug: ignoring loglevel setting.\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_log_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1096-1136",
    "snippet": "void __init setup_log_buf(int early)\n{\n\tunsigned long flags;\n\tchar *new_log_buf;\n\tunsigned int free;\n\n\tif (log_buf != __log_buf)\n\t\treturn;\n\n\tif (!early && !new_log_buf_len)\n\t\tlog_buf_add_cpu();\n\n\tif (!new_log_buf_len)\n\t\treturn;\n\n\tif (early) {\n\t\tnew_log_buf =\n\t\t\tmemblock_alloc(new_log_buf_len, LOG_ALIGN);\n\t} else {\n\t\tnew_log_buf = memblock_alloc_nopanic(new_log_buf_len,\n\t\t\t\t\t\t\t  LOG_ALIGN);\n\t}\n\n\tif (unlikely(!new_log_buf)) {\n\t\tpr_err(\"log_buf_len: %lu bytes not available\\n\",\n\t\t\tnew_log_buf_len);\n\t\treturn;\n\t}\n\n\tlogbuf_lock_irqsave(flags);\n\tlog_buf_len = new_log_buf_len;\n\tlog_buf = new_log_buf;\n\tnew_log_buf_len = 0;\n\tfree = __LOG_BUF_LEN - log_next_idx;\n\tmemcpy(log_buf, __log_buf, __LOG_BUF_LEN);\n\tlogbuf_unlock_irqrestore(flags);\n\n\tpr_info(\"log_buf_len: %u bytes\\n\", log_buf_len);\n\tpr_info(\"early log buf free: %u(%u%%)\\n\",\n\t\tfree, (free * 100) / __LOG_BUF_LEN);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)",
      "#define LOG_ALIGN __alignof__(struct printk_log)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"early log buf free: %u(%u%%)\\n\"",
            "free",
            "(free * 100) / __LOG_BUF_LEN"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"log_buf_len: %u bytes\\n\"",
            "log_buf_len"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_unlock_irqrestore",
          "args": [
            "flags"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "log_buf",
            "__log_buf",
            "__LOG_BUF_LEN"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irqsave",
          "args": [
            "flags"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"log_buf_len: %lu bytes not available\\n\"",
            "new_log_buf_len"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!new_log_buf"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc_nopanic",
          "args": [
            "new_log_buf_len",
            "LOG_ALIGN"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "new_log_buf_len",
            "LOG_ALIGN"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_buf_add_cpu",
          "args": [],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "log_buf_add_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1093-1093",
          "snippet": "static inline void log_buf_add_cpu(void) {}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic inline void log_buf_add_cpu(void) {}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)\n#define LOG_ALIGN __alignof__(struct printk_log)\n\nvoid __init setup_log_buf(int early)\n{\n\tunsigned long flags;\n\tchar *new_log_buf;\n\tunsigned int free;\n\n\tif (log_buf != __log_buf)\n\t\treturn;\n\n\tif (!early && !new_log_buf_len)\n\t\tlog_buf_add_cpu();\n\n\tif (!new_log_buf_len)\n\t\treturn;\n\n\tif (early) {\n\t\tnew_log_buf =\n\t\t\tmemblock_alloc(new_log_buf_len, LOG_ALIGN);\n\t} else {\n\t\tnew_log_buf = memblock_alloc_nopanic(new_log_buf_len,\n\t\t\t\t\t\t\t  LOG_ALIGN);\n\t}\n\n\tif (unlikely(!new_log_buf)) {\n\t\tpr_err(\"log_buf_len: %lu bytes not available\\n\",\n\t\t\tnew_log_buf_len);\n\t\treturn;\n\t}\n\n\tlogbuf_lock_irqsave(flags);\n\tlog_buf_len = new_log_buf_len;\n\tlog_buf = new_log_buf;\n\tnew_log_buf_len = 0;\n\tfree = __LOG_BUF_LEN - log_next_idx;\n\tmemcpy(log_buf, __log_buf, __LOG_BUF_LEN);\n\tlogbuf_unlock_irqrestore(flags);\n\n\tpr_info(\"log_buf_len: %u bytes\\n\", log_buf_len);\n\tpr_info(\"early log buf free: %u(%u%%)\\n\",\n\t\tfree, (free * 100) / __LOG_BUF_LEN);\n}"
  },
  {
    "function_name": "log_buf_add_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1093-1093",
    "snippet": "static inline void log_buf_add_cpu(void) {}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic inline void log_buf_add_cpu(void) {}"
  },
  {
    "function_name": "log_buf_add_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1066-1091",
    "snippet": "static void __init log_buf_add_cpu(void)\n{\n\tunsigned int cpu_extra;\n\n\t/*\n\t * archs should set up cpu_possible_bits properly with\n\t * set_cpu_possible() after setup_arch() but just in\n\t * case lets ensure this is valid.\n\t */\n\tif (num_possible_cpus() == 1)\n\t\treturn;\n\n\tcpu_extra = (num_possible_cpus() - 1) * __LOG_CPU_MAX_BUF_LEN;\n\n\t/* by default this will only continue through for large > 64 CPUs */\n\tif (cpu_extra <= __LOG_BUF_LEN / 2)\n\t\treturn;\n\n\tpr_info(\"log_buf_len individual max cpu contribution: %d bytes\\n\",\n\t\t__LOG_CPU_MAX_BUF_LEN);\n\tpr_info(\"log_buf_len total cpu_extra contributions: %d bytes\\n\",\n\t\tcpu_extra);\n\tpr_info(\"log_buf_len min size: %d bytes\\n\", __LOG_BUF_LEN);\n\n\tlog_buf_len_update(cpu_extra + __LOG_BUF_LEN);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define __LOG_CPU_MAX_BUF_LEN (1 << CONFIG_LOG_CPU_MAX_BUF_SHIFT)",
      "#define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_buf_len_update",
          "args": [
            "cpu_extra + __LOG_BUF_LEN"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "log_buf_len_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1034-1045",
          "snippet": "static void __init log_buf_len_update(u64 size)\n{\n\tif (size > (u64)LOG_BUF_LEN_MAX) {\n\t\tsize = (u64)LOG_BUF_LEN_MAX;\n\t\tpr_err(\"log_buf over 2G is not supported.\\n\");\n\t}\n\n\tif (size)\n\t\tsize = roundup_pow_of_two(size);\n\tif (size > log_buf_len)\n\t\tnew_log_buf_len = (unsigned long)size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define LOG_BUF_LEN_MAX (u32)(1 << 31)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define LOG_BUF_LEN_MAX (u32)(1 << 31)\n\nstatic void __init log_buf_len_update(u64 size)\n{\n\tif (size > (u64)LOG_BUF_LEN_MAX) {\n\t\tsize = (u64)LOG_BUF_LEN_MAX;\n\t\tpr_err(\"log_buf over 2G is not supported.\\n\");\n\t}\n\n\tif (size)\n\t\tsize = roundup_pow_of_two(size);\n\tif (size > log_buf_len)\n\t\tnew_log_buf_len = (unsigned long)size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"log_buf_len min size: %d bytes\\n\"",
            "__LOG_BUF_LEN"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"log_buf_len total cpu_extra contributions: %d bytes\\n\"",
            "cpu_extra"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"log_buf_len individual max cpu contribution: %d bytes\\n\"",
            "__LOG_CPU_MAX_BUF_LEN"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define __LOG_CPU_MAX_BUF_LEN (1 << CONFIG_LOG_CPU_MAX_BUF_SHIFT)\n#define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)\n\nstatic void __init log_buf_add_cpu(void)\n{\n\tunsigned int cpu_extra;\n\n\t/*\n\t * archs should set up cpu_possible_bits properly with\n\t * set_cpu_possible() after setup_arch() but just in\n\t * case lets ensure this is valid.\n\t */\n\tif (num_possible_cpus() == 1)\n\t\treturn;\n\n\tcpu_extra = (num_possible_cpus() - 1) * __LOG_CPU_MAX_BUF_LEN;\n\n\t/* by default this will only continue through for large > 64 CPUs */\n\tif (cpu_extra <= __LOG_BUF_LEN / 2)\n\t\treturn;\n\n\tpr_info(\"log_buf_len individual max cpu contribution: %d bytes\\n\",\n\t\t__LOG_CPU_MAX_BUF_LEN);\n\tpr_info(\"log_buf_len total cpu_extra contributions: %d bytes\\n\",\n\t\tcpu_extra);\n\tpr_info(\"log_buf_len min size: %d bytes\\n\", __LOG_BUF_LEN);\n\n\tlog_buf_len_update(cpu_extra + __LOG_BUF_LEN);\n}"
  },
  {
    "function_name": "log_buf_len_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1048-1060",
    "snippet": "static int __init log_buf_len_setup(char *str)\n{\n\tu64 size;\n\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tsize = memparse(str, &str);\n\n\tlog_buf_len_update(size);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_buf_len_update",
          "args": [
            "size"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "log_buf_len_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1034-1045",
          "snippet": "static void __init log_buf_len_update(u64 size)\n{\n\tif (size > (u64)LOG_BUF_LEN_MAX) {\n\t\tsize = (u64)LOG_BUF_LEN_MAX;\n\t\tpr_err(\"log_buf over 2G is not supported.\\n\");\n\t}\n\n\tif (size)\n\t\tsize = roundup_pow_of_two(size);\n\tif (size > log_buf_len)\n\t\tnew_log_buf_len = (unsigned long)size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define LOG_BUF_LEN_MAX (u32)(1 << 31)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define LOG_BUF_LEN_MAX (u32)(1 << 31)\n\nstatic void __init log_buf_len_update(u64 size)\n{\n\tif (size > (u64)LOG_BUF_LEN_MAX) {\n\t\tsize = (u64)LOG_BUF_LEN_MAX;\n\t\tpr_err(\"log_buf over 2G is not supported.\\n\");\n\t}\n\n\tif (size)\n\t\tsize = roundup_pow_of_two(size);\n\tif (size > log_buf_len)\n\t\tnew_log_buf_len = (unsigned long)size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "str",
            "&str"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int __init log_buf_len_setup(char *str)\n{\n\tu64 size;\n\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tsize = memparse(str, &str);\n\n\tlog_buf_len_update(size);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "log_buf_len_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1034-1045",
    "snippet": "static void __init log_buf_len_update(u64 size)\n{\n\tif (size > (u64)LOG_BUF_LEN_MAX) {\n\t\tsize = (u64)LOG_BUF_LEN_MAX;\n\t\tpr_err(\"log_buf over 2G is not supported.\\n\");\n\t}\n\n\tif (size)\n\t\tsize = roundup_pow_of_two(size);\n\tif (size > log_buf_len)\n\t\tnew_log_buf_len = (unsigned long)size;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define LOG_BUF_LEN_MAX (u32)(1 << 31)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "size"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"log_buf over 2G is not supported.\\n\""
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define LOG_BUF_LEN_MAX (u32)(1 << 31)\n\nstatic void __init log_buf_len_update(u64 size)\n{\n\tif (size > (u64)LOG_BUF_LEN_MAX) {\n\t\tsize = (u64)LOG_BUF_LEN_MAX;\n\t\tpr_err(\"log_buf over 2G is not supported.\\n\");\n\t}\n\n\tif (size)\n\t\tsize = roundup_pow_of_two(size);\n\tif (size > log_buf_len)\n\t\tnew_log_buf_len = (unsigned long)size;\n}"
  },
  {
    "function_name": "log_buf_vmcoreinfo_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1011-1027",
    "snippet": "void log_buf_vmcoreinfo_setup(void)\n{\n\tVMCOREINFO_SYMBOL(log_buf);\n\tVMCOREINFO_SYMBOL(log_buf_len);\n\tVMCOREINFO_SYMBOL(log_first_idx);\n\tVMCOREINFO_SYMBOL(clear_idx);\n\tVMCOREINFO_SYMBOL(log_next_idx);\n\t/*\n\t * Export struct printk_log size and field offsets. User space tools can\n\t * parse it and detect any changes to structure down the line.\n\t */\n\tVMCOREINFO_STRUCT_SIZE(printk_log);\n\tVMCOREINFO_OFFSET(printk_log, ts_nsec);\n\tVMCOREINFO_OFFSET(printk_log, len);\n\tVMCOREINFO_OFFSET(printk_log, text_len);\n\tVMCOREINFO_OFFSET(printk_log, dict_len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "printk_log",
            "dict_len"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "printk_log",
            "text_len"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "printk_log",
            "len"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "printk_log",
            "ts_nsec"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_STRUCT_SIZE",
          "args": [
            "printk_log"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "log_next_idx"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "clear_idx"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "log_first_idx"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "log_buf_len"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "log_buf"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid log_buf_vmcoreinfo_setup(void)\n{\n\tVMCOREINFO_SYMBOL(log_buf);\n\tVMCOREINFO_SYMBOL(log_buf_len);\n\tVMCOREINFO_SYMBOL(log_first_idx);\n\tVMCOREINFO_SYMBOL(clear_idx);\n\tVMCOREINFO_SYMBOL(log_next_idx);\n\t/*\n\t * Export struct printk_log size and field offsets. User space tools can\n\t * parse it and detect any changes to structure down the line.\n\t */\n\tVMCOREINFO_STRUCT_SIZE(printk_log);\n\tVMCOREINFO_OFFSET(printk_log, ts_nsec);\n\tVMCOREINFO_OFFSET(printk_log, len);\n\tVMCOREINFO_OFFSET(printk_log, text_len);\n\tVMCOREINFO_OFFSET(printk_log, dict_len);\n}"
  },
  {
    "function_name": "devkmsg_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "979-991",
    "snippet": "static int devkmsg_release(struct inode *inode, struct file *file)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\n\tif (!user)\n\t\treturn 0;\n\n\tratelimit_state_exit(&user->rs);\n\n\tmutex_destroy(&user->lock);\n\tkfree(user);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "user"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&user->lock"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1658-1664",
          "snippet": "void rt_mutex_destroy(struct rt_mutex *lock)\n{\n\tWARN_ON(rt_mutex_is_locked(lock));\n#ifdef CONFIG_DEBUG_RT_MUTEXES\n\tlock->magic = NULL;\n#endif\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid rt_mutex_destroy(struct rt_mutex *lock)\n{\n\tWARN_ON(rt_mutex_is_locked(lock));\n#ifdef CONFIG_DEBUG_RT_MUTEXES\n\tlock->magic = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ratelimit_state_exit",
          "args": [
            "&user->rs"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int devkmsg_release(struct inode *inode, struct file *file)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\n\tif (!user)\n\t\treturn 0;\n\n\tratelimit_state_exit(&user->rs);\n\n\tmutex_destroy(&user->lock);\n\tkfree(user);\n\treturn 0;\n}"
  },
  {
    "function_name": "devkmsg_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "945-977",
    "snippet": "static int devkmsg_open(struct inode *inode, struct file *file)\n{\n\tstruct devkmsg_user *user;\n\tint err;\n\n\tif (devkmsg_log & DEVKMSG_LOG_MASK_OFF)\n\t\treturn -EPERM;\n\n\t/* write-only does not need any file context */\n\tif ((file->f_flags & O_ACCMODE) != O_WRONLY) {\n\t\terr = check_syslog_permissions(SYSLOG_ACTION_READ_ALL,\n\t\t\t\t\t       SYSLOG_FROM_READER);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tuser = kmalloc(sizeof(struct devkmsg_user), GFP_KERNEL);\n\tif (!user)\n\t\treturn -ENOMEM;\n\n\tratelimit_default_init(&user->rs);\n\tratelimit_set_flags(&user->rs, RATELIMIT_MSG_ON_RELEASE);\n\n\tmutex_init(&user->lock);\n\n\tlogbuf_lock_irq();\n\tuser->idx = log_first_idx;\n\tuser->seq = log_first_seq;\n\tlogbuf_unlock_irq();\n\n\tfile->private_data = user;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logbuf_unlock_irq",
          "args": [],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irq",
          "args": [],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&user->lock"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1604-1612",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ratelimit_set_flags",
          "args": [
            "&user->rs",
            "RATELIMIT_MSG_ON_RELEASE"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ratelimit_default_init",
          "args": [
            "&user->rs"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct devkmsg_user)",
            "GFP_KERNEL"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_syslog_permissions",
          "args": [
            "SYSLOG_ACTION_READ_ALL",
            "SYSLOG_FROM_READER"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "check_syslog_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "651-678",
          "snippet": "static int check_syslog_permissions(int type, int source)\n{\n\t/*\n\t * If this is from /proc/kmsg and we've already opened it, then we've\n\t * already done the capabilities checks at open time.\n\t */\n\tif (source == SYSLOG_FROM_PROC && type != SYSLOG_ACTION_OPEN)\n\t\tgoto ok;\n\n\tif (syslog_action_restricted(type)) {\n\t\tif (capable(CAP_SYSLOG))\n\t\t\tgoto ok;\n\t\t/*\n\t\t * For historical reasons, accept CAP_SYS_ADMIN too, with\n\t\t * a warning.\n\t\t */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tpr_warn_once(\"%s (%d): Attempt to access syslog with \"\n\t\t\t\t     \"CAP_SYS_ADMIN but no CAP_SYSLOG \"\n\t\t\t\t     \"(deprecated).\\n\",\n\t\t\t\t current->comm, task_pid_nr(current));\n\t\t\tgoto ok;\n\t\t}\n\t\treturn -EPERM;\n\t}\nok:\n\treturn security_syslog(type);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int check_syslog_permissions(int type, int source)\n{\n\t/*\n\t * If this is from /proc/kmsg and we've already opened it, then we've\n\t * already done the capabilities checks at open time.\n\t */\n\tif (source == SYSLOG_FROM_PROC && type != SYSLOG_ACTION_OPEN)\n\t\tgoto ok;\n\n\tif (syslog_action_restricted(type)) {\n\t\tif (capable(CAP_SYSLOG))\n\t\t\tgoto ok;\n\t\t/*\n\t\t * For historical reasons, accept CAP_SYS_ADMIN too, with\n\t\t * a warning.\n\t\t */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tpr_warn_once(\"%s (%d): Attempt to access syslog with \"\n\t\t\t\t     \"CAP_SYS_ADMIN but no CAP_SYSLOG \"\n\t\t\t\t     \"(deprecated).\\n\",\n\t\t\t\t current->comm, task_pid_nr(current));\n\t\t\tgoto ok;\n\t\t}\n\t\treturn -EPERM;\n\t}\nok:\n\treturn security_syslog(type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int devkmsg_open(struct inode *inode, struct file *file)\n{\n\tstruct devkmsg_user *user;\n\tint err;\n\n\tif (devkmsg_log & DEVKMSG_LOG_MASK_OFF)\n\t\treturn -EPERM;\n\n\t/* write-only does not need any file context */\n\tif ((file->f_flags & O_ACCMODE) != O_WRONLY) {\n\t\terr = check_syslog_permissions(SYSLOG_ACTION_READ_ALL,\n\t\t\t\t\t       SYSLOG_FROM_READER);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tuser = kmalloc(sizeof(struct devkmsg_user), GFP_KERNEL);\n\tif (!user)\n\t\treturn -ENOMEM;\n\n\tratelimit_default_init(&user->rs);\n\tratelimit_set_flags(&user->rs, RATELIMIT_MSG_ON_RELEASE);\n\n\tmutex_init(&user->lock);\n\n\tlogbuf_lock_irq();\n\tuser->idx = log_first_idx;\n\tuser->seq = log_first_seq;\n\tlogbuf_unlock_irq();\n\n\tfile->private_data = user;\n\treturn 0;\n}"
  },
  {
    "function_name": "devkmsg_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "922-943",
    "snippet": "static __poll_t devkmsg_poll(struct file *file, poll_table *wait)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\t__poll_t ret = 0;\n\n\tif (!user)\n\t\treturn EPOLLERR|EPOLLNVAL;\n\n\tpoll_wait(file, &log_wait, wait);\n\n\tlogbuf_lock_irq();\n\tif (user->seq < log_next_seq) {\n\t\t/* return error when data has vanished underneath us */\n\t\tif (user->seq < log_first_seq)\n\t\t\tret = EPOLLIN|EPOLLRDNORM|EPOLLERR|EPOLLPRI;\n\t\telse\n\t\t\tret = EPOLLIN|EPOLLRDNORM;\n\t}\n\tlogbuf_unlock_irq();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logbuf_unlock_irq",
          "args": [],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irq",
          "args": [],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&log_wait",
            "wait"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic __poll_t devkmsg_poll(struct file *file, poll_table *wait)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\t__poll_t ret = 0;\n\n\tif (!user)\n\t\treturn EPOLLERR|EPOLLNVAL;\n\n\tpoll_wait(file, &log_wait, wait);\n\n\tlogbuf_lock_irq();\n\tif (user->seq < log_next_seq) {\n\t\t/* return error when data has vanished underneath us */\n\t\tif (user->seq < log_first_seq)\n\t\t\tret = EPOLLIN|EPOLLRDNORM|EPOLLERR|EPOLLPRI;\n\t\telse\n\t\t\tret = EPOLLIN|EPOLLRDNORM;\n\t}\n\tlogbuf_unlock_irq();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "devkmsg_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "884-920",
    "snippet": "static loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\tloff_t ret = 0;\n\n\tif (!user)\n\t\treturn -EBADF;\n\tif (offset)\n\t\treturn -ESPIPE;\n\n\tlogbuf_lock_irq();\n\tswitch (whence) {\n\tcase SEEK_SET:\n\t\t/* the first record */\n\t\tuser->idx = log_first_idx;\n\t\tuser->seq = log_first_seq;\n\t\tbreak;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * The first record after the last SYSLOG_ACTION_CLEAR,\n\t\t * like issued by 'dmesg -c'. Reading /dev/kmsg itself\n\t\t * changes no global state, and does not clear anything.\n\t\t */\n\t\tuser->idx = clear_idx;\n\t\tuser->seq = clear_seq;\n\t\tbreak;\n\tcase SEEK_END:\n\t\t/* after the last record */\n\t\tuser->idx = log_next_idx;\n\t\tuser->seq = log_next_seq;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tlogbuf_unlock_irq();\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logbuf_unlock_irq",
          "args": [],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irq",
          "args": [],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\tloff_t ret = 0;\n\n\tif (!user)\n\t\treturn -EBADF;\n\tif (offset)\n\t\treturn -ESPIPE;\n\n\tlogbuf_lock_irq();\n\tswitch (whence) {\n\tcase SEEK_SET:\n\t\t/* the first record */\n\t\tuser->idx = log_first_idx;\n\t\tuser->seq = log_first_seq;\n\t\tbreak;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * The first record after the last SYSLOG_ACTION_CLEAR,\n\t\t * like issued by 'dmesg -c'. Reading /dev/kmsg itself\n\t\t * changes no global state, and does not clear anything.\n\t\t */\n\t\tuser->idx = clear_idx;\n\t\tuser->seq = clear_seq;\n\t\tbreak;\n\tcase SEEK_END:\n\t\t/* after the last record */\n\t\tuser->idx = log_next_idx;\n\t\tuser->seq = log_next_seq;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tlogbuf_unlock_irq();\n\treturn ret;\n}"
  },
  {
    "function_name": "devkmsg_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "818-882",
    "snippet": "static ssize_t devkmsg_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\tstruct printk_log *msg;\n\tsize_t len;\n\tssize_t ret;\n\n\tif (!user)\n\t\treturn -EBADF;\n\n\tret = mutex_lock_interruptible(&user->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tlogbuf_lock_irq();\n\twhile (user->seq == log_next_seq) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tlogbuf_unlock_irq();\n\t\t\tgoto out;\n\t\t}\n\n\t\tlogbuf_unlock_irq();\n\t\tret = wait_event_interruptible(log_wait,\n\t\t\t\t\t       user->seq != log_next_seq);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tlogbuf_lock_irq();\n\t}\n\n\tif (user->seq < log_first_seq) {\n\t\t/* our last seen message is gone, return error and reset */\n\t\tuser->idx = log_first_idx;\n\t\tuser->seq = log_first_seq;\n\t\tret = -EPIPE;\n\t\tlogbuf_unlock_irq();\n\t\tgoto out;\n\t}\n\n\tmsg = log_from_idx(user->idx);\n\tlen = msg_print_ext_header(user->buf, sizeof(user->buf),\n\t\t\t\t   msg, user->seq);\n\tlen += msg_print_ext_body(user->buf + len, sizeof(user->buf) - len,\n\t\t\t\t  log_dict(msg), msg->dict_len,\n\t\t\t\t  log_text(msg), msg->text_len);\n\n\tuser->idx = log_next(user->idx);\n\tuser->seq++;\n\tlogbuf_unlock_irq();\n\n\tif (len > count) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(buf, user->buf, len)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tret = len;\nout:\n\tmutex_unlock(&user->lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&user->lock"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "user->buf",
            "len"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_unlock_irq",
          "args": [],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_next",
          "args": [
            "user->idx"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "log_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2020-2020",
          "snippet": "static u32 log_next(u32 idx) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic u32 log_next(u32 idx) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "msg_print_ext_body",
          "args": [
            "user->buf + len",
            "sizeof(user->buf) - len",
            "log_dict(msg)",
            "msg->dict_len",
            "log_text(msg)",
            "msg->text_len"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "msg_print_ext_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2024-2026",
          "snippet": "static ssize_t msg_print_ext_body(char *buf, size_t size,\n\t\t\t\t  char *dict, size_t dict_len,\n\t\t\t\t  char *text, size_t text_len) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic ssize_t msg_print_ext_body(char *buf, size_t size,\n\t\t\t\t  char *dict, size_t dict_len,\n\t\t\t\t  char *text, size_t text_len) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "log_text",
          "args": [
            "msg"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "log_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2017-2017",
          "snippet": "static char *log_text(const struct printk_log *msg) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic char *log_text(const struct printk_log *msg) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "log_dict",
          "args": [
            "msg"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "log_dict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2018-2018",
          "snippet": "static char *log_dict(const struct printk_log *msg) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic char *log_dict(const struct printk_log *msg) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "msg_print_ext_header",
          "args": [
            "user->buf",
            "sizeof(user->buf)",
            "msg",
            "user->seq"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "msg_print_ext_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2021-2023",
          "snippet": "static ssize_t msg_print_ext_header(char *buf, size_t size,\n\t\t\t\t    struct printk_log *msg,\n\t\t\t\t    u64 seq) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic ssize_t msg_print_ext_header(char *buf, size_t size,\n\t\t\t\t    struct printk_log *msg,\n\t\t\t\t    u64 seq) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "log_from_idx",
          "args": [
            "user->idx"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "log_from_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2019-2019",
          "snippet": "static struct printk_log *log_from_idx(u32 idx) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct printk_log *log_from_idx(u32 idx) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "logbuf_unlock_irq",
          "args": [],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irq",
          "args": [],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "log_wait",
            "user->seq != log_next_seq"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_unlock_irq",
          "args": [],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_unlock_irq",
          "args": [],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logbuf_lock_irq",
          "args": [],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&user->lock"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic ssize_t devkmsg_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\tstruct printk_log *msg;\n\tsize_t len;\n\tssize_t ret;\n\n\tif (!user)\n\t\treturn -EBADF;\n\n\tret = mutex_lock_interruptible(&user->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tlogbuf_lock_irq();\n\twhile (user->seq == log_next_seq) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tlogbuf_unlock_irq();\n\t\t\tgoto out;\n\t\t}\n\n\t\tlogbuf_unlock_irq();\n\t\tret = wait_event_interruptible(log_wait,\n\t\t\t\t\t       user->seq != log_next_seq);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tlogbuf_lock_irq();\n\t}\n\n\tif (user->seq < log_first_seq) {\n\t\t/* our last seen message is gone, return error and reset */\n\t\tuser->idx = log_first_idx;\n\t\tuser->seq = log_first_seq;\n\t\tret = -EPIPE;\n\t\tlogbuf_unlock_irq();\n\t\tgoto out;\n\t}\n\n\tmsg = log_from_idx(user->idx);\n\tlen = msg_print_ext_header(user->buf, sizeof(user->buf),\n\t\t\t\t   msg, user->seq);\n\tlen += msg_print_ext_body(user->buf + len, sizeof(user->buf) - len,\n\t\t\t\t  log_dict(msg), msg->dict_len,\n\t\t\t\t  log_text(msg), msg->text_len);\n\n\tuser->idx = log_next(user->idx);\n\tuser->seq++;\n\tlogbuf_unlock_irq();\n\n\tif (len > count) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(buf, user->buf, len)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tret = len;\nout:\n\tmutex_unlock(&user->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "devkmsg_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "755-816",
    "snippet": "static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tchar *buf, *line;\n\tint level = default_message_loglevel;\n\tint facility = 1;\t/* LOG_USER */\n\tstruct file *file = iocb->ki_filp;\n\tstruct devkmsg_user *user = file->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret = len;\n\n\tif (!user || len > LOG_LINE_MAX)\n\t\treturn -EINVAL;\n\n\t/* Ignore when user logging is disabled. */\n\tif (devkmsg_log & DEVKMSG_LOG_MASK_OFF)\n\t\treturn len;\n\n\t/* Ratelimit when not explicitly enabled. */\n\tif (!(devkmsg_log & DEVKMSG_LOG_MASK_ON)) {\n\t\tif (!___ratelimit(&user->rs, current->comm))\n\t\t\treturn ret;\n\t}\n\n\tbuf = kmalloc(len+1, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tbuf[len] = '\\0';\n\tif (!copy_from_iter_full(buf, len, from)) {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Extract and skip the syslog prefix <[0-9]*>. Coming from userspace\n\t * the decimal value represents 32bit, the lower 3 bit are the log\n\t * level, the rest are the log facility.\n\t *\n\t * If no prefix or no userspace facility is specified, we\n\t * enforce LOG_USER, to be able to reliably distinguish\n\t * kernel-generated messages from userspace-injected ones.\n\t */\n\tline = buf;\n\tif (line[0] == '<') {\n\t\tchar *endp = NULL;\n\t\tunsigned int u;\n\n\t\tu = simple_strtoul(line + 1, &endp, 10);\n\t\tif (endp && endp[0] == '>') {\n\t\t\tlevel = LOG_LEVEL(u);\n\t\t\tif (LOG_FACILITY(u) != 0)\n\t\t\t\tfacility = LOG_FACILITY(u);\n\t\t\tendp++;\n\t\t\tlen -= endp - line;\n\t\t\tline = endp;\n\t\t}\n\t}\n\n\tprintk_emit(facility, level, NULL, 0, \"%s\", line);\n\tkfree(buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define LOG_LINE_MAX\t\t0",
      "#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_emit",
          "args": [
            "facility",
            "level",
            "NULL",
            "0",
            "\"%s\"",
            "line"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "printk_emit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "1938-1950",
          "snippet": "asmlinkage int printk_emit(int facility, int level,\n\t\t\t   const char *dict, size_t dictlen,\n\t\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_emit(facility, level, dict, dictlen, fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nasmlinkage int printk_emit(int facility, int level,\n\t\t\t   const char *dict, size_t dictlen,\n\t\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_emit(facility, level, dict, dictlen, fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOG_FACILITY",
          "args": [
            "u"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG_FACILITY",
          "args": [
            "u"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG_LEVEL",
          "args": [
            "u"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "line + 1",
            "&endp",
            "10"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_iter_full",
          "args": [
            "buf",
            "len",
            "from"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len+1",
            "GFP_KERNEL"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "___ratelimit",
          "args": [
            "&user->rs",
            "current->comm"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define LOG_LINE_MAX\t\t0\n#define LOG_LINE_MAX\t\t(1024 - PREFIX_MAX)\n\nstatic ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tchar *buf, *line;\n\tint level = default_message_loglevel;\n\tint facility = 1;\t/* LOG_USER */\n\tstruct file *file = iocb->ki_filp;\n\tstruct devkmsg_user *user = file->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret = len;\n\n\tif (!user || len > LOG_LINE_MAX)\n\t\treturn -EINVAL;\n\n\t/* Ignore when user logging is disabled. */\n\tif (devkmsg_log & DEVKMSG_LOG_MASK_OFF)\n\t\treturn len;\n\n\t/* Ratelimit when not explicitly enabled. */\n\tif (!(devkmsg_log & DEVKMSG_LOG_MASK_ON)) {\n\t\tif (!___ratelimit(&user->rs, current->comm))\n\t\t\treturn ret;\n\t}\n\n\tbuf = kmalloc(len+1, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tbuf[len] = '\\0';\n\tif (!copy_from_iter_full(buf, len, from)) {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Extract and skip the syslog prefix <[0-9]*>. Coming from userspace\n\t * the decimal value represents 32bit, the lower 3 bit are the log\n\t * level, the rest are the log facility.\n\t *\n\t * If no prefix or no userspace facility is specified, we\n\t * enforce LOG_USER, to be able to reliably distinguish\n\t * kernel-generated messages from userspace-injected ones.\n\t */\n\tline = buf;\n\tif (line[0] == '<') {\n\t\tchar *endp = NULL;\n\t\tunsigned int u;\n\n\t\tu = simple_strtoul(line + 1, &endp, 10);\n\t\tif (endp && endp[0] == '>') {\n\t\t\tlevel = LOG_LEVEL(u);\n\t\t\tif (LOG_FACILITY(u) != 0)\n\t\t\t\tfacility = LOG_FACILITY(u);\n\t\t\tendp++;\n\t\t\tlen -= endp - line;\n\t\t\tline = endp;\n\t\t}\n\t}\n\n\tprintk_emit(facility, level, NULL, 0, \"%s\", line);\n\tkfree(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "msg_print_ext_body",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "698-744",
    "snippet": "static ssize_t msg_print_ext_body(char *buf, size_t size,\n\t\t\t\t  char *dict, size_t dict_len,\n\t\t\t\t  char *text, size_t text_len)\n{\n\tchar *p = buf, *e = buf + size;\n\tsize_t i;\n\n\t/* escape non-printable characters */\n\tfor (i = 0; i < text_len; i++) {\n\t\tunsigned char c = text[i];\n\n\t\tif (c < ' ' || c >= 127 || c == '\\\\')\n\t\t\tp += scnprintf(p, e - p, \"\\\\x%02x\", c);\n\t\telse\n\t\t\tappend_char(&p, e, c);\n\t}\n\tappend_char(&p, e, '\\n');\n\n\tif (dict_len) {\n\t\tbool line = true;\n\n\t\tfor (i = 0; i < dict_len; i++) {\n\t\t\tunsigned char c = dict[i];\n\n\t\t\tif (line) {\n\t\t\t\tappend_char(&p, e, ' ');\n\t\t\t\tline = false;\n\t\t\t}\n\n\t\t\tif (c == '\\0') {\n\t\t\t\tappend_char(&p, e, '\\n');\n\t\t\t\tline = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c < ' ' || c >= 127 || c == '\\\\') {\n\t\t\t\tp += scnprintf(p, e - p, \"\\\\x%02x\", c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tappend_char(&p, e, c);\n\t\t}\n\t\tappend_char(&p, e, '\\n');\n\t}\n\n\treturn p - buf;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "append_char",
          "args": [
            "&p",
            "e",
            "'\\n'"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "append_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "680-684",
          "snippet": "static void append_char(char **pp, char *e, char c)\n{\n\tif (*pp < e)\n\t\t*(*pp)++ = c;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void append_char(char **pp, char *e, char c)\n{\n\tif (*pp < e)\n\t\t*(*pp)++ = c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "p",
            "e - p",
            "\"\\\\x%02x\"",
            "c"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "p",
            "e - p",
            "\"\\\\x%02x\"",
            "c"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic ssize_t msg_print_ext_body(char *buf, size_t size,\n\t\t\t\t  char *dict, size_t dict_len,\n\t\t\t\t  char *text, size_t text_len)\n{\n\tchar *p = buf, *e = buf + size;\n\tsize_t i;\n\n\t/* escape non-printable characters */\n\tfor (i = 0; i < text_len; i++) {\n\t\tunsigned char c = text[i];\n\n\t\tif (c < ' ' || c >= 127 || c == '\\\\')\n\t\t\tp += scnprintf(p, e - p, \"\\\\x%02x\", c);\n\t\telse\n\t\t\tappend_char(&p, e, c);\n\t}\n\tappend_char(&p, e, '\\n');\n\n\tif (dict_len) {\n\t\tbool line = true;\n\n\t\tfor (i = 0; i < dict_len; i++) {\n\t\t\tunsigned char c = dict[i];\n\n\t\t\tif (line) {\n\t\t\t\tappend_char(&p, e, ' ');\n\t\t\t\tline = false;\n\t\t\t}\n\n\t\t\tif (c == '\\0') {\n\t\t\t\tappend_char(&p, e, '\\n');\n\t\t\t\tline = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c < ' ' || c >= 127 || c == '\\\\') {\n\t\t\t\tp += scnprintf(p, e - p, \"\\\\x%02x\", c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tappend_char(&p, e, c);\n\t\t}\n\t\tappend_char(&p, e, '\\n');\n\t}\n\n\treturn p - buf;\n}"
  },
  {
    "function_name": "msg_print_ext_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "686-696",
    "snippet": "static ssize_t msg_print_ext_header(char *buf, size_t size,\n\t\t\t\t    struct printk_log *msg, u64 seq)\n{\n\tu64 ts_usec = msg->ts_nsec;\n\n\tdo_div(ts_usec, 1000);\n\n\treturn scnprintf(buf, size, \"%u,%llu,%llu,%c;\",\n\t\t       (msg->facility << 3) | msg->level, seq, ts_usec,\n\t\t       msg->flags & LOG_CONT ? 'c' : '-');\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "size",
            "\"%u,%llu,%llu,%c;\"",
            "(msg->facility << 3) | msg->level",
            "seq",
            "ts_usec",
            "msg->flags & LOG_CONT ? 'c' : '-'"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ts_usec",
            "1000"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic ssize_t msg_print_ext_header(char *buf, size_t size,\n\t\t\t\t    struct printk_log *msg, u64 seq)\n{\n\tu64 ts_usec = msg->ts_nsec;\n\n\tdo_div(ts_usec, 1000);\n\n\treturn scnprintf(buf, size, \"%u,%llu,%llu,%c;\",\n\t\t       (msg->facility << 3) | msg->level, seq, ts_usec,\n\t\t       msg->flags & LOG_CONT ? 'c' : '-');\n}"
  },
  {
    "function_name": "append_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "680-684",
    "snippet": "static void append_char(char **pp, char *e, char c)\n{\n\tif (*pp < e)\n\t\t*(*pp)++ = c;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void append_char(char **pp, char *e, char c)\n{\n\tif (*pp < e)\n\t\t*(*pp)++ = c;\n}"
  },
  {
    "function_name": "check_syslog_permissions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "651-678",
    "snippet": "static int check_syslog_permissions(int type, int source)\n{\n\t/*\n\t * If this is from /proc/kmsg and we've already opened it, then we've\n\t * already done the capabilities checks at open time.\n\t */\n\tif (source == SYSLOG_FROM_PROC && type != SYSLOG_ACTION_OPEN)\n\t\tgoto ok;\n\n\tif (syslog_action_restricted(type)) {\n\t\tif (capable(CAP_SYSLOG))\n\t\t\tgoto ok;\n\t\t/*\n\t\t * For historical reasons, accept CAP_SYS_ADMIN too, with\n\t\t * a warning.\n\t\t */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tpr_warn_once(\"%s (%d): Attempt to access syslog with \"\n\t\t\t\t     \"CAP_SYS_ADMIN but no CAP_SYSLOG \"\n\t\t\t\t     \"(deprecated).\\n\",\n\t\t\t\t current->comm, task_pid_nr(current));\n\t\t\tgoto ok;\n\t\t}\n\t\treturn -EPERM;\n\t}\nok:\n\treturn security_syslog(type);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_syslog",
          "args": [
            "type"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"%s (%d): Attempt to access syslog with \"\n\t\t\t\t     \"CAP_SYS_ADMIN but no CAP_SYSLOG \"\n\t\t\t\t     \"(deprecated).\\n\"",
            "current->comm",
            "task_pid_nr(current)"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syslog_action_restricted",
          "args": [
            "type"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "syslog_action_restricted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "639-649",
          "snippet": "static int syslog_action_restricted(int type)\n{\n\tif (dmesg_restrict)\n\t\treturn 1;\n\t/*\n\t * Unless restricted, we allow \"read all\" and \"get buffer size\"\n\t * for everybody.\n\t */\n\treturn type != SYSLOG_ACTION_READ_ALL &&\n\t       type != SYSLOG_ACTION_SIZE_BUFFER;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int syslog_action_restricted(int type)\n{\n\tif (dmesg_restrict)\n\t\treturn 1;\n\t/*\n\t * Unless restricted, we allow \"read all\" and \"get buffer size\"\n\t * for everybody.\n\t */\n\treturn type != SYSLOG_ACTION_READ_ALL &&\n\t       type != SYSLOG_ACTION_SIZE_BUFFER;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int check_syslog_permissions(int type, int source)\n{\n\t/*\n\t * If this is from /proc/kmsg and we've already opened it, then we've\n\t * already done the capabilities checks at open time.\n\t */\n\tif (source == SYSLOG_FROM_PROC && type != SYSLOG_ACTION_OPEN)\n\t\tgoto ok;\n\n\tif (syslog_action_restricted(type)) {\n\t\tif (capable(CAP_SYSLOG))\n\t\t\tgoto ok;\n\t\t/*\n\t\t * For historical reasons, accept CAP_SYS_ADMIN too, with\n\t\t * a warning.\n\t\t */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tpr_warn_once(\"%s (%d): Attempt to access syslog with \"\n\t\t\t\t     \"CAP_SYS_ADMIN but no CAP_SYSLOG \"\n\t\t\t\t     \"(deprecated).\\n\",\n\t\t\t\t current->comm, task_pid_nr(current));\n\t\t\tgoto ok;\n\t\t}\n\t\treturn -EPERM;\n\t}\nok:\n\treturn security_syslog(type);\n}"
  },
  {
    "function_name": "syslog_action_restricted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "639-649",
    "snippet": "static int syslog_action_restricted(int type)\n{\n\tif (dmesg_restrict)\n\t\treturn 1;\n\t/*\n\t * Unless restricted, we allow \"read all\" and \"get buffer size\"\n\t * for everybody.\n\t */\n\treturn type != SYSLOG_ACTION_READ_ALL &&\n\t       type != SYSLOG_ACTION_SIZE_BUFFER;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int syslog_action_restricted(int type)\n{\n\tif (dmesg_restrict)\n\t\treturn 1;\n\t/*\n\t * Unless restricted, we allow \"read all\" and \"get buffer size\"\n\t * for everybody.\n\t */\n\treturn type != SYSLOG_ACTION_READ_ALL &&\n\t       type != SYSLOG_ACTION_SIZE_BUFFER;\n}"
  },
  {
    "function_name": "log_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "579-635",
    "snippet": "static int log_store(int facility, int level,\n\t\t     enum log_flags flags, u64 ts_nsec,\n\t\t     const char *dict, u16 dict_len,\n\t\t     const char *text, u16 text_len)\n{\n\tstruct printk_log *msg;\n\tu32 size, pad_len;\n\tu16 trunc_msg_len = 0;\n\n\t/* number of '\\0' padding bytes to next message */\n\tsize = msg_used_size(text_len, dict_len, &pad_len);\n\n\tif (log_make_free_space(size)) {\n\t\t/* truncate the message if it is too long for empty buffer */\n\t\tsize = truncate_msg(&text_len, &trunc_msg_len,\n\t\t\t\t    &dict_len, &pad_len);\n\t\t/* survive when the log buffer is too small for trunc_msg */\n\t\tif (log_make_free_space(size))\n\t\t\treturn 0;\n\t}\n\n\tif (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {\n\t\t/*\n\t\t * This message + an additional empty header does not fit\n\t\t * at the end of the buffer. Add an empty header with len == 0\n\t\t * to signify a wrap around.\n\t\t */\n\t\tmemset(log_buf + log_next_idx, 0, sizeof(struct printk_log));\n\t\tlog_next_idx = 0;\n\t}\n\n\t/* fill message */\n\tmsg = (struct printk_log *)(log_buf + log_next_idx);\n\tmemcpy(log_text(msg), text, text_len);\n\tmsg->text_len = text_len;\n\tif (trunc_msg_len) {\n\t\tmemcpy(log_text(msg) + text_len, trunc_msg, trunc_msg_len);\n\t\tmsg->text_len += trunc_msg_len;\n\t}\n\tmemcpy(log_dict(msg), dict, dict_len);\n\tmsg->dict_len = dict_len;\n\tmsg->facility = facility;\n\tmsg->level = level & 7;\n\tmsg->flags = flags & 0x1f;\n\tif (ts_nsec > 0)\n\t\tmsg->ts_nsec = ts_nsec;\n\telse\n\t\tmsg->ts_nsec = local_clock();\n\tmemset(log_dict(msg) + dict_len, 0, pad_len);\n\tmsg->len = size;\n\n\t/* insert message */\n\tlog_next_idx += msg->len;\n\tlog_next_seq++;\n\n\treturn msg->text_len;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "log_dict(msg) + dict_len",
            "0",
            "pad_len"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_dict",
          "args": [
            "msg"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "log_dict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2018-2018",
          "snippet": "static char *log_dict(const struct printk_log *msg) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic char *log_dict(const struct printk_log *msg) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "local_clock",
          "args": [],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "log_dict(msg)",
            "dict",
            "dict_len"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_text",
          "args": [
            "msg"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "log_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2017-2017",
          "snippet": "static char *log_text(const struct printk_log *msg) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic char *log_text(const struct printk_log *msg) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "log_buf + log_next_idx",
            "0",
            "sizeof(struct printk_log)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_make_free_space",
          "args": [
            "size"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "log_make_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "519-538",
          "snippet": "static int log_make_free_space(u32 msg_size)\n{\n\twhile (log_first_seq < log_next_seq &&\n\t       !logbuf_has_space(msg_size, false)) {\n\t\t/* drop old messages until we have enough contiguous space */\n\t\tlog_first_idx = log_next(log_first_idx);\n\t\tlog_first_seq++;\n\t}\n\n\tif (clear_seq < log_first_seq) {\n\t\tclear_seq = log_first_seq;\n\t\tclear_idx = log_first_idx;\n\t}\n\n\t/* sequence numbers are equal, so the log buffer is empty */\n\tif (logbuf_has_space(msg_size, log_first_seq == log_next_seq))\n\t\treturn 0;\n\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int log_make_free_space(u32 msg_size)\n{\n\twhile (log_first_seq < log_next_seq &&\n\t       !logbuf_has_space(msg_size, false)) {\n\t\t/* drop old messages until we have enough contiguous space */\n\t\tlog_first_idx = log_next(log_first_idx);\n\t\tlog_first_seq++;\n\t}\n\n\tif (clear_seq < log_first_seq) {\n\t\tclear_seq = log_first_seq;\n\t\tclear_idx = log_first_idx;\n\t}\n\n\t/* sequence numbers are equal, so the log buffer is empty */\n\tif (logbuf_has_space(msg_size, log_first_seq == log_next_seq))\n\t\treturn 0;\n\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_msg",
          "args": [
            "&text_len",
            "&trunc_msg_len",
            "&dict_len",
            "&pad_len"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "560-576",
          "snippet": "static u32 truncate_msg(u16 *text_len, u16 *trunc_msg_len,\n\t\t\tu16 *dict_len, u32 *pad_len)\n{\n\t/*\n\t * The message should not take the whole buffer. Otherwise, it might\n\t * get removed too soon.\n\t */\n\tu32 max_text_len = log_buf_len / MAX_LOG_TAKE_PART;\n\tif (*text_len > max_text_len)\n\t\t*text_len = max_text_len;\n\t/* enable the warning message */\n\t*trunc_msg_len = strlen(trunc_msg);\n\t/* disable the \"dict\" completely */\n\t*dict_len = 0;\n\t/* compute the size again, count also the warning message */\n\treturn msg_used_size(*text_len + *trunc_msg_len, 0, pad_len);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_LOG_TAKE_PART 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define MAX_LOG_TAKE_PART 4\n\nstatic u32 truncate_msg(u16 *text_len, u16 *trunc_msg_len,\n\t\t\tu16 *dict_len, u32 *pad_len)\n{\n\t/*\n\t * The message should not take the whole buffer. Otherwise, it might\n\t * get removed too soon.\n\t */\n\tu32 max_text_len = log_buf_len / MAX_LOG_TAKE_PART;\n\tif (*text_len > max_text_len)\n\t\t*text_len = max_text_len;\n\t/* enable the warning message */\n\t*trunc_msg_len = strlen(trunc_msg);\n\t/* disable the \"dict\" completely */\n\t*dict_len = 0;\n\t/* compute the size again, count also the warning message */\n\treturn msg_used_size(*text_len + *trunc_msg_len, 0, pad_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg_used_size",
          "args": [
            "text_len",
            "dict_len",
            "&pad_len"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "msg_used_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "541-550",
          "snippet": "static u32 msg_used_size(u16 text_len, u16 dict_len, u32 *pad_len)\n{\n\tu32 size;\n\n\tsize = sizeof(struct printk_log) + text_len + dict_len;\n\t*pad_len = (-size) & (LOG_ALIGN - 1);\n\tsize += *pad_len;\n\n\treturn size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define LOG_ALIGN __alignof__(struct printk_log)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define LOG_ALIGN __alignof__(struct printk_log)\n\nstatic u32 msg_used_size(u16 text_len, u16 dict_len, u32 *pad_len)\n{\n\tu32 size;\n\n\tsize = sizeof(struct printk_log) + text_len + dict_len;\n\t*pad_len = (-size) & (LOG_ALIGN - 1);\n\tsize += *pad_len;\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int log_store(int facility, int level,\n\t\t     enum log_flags flags, u64 ts_nsec,\n\t\t     const char *dict, u16 dict_len,\n\t\t     const char *text, u16 text_len)\n{\n\tstruct printk_log *msg;\n\tu32 size, pad_len;\n\tu16 trunc_msg_len = 0;\n\n\t/* number of '\\0' padding bytes to next message */\n\tsize = msg_used_size(text_len, dict_len, &pad_len);\n\n\tif (log_make_free_space(size)) {\n\t\t/* truncate the message if it is too long for empty buffer */\n\t\tsize = truncate_msg(&text_len, &trunc_msg_len,\n\t\t\t\t    &dict_len, &pad_len);\n\t\t/* survive when the log buffer is too small for trunc_msg */\n\t\tif (log_make_free_space(size))\n\t\t\treturn 0;\n\t}\n\n\tif (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {\n\t\t/*\n\t\t * This message + an additional empty header does not fit\n\t\t * at the end of the buffer. Add an empty header with len == 0\n\t\t * to signify a wrap around.\n\t\t */\n\t\tmemset(log_buf + log_next_idx, 0, sizeof(struct printk_log));\n\t\tlog_next_idx = 0;\n\t}\n\n\t/* fill message */\n\tmsg = (struct printk_log *)(log_buf + log_next_idx);\n\tmemcpy(log_text(msg), text, text_len);\n\tmsg->text_len = text_len;\n\tif (trunc_msg_len) {\n\t\tmemcpy(log_text(msg) + text_len, trunc_msg, trunc_msg_len);\n\t\tmsg->text_len += trunc_msg_len;\n\t}\n\tmemcpy(log_dict(msg), dict, dict_len);\n\tmsg->dict_len = dict_len;\n\tmsg->facility = facility;\n\tmsg->level = level & 7;\n\tmsg->flags = flags & 0x1f;\n\tif (ts_nsec > 0)\n\t\tmsg->ts_nsec = ts_nsec;\n\telse\n\t\tmsg->ts_nsec = local_clock();\n\tmemset(log_dict(msg) + dict_len, 0, pad_len);\n\tmsg->len = size;\n\n\t/* insert message */\n\tlog_next_idx += msg->len;\n\tlog_next_seq++;\n\n\treturn msg->text_len;\n}"
  },
  {
    "function_name": "truncate_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "560-576",
    "snippet": "static u32 truncate_msg(u16 *text_len, u16 *trunc_msg_len,\n\t\t\tu16 *dict_len, u32 *pad_len)\n{\n\t/*\n\t * The message should not take the whole buffer. Otherwise, it might\n\t * get removed too soon.\n\t */\n\tu32 max_text_len = log_buf_len / MAX_LOG_TAKE_PART;\n\tif (*text_len > max_text_len)\n\t\t*text_len = max_text_len;\n\t/* enable the warning message */\n\t*trunc_msg_len = strlen(trunc_msg);\n\t/* disable the \"dict\" completely */\n\t*dict_len = 0;\n\t/* compute the size again, count also the warning message */\n\treturn msg_used_size(*text_len + *trunc_msg_len, 0, pad_len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MAX_LOG_TAKE_PART 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msg_used_size",
          "args": [
            "*text_len + *trunc_msg_len",
            "0",
            "pad_len"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "msg_used_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "541-550",
          "snippet": "static u32 msg_used_size(u16 text_len, u16 dict_len, u32 *pad_len)\n{\n\tu32 size;\n\n\tsize = sizeof(struct printk_log) + text_len + dict_len;\n\t*pad_len = (-size) & (LOG_ALIGN - 1);\n\tsize += *pad_len;\n\n\treturn size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define LOG_ALIGN __alignof__(struct printk_log)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define LOG_ALIGN __alignof__(struct printk_log)\n\nstatic u32 msg_used_size(u16 text_len, u16 dict_len, u32 *pad_len)\n{\n\tu32 size;\n\n\tsize = sizeof(struct printk_log) + text_len + dict_len;\n\t*pad_len = (-size) & (LOG_ALIGN - 1);\n\tsize += *pad_len;\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "trunc_msg"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define MAX_LOG_TAKE_PART 4\n\nstatic u32 truncate_msg(u16 *text_len, u16 *trunc_msg_len,\n\t\t\tu16 *dict_len, u32 *pad_len)\n{\n\t/*\n\t * The message should not take the whole buffer. Otherwise, it might\n\t * get removed too soon.\n\t */\n\tu32 max_text_len = log_buf_len / MAX_LOG_TAKE_PART;\n\tif (*text_len > max_text_len)\n\t\t*text_len = max_text_len;\n\t/* enable the warning message */\n\t*trunc_msg_len = strlen(trunc_msg);\n\t/* disable the \"dict\" completely */\n\t*dict_len = 0;\n\t/* compute the size again, count also the warning message */\n\treturn msg_used_size(*text_len + *trunc_msg_len, 0, pad_len);\n}"
  },
  {
    "function_name": "msg_used_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "541-550",
    "snippet": "static u32 msg_used_size(u16 text_len, u16 dict_len, u32 *pad_len)\n{\n\tu32 size;\n\n\tsize = sizeof(struct printk_log) + text_len + dict_len;\n\t*pad_len = (-size) & (LOG_ALIGN - 1);\n\tsize += *pad_len;\n\n\treturn size;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define LOG_ALIGN __alignof__(struct printk_log)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define LOG_ALIGN __alignof__(struct printk_log)\n\nstatic u32 msg_used_size(u16 text_len, u16 dict_len, u32 *pad_len)\n{\n\tu32 size;\n\n\tsize = sizeof(struct printk_log) + text_len + dict_len;\n\t*pad_len = (-size) & (LOG_ALIGN - 1);\n\tsize += *pad_len;\n\n\treturn size;\n}"
  },
  {
    "function_name": "log_make_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "519-538",
    "snippet": "static int log_make_free_space(u32 msg_size)\n{\n\twhile (log_first_seq < log_next_seq &&\n\t       !logbuf_has_space(msg_size, false)) {\n\t\t/* drop old messages until we have enough contiguous space */\n\t\tlog_first_idx = log_next(log_first_idx);\n\t\tlog_first_seq++;\n\t}\n\n\tif (clear_seq < log_first_seq) {\n\t\tclear_seq = log_first_seq;\n\t\tclear_idx = log_first_idx;\n\t}\n\n\t/* sequence numbers are equal, so the log buffer is empty */\n\tif (logbuf_has_space(msg_size, log_first_seq == log_next_seq))\n\t\treturn 0;\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logbuf_has_space",
          "args": [
            "msg_size",
            "log_first_seq == log_next_seq"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "logbuf_has_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "503-517",
          "snippet": "static int logbuf_has_space(u32 msg_size, bool empty)\n{\n\tu32 free;\n\n\tif (log_next_idx > log_first_idx || empty)\n\t\tfree = max(log_buf_len - log_next_idx, log_first_idx);\n\telse\n\t\tfree = log_first_idx - log_next_idx;\n\n\t/*\n\t * We need space also for an empty header that signalizes wrapping\n\t * of the buffer.\n\t */\n\treturn free >= msg_size + sizeof(struct printk_log);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int logbuf_has_space(u32 msg_size, bool empty)\n{\n\tu32 free;\n\n\tif (log_next_idx > log_first_idx || empty)\n\t\tfree = max(log_buf_len - log_next_idx, log_first_idx);\n\telse\n\t\tfree = log_first_idx - log_next_idx;\n\n\t/*\n\t * We need space also for an empty header that signalizes wrapping\n\t * of the buffer.\n\t */\n\treturn free >= msg_size + sizeof(struct printk_log);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_next",
          "args": [
            "log_first_idx"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "log_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2020-2020",
          "snippet": "static u32 log_next(u32 idx) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic u32 log_next(u32 idx) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int log_make_free_space(u32 msg_size)\n{\n\twhile (log_first_seq < log_next_seq &&\n\t       !logbuf_has_space(msg_size, false)) {\n\t\t/* drop old messages until we have enough contiguous space */\n\t\tlog_first_idx = log_next(log_first_idx);\n\t\tlog_first_seq++;\n\t}\n\n\tif (clear_seq < log_first_seq) {\n\t\tclear_seq = log_first_seq;\n\t\tclear_idx = log_first_idx;\n\t}\n\n\t/* sequence numbers are equal, so the log buffer is empty */\n\tif (logbuf_has_space(msg_size, log_first_seq == log_next_seq))\n\t\treturn 0;\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "logbuf_has_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "503-517",
    "snippet": "static int logbuf_has_space(u32 msg_size, bool empty)\n{\n\tu32 free;\n\n\tif (log_next_idx > log_first_idx || empty)\n\t\tfree = max(log_buf_len - log_next_idx, log_first_idx);\n\telse\n\t\tfree = log_first_idx - log_next_idx;\n\n\t/*\n\t * We need space also for an empty header that signalizes wrapping\n\t * of the buffer.\n\t */\n\treturn free >= msg_size + sizeof(struct printk_log);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "log_buf_len - log_next_idx",
            "log_first_idx"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int logbuf_has_space(u32 msg_size, bool empty)\n{\n\tu32 free;\n\n\tif (log_next_idx > log_first_idx || empty)\n\t\tfree = max(log_buf_len - log_next_idx, log_first_idx);\n\telse\n\t\tfree = log_first_idx - log_next_idx;\n\n\t/*\n\t * We need space also for an empty header that signalizes wrapping\n\t * of the buffer.\n\t */\n\treturn free >= msg_size + sizeof(struct printk_log);\n}"
  },
  {
    "function_name": "log_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "477-492",
    "snippet": "static u32 log_next(u32 idx)\n{\n\tstruct printk_log *msg = (struct printk_log *)(log_buf + idx);\n\n\t/* length == 0 indicates the end of the buffer; wrap */\n\t/*\n\t * A length == 0 record is the end of buffer marker. Wrap around and\n\t * read the message at the start of the buffer as *this* one, and\n\t * return the one after that.\n\t */\n\tif (!msg->len) {\n\t\tmsg = (struct printk_log *)log_buf;\n\t\treturn msg->len;\n\t}\n\treturn idx + msg->len;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic u32 log_next(u32 idx)\n{\n\tstruct printk_log *msg = (struct printk_log *)(log_buf + idx);\n\n\t/* length == 0 indicates the end of the buffer; wrap */\n\t/*\n\t * A length == 0 record is the end of buffer marker. Wrap around and\n\t * read the message at the start of the buffer as *this* one, and\n\t * return the one after that.\n\t */\n\tif (!msg->len) {\n\t\tmsg = (struct printk_log *)log_buf;\n\t\treturn msg->len;\n\t}\n\treturn idx + msg->len;\n}"
  },
  {
    "function_name": "log_from_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "463-474",
    "snippet": "static struct printk_log *log_from_idx(u32 idx)\n{\n\tstruct printk_log *msg = (struct printk_log *)(log_buf + idx);\n\n\t/*\n\t * A length == 0 record is the end of buffer marker. Wrap around and\n\t * read the message at the start of the buffer.\n\t */\n\tif (!msg->len)\n\t\treturn (struct printk_log *)log_buf;\n\treturn msg;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct printk_log *log_from_idx(u32 idx)\n{\n\tstruct printk_log *msg = (struct printk_log *)(log_buf + idx);\n\n\t/*\n\t * A length == 0 record is the end of buffer marker. Wrap around and\n\t * read the message at the start of the buffer.\n\t */\n\tif (!msg->len)\n\t\treturn (struct printk_log *)log_buf;\n\treturn msg;\n}"
  },
  {
    "function_name": "log_dict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "457-460",
    "snippet": "static char *log_dict(const struct printk_log *msg)\n{\n\treturn (char *)msg + sizeof(struct printk_log) + msg->text_len;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic char *log_dict(const struct printk_log *msg)\n{\n\treturn (char *)msg + sizeof(struct printk_log) + msg->text_len;\n}"
  },
  {
    "function_name": "log_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "451-454",
    "snippet": "static char *log_text(const struct printk_log *msg)\n{\n\treturn (char *)msg + sizeof(struct printk_log);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic char *log_text(const struct printk_log *msg)\n{\n\treturn (char *)msg + sizeof(struct printk_log);\n}"
  },
  {
    "function_name": "log_buf_len_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "445-448",
    "snippet": "u32 log_buf_len_get(void)\n{\n\treturn log_buf_len;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nu32 log_buf_len_get(void)\n{\n\treturn log_buf_len;\n}"
  },
  {
    "function_name": "log_buf_addr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "439-442",
    "snippet": "char *log_buf_addr_get(void)\n{\n\treturn log_buf;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nchar *log_buf_addr_get(void)\n{\n\treturn log_buf;\n}"
  },
  {
    "function_name": "__up_console_sem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "229-238",
    "snippet": "static void __up_console_sem(unsigned long ip)\n{\n\tunsigned long flags;\n\n\tmutex_release(&console_lock_dep_map, 1, ip);\n\n\tprintk_safe_enter_irqsave(flags);\n\tup(&console_sem);\n\tprintk_safe_exit_irqrestore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SEMAPHORE(console_sem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_safe_exit_irqrestore",
          "args": [
            "flags"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up",
          "args": [
            "&console_sem"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_klogd_work_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2879-2891",
          "snippet": "static void wake_up_klogd_work_func(struct irq_work *irq_work)\n{\n\tint pending = __this_cpu_xchg(printk_pending, 0);\n\n\tif (pending & PRINTK_PENDING_OUTPUT) {\n\t\t/* If trylock fails, someone else is doing the printing */\n\t\tif (console_trylock())\n\t\t\tconsole_unlock();\n\t}\n\n\tif (pending & PRINTK_PENDING_WAKEUP)\n\t\twake_up_interruptible(&log_wait);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PRINTK_PENDING_OUTPUT\t0x02",
            "#define PRINTK_PENDING_WAKEUP\t0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define PRINTK_PENDING_OUTPUT\t0x02\n#define PRINTK_PENDING_WAKEUP\t0x01\n\nstatic void wake_up_klogd_work_func(struct irq_work *irq_work)\n{\n\tint pending = __this_cpu_xchg(printk_pending, 0);\n\n\tif (pending & PRINTK_PENDING_OUTPUT) {\n\t\t/* If trylock fails, someone else is doing the printing */\n\t\tif (console_trylock())\n\t\t\tconsole_unlock();\n\t}\n\n\tif (pending & PRINTK_PENDING_WAKEUP)\n\t\twake_up_interruptible(&log_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_safe_enter_irqsave",
          "args": [
            "flags"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_release",
          "args": [
            "&console_lock_dep_map",
            "1",
            "ip"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SEMAPHORE(console_sem);\n\nstatic void __up_console_sem(unsigned long ip)\n{\n\tunsigned long flags;\n\n\tmutex_release(&console_lock_dep_map, 1, ip);\n\n\tprintk_safe_enter_irqsave(flags);\n\tup(&console_sem);\n\tprintk_safe_exit_irqrestore(flags);\n}"
  },
  {
    "function_name": "__down_trylock_console_sem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "208-226",
    "snippet": "static int __down_trylock_console_sem(unsigned long ip)\n{\n\tint lock_failed;\n\tunsigned long flags;\n\n\t/*\n\t * Here and in __up_console_sem() we need to be in safe mode,\n\t * because spindump/WARN/etc from under console ->lock will\n\t * deadlock in printk()->down_trylock_console_sem() otherwise.\n\t */\n\tprintk_safe_enter_irqsave(flags);\n\tlock_failed = down_trylock(&console_sem);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (lock_failed)\n\t\treturn 1;\n\tmutex_acquire(&console_lock_dep_map, 0, 1, ip);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SEMAPHORE(console_sem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_acquire",
          "args": [
            "&console_lock_dep_map",
            "0",
            "1",
            "ip"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_safe_exit_irqrestore",
          "args": [
            "flags"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_trylock",
          "args": [
            "&console_sem"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "__down_trylock_console_sem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "208-226",
          "snippet": "static int __down_trylock_console_sem(unsigned long ip)\n{\n\tint lock_failed;\n\tunsigned long flags;\n\n\t/*\n\t * Here and in __up_console_sem() we need to be in safe mode,\n\t * because spindump/WARN/etc from under console ->lock will\n\t * deadlock in printk()->down_trylock_console_sem() otherwise.\n\t */\n\tprintk_safe_enter_irqsave(flags);\n\tlock_failed = down_trylock(&console_sem);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (lock_failed)\n\t\treturn 1;\n\tmutex_acquire(&console_lock_dep_map, 0, 1, ip);\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "printk_safe_enter_irqsave",
          "args": [
            "flags"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SEMAPHORE(console_sem);\n\nstatic int __down_trylock_console_sem(unsigned long ip)\n{\n\tint lock_failed;\n\tunsigned long flags;\n\n\t/*\n\t * Here and in __up_console_sem() we need to be in safe mode,\n\t * because spindump/WARN/etc from under console ->lock will\n\t * deadlock in printk()->down_trylock_console_sem() otherwise.\n\t */\n\tprintk_safe_enter_irqsave(flags);\n\tlock_failed = down_trylock(&console_sem);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (lock_failed)\n\t\treturn 1;\n\tmutex_acquire(&console_lock_dep_map, 0, 1, ip);\n\treturn 0;\n}"
  },
  {
    "function_name": "devkmsg_sysctl_set_loglvl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "157-194",
    "snippet": "int devkmsg_sysctl_set_loglvl(struct ctl_table *table, int write,\n\t\t\t      void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tchar old_str[DEVKMSG_STR_MAX_SIZE];\n\tunsigned int old;\n\tint err;\n\n\tif (write) {\n\t\tif (devkmsg_log & DEVKMSG_LOG_MASK_LOCK)\n\t\t\treturn -EINVAL;\n\n\t\told = devkmsg_log;\n\t\tstrncpy(old_str, devkmsg_log_str, DEVKMSG_STR_MAX_SIZE);\n\t}\n\n\terr = proc_dostring(table, write, buffer, lenp, ppos);\n\tif (err)\n\t\treturn err;\n\n\tif (write) {\n\t\terr = __control_devkmsg(devkmsg_log_str);\n\n\t\t/*\n\t\t * Do not accept an unknown string OR a known string with\n\t\t * trailing crap...\n\t\t */\n\t\tif (err < 0 || (err + 1 != *lenp)) {\n\n\t\t\t/* ... and restore old setting. */\n\t\t\tdevkmsg_log = old;\n\t\t\tstrncpy(devkmsg_log_str, old_str, DEVKMSG_STR_MAX_SIZE);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char devkmsg_log_str[DEVKMSG_STR_MAX_SIZE] = \"ratelimit\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "devkmsg_log_str",
            "old_str",
            "DEVKMSG_STR_MAX_SIZE"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__control_devkmsg",
          "args": [
            "devkmsg_log_str"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "__control_devkmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "111-127",
          "snippet": "static int __control_devkmsg(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (!strncmp(str, \"on\", 2)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_ON;\n\t\treturn 2;\n\t} else if (!strncmp(str, \"off\", 3)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_OFF;\n\t\treturn 3;\n\t} else if (!strncmp(str, \"ratelimit\", 9)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_DEFAULT;\n\t\treturn 9;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define DEVKMSG_LOG_MASK_DEFAULT\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define DEVKMSG_LOG_MASK_DEFAULT\t0\n\nstatic int __control_devkmsg(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (!strncmp(str, \"on\", 2)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_ON;\n\t\treturn 2;\n\t} else if (!strncmp(str, \"off\", 3)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_OFF;\n\t\treturn 3;\n\t} else if (!strncmp(str, \"ratelimit\", 9)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_DEFAULT;\n\t\treturn 9;\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dostring",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dostring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3182-3186",
          "snippet": "int proc_dostring(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dostring(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "old_str",
            "devkmsg_log_str",
            "DEVKMSG_STR_MAX_SIZE"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nchar devkmsg_log_str[DEVKMSG_STR_MAX_SIZE] = \"ratelimit\";\n\nint devkmsg_sysctl_set_loglvl(struct ctl_table *table, int write,\n\t\t\t      void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tchar old_str[DEVKMSG_STR_MAX_SIZE];\n\tunsigned int old;\n\tint err;\n\n\tif (write) {\n\t\tif (devkmsg_log & DEVKMSG_LOG_MASK_LOCK)\n\t\t\treturn -EINVAL;\n\n\t\told = devkmsg_log;\n\t\tstrncpy(old_str, devkmsg_log_str, DEVKMSG_STR_MAX_SIZE);\n\t}\n\n\terr = proc_dostring(table, write, buffer, lenp, ppos);\n\tif (err)\n\t\treturn err;\n\n\tif (write) {\n\t\terr = __control_devkmsg(devkmsg_log_str);\n\n\t\t/*\n\t\t * Do not accept an unknown string OR a known string with\n\t\t * trailing crap...\n\t\t */\n\t\tif (err < 0 || (err + 1 != *lenp)) {\n\n\t\t\t/* ... and restore old setting. */\n\t\t\tdevkmsg_log = old;\n\t\t\tstrncpy(devkmsg_log_str, old_str, DEVKMSG_STR_MAX_SIZE);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "control_devkmsg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "129-152",
    "snippet": "static int __init control_devkmsg(char *str)\n{\n\tif (__control_devkmsg(str) < 0)\n\t\treturn 1;\n\n\t/*\n\t * Set sysctl string accordingly:\n\t */\n\tif (devkmsg_log == DEVKMSG_LOG_MASK_ON)\n\t\tstrcpy(devkmsg_log_str, \"on\");\n\telse if (devkmsg_log == DEVKMSG_LOG_MASK_OFF)\n\t\tstrcpy(devkmsg_log_str, \"off\");\n\t/* else \"ratelimit\" which is set by default. */\n\n\t/*\n\t * Sysctl cannot change it anymore. The kernel command line setting of\n\t * this parameter is to force the setting to be permanent throughout the\n\t * runtime of the system. This is a precation measure against userspace\n\t * trying to be a smarta** and attempting to change it up on us.\n\t */\n\tdevkmsg_log |= DEVKMSG_LOG_MASK_LOCK;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char devkmsg_log_str[DEVKMSG_STR_MAX_SIZE] = \"ratelimit\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "devkmsg_log_str",
            "\"off\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "devkmsg_log_str",
            "\"on\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__control_devkmsg",
          "args": [
            "str"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "__control_devkmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "111-127",
          "snippet": "static int __control_devkmsg(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (!strncmp(str, \"on\", 2)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_ON;\n\t\treturn 2;\n\t} else if (!strncmp(str, \"off\", 3)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_OFF;\n\t\treturn 3;\n\t} else if (!strncmp(str, \"ratelimit\", 9)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_DEFAULT;\n\t\treturn 9;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define DEVKMSG_LOG_MASK_DEFAULT\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define DEVKMSG_LOG_MASK_DEFAULT\t0\n\nstatic int __control_devkmsg(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (!strncmp(str, \"on\", 2)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_ON;\n\t\treturn 2;\n\t} else if (!strncmp(str, \"off\", 3)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_OFF;\n\t\treturn 3;\n\t} else if (!strncmp(str, \"ratelimit\", 9)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_DEFAULT;\n\t\treturn 9;\n\t}\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nchar devkmsg_log_str[DEVKMSG_STR_MAX_SIZE] = \"ratelimit\";\n\nstatic int __init control_devkmsg(char *str)\n{\n\tif (__control_devkmsg(str) < 0)\n\t\treturn 1;\n\n\t/*\n\t * Set sysctl string accordingly:\n\t */\n\tif (devkmsg_log == DEVKMSG_LOG_MASK_ON)\n\t\tstrcpy(devkmsg_log_str, \"on\");\n\telse if (devkmsg_log == DEVKMSG_LOG_MASK_OFF)\n\t\tstrcpy(devkmsg_log_str, \"off\");\n\t/* else \"ratelimit\" which is set by default. */\n\n\t/*\n\t * Sysctl cannot change it anymore. The kernel command line setting of\n\t * this parameter is to force the setting to be permanent throughout the\n\t * runtime of the system. This is a precation measure against userspace\n\t * trying to be a smarta** and attempting to change it up on us.\n\t */\n\tdevkmsg_log |= DEVKMSG_LOG_MASK_LOCK;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__control_devkmsg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "111-127",
    "snippet": "static int __control_devkmsg(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (!strncmp(str, \"on\", 2)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_ON;\n\t\treturn 2;\n\t} else if (!strncmp(str, \"off\", 3)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_OFF;\n\t\treturn 3;\n\t} else if (!strncmp(str, \"ratelimit\", 9)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_DEFAULT;\n\t\treturn 9;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define DEVKMSG_LOG_MASK_DEFAULT\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"ratelimit\"",
            "9"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"off\"",
            "3"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"on\"",
            "2"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define DEVKMSG_LOG_MASK_DEFAULT\t0\n\nstatic int __control_devkmsg(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (!strncmp(str, \"on\", 2)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_ON;\n\t\treturn 2;\n\t} else if (!strncmp(str, \"off\", 3)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_OFF;\n\t\treturn 3;\n\t} else if (!strncmp(str, \"ratelimit\", 9)) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_DEFAULT;\n\t\treturn 9;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "syslog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
    "lines": "1555-1558",
    "snippet": "SYSCALL_DEFINE3(syslog, int, type, char __user *, buf, int, len)\n{\n\treturn do_syslog(type, buf, len, SYSLOG_FROM_READER);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"braille.h\"",
      "#include \"console_cmdline.h\"",
      "#include <trace/events/printk.h>",
      "#include <trace/events/initcall.h>",
      "#include <asm/sections.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/uio.h>",
      "#include <linux/ctype.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/cpu.h>",
      "#include <linux/syslog.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdb.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/console.h>",
      "#include <linux/tty_driver.h>",
      "#include <linux/tty.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE3(syslog, int, type, char __user *, buf, int, len)\n{\n\treturn do_syslog(type, buf, len, SYSLOG_FROM_READER);\n}"
  }
]