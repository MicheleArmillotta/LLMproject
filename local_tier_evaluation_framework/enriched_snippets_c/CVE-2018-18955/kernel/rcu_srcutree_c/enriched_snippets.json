[
  {
    "function_name": "srcu_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "1319-1331",
    "snippet": "void __init srcu_init(void)\n{\n\tstruct srcu_struct *sp;\n\n\tsrcu_init_done = true;\n\twhile (!list_empty(&srcu_boot_list)) {\n\t\tsp = list_first_entry(&srcu_boot_list, struct srcu_struct,\n\t\t\t\t      work.work.entry);\n\t\tcheck_init_srcu_struct(sp);\n\t\tlist_del_init(&sp->work.work.entry);\n\t\tqueue_work(rcu_gp_wq, &sp->work.work);\n\t}\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(srcu_boot_list);",
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "rcu_gp_wq",
            "&sp->work.work"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "77-97",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&sp->work.work.entry"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_init_srcu_struct",
          "args": [
            "sp"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "check_init_srcu_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "238-252",
          "snippet": "static void check_init_srcu_struct(struct srcu_struct *sp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (!rcu_seq_state(sp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(sp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(sp, true);\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *sp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (!rcu_seq_state(sp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(sp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(sp, true);\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&srcu_boot_list",
            "structsrcu_struct",
            "work.work.entry"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&srcu_boot_list"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(srcu_boot_list);\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nvoid __init srcu_init(void)\n{\n\tstruct srcu_struct *sp;\n\n\tsrcu_init_done = true;\n\twhile (!list_empty(&srcu_boot_list)) {\n\t\tsp = list_first_entry(&srcu_boot_list, struct srcu_struct,\n\t\t\t\t      work.work.entry);\n\t\tcheck_init_srcu_struct(sp);\n\t\tlist_del_init(&sp->work.work.entry);\n\t\tqueue_work(rcu_gp_wq, &sp->work.work);\n\t}\n}"
  },
  {
    "function_name": "srcu_bootup_announce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "1310-1316",
    "snippet": "static int __init srcu_bootup_announce(void)\n{\n\tpr_info(\"Hierarchical SRCU implementation.\\n\");\n\tif (exp_holdoff != DEFAULT_SRCU_EXP_HOLDOFF)\n\t\tpr_info(\"\\tNon-default auto-expedite holdoff of %lu ns.\\n\", exp_holdoff);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define DEFAULT_SRCU_EXP_HOLDOFF (25 * 1000)"
    ],
    "globals_used": [
      "static ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tNon-default auto-expedite holdoff of %lu ns.\\n\"",
            "exp_holdoff"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Hierarchical SRCU implementation.\\n\""
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define DEFAULT_SRCU_EXP_HOLDOFF (25 * 1000)\n\nstatic ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;\n\nstatic int __init srcu_bootup_announce(void)\n{\n\tpr_info(\"Hierarchical SRCU implementation.\\n\");\n\tif (exp_holdoff != DEFAULT_SRCU_EXP_HOLDOFF)\n\t\tpr_info(\"\\tNon-default auto-expedite holdoff of %lu ns.\\n\", exp_holdoff);\n\treturn 0;\n}"
  },
  {
    "function_name": "srcu_torture_stats_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "1271-1307",
    "snippet": "void srcu_torture_stats_print(struct srcu_struct *sp, char *tt, char *tf)\n{\n\tint cpu;\n\tint idx;\n\tunsigned long s0 = 0, s1 = 0;\n\n\tidx = sp->srcu_idx & 0x1;\n\tpr_alert(\"%s%s Tree SRCU g%ld per-CPU(idx=%d):\",\n\t\t tt, tf, rcu_seq_current(&sp->srcu_gp_seq), idx);\n\tfor_each_possible_cpu(cpu) {\n\t\tunsigned long l0, l1;\n\t\tunsigned long u0, u1;\n\t\tlong c0, c1;\n\t\tstruct srcu_data *sdp;\n\n\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\tu0 = sdp->srcu_unlock_count[!idx];\n\t\tu1 = sdp->srcu_unlock_count[idx];\n\n\t\t/*\n\t\t * Make sure that a lock is always counted if the corresponding\n\t\t * unlock is counted.\n\t\t */\n\t\tsmp_rmb();\n\n\t\tl0 = sdp->srcu_lock_count[!idx];\n\t\tl1 = sdp->srcu_lock_count[idx];\n\n\t\tc0 = l0 - u0;\n\t\tc1 = l1 - u1;\n\t\tpr_cont(\" %d(%ld,%ld %1p)\",\n\t\t\tcpu, c0, c1, rcu_segcblist_head(&sdp->srcu_cblist));\n\t\ts0 += c0;\n\t\ts1 += c1;\n\t}\n\tpr_cont(\" T(%ld,%ld)\\n\", s0, s1);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" T(%ld,%ld)\\n\"",
            "s0",
            "s1"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %d(%ld,%ld %1p)\"",
            "cpu",
            "c0",
            "c1",
            "rcu_segcblist_head(&sdp->srcu_cblist)"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_head",
          "args": [
            "&sdp->srcu_cblist"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "97-100",
          "snippet": "static inline struct rcu_head *rcu_segcblist_head(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline struct rcu_head *rcu_segcblist_head(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sp->sda",
            "cpu"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s%s Tree SRCU g%ld per-CPU(idx=%d):\"",
            "tt",
            "tf",
            "rcu_seq_current(&sp->srcu_gp_seq)",
            "idx"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&sp->srcu_gp_seq"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid srcu_torture_stats_print(struct srcu_struct *sp, char *tt, char *tf)\n{\n\tint cpu;\n\tint idx;\n\tunsigned long s0 = 0, s1 = 0;\n\n\tidx = sp->srcu_idx & 0x1;\n\tpr_alert(\"%s%s Tree SRCU g%ld per-CPU(idx=%d):\",\n\t\t tt, tf, rcu_seq_current(&sp->srcu_gp_seq), idx);\n\tfor_each_possible_cpu(cpu) {\n\t\tunsigned long l0, l1;\n\t\tunsigned long u0, u1;\n\t\tlong c0, c1;\n\t\tstruct srcu_data *sdp;\n\n\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\tu0 = sdp->srcu_unlock_count[!idx];\n\t\tu1 = sdp->srcu_unlock_count[idx];\n\n\t\t/*\n\t\t * Make sure that a lock is always counted if the corresponding\n\t\t * unlock is counted.\n\t\t */\n\t\tsmp_rmb();\n\n\t\tl0 = sdp->srcu_lock_count[!idx];\n\t\tl1 = sdp->srcu_lock_count[idx];\n\n\t\tc0 = l0 - u0;\n\t\tc1 = l1 - u1;\n\t\tpr_cont(\" %d(%ld,%ld %1p)\",\n\t\t\tcpu, c0, c1, rcu_segcblist_head(&sdp->srcu_cblist));\n\t\ts0 += c0;\n\t\ts1 += c1;\n\t}\n\tpr_cont(\" T(%ld,%ld)\\n\", s0, s1);\n}"
  },
  {
    "function_name": "srcutorture_get_gp_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "1260-1268",
    "snippet": "void srcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t     struct srcu_struct *sp, int *flags,\n\t\t\t     unsigned long *gp_seq)\n{\n\tif (test_type != SRCU_FLAVOR)\n\t\treturn;\n\t*flags = 0;\n\t*gp_seq = rcu_seq_current(&sp->srcu_gp_seq);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&sp->srcu_gp_seq"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid srcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t     struct srcu_struct *sp, int *flags,\n\t\t\t     unsigned long *gp_seq)\n{\n\tif (test_type != SRCU_FLAVOR)\n\t\treturn;\n\t*flags = 0;\n\t*gp_seq = rcu_seq_current(&sp->srcu_gp_seq);\n}"
  },
  {
    "function_name": "process_srcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "1250-1258",
    "snippet": "static void process_srcu(struct work_struct *work)\n{\n\tstruct srcu_struct *sp;\n\n\tsp = container_of(work, struct srcu_struct, work.work);\n\n\tsrcu_advance_state(sp);\n\tsrcu_reschedule(sp, srcu_get_delay(sp));\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_reschedule",
          "args": [
            "sp",
            "srcu_get_delay(sp)"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_reschedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1227-1245",
          "snippet": "static void srcu_reschedule(struct srcu_struct *sp, unsigned long delay)\n{\n\tbool pushgp = true;\n\n\tspin_lock_irq_rcu_node(sp);\n\tif (ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed)) {\n\t\tif (!WARN_ON_ONCE(rcu_seq_state(sp->srcu_gp_seq))) {\n\t\t\t/* All requests fulfilled, time to go idle. */\n\t\t\tpushgp = false;\n\t\t}\n\t} else if (!rcu_seq_state(sp->srcu_gp_seq)) {\n\t\t/* Outstanding request and no GP.  Start one. */\n\t\tsrcu_gp_start(sp);\n\t}\n\tspin_unlock_irq_rcu_node(sp);\n\n\tif (pushgp)\n\t\tqueue_delayed_work(rcu_gp_wq, &sp->work, delay);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_reschedule(struct srcu_struct *sp, unsigned long delay)\n{\n\tbool pushgp = true;\n\n\tspin_lock_irq_rcu_node(sp);\n\tif (ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed)) {\n\t\tif (!WARN_ON_ONCE(rcu_seq_state(sp->srcu_gp_seq))) {\n\t\t\t/* All requests fulfilled, time to go idle. */\n\t\t\tpushgp = false;\n\t\t}\n\t} else if (!rcu_seq_state(sp->srcu_gp_seq)) {\n\t\t/* Outstanding request and no GP.  Start one. */\n\t\tsrcu_gp_start(sp);\n\t}\n\tspin_unlock_irq_rcu_node(sp);\n\n\tif (pushgp)\n\t\tqueue_delayed_work(rcu_gp_wq, &sp->work, delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_get_delay",
          "args": [
            "sp"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_get_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "366-372",
          "snippet": "static unsigned long srcu_get_delay(struct srcu_struct *sp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(sp->srcu_gp_seq),\n\t\t\t READ_ONCE(sp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SRCU_INTERVAL\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic unsigned long srcu_get_delay(struct srcu_struct *sp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(sp->srcu_gp_seq),\n\t\t\t READ_ONCE(sp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_advance_state",
          "args": [
            "sp"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_advance_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1110-1168",
          "snippet": "static void srcu_advance_state(struct srcu_struct *sp)\n{\n\tint idx;\n\n\tmutex_lock(&sp->srcu_gp_mutex);\n\n\t/*\n\t * Because readers might be delayed for an extended period after\n\t * fetching ->srcu_idx for their index, at any point in time there\n\t * might well be readers using both idx=0 and idx=1.  We therefore\n\t * need to wait for readers to clear from both index values before\n\t * invoking a callback.\n\t *\n\t * The load-acquire ensures that we see the accesses performed\n\t * by the prior grace period.\n\t */\n\tidx = rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq)); /* ^^^ */\n\tif (idx == SRCU_STATE_IDLE) {\n\t\tspin_lock_irq_rcu_node(sp);\n\t\tif (ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed)) {\n\t\t\tWARN_ON_ONCE(rcu_seq_state(sp->srcu_gp_seq));\n\t\t\tspin_unlock_irq_rcu_node(sp);\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn;\n\t\t}\n\t\tidx = rcu_seq_state(READ_ONCE(sp->srcu_gp_seq));\n\t\tif (idx == SRCU_STATE_IDLE)\n\t\t\tsrcu_gp_start(sp);\n\t\tspin_unlock_irq_rcu_node(sp);\n\t\tif (idx != SRCU_STATE_IDLE) {\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn; /* Someone else started the grace period. */\n\t\t}\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(sp->srcu_gp_seq)) == SRCU_STATE_SCAN1) {\n\t\tidx = 1 ^ (sp->srcu_idx & 1);\n\t\tif (!try_check_zero(sp, idx, 1)) {\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_flip(sp);\n\t\trcu_seq_set_state(&sp->srcu_gp_seq, SRCU_STATE_SCAN2);\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(sp->srcu_gp_seq)) == SRCU_STATE_SCAN2) {\n\n\t\t/*\n\t\t * SRCU read-side critical sections are normally short,\n\t\t * so check at least twice in quick succession after a flip.\n\t\t */\n\t\tidx = 1 ^ (sp->srcu_idx & 1);\n\t\tif (!try_check_zero(sp, idx, 2)) {\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_gp_end(sp);  /* Releases ->srcu_gp_mutex. */\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_advance_state(struct srcu_struct *sp)\n{\n\tint idx;\n\n\tmutex_lock(&sp->srcu_gp_mutex);\n\n\t/*\n\t * Because readers might be delayed for an extended period after\n\t * fetching ->srcu_idx for their index, at any point in time there\n\t * might well be readers using both idx=0 and idx=1.  We therefore\n\t * need to wait for readers to clear from both index values before\n\t * invoking a callback.\n\t *\n\t * The load-acquire ensures that we see the accesses performed\n\t * by the prior grace period.\n\t */\n\tidx = rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq)); /* ^^^ */\n\tif (idx == SRCU_STATE_IDLE) {\n\t\tspin_lock_irq_rcu_node(sp);\n\t\tif (ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed)) {\n\t\t\tWARN_ON_ONCE(rcu_seq_state(sp->srcu_gp_seq));\n\t\t\tspin_unlock_irq_rcu_node(sp);\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn;\n\t\t}\n\t\tidx = rcu_seq_state(READ_ONCE(sp->srcu_gp_seq));\n\t\tif (idx == SRCU_STATE_IDLE)\n\t\t\tsrcu_gp_start(sp);\n\t\tspin_unlock_irq_rcu_node(sp);\n\t\tif (idx != SRCU_STATE_IDLE) {\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn; /* Someone else started the grace period. */\n\t\t}\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(sp->srcu_gp_seq)) == SRCU_STATE_SCAN1) {\n\t\tidx = 1 ^ (sp->srcu_idx & 1);\n\t\tif (!try_check_zero(sp, idx, 1)) {\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_flip(sp);\n\t\trcu_seq_set_state(&sp->srcu_gp_seq, SRCU_STATE_SCAN2);\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(sp->srcu_gp_seq)) == SRCU_STATE_SCAN2) {\n\n\t\t/*\n\t\t * SRCU read-side critical sections are normally short,\n\t\t * so check at least twice in quick succession after a flip.\n\t\t */\n\t\tidx = 1 ^ (sp->srcu_idx & 1);\n\t\tif (!try_check_zero(sp, idx, 2)) {\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_gp_end(sp);  /* Releases ->srcu_gp_mutex. */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structsrcu_struct",
            "work.work"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void process_srcu(struct work_struct *work)\n{\n\tstruct srcu_struct *sp;\n\n\tsp = container_of(work, struct srcu_struct, work.work);\n\n\tsrcu_advance_state(sp);\n\tsrcu_reschedule(sp, srcu_get_delay(sp));\n}"
  },
  {
    "function_name": "srcu_reschedule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "1227-1245",
    "snippet": "static void srcu_reschedule(struct srcu_struct *sp, unsigned long delay)\n{\n\tbool pushgp = true;\n\n\tspin_lock_irq_rcu_node(sp);\n\tif (ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed)) {\n\t\tif (!WARN_ON_ONCE(rcu_seq_state(sp->srcu_gp_seq))) {\n\t\t\t/* All requests fulfilled, time to go idle. */\n\t\t\tpushgp = false;\n\t\t}\n\t} else if (!rcu_seq_state(sp->srcu_gp_seq)) {\n\t\t/* Outstanding request and no GP.  Start one. */\n\t\tsrcu_gp_start(sp);\n\t}\n\tspin_unlock_irq_rcu_node(sp);\n\n\tif (pushgp)\n\t\tqueue_delayed_work(rcu_gp_wq, &sp->work, delay);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "rcu_gp_wq",
            "&sp->work",
            "delay"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "903-920",
          "snippet": "bool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "sp"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_gp_start",
          "args": [
            "sp"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_gp_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "447-462",
          "snippet": "static void srcu_gp_start(struct srcu_struct *sp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(sp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(sp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&sp->srcu_gp_seq));\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&sp->srcu_gp_seq);\n\tstate = rcu_seq_state(READ_ONCE(sp->srcu_gp_seq));\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_gp_start(struct srcu_struct *sp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(sp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(sp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&sp->srcu_gp_seq));\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&sp->srcu_gp_seq);\n\tstate = rcu_seq_state(READ_ONCE(sp->srcu_gp_seq));\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "sp->srcu_gp_seq"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "57-60",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_seq_state(sp->srcu_gp_seq)"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "sp->srcu_gp_seq",
            "sp->srcu_gp_seq_needed"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "sp"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_reschedule(struct srcu_struct *sp, unsigned long delay)\n{\n\tbool pushgp = true;\n\n\tspin_lock_irq_rcu_node(sp);\n\tif (ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed)) {\n\t\tif (!WARN_ON_ONCE(rcu_seq_state(sp->srcu_gp_seq))) {\n\t\t\t/* All requests fulfilled, time to go idle. */\n\t\t\tpushgp = false;\n\t\t}\n\t} else if (!rcu_seq_state(sp->srcu_gp_seq)) {\n\t\t/* Outstanding request and no GP.  Start one. */\n\t\tsrcu_gp_start(sp);\n\t}\n\tspin_unlock_irq_rcu_node(sp);\n\n\tif (pushgp)\n\t\tqueue_delayed_work(rcu_gp_wq, &sp->work, delay);\n}"
  },
  {
    "function_name": "srcu_invoke_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "1176-1221",
    "snippet": "static void srcu_invoke_callbacks(struct work_struct *work)\n{\n\tbool more;\n\tstruct rcu_cblist ready_cbs;\n\tstruct rcu_head *rhp;\n\tstruct srcu_data *sdp;\n\tstruct srcu_struct *sp;\n\n\tsdp = container_of(work, struct srcu_data, work.work);\n\tsp = sdp->sp;\n\trcu_cblist_init(&ready_cbs);\n\tspin_lock_irq_rcu_node(sdp);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\tif (sdp->srcu_cblist_invoking ||\n\t    !rcu_segcblist_ready_cbs(&sdp->srcu_cblist)) {\n\t\tspin_unlock_irq_rcu_node(sdp);\n\t\treturn;  /* Someone else on the job or nothing to do. */\n\t}\n\n\t/* We are on the job!  Extract and invoke ready callbacks. */\n\tsdp->srcu_cblist_invoking = true;\n\trcu_segcblist_extract_done_cbs(&sdp->srcu_cblist, &ready_cbs);\n\tspin_unlock_irq_rcu_node(sdp);\n\trhp = rcu_cblist_dequeue(&ready_cbs);\n\tfor (; rhp != NULL; rhp = rcu_cblist_dequeue(&ready_cbs)) {\n\t\tdebug_rcu_head_unqueue(rhp);\n\t\tlocal_bh_disable();\n\t\trhp->func(rhp);\n\t\tlocal_bh_enable();\n\t}\n\n\t/*\n\t * Update counts, accelerate new callbacks, and if needed,\n\t * schedule another round of callback invocation.\n\t */\n\tspin_lock_irq_rcu_node(sdp);\n\trcu_segcblist_insert_count(&sdp->srcu_cblist, &ready_cbs);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&sp->srcu_gp_seq));\n\tsdp->srcu_cblist_invoking = false;\n\tmore = rcu_segcblist_ready_cbs(&sdp->srcu_cblist);\n\tspin_unlock_irq_rcu_node(sdp);\n\tif (more)\n\t\tsrcu_schedule_cbs_sdp(sdp, 0);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_schedule_cbs_sdp",
          "args": [
            "sdp",
            "0"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_schedule_cbs_sdp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "503-506",
          "snippet": "static void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp->cpu, rcu_gp_wq, &sdp->work, delay);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp->cpu, rcu_gp_wq, &sdp->work, delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_ready_cbs",
          "args": [
            "&sdp->srcu_cblist"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_ready_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "92-96",
          "snippet": "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != rsclp->tails[RCU_DONE_TAIL];\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != rsclp->tails[RCU_DONE_TAIL];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_accelerate",
          "args": [
            "&sdp->srcu_cblist",
            "rcu_seq_snap(&sp->srcu_gp_seq)"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_accelerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "355-404",
          "snippet": "bool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t */\n\tif (++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\trsclp->tails[i] = rsclp->tails[RCU_NEXT_TAIL];\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t */\n\tif (++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\trsclp->tails[i] = rsclp->tails[RCU_NEXT_TAIL];\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&sp->srcu_gp_seq"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "105-112",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_insert_count",
          "args": [
            "&sdp->srcu_cblist",
            "&ready_cbs"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_insert_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "249-257",
          "snippet": "void rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp)\n{\n\trsclp->len_lazy += rclp->len_lazy;\n\t/* ->len sampled locklessly. */\n\tWRITE_ONCE(rsclp->len, rsclp->len + rclp->len);\n\trclp->len_lazy = 0;\n\trclp->len = 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp)\n{\n\trsclp->len_lazy += rclp->len_lazy;\n\t/* ->len sampled locklessly. */\n\tWRITE_ONCE(rsclp->len, rsclp->len + rclp->len);\n\trclp->len_lazy = 0;\n\trclp->len = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "159-163",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rhp->func",
          "args": [
            "rhp"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_unqueue",
          "args": [
            "rhp"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_unqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "214-216",
          "snippet": "static inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_cblist_dequeue",
          "args": [
            "&ready_cbs"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cblist_dequeued_lazy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "29-32",
          "snippet": "static inline void rcu_cblist_dequeued_lazy(struct rcu_cblist *rclp)\n{\n\trclp->len_lazy--;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_cblist_init(struct rcu_cblist *rclp);",
            "struct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_count(struct rcu_segcblist *rsclp,\n\t\t\t\t struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_cblist_init(struct rcu_cblist *rclp);\nstruct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_count(struct rcu_segcblist *rsclp,\n\t\t\t\t struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);\n\nstatic inline void rcu_cblist_dequeued_lazy(struct rcu_cblist *rclp)\n{\n\trclp->len_lazy--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_extract_done_cbs",
          "args": [
            "&sdp->srcu_cblist",
            "&ready_cbs"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_extract_done_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "208-222",
          "snippet": "void rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rcu_segcblist_ready_cbs(rsclp))\n\t\treturn; /* Nothing to do. */\n\t*rclp->tail = rsclp->head;\n\trsclp->head = *rsclp->tails[RCU_DONE_TAIL];\n\t*rsclp->tails[RCU_DONE_TAIL] = NULL;\n\trclp->tail = rsclp->tails[RCU_DONE_TAIL];\n\tfor (i = RCU_CBLIST_NSEGS - 1; i >= RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] == rsclp->tails[RCU_DONE_TAIL])\n\t\t\trsclp->tails[i] = &rsclp->head;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rcu_segcblist_ready_cbs(rsclp))\n\t\treturn; /* Nothing to do. */\n\t*rclp->tail = rsclp->head;\n\trsclp->head = *rsclp->tails[RCU_DONE_TAIL];\n\t*rsclp->tails[RCU_DONE_TAIL] = NULL;\n\trclp->tail = rsclp->tails[RCU_DONE_TAIL];\n\tfor (i = RCU_CBLIST_NSEGS - 1; i >= RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] == rsclp->tails[RCU_DONE_TAIL])\n\t\t\trsclp->tails[i] = &rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_advance",
          "args": [
            "&sdp->srcu_cblist",
            "rcu_seq_current(&sp->srcu_gp_seq)"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_advance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "300-338",
          "snippet": "void rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\trsclp->tails[RCU_DONE_TAIL] = rsclp->tails[i];\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\trsclp->tails[j] = rsclp->tails[RCU_DONE_TAIL];\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\trsclp->tails[j] = rsclp->tails[i];\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\trsclp->tails[RCU_DONE_TAIL] = rsclp->tails[i];\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\trsclp->tails[j] = rsclp->tails[RCU_DONE_TAIL];\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\trsclp->tails[j] = rsclp->tails[i];\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&sp->srcu_gp_seq"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_cblist_init",
          "args": [
            "&ready_cbs"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cblist_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "31-37",
          "snippet": "void rcu_cblist_init(struct rcu_cblist *rclp)\n{\n\trclp->head = NULL;\n\trclp->tail = &rclp->head;\n\trclp->len = 0;\n\trclp->len_lazy = 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_cblist_init(struct rcu_cblist *rclp)\n{\n\trclp->head = NULL;\n\trclp->tail = &rclp->head;\n\trclp->len = 0;\n\trclp->len_lazy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structsrcu_data",
            "work.work"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_invoke_callbacks(struct work_struct *work)\n{\n\tbool more;\n\tstruct rcu_cblist ready_cbs;\n\tstruct rcu_head *rhp;\n\tstruct srcu_data *sdp;\n\tstruct srcu_struct *sp;\n\n\tsdp = container_of(work, struct srcu_data, work.work);\n\tsp = sdp->sp;\n\trcu_cblist_init(&ready_cbs);\n\tspin_lock_irq_rcu_node(sdp);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\tif (sdp->srcu_cblist_invoking ||\n\t    !rcu_segcblist_ready_cbs(&sdp->srcu_cblist)) {\n\t\tspin_unlock_irq_rcu_node(sdp);\n\t\treturn;  /* Someone else on the job or nothing to do. */\n\t}\n\n\t/* We are on the job!  Extract and invoke ready callbacks. */\n\tsdp->srcu_cblist_invoking = true;\n\trcu_segcblist_extract_done_cbs(&sdp->srcu_cblist, &ready_cbs);\n\tspin_unlock_irq_rcu_node(sdp);\n\trhp = rcu_cblist_dequeue(&ready_cbs);\n\tfor (; rhp != NULL; rhp = rcu_cblist_dequeue(&ready_cbs)) {\n\t\tdebug_rcu_head_unqueue(rhp);\n\t\tlocal_bh_disable();\n\t\trhp->func(rhp);\n\t\tlocal_bh_enable();\n\t}\n\n\t/*\n\t * Update counts, accelerate new callbacks, and if needed,\n\t * schedule another round of callback invocation.\n\t */\n\tspin_lock_irq_rcu_node(sdp);\n\trcu_segcblist_insert_count(&sdp->srcu_cblist, &ready_cbs);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&sp->srcu_gp_seq));\n\tsdp->srcu_cblist_invoking = false;\n\tmore = rcu_segcblist_ready_cbs(&sdp->srcu_cblist);\n\tspin_unlock_irq_rcu_node(sdp);\n\tif (more)\n\t\tsrcu_schedule_cbs_sdp(sdp, 0);\n}"
  },
  {
    "function_name": "srcu_advance_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "1110-1168",
    "snippet": "static void srcu_advance_state(struct srcu_struct *sp)\n{\n\tint idx;\n\n\tmutex_lock(&sp->srcu_gp_mutex);\n\n\t/*\n\t * Because readers might be delayed for an extended period after\n\t * fetching ->srcu_idx for their index, at any point in time there\n\t * might well be readers using both idx=0 and idx=1.  We therefore\n\t * need to wait for readers to clear from both index values before\n\t * invoking a callback.\n\t *\n\t * The load-acquire ensures that we see the accesses performed\n\t * by the prior grace period.\n\t */\n\tidx = rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq)); /* ^^^ */\n\tif (idx == SRCU_STATE_IDLE) {\n\t\tspin_lock_irq_rcu_node(sp);\n\t\tif (ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed)) {\n\t\t\tWARN_ON_ONCE(rcu_seq_state(sp->srcu_gp_seq));\n\t\t\tspin_unlock_irq_rcu_node(sp);\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn;\n\t\t}\n\t\tidx = rcu_seq_state(READ_ONCE(sp->srcu_gp_seq));\n\t\tif (idx == SRCU_STATE_IDLE)\n\t\t\tsrcu_gp_start(sp);\n\t\tspin_unlock_irq_rcu_node(sp);\n\t\tif (idx != SRCU_STATE_IDLE) {\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn; /* Someone else started the grace period. */\n\t\t}\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(sp->srcu_gp_seq)) == SRCU_STATE_SCAN1) {\n\t\tidx = 1 ^ (sp->srcu_idx & 1);\n\t\tif (!try_check_zero(sp, idx, 1)) {\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_flip(sp);\n\t\trcu_seq_set_state(&sp->srcu_gp_seq, SRCU_STATE_SCAN2);\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(sp->srcu_gp_seq)) == SRCU_STATE_SCAN2) {\n\n\t\t/*\n\t\t * SRCU read-side critical sections are normally short,\n\t\t * so check at least twice in quick succession after a flip.\n\t\t */\n\t\tidx = 1 ^ (sp->srcu_idx & 1);\n\t\tif (!try_check_zero(sp, idx, 2)) {\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_gp_end(sp);  /* Releases ->srcu_gp_mutex. */\n\t}\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_gp_end",
          "args": [
            "sp"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_gp_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "535-612",
          "snippet": "static void srcu_gp_end(struct srcu_struct *sp)\n{\n\tunsigned long cbdelay;\n\tbool cbs;\n\tbool last_lvl;\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpseq;\n\tint idx;\n\tunsigned long mask;\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\n\t/* Prevent more than one additional grace period. */\n\tmutex_lock(&sp->srcu_cb_mutex);\n\n\t/* End the current grace period. */\n\tspin_lock_irq_rcu_node(sp);\n\tidx = rcu_seq_state(sp->srcu_gp_seq);\n\tWARN_ON_ONCE(idx != SRCU_STATE_SCAN2);\n\tcbdelay = srcu_get_delay(sp);\n\tsp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\trcu_seq_end(&sp->srcu_gp_seq);\n\tgpseq = rcu_seq_current(&sp->srcu_gp_seq);\n\tif (ULONG_CMP_LT(sp->srcu_gp_seq_needed_exp, gpseq))\n\t\tsp->srcu_gp_seq_needed_exp = gpseq;\n\tspin_unlock_irq_rcu_node(sp);\n\tmutex_unlock(&sp->srcu_gp_mutex);\n\t/* A new grace period can start at this point.  But only one. */\n\n\t/* Initiate callback invocation as needed. */\n\tidx = rcu_seq_ctr(gpseq) % ARRAY_SIZE(snp->srcu_have_cbs);\n\tsrcu_for_each_node_breadth_first(sp, snp) {\n\t\tspin_lock_irq_rcu_node(snp);\n\t\tcbs = false;\n\t\tlast_lvl = snp >= sp->level[rcu_num_lvls - 1];\n\t\tif (last_lvl)\n\t\t\tcbs = snp->srcu_have_cbs[idx] == gpseq;\n\t\tsnp->srcu_have_cbs[idx] = gpseq;\n\t\trcu_seq_set_state(&snp->srcu_have_cbs[idx], 1);\n\t\tif (ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, gpseq))\n\t\t\tsnp->srcu_gp_seq_needed_exp = gpseq;\n\t\tmask = snp->srcu_data_have_cbs[idx];\n\t\tsnp->srcu_data_have_cbs[idx] = 0;\n\t\tspin_unlock_irq_rcu_node(snp);\n\t\tif (cbs)\n\t\t\tsrcu_schedule_cbs_snp(sp, snp, mask, cbdelay);\n\n\t\t/* Occasionally prevent srcu_data counter wrap. */\n\t\tif (!(gpseq & counter_wrap_check) && last_lvl)\n\t\t\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\t\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\t\t\tspin_lock_irqsave_rcu_node(sdp, flags);\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed = gpseq;\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed_exp + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed_exp = gpseq;\n\t\t\t\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\t\t\t}\n\t}\n\n\t/* Callback initiation done, allow grace periods after next. */\n\tmutex_unlock(&sp->srcu_cb_mutex);\n\n\t/* Start a new grace period if needed. */\n\tspin_lock_irq_rcu_node(sp);\n\tgpseq = rcu_seq_current(&sp->srcu_gp_seq);\n\tif (!rcu_seq_state(gpseq) &&\n\t    ULONG_CMP_LT(gpseq, sp->srcu_gp_seq_needed)) {\n\t\tsrcu_gp_start(sp);\n\t\tspin_unlock_irq_rcu_node(sp);\n\t\tsrcu_reschedule(sp, 0);\n\t} else {\n\t\tspin_unlock_irq_rcu_node(sp);\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ulong counter_wrap_check = (ULONG_MAX >> 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic ulong counter_wrap_check = (ULONG_MAX >> 2);\n\nstatic void srcu_gp_end(struct srcu_struct *sp)\n{\n\tunsigned long cbdelay;\n\tbool cbs;\n\tbool last_lvl;\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpseq;\n\tint idx;\n\tunsigned long mask;\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\n\t/* Prevent more than one additional grace period. */\n\tmutex_lock(&sp->srcu_cb_mutex);\n\n\t/* End the current grace period. */\n\tspin_lock_irq_rcu_node(sp);\n\tidx = rcu_seq_state(sp->srcu_gp_seq);\n\tWARN_ON_ONCE(idx != SRCU_STATE_SCAN2);\n\tcbdelay = srcu_get_delay(sp);\n\tsp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\trcu_seq_end(&sp->srcu_gp_seq);\n\tgpseq = rcu_seq_current(&sp->srcu_gp_seq);\n\tif (ULONG_CMP_LT(sp->srcu_gp_seq_needed_exp, gpseq))\n\t\tsp->srcu_gp_seq_needed_exp = gpseq;\n\tspin_unlock_irq_rcu_node(sp);\n\tmutex_unlock(&sp->srcu_gp_mutex);\n\t/* A new grace period can start at this point.  But only one. */\n\n\t/* Initiate callback invocation as needed. */\n\tidx = rcu_seq_ctr(gpseq) % ARRAY_SIZE(snp->srcu_have_cbs);\n\tsrcu_for_each_node_breadth_first(sp, snp) {\n\t\tspin_lock_irq_rcu_node(snp);\n\t\tcbs = false;\n\t\tlast_lvl = snp >= sp->level[rcu_num_lvls - 1];\n\t\tif (last_lvl)\n\t\t\tcbs = snp->srcu_have_cbs[idx] == gpseq;\n\t\tsnp->srcu_have_cbs[idx] = gpseq;\n\t\trcu_seq_set_state(&snp->srcu_have_cbs[idx], 1);\n\t\tif (ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, gpseq))\n\t\t\tsnp->srcu_gp_seq_needed_exp = gpseq;\n\t\tmask = snp->srcu_data_have_cbs[idx];\n\t\tsnp->srcu_data_have_cbs[idx] = 0;\n\t\tspin_unlock_irq_rcu_node(snp);\n\t\tif (cbs)\n\t\t\tsrcu_schedule_cbs_snp(sp, snp, mask, cbdelay);\n\n\t\t/* Occasionally prevent srcu_data counter wrap. */\n\t\tif (!(gpseq & counter_wrap_check) && last_lvl)\n\t\t\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\t\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\t\t\tspin_lock_irqsave_rcu_node(sdp, flags);\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed = gpseq;\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed_exp + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed_exp = gpseq;\n\t\t\t\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\t\t\t}\n\t}\n\n\t/* Callback initiation done, allow grace periods after next. */\n\tmutex_unlock(&sp->srcu_cb_mutex);\n\n\t/* Start a new grace period if needed. */\n\tspin_lock_irq_rcu_node(sp);\n\tgpseq = rcu_seq_current(&sp->srcu_gp_seq);\n\tif (!rcu_seq_state(gpseq) &&\n\t    ULONG_CMP_LT(gpseq, sp->srcu_gp_seq_needed)) {\n\t\tsrcu_gp_start(sp);\n\t\tspin_unlock_irq_rcu_node(sp);\n\t\tsrcu_reschedule(sp, 0);\n\t} else {\n\t\tspin_unlock_irq_rcu_node(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sp->srcu_gp_mutex"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_check_zero",
          "args": [
            "sp",
            "idx",
            "2"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "try_check_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "721-730",
          "snippet": "static bool try_check_zero(struct srcu_struct *sp, int idx, int trycount)\n{\n\tfor (;;) {\n\t\tif (srcu_readers_active_idx_check(sp, idx))\n\t\t\treturn true;\n\t\tif (--trycount + !srcu_get_delay(sp) <= 0)\n\t\t\treturn false;\n\t\tudelay(SRCU_RETRY_CHECK_DELAY);\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SRCU_RETRY_CHECK_DELAY\t\t5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_RETRY_CHECK_DELAY\t\t5\n\nstatic bool try_check_zero(struct srcu_struct *sp, int idx, int trycount)\n{\n\tfor (;;) {\n\t\tif (srcu_readers_active_idx_check(sp, idx))\n\t\t\treturn true;\n\t\tif (--trycount + !srcu_get_delay(sp) <= 0)\n\t\t\treturn false;\n\t\tudelay(SRCU_RETRY_CHECK_DELAY);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "READ_ONCE(sp->srcu_gp_seq)"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "57-60",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_gp_seq"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_set_state",
          "args": [
            "&sp->srcu_gp_seq",
            "SRCU_STATE_SCAN2"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "66-70",
          "snippet": "static inline void rcu_seq_set_state(unsigned long *sp, int newstate)\n{\n\tWARN_ON_ONCE(newstate & ~RCU_SEQ_STATE_MASK);\n\tWRITE_ONCE(*sp, (*sp & ~RCU_SEQ_STATE_MASK) + newstate);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline void rcu_seq_set_state(unsigned long *sp, int newstate)\n{\n\tWARN_ON_ONCE(newstate & ~RCU_SEQ_STATE_MASK);\n\tWRITE_ONCE(*sp, (*sp & ~RCU_SEQ_STATE_MASK) + newstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_flip",
          "args": [
            "sp"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_flip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "737-759",
          "snippet": "static void srcu_flip(struct srcu_struct *sp)\n{\n\t/*\n\t * Ensure that if this updater saw a given reader's increment\n\t * from __srcu_read_lock(), that reader was using an old value\n\t * of ->srcu_idx.  Also ensure that if a given reader sees the\n\t * new value of ->srcu_idx, this updater's earlier scans cannot\n\t * have seen that reader's increments (which is OK, because this\n\t * grace period need not wait on that reader).\n\t */\n\tsmp_mb(); /* E */  /* Pairs with B and C. */\n\n\tWRITE_ONCE(sp->srcu_idx, sp->srcu_idx + 1);\n\n\t/*\n\t * Ensure that if the updater misses an __srcu_read_unlock()\n\t * increment, that task's next __srcu_read_lock() will see the\n\t * above counter update.  Note that both this memory barrier\n\t * and the one in srcu_readers_active_idx_check() provide the\n\t * guarantee for __srcu_read_lock().\n\t */\n\tsmp_mb(); /* D */  /* Pairs with C. */\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_flip(struct srcu_struct *sp)\n{\n\t/*\n\t * Ensure that if this updater saw a given reader's increment\n\t * from __srcu_read_lock(), that reader was using an old value\n\t * of ->srcu_idx.  Also ensure that if a given reader sees the\n\t * new value of ->srcu_idx, this updater's earlier scans cannot\n\t * have seen that reader's increments (which is OK, because this\n\t * grace period need not wait on that reader).\n\t */\n\tsmp_mb(); /* E */  /* Pairs with B and C. */\n\n\tWRITE_ONCE(sp->srcu_idx, sp->srcu_idx + 1);\n\n\t/*\n\t * Ensure that if the updater misses an __srcu_read_unlock()\n\t * increment, that task's next __srcu_read_lock() will see the\n\t * above counter update.  Note that both this memory barrier\n\t * and the one in srcu_readers_active_idx_check() provide the\n\t * guarantee for __srcu_read_lock().\n\t */\n\tsmp_mb(); /* D */  /* Pairs with C. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_gp_seq"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "sp"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_gp_start",
          "args": [
            "sp"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_gp_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "447-462",
          "snippet": "static void srcu_gp_start(struct srcu_struct *sp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(sp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(sp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&sp->srcu_gp_seq));\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&sp->srcu_gp_seq);\n\tstate = rcu_seq_state(READ_ONCE(sp->srcu_gp_seq));\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_gp_start(struct srcu_struct *sp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(sp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(sp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&sp->srcu_gp_seq));\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&sp->srcu_gp_seq);\n\tstate = rcu_seq_state(READ_ONCE(sp->srcu_gp_seq));\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_gp_seq"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "sp"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_seq_state(sp->srcu_gp_seq)"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "sp->srcu_gp_seq",
            "sp->srcu_gp_seq_needed"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "sp"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&sp->srcu_gp_seq"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sp->srcu_gp_mutex"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_advance_state(struct srcu_struct *sp)\n{\n\tint idx;\n\n\tmutex_lock(&sp->srcu_gp_mutex);\n\n\t/*\n\t * Because readers might be delayed for an extended period after\n\t * fetching ->srcu_idx for their index, at any point in time there\n\t * might well be readers using both idx=0 and idx=1.  We therefore\n\t * need to wait for readers to clear from both index values before\n\t * invoking a callback.\n\t *\n\t * The load-acquire ensures that we see the accesses performed\n\t * by the prior grace period.\n\t */\n\tidx = rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq)); /* ^^^ */\n\tif (idx == SRCU_STATE_IDLE) {\n\t\tspin_lock_irq_rcu_node(sp);\n\t\tif (ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed)) {\n\t\t\tWARN_ON_ONCE(rcu_seq_state(sp->srcu_gp_seq));\n\t\t\tspin_unlock_irq_rcu_node(sp);\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn;\n\t\t}\n\t\tidx = rcu_seq_state(READ_ONCE(sp->srcu_gp_seq));\n\t\tif (idx == SRCU_STATE_IDLE)\n\t\t\tsrcu_gp_start(sp);\n\t\tspin_unlock_irq_rcu_node(sp);\n\t\tif (idx != SRCU_STATE_IDLE) {\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn; /* Someone else started the grace period. */\n\t\t}\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(sp->srcu_gp_seq)) == SRCU_STATE_SCAN1) {\n\t\tidx = 1 ^ (sp->srcu_idx & 1);\n\t\tif (!try_check_zero(sp, idx, 1)) {\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_flip(sp);\n\t\trcu_seq_set_state(&sp->srcu_gp_seq, SRCU_STATE_SCAN2);\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(sp->srcu_gp_seq)) == SRCU_STATE_SCAN2) {\n\n\t\t/*\n\t\t * SRCU read-side critical sections are normally short,\n\t\t * so check at least twice in quick succession after a flip.\n\t\t */\n\t\tidx = 1 ^ (sp->srcu_idx & 1);\n\t\tif (!try_check_zero(sp, idx, 2)) {\n\t\t\tmutex_unlock(&sp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_gp_end(sp);  /* Releases ->srcu_gp_mutex. */\n\t}\n}"
  },
  {
    "function_name": "srcu_batches_completed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "1099-1102",
    "snippet": "unsigned long srcu_batches_completed(struct srcu_struct *sp)\n{\n\treturn sp->srcu_idx;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long srcu_batches_completed(struct srcu_struct *sp)\n{\n\treturn sp->srcu_idx;\n}"
  },
  {
    "function_name": "srcu_barrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "1041-1089",
    "snippet": "void srcu_barrier(struct srcu_struct *sp)\n{\n\tint cpu;\n\tstruct srcu_data *sdp;\n\tunsigned long s = rcu_seq_snap(&sp->srcu_barrier_seq);\n\n\tcheck_init_srcu_struct(sp);\n\tmutex_lock(&sp->srcu_barrier_mutex);\n\tif (rcu_seq_done(&sp->srcu_barrier_seq, s)) {\n\t\tsmp_mb(); /* Force ordering following return. */\n\t\tmutex_unlock(&sp->srcu_barrier_mutex);\n\t\treturn; /* Someone else did our work for us. */\n\t}\n\trcu_seq_start(&sp->srcu_barrier_seq);\n\tinit_completion(&sp->srcu_barrier_completion);\n\n\t/* Initial count prevents reaching zero until all CBs are posted. */\n\tatomic_set(&sp->srcu_barrier_cpu_cnt, 1);\n\n\t/*\n\t * Each pass through this loop enqueues a callback, but only\n\t * on CPUs already having callbacks enqueued.  Note that if\n\t * a CPU already has callbacks enqueue, it must have already\n\t * registered the need for a future grace period, so all we\n\t * need do is enqueue a callback that will use the same\n\t * grace period as the last callback already in the queue.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\tspin_lock_irq_rcu_node(sdp);\n\t\tatomic_inc(&sp->srcu_barrier_cpu_cnt);\n\t\tsdp->srcu_barrier_head.func = srcu_barrier_cb;\n\t\tdebug_rcu_head_queue(&sdp->srcu_barrier_head);\n\t\tif (!rcu_segcblist_entrain(&sdp->srcu_cblist,\n\t\t\t\t\t   &sdp->srcu_barrier_head, 0)) {\n\t\t\tdebug_rcu_head_unqueue(&sdp->srcu_barrier_head);\n\t\t\tatomic_dec(&sp->srcu_barrier_cpu_cnt);\n\t\t}\n\t\tspin_unlock_irq_rcu_node(sdp);\n\t}\n\n\t/* Remove the initial count, at which point reaching zero can happen. */\n\tif (atomic_dec_and_test(&sp->srcu_barrier_cpu_cnt))\n\t\tcomplete(&sp->srcu_barrier_completion);\n\twait_for_completion(&sp->srcu_barrier_completion);\n\n\trcu_seq_end(&sp->srcu_barrier_seq);\n\tmutex_unlock(&sp->srcu_barrier_mutex);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sp->srcu_barrier_mutex"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_end",
          "args": [
            "&sp->srcu_barrier_seq"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "87-92",
          "snippet": "static inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&sp->srcu_barrier_completion"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&sp->srcu_barrier_completion"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_batches_completed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1099-1102",
          "snippet": "unsigned long srcu_batches_completed(struct srcu_struct *sp)\n{\n\treturn sp->srcu_idx;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long srcu_batches_completed(struct srcu_struct *sp)\n{\n\treturn sp->srcu_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&sp->srcu_barrier_cpu_cnt"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&sp->srcu_barrier_cpu_cnt"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_unqueue",
          "args": [
            "&sdp->srcu_barrier_head"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_unqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "214-216",
          "snippet": "static inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_entrain",
          "args": [
            "&sdp->srcu_cblist",
            "&sdp->srcu_barrier_head",
            "0"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_entrain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "164-183",
          "snippet": "bool rcu_segcblist_entrain(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp, bool lazy)\n{\n\tint i;\n\n\tif (rcu_segcblist_n_cbs(rsclp) == 0)\n\t\treturn false;\n\tWRITE_ONCE(rsclp->len, rsclp->len + 1);\n\tif (lazy)\n\t\trsclp->len_lazy++;\n\tsmp_mb(); /* Ensure counts are updated before callback is entrained. */\n\trhp->next = NULL;\n\tfor (i = RCU_NEXT_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1])\n\t\t\tbreak;\n\t*rsclp->tails[i] = rhp;\n\tfor (; i <= RCU_NEXT_TAIL; i++)\n\t\trsclp->tails[i] = &rhp->next;\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_entrain(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp, bool lazy)\n{\n\tint i;\n\n\tif (rcu_segcblist_n_cbs(rsclp) == 0)\n\t\treturn false;\n\tWRITE_ONCE(rsclp->len, rsclp->len + 1);\n\tif (lazy)\n\t\trsclp->len_lazy++;\n\tsmp_mb(); /* Ensure counts are updated before callback is entrained. */\n\trhp->next = NULL;\n\tfor (i = RCU_NEXT_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1])\n\t\t\tbreak;\n\t*rsclp->tails[i] = rhp;\n\tfor (; i <= RCU_NEXT_TAIL; i++)\n\t\trsclp->tails[i] = &rhp->next;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_queue",
          "args": [
            "&sdp->srcu_barrier_head"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "209-212",
          "snippet": "static inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sp->srcu_barrier_cpu_cnt"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sp->sda",
            "cpu"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sp->srcu_barrier_cpu_cnt",
            "1"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&sp->srcu_barrier_completion"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_start",
          "args": [
            "&sp->srcu_barrier_seq"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "73-78",
          "snippet": "static inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&sp->srcu_barrier_seq",
            "s"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "133-136",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sp->srcu_barrier_mutex"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_init_srcu_struct",
          "args": [
            "sp"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "check_init_srcu_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "238-252",
          "snippet": "static void check_init_srcu_struct(struct srcu_struct *sp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (!rcu_seq_state(sp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(sp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(sp, true);\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *sp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (!rcu_seq_state(sp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(sp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(sp, true);\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&sp->srcu_barrier_seq"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "105-112",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nvoid srcu_barrier(struct srcu_struct *sp)\n{\n\tint cpu;\n\tstruct srcu_data *sdp;\n\tunsigned long s = rcu_seq_snap(&sp->srcu_barrier_seq);\n\n\tcheck_init_srcu_struct(sp);\n\tmutex_lock(&sp->srcu_barrier_mutex);\n\tif (rcu_seq_done(&sp->srcu_barrier_seq, s)) {\n\t\tsmp_mb(); /* Force ordering following return. */\n\t\tmutex_unlock(&sp->srcu_barrier_mutex);\n\t\treturn; /* Someone else did our work for us. */\n\t}\n\trcu_seq_start(&sp->srcu_barrier_seq);\n\tinit_completion(&sp->srcu_barrier_completion);\n\n\t/* Initial count prevents reaching zero until all CBs are posted. */\n\tatomic_set(&sp->srcu_barrier_cpu_cnt, 1);\n\n\t/*\n\t * Each pass through this loop enqueues a callback, but only\n\t * on CPUs already having callbacks enqueued.  Note that if\n\t * a CPU already has callbacks enqueue, it must have already\n\t * registered the need for a future grace period, so all we\n\t * need do is enqueue a callback that will use the same\n\t * grace period as the last callback already in the queue.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\tspin_lock_irq_rcu_node(sdp);\n\t\tatomic_inc(&sp->srcu_barrier_cpu_cnt);\n\t\tsdp->srcu_barrier_head.func = srcu_barrier_cb;\n\t\tdebug_rcu_head_queue(&sdp->srcu_barrier_head);\n\t\tif (!rcu_segcblist_entrain(&sdp->srcu_cblist,\n\t\t\t\t\t   &sdp->srcu_barrier_head, 0)) {\n\t\t\tdebug_rcu_head_unqueue(&sdp->srcu_barrier_head);\n\t\t\tatomic_dec(&sp->srcu_barrier_cpu_cnt);\n\t\t}\n\t\tspin_unlock_irq_rcu_node(sdp);\n\t}\n\n\t/* Remove the initial count, at which point reaching zero can happen. */\n\tif (atomic_dec_and_test(&sp->srcu_barrier_cpu_cnt))\n\t\tcomplete(&sp->srcu_barrier_completion);\n\twait_for_completion(&sp->srcu_barrier_completion);\n\n\trcu_seq_end(&sp->srcu_barrier_seq);\n\tmutex_unlock(&sp->srcu_barrier_mutex);\n}"
  },
  {
    "function_name": "srcu_barrier_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "1026-1035",
    "snippet": "static void srcu_barrier_cb(struct rcu_head *rhp)\n{\n\tstruct srcu_data *sdp;\n\tstruct srcu_struct *sp;\n\n\tsdp = container_of(rhp, struct srcu_data, srcu_barrier_head);\n\tsp = sdp->sp;\n\tif (atomic_dec_and_test(&sp->srcu_barrier_cpu_cnt))\n\t\tcomplete(&sp->srcu_barrier_completion);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&sp->srcu_barrier_completion"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_batches_completed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1099-1102",
          "snippet": "unsigned long srcu_batches_completed(struct srcu_struct *sp)\n{\n\treturn sp->srcu_idx;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long srcu_batches_completed(struct srcu_struct *sp)\n{\n\treturn sp->srcu_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&sp->srcu_barrier_cpu_cnt"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rhp",
            "structsrcu_data",
            "srcu_barrier_head"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_barrier_cb(struct rcu_head *rhp)\n{\n\tstruct srcu_data *sdp;\n\tstruct srcu_struct *sp;\n\n\tsdp = container_of(rhp, struct srcu_data, srcu_barrier_head);\n\tsp = sdp->sp;\n\tif (atomic_dec_and_test(&sp->srcu_barrier_cpu_cnt))\n\t\tcomplete(&sp->srcu_barrier_completion);\n}"
  },
  {
    "function_name": "synchronize_srcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "1014-1020",
    "snippet": "void synchronize_srcu(struct srcu_struct *sp)\n{\n\tif (srcu_might_be_idle(sp) || rcu_gp_is_expedited())\n\t\tsynchronize_srcu_expedited(sp);\n\telse\n\t\t__synchronize_srcu(sp, true);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__synchronize_srcu",
          "args": [
            "sp",
            "true"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "__synchronize_srcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "924-952",
          "snippet": "static void __synchronize_srcu(struct srcu_struct *sp, bool do_norm)\n{\n\tstruct rcu_synchronize rcu;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&sp->dep_map) ||\n\t\t\t lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\tmight_sleep();\n\tcheck_init_srcu_struct(sp);\n\tinit_completion(&rcu.completion);\n\tinit_rcu_head_on_stack(&rcu.head);\n\t__call_srcu(sp, &rcu.head, wakeme_after_rcu, do_norm);\n\twait_for_completion(&rcu.completion);\n\tdestroy_rcu_head_on_stack(&rcu.head);\n\n\t/*\n\t * Make sure that later code is ordered after the SRCU grace\n\t * period.  This pairs with the spin_lock_irq_rcu_node()\n\t * in srcu_invoke_callbacks().  Unlike Tree RCU, this is needed\n\t * because the current CPU might have been totally uninvolved with\n\t * (and thus unordered against) that grace period.\n\t */\n\tsmp_mb();\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void __synchronize_srcu(struct srcu_struct *sp, bool do_norm)\n{\n\tstruct rcu_synchronize rcu;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&sp->dep_map) ||\n\t\t\t lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\tmight_sleep();\n\tcheck_init_srcu_struct(sp);\n\tinit_completion(&rcu.completion);\n\tinit_rcu_head_on_stack(&rcu.head);\n\t__call_srcu(sp, &rcu.head, wakeme_after_rcu, do_norm);\n\twait_for_completion(&rcu.completion);\n\tdestroy_rcu_head_on_stack(&rcu.head);\n\n\t/*\n\t * Make sure that later code is ordered after the SRCU grace\n\t * period.  This pairs with the spin_lock_irq_rcu_node()\n\t * in srcu_invoke_callbacks().  Unlike Tree RCU, this is needed\n\t * because the current CPU might have been totally uninvolved with\n\t * (and thus unordered against) that grace period.\n\t */\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_srcu_expedited",
          "args": [
            "sp"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_srcu_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "964-967",
          "snippet": "void synchronize_srcu_expedited(struct srcu_struct *sp)\n{\n\t__synchronize_srcu(sp, rcu_gp_is_normal());\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid synchronize_srcu_expedited(struct srcu_struct *sp)\n{\n\t__synchronize_srcu(sp, rcu_gp_is_normal());\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_expedited",
          "args": [],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "149-153",
          "snippet": "bool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting) ||\n\t       rcu_scheduler_active == RCU_SCHEDULER_INIT;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting) ||\n\t       rcu_scheduler_active == RCU_SCHEDULER_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_might_be_idle",
          "args": [
            "sp"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_might_be_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "782-820",
          "snippet": "static bool srcu_might_be_idle(struct srcu_struct *sp)\n{\n\tunsigned long curseq;\n\tunsigned long flags;\n\tstruct srcu_data *sdp;\n\tunsigned long t;\n\n\t/* If the local srcu_data structure has callbacks, not idle.  */\n\tlocal_irq_save(flags);\n\tsdp = this_cpu_ptr(sp->sda);\n\tif (rcu_segcblist_pend_cbs(&sdp->srcu_cblist)) {\n\t\tlocal_irq_restore(flags);\n\t\treturn false; /* Callbacks already present, so not idle. */\n\t}\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * No local callbacks, so probabalistically probe global state.\n\t * Exact information would require acquiring locks, which would\n\t * kill scalability, hence the probabalistic nature of the probe.\n\t */\n\n\t/* First, see if enough time has passed since the last GP. */\n\tt = ktime_get_mono_fast_ns();\n\tif (exp_holdoff == 0 ||\n\t    time_in_range_open(t, sp->srcu_last_gp_end,\n\t\t\t       sp->srcu_last_gp_end + exp_holdoff))\n\t\treturn false; /* Too soon after last GP. */\n\n\t/* Next, check for probable idleness. */\n\tcurseq = rcu_seq_current(&sp->srcu_gp_seq);\n\tsmp_mb(); /* Order ->srcu_gp_seq with ->srcu_gp_seq_needed. */\n\tif (ULONG_CMP_LT(curseq, READ_ONCE(sp->srcu_gp_seq_needed)))\n\t\treturn false; /* Grace period in progress, so not idle. */\n\tsmp_mb(); /* Order ->srcu_gp_seq with prior access. */\n\tif (curseq != rcu_seq_current(&sp->srcu_gp_seq))\n\t\treturn false; /* GP # changed, so not idle. */\n\treturn true; /* With reasonable probability, idle! */\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;\n\nstatic bool srcu_might_be_idle(struct srcu_struct *sp)\n{\n\tunsigned long curseq;\n\tunsigned long flags;\n\tstruct srcu_data *sdp;\n\tunsigned long t;\n\n\t/* If the local srcu_data structure has callbacks, not idle.  */\n\tlocal_irq_save(flags);\n\tsdp = this_cpu_ptr(sp->sda);\n\tif (rcu_segcblist_pend_cbs(&sdp->srcu_cblist)) {\n\t\tlocal_irq_restore(flags);\n\t\treturn false; /* Callbacks already present, so not idle. */\n\t}\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * No local callbacks, so probabalistically probe global state.\n\t * Exact information would require acquiring locks, which would\n\t * kill scalability, hence the probabalistic nature of the probe.\n\t */\n\n\t/* First, see if enough time has passed since the last GP. */\n\tt = ktime_get_mono_fast_ns();\n\tif (exp_holdoff == 0 ||\n\t    time_in_range_open(t, sp->srcu_last_gp_end,\n\t\t\t       sp->srcu_last_gp_end + exp_holdoff))\n\t\treturn false; /* Too soon after last GP. */\n\n\t/* Next, check for probable idleness. */\n\tcurseq = rcu_seq_current(&sp->srcu_gp_seq);\n\tsmp_mb(); /* Order ->srcu_gp_seq with ->srcu_gp_seq_needed. */\n\tif (ULONG_CMP_LT(curseq, READ_ONCE(sp->srcu_gp_seq_needed)))\n\t\treturn false; /* Grace period in progress, so not idle. */\n\tsmp_mb(); /* Order ->srcu_gp_seq with prior access. */\n\tif (curseq != rcu_seq_current(&sp->srcu_gp_seq))\n\t\treturn false; /* GP # changed, so not idle. */\n\treturn true; /* With reasonable probability, idle! */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid synchronize_srcu(struct srcu_struct *sp)\n{\n\tif (srcu_might_be_idle(sp) || rcu_gp_is_expedited())\n\t\tsynchronize_srcu_expedited(sp);\n\telse\n\t\t__synchronize_srcu(sp, true);\n}"
  },
  {
    "function_name": "synchronize_srcu_expedited",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "964-967",
    "snippet": "void synchronize_srcu_expedited(struct srcu_struct *sp)\n{\n\t__synchronize_srcu(sp, rcu_gp_is_normal());\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__synchronize_srcu",
          "args": [
            "sp",
            "rcu_gp_is_normal()"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "__synchronize_srcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "924-952",
          "snippet": "static void __synchronize_srcu(struct srcu_struct *sp, bool do_norm)\n{\n\tstruct rcu_synchronize rcu;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&sp->dep_map) ||\n\t\t\t lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\tmight_sleep();\n\tcheck_init_srcu_struct(sp);\n\tinit_completion(&rcu.completion);\n\tinit_rcu_head_on_stack(&rcu.head);\n\t__call_srcu(sp, &rcu.head, wakeme_after_rcu, do_norm);\n\twait_for_completion(&rcu.completion);\n\tdestroy_rcu_head_on_stack(&rcu.head);\n\n\t/*\n\t * Make sure that later code is ordered after the SRCU grace\n\t * period.  This pairs with the spin_lock_irq_rcu_node()\n\t * in srcu_invoke_callbacks().  Unlike Tree RCU, this is needed\n\t * because the current CPU might have been totally uninvolved with\n\t * (and thus unordered against) that grace period.\n\t */\n\tsmp_mb();\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void __synchronize_srcu(struct srcu_struct *sp, bool do_norm)\n{\n\tstruct rcu_synchronize rcu;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&sp->dep_map) ||\n\t\t\t lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\tmight_sleep();\n\tcheck_init_srcu_struct(sp);\n\tinit_completion(&rcu.completion);\n\tinit_rcu_head_on_stack(&rcu.head);\n\t__call_srcu(sp, &rcu.head, wakeme_after_rcu, do_norm);\n\twait_for_completion(&rcu.completion);\n\tdestroy_rcu_head_on_stack(&rcu.head);\n\n\t/*\n\t * Make sure that later code is ordered after the SRCU grace\n\t * period.  This pairs with the spin_lock_irq_rcu_node()\n\t * in srcu_invoke_callbacks().  Unlike Tree RCU, this is needed\n\t * because the current CPU might have been totally uninvolved with\n\t * (and thus unordered against) that grace period.\n\t */\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_normal",
          "args": [],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "133-137",
          "snippet": "bool rcu_gp_is_normal(void)\n{\n\treturn READ_ONCE(rcu_normal) &&\n\t       rcu_scheduler_active != RCU_SCHEDULER_INIT;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_normal(void)\n{\n\treturn READ_ONCE(rcu_normal) &&\n\t       rcu_scheduler_active != RCU_SCHEDULER_INIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid synchronize_srcu_expedited(struct srcu_struct *sp)\n{\n\t__synchronize_srcu(sp, rcu_gp_is_normal());\n}"
  },
  {
    "function_name": "__synchronize_srcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "924-952",
    "snippet": "static void __synchronize_srcu(struct srcu_struct *sp, bool do_norm)\n{\n\tstruct rcu_synchronize rcu;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&sp->dep_map) ||\n\t\t\t lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\tmight_sleep();\n\tcheck_init_srcu_struct(sp);\n\tinit_completion(&rcu.completion);\n\tinit_rcu_head_on_stack(&rcu.head);\n\t__call_srcu(sp, &rcu.head, wakeme_after_rcu, do_norm);\n\twait_for_completion(&rcu.completion);\n\tdestroy_rcu_head_on_stack(&rcu.head);\n\n\t/*\n\t * Make sure that later code is ordered after the SRCU grace\n\t * period.  This pairs with the spin_lock_irq_rcu_node()\n\t * in srcu_invoke_callbacks().  Unlike Tree RCU, this is needed\n\t * because the current CPU might have been totally uninvolved with\n\t * (and thus unordered against) that grace period.\n\t */\n\tsmp_mb();\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_rcu_head_on_stack",
          "args": [
            "&rcu.head"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_rcu_head_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "413-416",
          "snippet": "void destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&rcu.completion"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__call_srcu",
          "args": [
            "sp",
            "&rcu.head",
            "wakeme_after_rcu",
            "do_norm"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "__call_srcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "857-895",
          "snippet": "void __call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t\t rcu_callback_t func, bool do_norm)\n{\n\tunsigned long flags;\n\tbool needexp = false;\n\tbool needgp = false;\n\tunsigned long s;\n\tstruct srcu_data *sdp;\n\n\tcheck_init_srcu_struct(sp);\n\tif (debug_rcu_head_queue(rhp)) {\n\t\t/* Probable double call_srcu(), so leak the callback. */\n\t\tWRITE_ONCE(rhp->func, srcu_leak_callback);\n\t\tWARN_ONCE(1, \"call_srcu(): Leaked duplicate callback\\n\");\n\t\treturn;\n\t}\n\trhp->func = func;\n\tlocal_irq_save(flags);\n\tsdp = this_cpu_ptr(sp->sda);\n\tspin_lock_rcu_node(sdp);\n\trcu_segcblist_enqueue(&sdp->srcu_cblist, rhp, false);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\ts = rcu_seq_snap(&sp->srcu_gp_seq);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist, s);\n\tif (ULONG_CMP_LT(sdp->srcu_gp_seq_needed, s)) {\n\t\tsdp->srcu_gp_seq_needed = s;\n\t\tneedgp = true;\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sdp->srcu_gp_seq_needed_exp, s)) {\n\t\tsdp->srcu_gp_seq_needed_exp = s;\n\t\tneedexp = true;\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\tif (needgp)\n\t\tsrcu_funnel_gp_start(sp, sdp, s, do_norm);\n\telse if (needexp)\n\t\tsrcu_funnel_exp_start(sp, sdp->mynode, s);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid __call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t\t rcu_callback_t func, bool do_norm)\n{\n\tunsigned long flags;\n\tbool needexp = false;\n\tbool needgp = false;\n\tunsigned long s;\n\tstruct srcu_data *sdp;\n\n\tcheck_init_srcu_struct(sp);\n\tif (debug_rcu_head_queue(rhp)) {\n\t\t/* Probable double call_srcu(), so leak the callback. */\n\t\tWRITE_ONCE(rhp->func, srcu_leak_callback);\n\t\tWARN_ONCE(1, \"call_srcu(): Leaked duplicate callback\\n\");\n\t\treturn;\n\t}\n\trhp->func = func;\n\tlocal_irq_save(flags);\n\tsdp = this_cpu_ptr(sp->sda);\n\tspin_lock_rcu_node(sdp);\n\trcu_segcblist_enqueue(&sdp->srcu_cblist, rhp, false);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\ts = rcu_seq_snap(&sp->srcu_gp_seq);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist, s);\n\tif (ULONG_CMP_LT(sdp->srcu_gp_seq_needed, s)) {\n\t\tsdp->srcu_gp_seq_needed = s;\n\t\tneedgp = true;\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sdp->srcu_gp_seq_needed_exp, s)) {\n\t\tsdp->srcu_gp_seq_needed_exp = s;\n\t\tneedexp = true;\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\tif (needgp)\n\t\tsrcu_funnel_gp_start(sp, sdp, s, do_norm);\n\telse if (needexp)\n\t\tsrcu_funnel_exp_start(sp, sdp->mynode, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rcu_head_on_stack",
          "args": [
            "&rcu.head"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "init_rcu_head_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "396-399",
          "snippet": "void init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&rcu.completion"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_init_srcu_struct",
          "args": [
            "sp"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "check_init_srcu_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "238-252",
          "snippet": "static void check_init_srcu_struct(struct srcu_struct *sp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (!rcu_seq_state(sp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(sp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(sp, true);\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *sp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (!rcu_seq_state(sp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(sp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(sp, true);\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "lock_is_held(&sp->dep_map) ||\n\t\t\t lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map)",
            "\"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\""
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_sched_lock_map"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_lock_map"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_bh_lock_map"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&sp->dep_map"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void __synchronize_srcu(struct srcu_struct *sp, bool do_norm)\n{\n\tstruct rcu_synchronize rcu;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&sp->dep_map) ||\n\t\t\t lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\tmight_sleep();\n\tcheck_init_srcu_struct(sp);\n\tinit_completion(&rcu.completion);\n\tinit_rcu_head_on_stack(&rcu.head);\n\t__call_srcu(sp, &rcu.head, wakeme_after_rcu, do_norm);\n\twait_for_completion(&rcu.completion);\n\tdestroy_rcu_head_on_stack(&rcu.head);\n\n\t/*\n\t * Make sure that later code is ordered after the SRCU grace\n\t * period.  This pairs with the spin_lock_irq_rcu_node()\n\t * in srcu_invoke_callbacks().  Unlike Tree RCU, this is needed\n\t * because the current CPU might have been totally uninvolved with\n\t * (and thus unordered against) that grace period.\n\t */\n\tsmp_mb();\n}"
  },
  {
    "function_name": "call_srcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "914-918",
    "snippet": "void call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(sp, rhp, func, true);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__call_srcu",
          "args": [
            "sp",
            "rhp",
            "func",
            "true"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "__call_srcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "857-895",
          "snippet": "void __call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t\t rcu_callback_t func, bool do_norm)\n{\n\tunsigned long flags;\n\tbool needexp = false;\n\tbool needgp = false;\n\tunsigned long s;\n\tstruct srcu_data *sdp;\n\n\tcheck_init_srcu_struct(sp);\n\tif (debug_rcu_head_queue(rhp)) {\n\t\t/* Probable double call_srcu(), so leak the callback. */\n\t\tWRITE_ONCE(rhp->func, srcu_leak_callback);\n\t\tWARN_ONCE(1, \"call_srcu(): Leaked duplicate callback\\n\");\n\t\treturn;\n\t}\n\trhp->func = func;\n\tlocal_irq_save(flags);\n\tsdp = this_cpu_ptr(sp->sda);\n\tspin_lock_rcu_node(sdp);\n\trcu_segcblist_enqueue(&sdp->srcu_cblist, rhp, false);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\ts = rcu_seq_snap(&sp->srcu_gp_seq);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist, s);\n\tif (ULONG_CMP_LT(sdp->srcu_gp_seq_needed, s)) {\n\t\tsdp->srcu_gp_seq_needed = s;\n\t\tneedgp = true;\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sdp->srcu_gp_seq_needed_exp, s)) {\n\t\tsdp->srcu_gp_seq_needed_exp = s;\n\t\tneedexp = true;\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\tif (needgp)\n\t\tsrcu_funnel_gp_start(sp, sdp, s, do_norm);\n\telse if (needexp)\n\t\tsrcu_funnel_exp_start(sp, sdp->mynode, s);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid __call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t\t rcu_callback_t func, bool do_norm)\n{\n\tunsigned long flags;\n\tbool needexp = false;\n\tbool needgp = false;\n\tunsigned long s;\n\tstruct srcu_data *sdp;\n\n\tcheck_init_srcu_struct(sp);\n\tif (debug_rcu_head_queue(rhp)) {\n\t\t/* Probable double call_srcu(), so leak the callback. */\n\t\tWRITE_ONCE(rhp->func, srcu_leak_callback);\n\t\tWARN_ONCE(1, \"call_srcu(): Leaked duplicate callback\\n\");\n\t\treturn;\n\t}\n\trhp->func = func;\n\tlocal_irq_save(flags);\n\tsdp = this_cpu_ptr(sp->sda);\n\tspin_lock_rcu_node(sdp);\n\trcu_segcblist_enqueue(&sdp->srcu_cblist, rhp, false);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\ts = rcu_seq_snap(&sp->srcu_gp_seq);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist, s);\n\tif (ULONG_CMP_LT(sdp->srcu_gp_seq_needed, s)) {\n\t\tsdp->srcu_gp_seq_needed = s;\n\t\tneedgp = true;\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sdp->srcu_gp_seq_needed_exp, s)) {\n\t\tsdp->srcu_gp_seq_needed_exp = s;\n\t\tneedexp = true;\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\tif (needgp)\n\t\tsrcu_funnel_gp_start(sp, sdp, s, do_norm);\n\telse if (needexp)\n\t\tsrcu_funnel_exp_start(sp, sdp->mynode, s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(sp, rhp, func, true);\n}"
  },
  {
    "function_name": "__call_srcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "857-895",
    "snippet": "void __call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t\t rcu_callback_t func, bool do_norm)\n{\n\tunsigned long flags;\n\tbool needexp = false;\n\tbool needgp = false;\n\tunsigned long s;\n\tstruct srcu_data *sdp;\n\n\tcheck_init_srcu_struct(sp);\n\tif (debug_rcu_head_queue(rhp)) {\n\t\t/* Probable double call_srcu(), so leak the callback. */\n\t\tWRITE_ONCE(rhp->func, srcu_leak_callback);\n\t\tWARN_ONCE(1, \"call_srcu(): Leaked duplicate callback\\n\");\n\t\treturn;\n\t}\n\trhp->func = func;\n\tlocal_irq_save(flags);\n\tsdp = this_cpu_ptr(sp->sda);\n\tspin_lock_rcu_node(sdp);\n\trcu_segcblist_enqueue(&sdp->srcu_cblist, rhp, false);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\ts = rcu_seq_snap(&sp->srcu_gp_seq);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist, s);\n\tif (ULONG_CMP_LT(sdp->srcu_gp_seq_needed, s)) {\n\t\tsdp->srcu_gp_seq_needed = s;\n\t\tneedgp = true;\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sdp->srcu_gp_seq_needed_exp, s)) {\n\t\tsdp->srcu_gp_seq_needed_exp = s;\n\t\tneedexp = true;\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\tif (needgp)\n\t\tsrcu_funnel_gp_start(sp, sdp, s, do_norm);\n\telse if (needexp)\n\t\tsrcu_funnel_exp_start(sp, sdp->mynode, s);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_funnel_exp_start",
          "args": [
            "sp",
            "sdp->mynode",
            "s"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_funnel_exp_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "621-642",
          "snippet": "static void srcu_funnel_exp_start(struct srcu_struct *sp, struct srcu_node *snp,\n\t\t\t\t  unsigned long s)\n{\n\tunsigned long flags;\n\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&sp->srcu_gp_seq, s) ||\n\t\t    ULONG_CMP_GE(READ_ONCE(snp->srcu_gp_seq_needed_exp), s))\n\t\t\treturn;\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_gp_seq_needed_exp, s)) {\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (ULONG_CMP_LT(sp->srcu_gp_seq_needed_exp, s))\n\t\tsp->srcu_gp_seq_needed_exp = s;\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_funnel_exp_start(struct srcu_struct *sp, struct srcu_node *snp,\n\t\t\t\t  unsigned long s)\n{\n\tunsigned long flags;\n\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&sp->srcu_gp_seq, s) ||\n\t\t    ULONG_CMP_GE(READ_ONCE(snp->srcu_gp_seq_needed_exp), s))\n\t\t\treturn;\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_gp_seq_needed_exp, s)) {\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (ULONG_CMP_LT(sp->srcu_gp_seq_needed_exp, s))\n\t\tsp->srcu_gp_seq_needed_exp = s;\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_funnel_gp_start",
          "args": [
            "sp",
            "sdp",
            "s",
            "do_norm"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_funnel_gp_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "654-714",
          "snippet": "static void srcu_funnel_gp_start(struct srcu_struct *sp, struct srcu_data *sdp,\n\t\t\t\t unsigned long s, bool do_norm)\n{\n\tunsigned long flags;\n\tint idx = rcu_seq_ctr(s) % ARRAY_SIZE(sdp->mynode->srcu_have_cbs);\n\tstruct srcu_node *snp = sdp->mynode;\n\tunsigned long snp_seq;\n\n\t/* Each pass through the loop does one level of the srcu_node tree. */\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&sp->srcu_gp_seq, s) && snp != sdp->mynode)\n\t\t\treturn; /* GP already done and CBs recorded. */\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_have_cbs[idx], s)) {\n\t\t\tsnp_seq = snp->srcu_have_cbs[idx];\n\t\t\tif (snp == sdp->mynode && snp_seq == s)\n\t\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\tif (snp == sdp->mynode && snp_seq != s) {\n\t\t\t\tsrcu_schedule_cbs_sdp(sdp, do_norm\n\t\t\t\t\t\t\t   ? SRCU_INTERVAL\n\t\t\t\t\t\t\t   : 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!do_norm)\n\t\t\t\tsrcu_funnel_exp_start(sp, snp, s);\n\t\t\treturn;\n\t\t}\n\t\tsnp->srcu_have_cbs[idx] = s;\n\t\tif (snp == sdp->mynode)\n\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\tif (!do_norm && ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, s))\n\t\t\tsnp->srcu_gp_seq_needed_exp = s;\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\n\t/* Top of tree, must ensure the grace period will be started. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (ULONG_CMP_LT(sp->srcu_gp_seq_needed, s)) {\n\t\t/*\n\t\t * Record need for grace period s.  Pair with load\n\t\t * acquire setting up for initialization.\n\t\t */\n\t\tsmp_store_release(&sp->srcu_gp_seq_needed, s); /*^^^*/\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sp->srcu_gp_seq_needed_exp, s))\n\t\tsp->srcu_gp_seq_needed_exp = s;\n\n\t/* If grace period not already done and none in progress, start it. */\n\tif (!rcu_seq_done(&sp->srcu_gp_seq, s) &&\n\t    rcu_seq_state(sp->srcu_gp_seq) == SRCU_STATE_IDLE) {\n\t\tWARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));\n\t\tsrcu_gp_start(sp);\n\t\tif (likely(srcu_init_done))\n\t\t\tqueue_delayed_work(rcu_gp_wq, &sp->work,\n\t\t\t\t\t   srcu_get_delay(sp));\n\t\telse if (list_empty(&sp->work.work.entry))\n\t\t\tlist_add(&sp->work.work.entry, &srcu_boot_list);\n\t}\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SRCU_INTERVAL\t\t1"
          ],
          "globals_used": [
            "static LIST_HEAD(srcu_boot_list);",
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic LIST_HEAD(srcu_boot_list);\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_funnel_gp_start(struct srcu_struct *sp, struct srcu_data *sdp,\n\t\t\t\t unsigned long s, bool do_norm)\n{\n\tunsigned long flags;\n\tint idx = rcu_seq_ctr(s) % ARRAY_SIZE(sdp->mynode->srcu_have_cbs);\n\tstruct srcu_node *snp = sdp->mynode;\n\tunsigned long snp_seq;\n\n\t/* Each pass through the loop does one level of the srcu_node tree. */\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&sp->srcu_gp_seq, s) && snp != sdp->mynode)\n\t\t\treturn; /* GP already done and CBs recorded. */\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_have_cbs[idx], s)) {\n\t\t\tsnp_seq = snp->srcu_have_cbs[idx];\n\t\t\tif (snp == sdp->mynode && snp_seq == s)\n\t\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\tif (snp == sdp->mynode && snp_seq != s) {\n\t\t\t\tsrcu_schedule_cbs_sdp(sdp, do_norm\n\t\t\t\t\t\t\t   ? SRCU_INTERVAL\n\t\t\t\t\t\t\t   : 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!do_norm)\n\t\t\t\tsrcu_funnel_exp_start(sp, snp, s);\n\t\t\treturn;\n\t\t}\n\t\tsnp->srcu_have_cbs[idx] = s;\n\t\tif (snp == sdp->mynode)\n\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\tif (!do_norm && ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, s))\n\t\t\tsnp->srcu_gp_seq_needed_exp = s;\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\n\t/* Top of tree, must ensure the grace period will be started. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (ULONG_CMP_LT(sp->srcu_gp_seq_needed, s)) {\n\t\t/*\n\t\t * Record need for grace period s.  Pair with load\n\t\t * acquire setting up for initialization.\n\t\t */\n\t\tsmp_store_release(&sp->srcu_gp_seq_needed, s); /*^^^*/\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sp->srcu_gp_seq_needed_exp, s))\n\t\tsp->srcu_gp_seq_needed_exp = s;\n\n\t/* If grace period not already done and none in progress, start it. */\n\tif (!rcu_seq_done(&sp->srcu_gp_seq, s) &&\n\t    rcu_seq_state(sp->srcu_gp_seq) == SRCU_STATE_IDLE) {\n\t\tWARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));\n\t\tsrcu_gp_start(sp);\n\t\tif (likely(srcu_init_done))\n\t\t\tqueue_delayed_work(rcu_gp_wq, &sp->work,\n\t\t\t\t\t   srcu_get_delay(sp));\n\t\telse if (list_empty(&sp->work.work.entry))\n\t\t\tlist_add(&sp->work.work.entry, &srcu_boot_list);\n\t}\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "sdp",
            "flags"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "sdp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "sdp->srcu_gp_seq_needed",
            "s"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_accelerate",
          "args": [
            "&sdp->srcu_cblist",
            "s"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_accelerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "355-404",
          "snippet": "bool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t */\n\tif (++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\trsclp->tails[i] = rsclp->tails[RCU_NEXT_TAIL];\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t */\n\tif (++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\trsclp->tails[i] = rsclp->tails[RCU_NEXT_TAIL];\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&sp->srcu_gp_seq"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "105-112",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_advance",
          "args": [
            "&sdp->srcu_cblist",
            "rcu_seq_current(&sp->srcu_gp_seq)"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_advance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "300-338",
          "snippet": "void rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\trsclp->tails[RCU_DONE_TAIL] = rsclp->tails[i];\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\trsclp->tails[j] = rsclp->tails[RCU_DONE_TAIL];\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\trsclp->tails[j] = rsclp->tails[i];\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\trsclp->tails[RCU_DONE_TAIL] = rsclp->tails[i];\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\trsclp->tails[j] = rsclp->tails[RCU_DONE_TAIL];\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\trsclp->tails[j] = rsclp->tails[i];\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&sp->srcu_gp_seq"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_enqueue",
          "args": [
            "&sdp->srcu_cblist",
            "rhp",
            "false"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_enqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "142-152",
          "snippet": "void rcu_segcblist_enqueue(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp, bool lazy)\n{\n\tWRITE_ONCE(rsclp->len, rsclp->len + 1); /* ->len sampled locklessly. */\n\tif (lazy)\n\t\trsclp->len_lazy++;\n\tsmp_mb(); /* Ensure counts are updated before callback is enqueued. */\n\trhp->next = NULL;\n\t*rsclp->tails[RCU_NEXT_TAIL] = rhp;\n\trsclp->tails[RCU_NEXT_TAIL] = &rhp->next;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_enqueue(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp, bool lazy)\n{\n\tWRITE_ONCE(rsclp->len, rsclp->len + 1); /* ->len sampled locklessly. */\n\tif (lazy)\n\t\trsclp->len_lazy++;\n\tsmp_mb(); /* Ensure counts are updated before callback is enqueued. */\n\trhp->next = NULL;\n\t*rsclp->tails[RCU_NEXT_TAIL] = rhp;\n\trsclp->tails[RCU_NEXT_TAIL] = &rhp->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "sp->sda"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"call_srcu(): Leaked duplicate callback\\n\""
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rhp->func",
            "srcu_leak_callback"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_queue",
          "args": [
            "rhp"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "209-212",
          "snippet": "static inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_init_srcu_struct",
          "args": [
            "sp"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "check_init_srcu_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "238-252",
          "snippet": "static void check_init_srcu_struct(struct srcu_struct *sp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (!rcu_seq_state(sp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(sp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(sp, true);\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *sp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (!rcu_seq_state(sp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(sp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(sp, true);\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid __call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t\t rcu_callback_t func, bool do_norm)\n{\n\tunsigned long flags;\n\tbool needexp = false;\n\tbool needgp = false;\n\tunsigned long s;\n\tstruct srcu_data *sdp;\n\n\tcheck_init_srcu_struct(sp);\n\tif (debug_rcu_head_queue(rhp)) {\n\t\t/* Probable double call_srcu(), so leak the callback. */\n\t\tWRITE_ONCE(rhp->func, srcu_leak_callback);\n\t\tWARN_ONCE(1, \"call_srcu(): Leaked duplicate callback\\n\");\n\t\treturn;\n\t}\n\trhp->func = func;\n\tlocal_irq_save(flags);\n\tsdp = this_cpu_ptr(sp->sda);\n\tspin_lock_rcu_node(sdp);\n\trcu_segcblist_enqueue(&sdp->srcu_cblist, rhp, false);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\ts = rcu_seq_snap(&sp->srcu_gp_seq);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist, s);\n\tif (ULONG_CMP_LT(sdp->srcu_gp_seq_needed, s)) {\n\t\tsdp->srcu_gp_seq_needed = s;\n\t\tneedgp = true;\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sdp->srcu_gp_seq_needed_exp, s)) {\n\t\tsdp->srcu_gp_seq_needed_exp = s;\n\t\tneedexp = true;\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\tif (needgp)\n\t\tsrcu_funnel_gp_start(sp, sdp, s, do_norm);\n\telse if (needexp)\n\t\tsrcu_funnel_exp_start(sp, sdp->mynode, s);\n}"
  },
  {
    "function_name": "srcu_leak_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "825-827",
    "snippet": "static void srcu_leak_callback(struct rcu_head *rhp)\n{\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_leak_callback(struct rcu_head *rhp)\n{\n}"
  },
  {
    "function_name": "srcu_might_be_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "782-820",
    "snippet": "static bool srcu_might_be_idle(struct srcu_struct *sp)\n{\n\tunsigned long curseq;\n\tunsigned long flags;\n\tstruct srcu_data *sdp;\n\tunsigned long t;\n\n\t/* If the local srcu_data structure has callbacks, not idle.  */\n\tlocal_irq_save(flags);\n\tsdp = this_cpu_ptr(sp->sda);\n\tif (rcu_segcblist_pend_cbs(&sdp->srcu_cblist)) {\n\t\tlocal_irq_restore(flags);\n\t\treturn false; /* Callbacks already present, so not idle. */\n\t}\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * No local callbacks, so probabalistically probe global state.\n\t * Exact information would require acquiring locks, which would\n\t * kill scalability, hence the probabalistic nature of the probe.\n\t */\n\n\t/* First, see if enough time has passed since the last GP. */\n\tt = ktime_get_mono_fast_ns();\n\tif (exp_holdoff == 0 ||\n\t    time_in_range_open(t, sp->srcu_last_gp_end,\n\t\t\t       sp->srcu_last_gp_end + exp_holdoff))\n\t\treturn false; /* Too soon after last GP. */\n\n\t/* Next, check for probable idleness. */\n\tcurseq = rcu_seq_current(&sp->srcu_gp_seq);\n\tsmp_mb(); /* Order ->srcu_gp_seq with ->srcu_gp_seq_needed. */\n\tif (ULONG_CMP_LT(curseq, READ_ONCE(sp->srcu_gp_seq_needed)))\n\t\treturn false; /* Grace period in progress, so not idle. */\n\tsmp_mb(); /* Order ->srcu_gp_seq with prior access. */\n\tif (curseq != rcu_seq_current(&sp->srcu_gp_seq))\n\t\treturn false; /* GP # changed, so not idle. */\n\treturn true; /* With reasonable probability, idle! */\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&sp->srcu_gp_seq"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "curseq",
            "READ_ONCE(sp->srcu_gp_seq_needed)"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_gp_seq_needed"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_in_range_open",
          "args": [
            "t",
            "sp->srcu_last_gp_end",
            "sp->srcu_last_gp_end + exp_holdoff"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_mono_fast_ns",
          "args": [],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_mono_fast_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "469-472",
          "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_pend_cbs",
          "args": [
            "&sdp->srcu_cblist"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_pend_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "102-106",
          "snippet": "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "sp->sda"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;\n\nstatic bool srcu_might_be_idle(struct srcu_struct *sp)\n{\n\tunsigned long curseq;\n\tunsigned long flags;\n\tstruct srcu_data *sdp;\n\tunsigned long t;\n\n\t/* If the local srcu_data structure has callbacks, not idle.  */\n\tlocal_irq_save(flags);\n\tsdp = this_cpu_ptr(sp->sda);\n\tif (rcu_segcblist_pend_cbs(&sdp->srcu_cblist)) {\n\t\tlocal_irq_restore(flags);\n\t\treturn false; /* Callbacks already present, so not idle. */\n\t}\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * No local callbacks, so probabalistically probe global state.\n\t * Exact information would require acquiring locks, which would\n\t * kill scalability, hence the probabalistic nature of the probe.\n\t */\n\n\t/* First, see if enough time has passed since the last GP. */\n\tt = ktime_get_mono_fast_ns();\n\tif (exp_holdoff == 0 ||\n\t    time_in_range_open(t, sp->srcu_last_gp_end,\n\t\t\t       sp->srcu_last_gp_end + exp_holdoff))\n\t\treturn false; /* Too soon after last GP. */\n\n\t/* Next, check for probable idleness. */\n\tcurseq = rcu_seq_current(&sp->srcu_gp_seq);\n\tsmp_mb(); /* Order ->srcu_gp_seq with ->srcu_gp_seq_needed. */\n\tif (ULONG_CMP_LT(curseq, READ_ONCE(sp->srcu_gp_seq_needed)))\n\t\treturn false; /* Grace period in progress, so not idle. */\n\tsmp_mb(); /* Order ->srcu_gp_seq with prior access. */\n\tif (curseq != rcu_seq_current(&sp->srcu_gp_seq))\n\t\treturn false; /* GP # changed, so not idle. */\n\treturn true; /* With reasonable probability, idle! */\n}"
  },
  {
    "function_name": "srcu_flip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "737-759",
    "snippet": "static void srcu_flip(struct srcu_struct *sp)\n{\n\t/*\n\t * Ensure that if this updater saw a given reader's increment\n\t * from __srcu_read_lock(), that reader was using an old value\n\t * of ->srcu_idx.  Also ensure that if a given reader sees the\n\t * new value of ->srcu_idx, this updater's earlier scans cannot\n\t * have seen that reader's increments (which is OK, because this\n\t * grace period need not wait on that reader).\n\t */\n\tsmp_mb(); /* E */  /* Pairs with B and C. */\n\n\tWRITE_ONCE(sp->srcu_idx, sp->srcu_idx + 1);\n\n\t/*\n\t * Ensure that if the updater misses an __srcu_read_unlock()\n\t * increment, that task's next __srcu_read_lock() will see the\n\t * above counter update.  Note that both this memory barrier\n\t * and the one in srcu_readers_active_idx_check() provide the\n\t * guarantee for __srcu_read_lock().\n\t */\n\tsmp_mb(); /* D */  /* Pairs with C. */\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "sp->srcu_idx",
            "sp->srcu_idx + 1"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_flip(struct srcu_struct *sp)\n{\n\t/*\n\t * Ensure that if this updater saw a given reader's increment\n\t * from __srcu_read_lock(), that reader was using an old value\n\t * of ->srcu_idx.  Also ensure that if a given reader sees the\n\t * new value of ->srcu_idx, this updater's earlier scans cannot\n\t * have seen that reader's increments (which is OK, because this\n\t * grace period need not wait on that reader).\n\t */\n\tsmp_mb(); /* E */  /* Pairs with B and C. */\n\n\tWRITE_ONCE(sp->srcu_idx, sp->srcu_idx + 1);\n\n\t/*\n\t * Ensure that if the updater misses an __srcu_read_unlock()\n\t * increment, that task's next __srcu_read_lock() will see the\n\t * above counter update.  Note that both this memory barrier\n\t * and the one in srcu_readers_active_idx_check() provide the\n\t * guarantee for __srcu_read_lock().\n\t */\n\tsmp_mb(); /* D */  /* Pairs with C. */\n}"
  },
  {
    "function_name": "try_check_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "721-730",
    "snippet": "static bool try_check_zero(struct srcu_struct *sp, int idx, int trycount)\n{\n\tfor (;;) {\n\t\tif (srcu_readers_active_idx_check(sp, idx))\n\t\t\treturn true;\n\t\tif (--trycount + !srcu_get_delay(sp) <= 0)\n\t\t\treturn false;\n\t\tudelay(SRCU_RETRY_CHECK_DELAY);\n\t}\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define SRCU_RETRY_CHECK_DELAY\t\t5"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "SRCU_RETRY_CHECK_DELAY"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_get_delay",
          "args": [
            "sp"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_get_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "366-372",
          "snippet": "static unsigned long srcu_get_delay(struct srcu_struct *sp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(sp->srcu_gp_seq),\n\t\t\t READ_ONCE(sp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SRCU_INTERVAL\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic unsigned long srcu_get_delay(struct srcu_struct *sp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(sp->srcu_gp_seq),\n\t\t\t READ_ONCE(sp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_readers_active_idx_check",
          "args": [
            "sp",
            "idx"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_readers_active_idx_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "292-333",
          "snippet": "static bool srcu_readers_active_idx_check(struct srcu_struct *sp, int idx)\n{\n\tunsigned long unlocks;\n\n\tunlocks = srcu_readers_unlock_idx(sp, idx);\n\n\t/*\n\t * Make sure that a lock is always counted if the corresponding\n\t * unlock is counted. Needs to be a smp_mb() as the read side may\n\t * contain a read from a variable that is written to before the\n\t * synchronize_srcu() in the write side. In this case smp_mb()s\n\t * A and B act like the store buffering pattern.\n\t *\n\t * This smp_mb() also pairs with smp_mb() C to prevent accesses\n\t * after the synchronize_srcu() from being executed before the\n\t * grace period ends.\n\t */\n\tsmp_mb(); /* A */\n\n\t/*\n\t * If the locks are the same as the unlocks, then there must have\n\t * been no readers on this index at some time in between. This does\n\t * not mean that there are no more readers, as one could have read\n\t * the current index but not have incremented the lock counter yet.\n\t *\n\t * So suppose that the updater is preempted here for so long\n\t * that more than ULONG_MAX non-nested readers come and go in\n\t * the meantime.  It turns out that this cannot result in overflow\n\t * because if a reader modifies its unlock count after we read it\n\t * above, then that reader's next load of ->srcu_idx is guaranteed\n\t * to get the new value, which will cause it to operate on the\n\t * other bank of counters, where it cannot contribute to the\n\t * overflow of these counters.  This means that there is a maximum\n\t * of 2*NR_CPUS increments, which cannot overflow given current\n\t * systems, especially not on 64-bit systems.\n\t *\n\t * OK, how about nesting?  This does impose a limit on nesting\n\t * of floor(ULONG_MAX/NR_CPUS/2), which should be sufficient,\n\t * especially on 64-bit systems.\n\t */\n\treturn srcu_readers_lock_idx(sp, idx) == unlocks;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic bool srcu_readers_active_idx_check(struct srcu_struct *sp, int idx)\n{\n\tunsigned long unlocks;\n\n\tunlocks = srcu_readers_unlock_idx(sp, idx);\n\n\t/*\n\t * Make sure that a lock is always counted if the corresponding\n\t * unlock is counted. Needs to be a smp_mb() as the read side may\n\t * contain a read from a variable that is written to before the\n\t * synchronize_srcu() in the write side. In this case smp_mb()s\n\t * A and B act like the store buffering pattern.\n\t *\n\t * This smp_mb() also pairs with smp_mb() C to prevent accesses\n\t * after the synchronize_srcu() from being executed before the\n\t * grace period ends.\n\t */\n\tsmp_mb(); /* A */\n\n\t/*\n\t * If the locks are the same as the unlocks, then there must have\n\t * been no readers on this index at some time in between. This does\n\t * not mean that there are no more readers, as one could have read\n\t * the current index but not have incremented the lock counter yet.\n\t *\n\t * So suppose that the updater is preempted here for so long\n\t * that more than ULONG_MAX non-nested readers come and go in\n\t * the meantime.  It turns out that this cannot result in overflow\n\t * because if a reader modifies its unlock count after we read it\n\t * above, then that reader's next load of ->srcu_idx is guaranteed\n\t * to get the new value, which will cause it to operate on the\n\t * other bank of counters, where it cannot contribute to the\n\t * overflow of these counters.  This means that there is a maximum\n\t * of 2*NR_CPUS increments, which cannot overflow given current\n\t * systems, especially not on 64-bit systems.\n\t *\n\t * OK, how about nesting?  This does impose a limit on nesting\n\t * of floor(ULONG_MAX/NR_CPUS/2), which should be sufficient,\n\t * especially on 64-bit systems.\n\t */\n\treturn srcu_readers_lock_idx(sp, idx) == unlocks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_RETRY_CHECK_DELAY\t\t5\n\nstatic bool try_check_zero(struct srcu_struct *sp, int idx, int trycount)\n{\n\tfor (;;) {\n\t\tif (srcu_readers_active_idx_check(sp, idx))\n\t\t\treturn true;\n\t\tif (--trycount + !srcu_get_delay(sp) <= 0)\n\t\t\treturn false;\n\t\tudelay(SRCU_RETRY_CHECK_DELAY);\n\t}\n}"
  },
  {
    "function_name": "srcu_funnel_gp_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "654-714",
    "snippet": "static void srcu_funnel_gp_start(struct srcu_struct *sp, struct srcu_data *sdp,\n\t\t\t\t unsigned long s, bool do_norm)\n{\n\tunsigned long flags;\n\tint idx = rcu_seq_ctr(s) % ARRAY_SIZE(sdp->mynode->srcu_have_cbs);\n\tstruct srcu_node *snp = sdp->mynode;\n\tunsigned long snp_seq;\n\n\t/* Each pass through the loop does one level of the srcu_node tree. */\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&sp->srcu_gp_seq, s) && snp != sdp->mynode)\n\t\t\treturn; /* GP already done and CBs recorded. */\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_have_cbs[idx], s)) {\n\t\t\tsnp_seq = snp->srcu_have_cbs[idx];\n\t\t\tif (snp == sdp->mynode && snp_seq == s)\n\t\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\tif (snp == sdp->mynode && snp_seq != s) {\n\t\t\t\tsrcu_schedule_cbs_sdp(sdp, do_norm\n\t\t\t\t\t\t\t   ? SRCU_INTERVAL\n\t\t\t\t\t\t\t   : 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!do_norm)\n\t\t\t\tsrcu_funnel_exp_start(sp, snp, s);\n\t\t\treturn;\n\t\t}\n\t\tsnp->srcu_have_cbs[idx] = s;\n\t\tif (snp == sdp->mynode)\n\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\tif (!do_norm && ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, s))\n\t\t\tsnp->srcu_gp_seq_needed_exp = s;\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\n\t/* Top of tree, must ensure the grace period will be started. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (ULONG_CMP_LT(sp->srcu_gp_seq_needed, s)) {\n\t\t/*\n\t\t * Record need for grace period s.  Pair with load\n\t\t * acquire setting up for initialization.\n\t\t */\n\t\tsmp_store_release(&sp->srcu_gp_seq_needed, s); /*^^^*/\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sp->srcu_gp_seq_needed_exp, s))\n\t\tsp->srcu_gp_seq_needed_exp = s;\n\n\t/* If grace period not already done and none in progress, start it. */\n\tif (!rcu_seq_done(&sp->srcu_gp_seq, s) &&\n\t    rcu_seq_state(sp->srcu_gp_seq) == SRCU_STATE_IDLE) {\n\t\tWARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));\n\t\tsrcu_gp_start(sp);\n\t\tif (likely(srcu_init_done))\n\t\t\tqueue_delayed_work(rcu_gp_wq, &sp->work,\n\t\t\t\t\t   srcu_get_delay(sp));\n\t\telse if (list_empty(&sp->work.work.entry))\n\t\t\tlist_add(&sp->work.work.entry, &srcu_boot_list);\n\t}\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define SRCU_INTERVAL\t\t1"
    ],
    "globals_used": [
      "static LIST_HEAD(srcu_boot_list);",
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "sp",
            "flags"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&sp->work.work.entry",
            "&srcu_boot_list"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sp->work.work.entry"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "rcu_gp_wq",
            "&sp->work",
            "srcu_get_delay(sp)"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "903-920",
          "snippet": "bool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_get_delay",
          "args": [
            "sp"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_get_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "366-372",
          "snippet": "static unsigned long srcu_get_delay(struct srcu_struct *sp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(sp->srcu_gp_seq),\n\t\t\t READ_ONCE(sp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SRCU_INTERVAL\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic unsigned long srcu_get_delay(struct srcu_struct *sp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(sp->srcu_gp_seq),\n\t\t\t READ_ONCE(sp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "srcu_init_done"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_gp_start",
          "args": [
            "sp"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_gp_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "447-462",
          "snippet": "static void srcu_gp_start(struct srcu_struct *sp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(sp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(sp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&sp->srcu_gp_seq));\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&sp->srcu_gp_seq);\n\tstate = rcu_seq_state(READ_ONCE(sp->srcu_gp_seq));\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_gp_start(struct srcu_struct *sp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(sp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(sp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&sp->srcu_gp_seq));\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&sp->srcu_gp_seq);\n\tstate = rcu_seq_state(READ_ONCE(sp->srcu_gp_seq));\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed)"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "sp->srcu_gp_seq",
            "sp->srcu_gp_seq_needed"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "sp->srcu_gp_seq"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "57-60",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&sp->srcu_gp_seq",
            "s"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "133-136",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "sp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&sp->srcu_gp_seq_needed",
            "s"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "sp->srcu_gp_seq_needed",
            "s"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_rcu_node",
          "args": [
            "sp",
            "flags"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "snp",
            "flags"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "snp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_funnel_exp_start",
          "args": [
            "sp",
            "snp",
            "s"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_funnel_exp_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "621-642",
          "snippet": "static void srcu_funnel_exp_start(struct srcu_struct *sp, struct srcu_node *snp,\n\t\t\t\t  unsigned long s)\n{\n\tunsigned long flags;\n\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&sp->srcu_gp_seq, s) ||\n\t\t    ULONG_CMP_GE(READ_ONCE(snp->srcu_gp_seq_needed_exp), s))\n\t\t\treturn;\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_gp_seq_needed_exp, s)) {\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (ULONG_CMP_LT(sp->srcu_gp_seq_needed_exp, s))\n\t\tsp->srcu_gp_seq_needed_exp = s;\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_funnel_exp_start(struct srcu_struct *sp, struct srcu_node *snp,\n\t\t\t\t  unsigned long s)\n{\n\tunsigned long flags;\n\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&sp->srcu_gp_seq, s) ||\n\t\t    ULONG_CMP_GE(READ_ONCE(snp->srcu_gp_seq_needed_exp), s))\n\t\t\treturn;\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_gp_seq_needed_exp, s)) {\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (ULONG_CMP_LT(sp->srcu_gp_seq_needed_exp, s))\n\t\tsp->srcu_gp_seq_needed_exp = s;\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_schedule_cbs_sdp",
          "args": [
            "sdp",
            "do_norm\n\t\t\t\t\t\t\t   ? SRCU_INTERVAL\n\t\t\t\t\t\t\t   : 0"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_schedule_cbs_sdp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "503-506",
          "snippet": "static void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp->cpu, rcu_gp_wq, &sdp->work, delay);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp->cpu, rcu_gp_wq, &sdp->work, delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "snp",
            "flags"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "snp->srcu_have_cbs[idx]",
            "s"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_rcu_node",
          "args": [
            "snp",
            "flags"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "sdp->mynode->srcu_have_cbs"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "s"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "48-51",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic LIST_HEAD(srcu_boot_list);\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_funnel_gp_start(struct srcu_struct *sp, struct srcu_data *sdp,\n\t\t\t\t unsigned long s, bool do_norm)\n{\n\tunsigned long flags;\n\tint idx = rcu_seq_ctr(s) % ARRAY_SIZE(sdp->mynode->srcu_have_cbs);\n\tstruct srcu_node *snp = sdp->mynode;\n\tunsigned long snp_seq;\n\n\t/* Each pass through the loop does one level of the srcu_node tree. */\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&sp->srcu_gp_seq, s) && snp != sdp->mynode)\n\t\t\treturn; /* GP already done and CBs recorded. */\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_have_cbs[idx], s)) {\n\t\t\tsnp_seq = snp->srcu_have_cbs[idx];\n\t\t\tif (snp == sdp->mynode && snp_seq == s)\n\t\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\tif (snp == sdp->mynode && snp_seq != s) {\n\t\t\t\tsrcu_schedule_cbs_sdp(sdp, do_norm\n\t\t\t\t\t\t\t   ? SRCU_INTERVAL\n\t\t\t\t\t\t\t   : 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!do_norm)\n\t\t\t\tsrcu_funnel_exp_start(sp, snp, s);\n\t\t\treturn;\n\t\t}\n\t\tsnp->srcu_have_cbs[idx] = s;\n\t\tif (snp == sdp->mynode)\n\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\tif (!do_norm && ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, s))\n\t\t\tsnp->srcu_gp_seq_needed_exp = s;\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\n\t/* Top of tree, must ensure the grace period will be started. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (ULONG_CMP_LT(sp->srcu_gp_seq_needed, s)) {\n\t\t/*\n\t\t * Record need for grace period s.  Pair with load\n\t\t * acquire setting up for initialization.\n\t\t */\n\t\tsmp_store_release(&sp->srcu_gp_seq_needed, s); /*^^^*/\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sp->srcu_gp_seq_needed_exp, s))\n\t\tsp->srcu_gp_seq_needed_exp = s;\n\n\t/* If grace period not already done and none in progress, start it. */\n\tif (!rcu_seq_done(&sp->srcu_gp_seq, s) &&\n\t    rcu_seq_state(sp->srcu_gp_seq) == SRCU_STATE_IDLE) {\n\t\tWARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));\n\t\tsrcu_gp_start(sp);\n\t\tif (likely(srcu_init_done))\n\t\t\tqueue_delayed_work(rcu_gp_wq, &sp->work,\n\t\t\t\t\t   srcu_get_delay(sp));\n\t\telse if (list_empty(&sp->work.work.entry))\n\t\t\tlist_add(&sp->work.work.entry, &srcu_boot_list);\n\t}\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}"
  },
  {
    "function_name": "srcu_funnel_exp_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "621-642",
    "snippet": "static void srcu_funnel_exp_start(struct srcu_struct *sp, struct srcu_node *snp,\n\t\t\t\t  unsigned long s)\n{\n\tunsigned long flags;\n\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&sp->srcu_gp_seq, s) ||\n\t\t    ULONG_CMP_GE(READ_ONCE(snp->srcu_gp_seq_needed_exp), s))\n\t\t\treturn;\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_gp_seq_needed_exp, s)) {\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (ULONG_CMP_LT(sp->srcu_gp_seq_needed_exp, s))\n\t\tsp->srcu_gp_seq_needed_exp = s;\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "sp",
            "flags"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "sp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_rcu_node",
          "args": [
            "sp",
            "flags"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "snp",
            "flags"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "snp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "snp",
            "flags"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "snp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_rcu_node",
          "args": [
            "snp",
            "flags"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "READ_ONCE(snp->srcu_gp_seq_needed_exp)",
            "s"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "snp->srcu_gp_seq_needed_exp"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&sp->srcu_gp_seq",
            "s"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "133-136",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_funnel_exp_start(struct srcu_struct *sp, struct srcu_node *snp,\n\t\t\t\t  unsigned long s)\n{\n\tunsigned long flags;\n\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&sp->srcu_gp_seq, s) ||\n\t\t    ULONG_CMP_GE(READ_ONCE(snp->srcu_gp_seq_needed_exp), s))\n\t\t\treturn;\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_gp_seq_needed_exp, s)) {\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (ULONG_CMP_LT(sp->srcu_gp_seq_needed_exp, s))\n\t\tsp->srcu_gp_seq_needed_exp = s;\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}"
  },
  {
    "function_name": "srcu_gp_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "535-612",
    "snippet": "static void srcu_gp_end(struct srcu_struct *sp)\n{\n\tunsigned long cbdelay;\n\tbool cbs;\n\tbool last_lvl;\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpseq;\n\tint idx;\n\tunsigned long mask;\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\n\t/* Prevent more than one additional grace period. */\n\tmutex_lock(&sp->srcu_cb_mutex);\n\n\t/* End the current grace period. */\n\tspin_lock_irq_rcu_node(sp);\n\tidx = rcu_seq_state(sp->srcu_gp_seq);\n\tWARN_ON_ONCE(idx != SRCU_STATE_SCAN2);\n\tcbdelay = srcu_get_delay(sp);\n\tsp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\trcu_seq_end(&sp->srcu_gp_seq);\n\tgpseq = rcu_seq_current(&sp->srcu_gp_seq);\n\tif (ULONG_CMP_LT(sp->srcu_gp_seq_needed_exp, gpseq))\n\t\tsp->srcu_gp_seq_needed_exp = gpseq;\n\tspin_unlock_irq_rcu_node(sp);\n\tmutex_unlock(&sp->srcu_gp_mutex);\n\t/* A new grace period can start at this point.  But only one. */\n\n\t/* Initiate callback invocation as needed. */\n\tidx = rcu_seq_ctr(gpseq) % ARRAY_SIZE(snp->srcu_have_cbs);\n\tsrcu_for_each_node_breadth_first(sp, snp) {\n\t\tspin_lock_irq_rcu_node(snp);\n\t\tcbs = false;\n\t\tlast_lvl = snp >= sp->level[rcu_num_lvls - 1];\n\t\tif (last_lvl)\n\t\t\tcbs = snp->srcu_have_cbs[idx] == gpseq;\n\t\tsnp->srcu_have_cbs[idx] = gpseq;\n\t\trcu_seq_set_state(&snp->srcu_have_cbs[idx], 1);\n\t\tif (ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, gpseq))\n\t\t\tsnp->srcu_gp_seq_needed_exp = gpseq;\n\t\tmask = snp->srcu_data_have_cbs[idx];\n\t\tsnp->srcu_data_have_cbs[idx] = 0;\n\t\tspin_unlock_irq_rcu_node(snp);\n\t\tif (cbs)\n\t\t\tsrcu_schedule_cbs_snp(sp, snp, mask, cbdelay);\n\n\t\t/* Occasionally prevent srcu_data counter wrap. */\n\t\tif (!(gpseq & counter_wrap_check) && last_lvl)\n\t\t\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\t\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\t\t\tspin_lock_irqsave_rcu_node(sdp, flags);\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed = gpseq;\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed_exp + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed_exp = gpseq;\n\t\t\t\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\t\t\t}\n\t}\n\n\t/* Callback initiation done, allow grace periods after next. */\n\tmutex_unlock(&sp->srcu_cb_mutex);\n\n\t/* Start a new grace period if needed. */\n\tspin_lock_irq_rcu_node(sp);\n\tgpseq = rcu_seq_current(&sp->srcu_gp_seq);\n\tif (!rcu_seq_state(gpseq) &&\n\t    ULONG_CMP_LT(gpseq, sp->srcu_gp_seq_needed)) {\n\t\tsrcu_gp_start(sp);\n\t\tspin_unlock_irq_rcu_node(sp);\n\t\tsrcu_reschedule(sp, 0);\n\t} else {\n\t\tspin_unlock_irq_rcu_node(sp);\n\t}\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ulong counter_wrap_check = (ULONG_MAX >> 2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "sp"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_reschedule",
          "args": [
            "sp",
            "0"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_reschedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1227-1245",
          "snippet": "static void srcu_reschedule(struct srcu_struct *sp, unsigned long delay)\n{\n\tbool pushgp = true;\n\n\tspin_lock_irq_rcu_node(sp);\n\tif (ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed)) {\n\t\tif (!WARN_ON_ONCE(rcu_seq_state(sp->srcu_gp_seq))) {\n\t\t\t/* All requests fulfilled, time to go idle. */\n\t\t\tpushgp = false;\n\t\t}\n\t} else if (!rcu_seq_state(sp->srcu_gp_seq)) {\n\t\t/* Outstanding request and no GP.  Start one. */\n\t\tsrcu_gp_start(sp);\n\t}\n\tspin_unlock_irq_rcu_node(sp);\n\n\tif (pushgp)\n\t\tqueue_delayed_work(rcu_gp_wq, &sp->work, delay);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_reschedule(struct srcu_struct *sp, unsigned long delay)\n{\n\tbool pushgp = true;\n\n\tspin_lock_irq_rcu_node(sp);\n\tif (ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed)) {\n\t\tif (!WARN_ON_ONCE(rcu_seq_state(sp->srcu_gp_seq))) {\n\t\t\t/* All requests fulfilled, time to go idle. */\n\t\t\tpushgp = false;\n\t\t}\n\t} else if (!rcu_seq_state(sp->srcu_gp_seq)) {\n\t\t/* Outstanding request and no GP.  Start one. */\n\t\tsrcu_gp_start(sp);\n\t}\n\tspin_unlock_irq_rcu_node(sp);\n\n\tif (pushgp)\n\t\tqueue_delayed_work(rcu_gp_wq, &sp->work, delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "sp"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_gp_start",
          "args": [
            "sp"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_gp_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "447-462",
          "snippet": "static void srcu_gp_start(struct srcu_struct *sp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(sp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(sp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&sp->srcu_gp_seq));\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&sp->srcu_gp_seq);\n\tstate = rcu_seq_state(READ_ONCE(sp->srcu_gp_seq));\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_gp_start(struct srcu_struct *sp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(sp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(sp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&sp->srcu_gp_seq));\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&sp->srcu_gp_seq);\n\tstate = rcu_seq_state(READ_ONCE(sp->srcu_gp_seq));\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "gpseq",
            "sp->srcu_gp_seq_needed"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "gpseq"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "57-60",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&sp->srcu_gp_seq"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "sp"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sp->srcu_cb_mutex"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "sdp",
            "flags"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "gpseq",
            "sdp->srcu_gp_seq_needed_exp + 100"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "gpseq",
            "sdp->srcu_gp_seq_needed + 100"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_rcu_node",
          "args": [
            "sdp",
            "flags"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sp->sda",
            "cpu"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_schedule_cbs_snp",
          "args": [
            "sp",
            "snp",
            "mask",
            "cbdelay"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_schedule_cbs_snp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "514-524",
          "snippet": "static void srcu_schedule_cbs_snp(struct srcu_struct *sp, struct srcu_node *snp,\n\t\t\t\t  unsigned long mask, unsigned long delay)\n{\n\tint cpu;\n\n\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\tif (!(mask & (1 << (cpu - snp->grplo))))\n\t\t\tcontinue;\n\t\tsrcu_schedule_cbs_sdp(per_cpu_ptr(sp->sda, cpu), delay);\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);\n\nstatic void srcu_schedule_cbs_snp(struct srcu_struct *sp, struct srcu_node *snp,\n\t\t\t\t  unsigned long mask, unsigned long delay)\n{\n\tint cpu;\n\n\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\tif (!(mask & (1 << (cpu - snp->grplo))))\n\t\t\tcontinue;\n\t\tsrcu_schedule_cbs_sdp(per_cpu_ptr(sp->sda, cpu), delay);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "snp"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "snp->srcu_gp_seq_needed_exp",
            "gpseq"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_set_state",
          "args": [
            "&snp->srcu_have_cbs[idx]",
            "1"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "66-70",
          "snippet": "static inline void rcu_seq_set_state(unsigned long *sp, int newstate)\n{\n\tWARN_ON_ONCE(newstate & ~RCU_SEQ_STATE_MASK);\n\tWRITE_ONCE(*sp, (*sp & ~RCU_SEQ_STATE_MASK) + newstate);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline void rcu_seq_set_state(unsigned long *sp, int newstate)\n{\n\tWARN_ON_ONCE(newstate & ~RCU_SEQ_STATE_MASK);\n\tWRITE_ONCE(*sp, (*sp & ~RCU_SEQ_STATE_MASK) + newstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "snp"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_for_each_node_breadth_first",
          "args": [
            "sp",
            "snp"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "snp->srcu_have_cbs"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "gpseq"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "48-51",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "sp"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "sp->srcu_gp_seq_needed_exp",
            "gpseq"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_end",
          "args": [
            "&sp->srcu_gp_seq"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "87-92",
          "snippet": "static inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_mono_fast_ns",
          "args": [],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_mono_fast_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "469-472",
          "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_get_delay",
          "args": [
            "sp"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_get_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "366-372",
          "snippet": "static unsigned long srcu_get_delay(struct srcu_struct *sp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(sp->srcu_gp_seq),\n\t\t\t READ_ONCE(sp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SRCU_INTERVAL\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic unsigned long srcu_get_delay(struct srcu_struct *sp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(sp->srcu_gp_seq),\n\t\t\t READ_ONCE(sp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "idx != SRCU_STATE_SCAN2"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "sp"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sp->srcu_cb_mutex"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic ulong counter_wrap_check = (ULONG_MAX >> 2);\n\nstatic void srcu_gp_end(struct srcu_struct *sp)\n{\n\tunsigned long cbdelay;\n\tbool cbs;\n\tbool last_lvl;\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpseq;\n\tint idx;\n\tunsigned long mask;\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\n\t/* Prevent more than one additional grace period. */\n\tmutex_lock(&sp->srcu_cb_mutex);\n\n\t/* End the current grace period. */\n\tspin_lock_irq_rcu_node(sp);\n\tidx = rcu_seq_state(sp->srcu_gp_seq);\n\tWARN_ON_ONCE(idx != SRCU_STATE_SCAN2);\n\tcbdelay = srcu_get_delay(sp);\n\tsp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\trcu_seq_end(&sp->srcu_gp_seq);\n\tgpseq = rcu_seq_current(&sp->srcu_gp_seq);\n\tif (ULONG_CMP_LT(sp->srcu_gp_seq_needed_exp, gpseq))\n\t\tsp->srcu_gp_seq_needed_exp = gpseq;\n\tspin_unlock_irq_rcu_node(sp);\n\tmutex_unlock(&sp->srcu_gp_mutex);\n\t/* A new grace period can start at this point.  But only one. */\n\n\t/* Initiate callback invocation as needed. */\n\tidx = rcu_seq_ctr(gpseq) % ARRAY_SIZE(snp->srcu_have_cbs);\n\tsrcu_for_each_node_breadth_first(sp, snp) {\n\t\tspin_lock_irq_rcu_node(snp);\n\t\tcbs = false;\n\t\tlast_lvl = snp >= sp->level[rcu_num_lvls - 1];\n\t\tif (last_lvl)\n\t\t\tcbs = snp->srcu_have_cbs[idx] == gpseq;\n\t\tsnp->srcu_have_cbs[idx] = gpseq;\n\t\trcu_seq_set_state(&snp->srcu_have_cbs[idx], 1);\n\t\tif (ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, gpseq))\n\t\t\tsnp->srcu_gp_seq_needed_exp = gpseq;\n\t\tmask = snp->srcu_data_have_cbs[idx];\n\t\tsnp->srcu_data_have_cbs[idx] = 0;\n\t\tspin_unlock_irq_rcu_node(snp);\n\t\tif (cbs)\n\t\t\tsrcu_schedule_cbs_snp(sp, snp, mask, cbdelay);\n\n\t\t/* Occasionally prevent srcu_data counter wrap. */\n\t\tif (!(gpseq & counter_wrap_check) && last_lvl)\n\t\t\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\t\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\t\t\tspin_lock_irqsave_rcu_node(sdp, flags);\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed = gpseq;\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed_exp + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed_exp = gpseq;\n\t\t\t\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\t\t\t}\n\t}\n\n\t/* Callback initiation done, allow grace periods after next. */\n\tmutex_unlock(&sp->srcu_cb_mutex);\n\n\t/* Start a new grace period if needed. */\n\tspin_lock_irq_rcu_node(sp);\n\tgpseq = rcu_seq_current(&sp->srcu_gp_seq);\n\tif (!rcu_seq_state(gpseq) &&\n\t    ULONG_CMP_LT(gpseq, sp->srcu_gp_seq_needed)) {\n\t\tsrcu_gp_start(sp);\n\t\tspin_unlock_irq_rcu_node(sp);\n\t\tsrcu_reschedule(sp, 0);\n\t} else {\n\t\tspin_unlock_irq_rcu_node(sp);\n\t}\n}"
  },
  {
    "function_name": "srcu_schedule_cbs_snp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "514-524",
    "snippet": "static void srcu_schedule_cbs_snp(struct srcu_struct *sp, struct srcu_node *snp,\n\t\t\t\t  unsigned long mask, unsigned long delay)\n{\n\tint cpu;\n\n\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\tif (!(mask & (1 << (cpu - snp->grplo))))\n\t\t\tcontinue;\n\t\tsrcu_schedule_cbs_sdp(per_cpu_ptr(sp->sda, cpu), delay);\n\t}\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_schedule_cbs_sdp",
          "args": [
            "per_cpu_ptr(sp->sda, cpu)",
            "delay"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_schedule_cbs_sdp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "503-506",
          "snippet": "static void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp->cpu, rcu_gp_wq, &sdp->work, delay);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp->cpu, rcu_gp_wq, &sdp->work, delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sp->sda",
            "cpu"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);\n\nstatic void srcu_schedule_cbs_snp(struct srcu_struct *sp, struct srcu_node *snp,\n\t\t\t\t  unsigned long mask, unsigned long delay)\n{\n\tint cpu;\n\n\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\tif (!(mask & (1 << (cpu - snp->grplo))))\n\t\t\tcontinue;\n\t\tsrcu_schedule_cbs_sdp(per_cpu_ptr(sp->sda, cpu), delay);\n\t}\n}"
  },
  {
    "function_name": "srcu_schedule_cbs_sdp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "503-506",
    "snippet": "static void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp->cpu, rcu_gp_wq, &sdp->work, delay);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_queue_delayed_work_on",
          "args": [
            "sdp->cpu",
            "rcu_gp_wq",
            "&sdp->work",
            "delay"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_queue_delayed_work_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "484-497",
          "snippet": "static bool srcu_queue_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\t\t       struct delayed_work *dwork,\n\t\t\t\t       unsigned long delay)\n{\n\tbool ret;\n\n\tpreempt_disable();\n\tif (READ_ONCE(per_cpu(srcu_online, cpu)))\n\t\tret = queue_delayed_work_on(cpu, wq, dwork, delay);\n\telse\n\t\tret = queue_delayed_work(wq, dwork, delay);\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);\n\nstatic bool srcu_queue_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\t\t       struct delayed_work *dwork,\n\t\t\t\t       unsigned long delay)\n{\n\tbool ret;\n\n\tpreempt_disable();\n\tif (READ_ONCE(per_cpu(srcu_online, cpu)))\n\t\tret = queue_delayed_work_on(cpu, wq, dwork, delay);\n\telse\n\t\tret = queue_delayed_work(wq, dwork, delay);\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp->cpu, rcu_gp_wq, &sdp->work, delay);\n}"
  },
  {
    "function_name": "srcu_queue_delayed_work_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "484-497",
    "snippet": "static bool srcu_queue_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\t\t       struct delayed_work *dwork,\n\t\t\t\t       unsigned long delay)\n{\n\tbool ret;\n\n\tpreempt_disable();\n\tif (READ_ONCE(per_cpu(srcu_online, cpu)))\n\t\tret = queue_delayed_work_on(cpu, wq, dwork, delay);\n\telse\n\t\tret = queue_delayed_work(wq, dwork, delay);\n\tpreempt_enable();\n\treturn ret;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "wq",
            "dwork",
            "delay"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "903-920",
          "snippet": "bool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work_on",
          "args": [
            "cpu",
            "wq",
            "dwork",
            "delay"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_queue_delayed_work_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "484-497",
          "snippet": "static bool srcu_queue_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\t\t       struct delayed_work *dwork,\n\t\t\t\t       unsigned long delay)\n{\n\tbool ret;\n\n\tpreempt_disable();\n\tif (READ_ONCE(per_cpu(srcu_online, cpu)))\n\t\tret = queue_delayed_work_on(cpu, wq, dwork, delay);\n\telse\n\t\tret = queue_delayed_work(wq, dwork, delay);\n\tpreempt_enable();\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "per_cpu(srcu_online, cpu)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "srcu_online",
            "cpu"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_reschedule(struct srcu_struct *sp, unsigned long delay);\n\nstatic bool srcu_queue_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\t\t       struct delayed_work *dwork,\n\t\t\t\t       unsigned long delay)\n{\n\tbool ret;\n\n\tpreempt_disable();\n\tif (READ_ONCE(per_cpu(srcu_online, cpu)))\n\t\tret = queue_delayed_work_on(cpu, wq, dwork, delay);\n\telse\n\t\tret = queue_delayed_work(wq, dwork, delay);\n\tpreempt_enable();\n\treturn ret;\n}"
  },
  {
    "function_name": "srcu_offline_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "474-477",
    "snippet": "void srcu_offline_cpu(unsigned int cpu)\n{\n\tWRITE_ONCE(per_cpu(srcu_online, cpu), false);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "per_cpu(srcu_online, cpu)",
            "false"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "srcu_online",
            "cpu"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid srcu_offline_cpu(unsigned int cpu)\n{\n\tWRITE_ONCE(per_cpu(srcu_online, cpu), false);\n}"
  },
  {
    "function_name": "srcu_online_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "469-472",
    "snippet": "void srcu_online_cpu(unsigned int cpu)\n{\n\tWRITE_ONCE(per_cpu(srcu_online, cpu), true);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "per_cpu(srcu_online, cpu)",
            "true"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "srcu_online",
            "cpu"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid srcu_online_cpu(unsigned int cpu)\n{\n\tWRITE_ONCE(per_cpu(srcu_online, cpu), true);\n}"
  },
  {
    "function_name": "srcu_gp_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "447-462",
    "snippet": "static void srcu_gp_start(struct srcu_struct *sp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(sp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(sp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&sp->srcu_gp_seq));\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&sp->srcu_gp_seq);\n\tstate = rcu_seq_state(READ_ONCE(sp->srcu_gp_seq));\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "state != SRCU_STATE_SCAN1"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "READ_ONCE(sp->srcu_gp_seq)"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "57-60",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_gp_seq"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_start",
          "args": [
            "&sp->srcu_gp_seq"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "73-78",
          "snippet": "static inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_accelerate",
          "args": [
            "&sdp->srcu_cblist",
            "rcu_seq_snap(&sp->srcu_gp_seq)"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_accelerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "355-404",
          "snippet": "bool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t */\n\tif (++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\trsclp->tails[i] = rsclp->tails[RCU_NEXT_TAIL];\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t */\n\tif (++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\trsclp->tails[i] = rsclp->tails[RCU_NEXT_TAIL];\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&sp->srcu_gp_seq"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "105-112",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_advance",
          "args": [
            "&sdp->srcu_cblist",
            "rcu_seq_current(&sp->srcu_gp_seq)"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_advance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "300-338",
          "snippet": "void rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\trsclp->tails[RCU_DONE_TAIL] = rsclp->tails[i];\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\trsclp->tails[j] = rsclp->tails[RCU_DONE_TAIL];\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\trsclp->tails[j] = rsclp->tails[i];\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\trsclp->tails[RCU_DONE_TAIL] = rsclp->tails[i];\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\trsclp->tails[j] = rsclp->tails[RCU_DONE_TAIL];\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\trsclp->tails[j] = rsclp->tails[i];\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&sp->srcu_gp_seq"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed)"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "sp->srcu_gp_seq",
            "sp->srcu_gp_seq_needed"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&ACCESS_PRIVATE(sp, lock)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_PRIVATE",
          "args": [
            "sp",
            "lock"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "sp->sda"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_gp_start(struct srcu_struct *sp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(sp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(sp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&sp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&sp->srcu_gp_seq));\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&sp->srcu_gp_seq);\n\tstate = rcu_seq_state(READ_ONCE(sp->srcu_gp_seq));\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}"
  },
  {
    "function_name": "__srcu_read_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "428-432",
    "snippet": "void __srcu_read_unlock(struct srcu_struct *sp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(sp->sda->srcu_unlock_count[idx]);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "sp->sda->srcu_unlock_count[idx]"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid __srcu_read_unlock(struct srcu_struct *sp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(sp->sda->srcu_unlock_count[idx]);\n}"
  },
  {
    "function_name": "__srcu_read_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "412-420",
    "snippet": "int __srcu_read_lock(struct srcu_struct *sp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(sp->srcu_idx) & 0x1;\n\tthis_cpu_inc(sp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "sp->sda->srcu_lock_count[idx]"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_idx"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint __srcu_read_lock(struct srcu_struct *sp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(sp->srcu_idx) & 0x1;\n\tthis_cpu_inc(sp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}"
  },
  {
    "function_name": "_cleanup_srcu_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "375-404",
    "snippet": "void _cleanup_srcu_struct(struct srcu_struct *sp, bool quiesced)\n{\n\tint cpu;\n\n\tif (WARN_ON(!srcu_get_delay(sp)))\n\t\treturn; /* Just leak it! */\n\tif (WARN_ON(srcu_readers_active(sp)))\n\t\treturn; /* Just leak it! */\n\tif (quiesced) {\n\t\tif (WARN_ON(delayed_work_pending(&sp->work)))\n\t\t\treturn; /* Just leak it! */\n\t} else {\n\t\tflush_delayed_work(&sp->work);\n\t}\n\tfor_each_possible_cpu(cpu)\n\t\tif (quiesced) {\n\t\t\tif (WARN_ON(delayed_work_pending(&per_cpu_ptr(sp->sda, cpu)->work)))\n\t\t\t\treturn; /* Just leak it! */\n\t\t} else {\n\t\t\tflush_delayed_work(&per_cpu_ptr(sp->sda, cpu)->work);\n\t\t}\n\tif (WARN_ON(rcu_seq_state(READ_ONCE(sp->srcu_gp_seq)) != SRCU_STATE_IDLE) ||\n\t    WARN_ON(srcu_readers_active(sp))) {\n\t\tpr_info(\"%s: Active srcu_struct %p state: %d\\n\",\n\t\t\t__func__, sp, rcu_seq_state(READ_ONCE(sp->srcu_gp_seq)));\n\t\treturn; /* Caller forgot to stop doing call_srcu()? */\n\t}\n\tfree_percpu(sp->sda);\n\tsp->sda = NULL;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "sp->sda"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Active srcu_struct %p state: %d\\n\"",
            "__func__",
            "sp",
            "rcu_seq_state(READ_ONCE(sp->srcu_gp_seq))"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "READ_ONCE(sp->srcu_gp_seq)"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "57-60",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_gp_seq"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "srcu_readers_active(sp)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_readers_active",
          "args": [
            "sp"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_readers_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "344-358",
          "snippet": "static bool srcu_readers_active(struct srcu_struct *sp)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(sp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[0]);\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[1]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[0]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[1]);\n\t}\n\treturn sum;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic bool srcu_readers_active(struct srcu_struct *sp)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(sp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[0]);\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[1]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[0]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[1]);\n\t}\n\treturn sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "rcu_seq_state(READ_ONCE(sp->srcu_gp_seq)) != SRCU_STATE_IDLE"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_gp_seq"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_delayed_work",
          "args": [
            "&per_cpu_ptr(sp->sda, cpu)->work"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "flush_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3056-3063",
          "snippet": "bool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->timer))\n\t\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n\tlocal_irq_enable();\n\treturn flush_work(&dwork->work);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->timer))\n\t\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n\tlocal_irq_enable();\n\treturn flush_work(&dwork->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sp->sda",
            "cpu"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "delayed_work_pending(&per_cpu_ptr(sp->sda, cpu)->work)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delayed_work_pending",
          "args": [
            "&per_cpu_ptr(sp->sda, cpu)->work"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sp->sda",
            "cpu"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "delayed_work_pending(&sp->work)"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delayed_work_pending",
          "args": [
            "&sp->work"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "srcu_readers_active(sp)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!srcu_get_delay(sp)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_get_delay",
          "args": [
            "sp"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_get_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "366-372",
          "snippet": "static unsigned long srcu_get_delay(struct srcu_struct *sp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(sp->srcu_gp_seq),\n\t\t\t READ_ONCE(sp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SRCU_INTERVAL\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic unsigned long srcu_get_delay(struct srcu_struct *sp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(sp->srcu_gp_seq),\n\t\t\t READ_ONCE(sp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nvoid _cleanup_srcu_struct(struct srcu_struct *sp, bool quiesced)\n{\n\tint cpu;\n\n\tif (WARN_ON(!srcu_get_delay(sp)))\n\t\treturn; /* Just leak it! */\n\tif (WARN_ON(srcu_readers_active(sp)))\n\t\treturn; /* Just leak it! */\n\tif (quiesced) {\n\t\tif (WARN_ON(delayed_work_pending(&sp->work)))\n\t\t\treturn; /* Just leak it! */\n\t} else {\n\t\tflush_delayed_work(&sp->work);\n\t}\n\tfor_each_possible_cpu(cpu)\n\t\tif (quiesced) {\n\t\t\tif (WARN_ON(delayed_work_pending(&per_cpu_ptr(sp->sda, cpu)->work)))\n\t\t\t\treturn; /* Just leak it! */\n\t\t} else {\n\t\t\tflush_delayed_work(&per_cpu_ptr(sp->sda, cpu)->work);\n\t\t}\n\tif (WARN_ON(rcu_seq_state(READ_ONCE(sp->srcu_gp_seq)) != SRCU_STATE_IDLE) ||\n\t    WARN_ON(srcu_readers_active(sp))) {\n\t\tpr_info(\"%s: Active srcu_struct %p state: %d\\n\",\n\t\t\t__func__, sp, rcu_seq_state(READ_ONCE(sp->srcu_gp_seq)));\n\t\treturn; /* Caller forgot to stop doing call_srcu()? */\n\t}\n\tfree_percpu(sp->sda);\n\tsp->sda = NULL;\n}"
  },
  {
    "function_name": "srcu_get_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "366-372",
    "snippet": "static unsigned long srcu_get_delay(struct srcu_struct *sp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(sp->srcu_gp_seq),\n\t\t\t READ_ONCE(sp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define SRCU_INTERVAL\t\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "READ_ONCE(sp->srcu_gp_seq)",
            "READ_ONCE(sp->srcu_gp_seq_needed_exp)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_gp_seq_needed_exp"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_gp_seq"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic unsigned long srcu_get_delay(struct srcu_struct *sp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(sp->srcu_gp_seq),\n\t\t\t READ_ONCE(sp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}"
  },
  {
    "function_name": "srcu_readers_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "344-358",
    "snippet": "static bool srcu_readers_active(struct srcu_struct *sp)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(sp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[0]);\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[1]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[0]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[1]);\n\t}\n\treturn sum;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cpuc->srcu_unlock_count[1]"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cpuc->srcu_unlock_count[0]"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cpuc->srcu_lock_count[1]"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cpuc->srcu_lock_count[0]"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sp->sda",
            "cpu"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic bool srcu_readers_active(struct srcu_struct *sp)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(sp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[0]);\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[1]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[0]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[1]);\n\t}\n\treturn sum;\n}"
  },
  {
    "function_name": "srcu_readers_active_idx_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "292-333",
    "snippet": "static bool srcu_readers_active_idx_check(struct srcu_struct *sp, int idx)\n{\n\tunsigned long unlocks;\n\n\tunlocks = srcu_readers_unlock_idx(sp, idx);\n\n\t/*\n\t * Make sure that a lock is always counted if the corresponding\n\t * unlock is counted. Needs to be a smp_mb() as the read side may\n\t * contain a read from a variable that is written to before the\n\t * synchronize_srcu() in the write side. In this case smp_mb()s\n\t * A and B act like the store buffering pattern.\n\t *\n\t * This smp_mb() also pairs with smp_mb() C to prevent accesses\n\t * after the synchronize_srcu() from being executed before the\n\t * grace period ends.\n\t */\n\tsmp_mb(); /* A */\n\n\t/*\n\t * If the locks are the same as the unlocks, then there must have\n\t * been no readers on this index at some time in between. This does\n\t * not mean that there are no more readers, as one could have read\n\t * the current index but not have incremented the lock counter yet.\n\t *\n\t * So suppose that the updater is preempted here for so long\n\t * that more than ULONG_MAX non-nested readers come and go in\n\t * the meantime.  It turns out that this cannot result in overflow\n\t * because if a reader modifies its unlock count after we read it\n\t * above, then that reader's next load of ->srcu_idx is guaranteed\n\t * to get the new value, which will cause it to operate on the\n\t * other bank of counters, where it cannot contribute to the\n\t * overflow of these counters.  This means that there is a maximum\n\t * of 2*NR_CPUS increments, which cannot overflow given current\n\t * systems, especially not on 64-bit systems.\n\t *\n\t * OK, how about nesting?  This does impose a limit on nesting\n\t * of floor(ULONG_MAX/NR_CPUS/2), which should be sufficient,\n\t * especially on 64-bit systems.\n\t */\n\treturn srcu_readers_lock_idx(sp, idx) == unlocks;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_readers_lock_idx",
          "args": [
            "sp",
            "idx"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_readers_lock_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "258-269",
          "snippet": "static unsigned long srcu_readers_lock_idx(struct srcu_struct *sp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(sp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[idx]);\n\t}\n\treturn sum;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic unsigned long srcu_readers_lock_idx(struct srcu_struct *sp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(sp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[idx]);\n\t}\n\treturn sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_readers_unlock_idx",
          "args": [
            "sp",
            "idx"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_readers_unlock_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "275-286",
          "snippet": "static unsigned long srcu_readers_unlock_idx(struct srcu_struct *sp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(sp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_unlock_count[idx]);\n\t}\n\treturn sum;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic unsigned long srcu_readers_unlock_idx(struct srcu_struct *sp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(sp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_unlock_count[idx]);\n\t}\n\treturn sum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic bool srcu_readers_active_idx_check(struct srcu_struct *sp, int idx)\n{\n\tunsigned long unlocks;\n\n\tunlocks = srcu_readers_unlock_idx(sp, idx);\n\n\t/*\n\t * Make sure that a lock is always counted if the corresponding\n\t * unlock is counted. Needs to be a smp_mb() as the read side may\n\t * contain a read from a variable that is written to before the\n\t * synchronize_srcu() in the write side. In this case smp_mb()s\n\t * A and B act like the store buffering pattern.\n\t *\n\t * This smp_mb() also pairs with smp_mb() C to prevent accesses\n\t * after the synchronize_srcu() from being executed before the\n\t * grace period ends.\n\t */\n\tsmp_mb(); /* A */\n\n\t/*\n\t * If the locks are the same as the unlocks, then there must have\n\t * been no readers on this index at some time in between. This does\n\t * not mean that there are no more readers, as one could have read\n\t * the current index but not have incremented the lock counter yet.\n\t *\n\t * So suppose that the updater is preempted here for so long\n\t * that more than ULONG_MAX non-nested readers come and go in\n\t * the meantime.  It turns out that this cannot result in overflow\n\t * because if a reader modifies its unlock count after we read it\n\t * above, then that reader's next load of ->srcu_idx is guaranteed\n\t * to get the new value, which will cause it to operate on the\n\t * other bank of counters, where it cannot contribute to the\n\t * overflow of these counters.  This means that there is a maximum\n\t * of 2*NR_CPUS increments, which cannot overflow given current\n\t * systems, especially not on 64-bit systems.\n\t *\n\t * OK, how about nesting?  This does impose a limit on nesting\n\t * of floor(ULONG_MAX/NR_CPUS/2), which should be sufficient,\n\t * especially on 64-bit systems.\n\t */\n\treturn srcu_readers_lock_idx(sp, idx) == unlocks;\n}"
  },
  {
    "function_name": "srcu_readers_unlock_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "275-286",
    "snippet": "static unsigned long srcu_readers_unlock_idx(struct srcu_struct *sp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(sp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_unlock_count[idx]);\n\t}\n\treturn sum;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cpuc->srcu_unlock_count[idx]"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sp->sda",
            "cpu"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic unsigned long srcu_readers_unlock_idx(struct srcu_struct *sp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(sp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_unlock_count[idx]);\n\t}\n\treturn sum;\n}"
  },
  {
    "function_name": "srcu_readers_lock_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "258-269",
    "snippet": "static unsigned long srcu_readers_lock_idx(struct srcu_struct *sp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(sp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[idx]);\n\t}\n\treturn sum;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cpuc->srcu_lock_count[idx]"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sp->sda",
            "cpu"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic unsigned long srcu_readers_lock_idx(struct srcu_struct *sp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(sp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[idx]);\n\t}\n\treturn sum;\n}"
  },
  {
    "function_name": "check_init_srcu_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "238-252",
    "snippet": "static void check_init_srcu_struct(struct srcu_struct *sp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (!rcu_seq_state(sp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(sp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(sp, true);\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "sp",
            "flags"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_srcu_struct_fields",
          "args": [
            "sp",
            "true"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "init_srcu_struct_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "179-196",
          "snippet": "static int init_srcu_struct_fields(struct srcu_struct *sp, bool is_static)\n{\n\tmutex_init(&sp->srcu_cb_mutex);\n\tmutex_init(&sp->srcu_gp_mutex);\n\tsp->srcu_idx = 0;\n\tsp->srcu_gp_seq = 0;\n\tsp->srcu_barrier_seq = 0;\n\tmutex_init(&sp->srcu_barrier_mutex);\n\tatomic_set(&sp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&sp->work, process_srcu);\n\tif (!is_static)\n\t\tsp->sda = alloc_percpu(struct srcu_data);\n\tinit_srcu_struct_nodes(sp, is_static);\n\tsp->srcu_gp_seq_needed_exp = 0;\n\tsp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&sp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn sp->sda ? 0 : -ENOMEM;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic int init_srcu_struct_fields(struct srcu_struct *sp, bool is_static)\n{\n\tmutex_init(&sp->srcu_cb_mutex);\n\tmutex_init(&sp->srcu_gp_mutex);\n\tsp->srcu_idx = 0;\n\tsp->srcu_gp_seq = 0;\n\tsp->srcu_barrier_seq = 0;\n\tmutex_init(&sp->srcu_barrier_mutex);\n\tatomic_set(&sp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&sp->work, process_srcu);\n\tif (!is_static)\n\t\tsp->sda = alloc_percpu(struct srcu_data);\n\tinit_srcu_struct_nodes(sp, is_static);\n\tsp->srcu_gp_seq_needed_exp = 0;\n\tsp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&sp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn sp->sda ? 0 : -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "sp",
            "flags"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "sp->srcu_gp_seq_needed"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "57-60",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_rcu_node",
          "args": [
            "sp",
            "flags"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&sp->srcu_gp_seq_needed"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *sp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (!rcu_seq_state(sp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(sp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(sp, true);\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}"
  },
  {
    "function_name": "init_srcu_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "221-225",
    "snippet": "int init_srcu_struct(struct srcu_struct *sp)\n{\n\tspin_lock_init(&ACCESS_PRIVATE(sp, lock));\n\treturn init_srcu_struct_fields(sp, false);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_srcu_struct_fields",
          "args": [
            "sp",
            "false"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "init_srcu_struct_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "179-196",
          "snippet": "static int init_srcu_struct_fields(struct srcu_struct *sp, bool is_static)\n{\n\tmutex_init(&sp->srcu_cb_mutex);\n\tmutex_init(&sp->srcu_gp_mutex);\n\tsp->srcu_idx = 0;\n\tsp->srcu_gp_seq = 0;\n\tsp->srcu_barrier_seq = 0;\n\tmutex_init(&sp->srcu_barrier_mutex);\n\tatomic_set(&sp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&sp->work, process_srcu);\n\tif (!is_static)\n\t\tsp->sda = alloc_percpu(struct srcu_data);\n\tinit_srcu_struct_nodes(sp, is_static);\n\tsp->srcu_gp_seq_needed_exp = 0;\n\tsp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&sp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn sp->sda ? 0 : -ENOMEM;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic int init_srcu_struct_fields(struct srcu_struct *sp, bool is_static)\n{\n\tmutex_init(&sp->srcu_cb_mutex);\n\tmutex_init(&sp->srcu_gp_mutex);\n\tsp->srcu_idx = 0;\n\tsp->srcu_gp_seq = 0;\n\tsp->srcu_barrier_seq = 0;\n\tmutex_init(&sp->srcu_barrier_mutex);\n\tatomic_set(&sp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&sp->work, process_srcu);\n\tif (!is_static)\n\t\tsp->sda = alloc_percpu(struct srcu_data);\n\tinit_srcu_struct_nodes(sp, is_static);\n\tsp->srcu_gp_seq_needed_exp = 0;\n\tsp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&sp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn sp->sda ? 0 : -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ACCESS_PRIVATE(sp, lock)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_PRIVATE",
          "args": [
            "sp",
            "lock"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint init_srcu_struct(struct srcu_struct *sp)\n{\n\tspin_lock_init(&ACCESS_PRIVATE(sp, lock));\n\treturn init_srcu_struct_fields(sp, false);\n}"
  },
  {
    "function_name": "__init_srcu_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "200-208",
    "snippet": "int __init_srcu_struct(struct srcu_struct *sp, const char *name,\n\t\t       struct lock_class_key *key)\n{\n\t/* Don't re-initialize a lock while it is held. */\n\tdebug_check_no_locks_freed((void *)sp, sizeof(*sp));\n\tlockdep_init_map(&sp->dep_map, name, key, 0);\n\tspin_lock_init(&ACCESS_PRIVATE(sp, lock));\n\treturn init_srcu_struct_fields(sp, false);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_srcu_struct_fields",
          "args": [
            "sp",
            "false"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "init_srcu_struct_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "179-196",
          "snippet": "static int init_srcu_struct_fields(struct srcu_struct *sp, bool is_static)\n{\n\tmutex_init(&sp->srcu_cb_mutex);\n\tmutex_init(&sp->srcu_gp_mutex);\n\tsp->srcu_idx = 0;\n\tsp->srcu_gp_seq = 0;\n\tsp->srcu_barrier_seq = 0;\n\tmutex_init(&sp->srcu_barrier_mutex);\n\tatomic_set(&sp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&sp->work, process_srcu);\n\tif (!is_static)\n\t\tsp->sda = alloc_percpu(struct srcu_data);\n\tinit_srcu_struct_nodes(sp, is_static);\n\tsp->srcu_gp_seq_needed_exp = 0;\n\tsp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&sp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn sp->sda ? 0 : -ENOMEM;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic int init_srcu_struct_fields(struct srcu_struct *sp, bool is_static)\n{\n\tmutex_init(&sp->srcu_cb_mutex);\n\tmutex_init(&sp->srcu_gp_mutex);\n\tsp->srcu_idx = 0;\n\tsp->srcu_gp_seq = 0;\n\tsp->srcu_barrier_seq = 0;\n\tmutex_init(&sp->srcu_barrier_mutex);\n\tatomic_set(&sp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&sp->work, process_srcu);\n\tif (!is_static)\n\t\tsp->sda = alloc_percpu(struct srcu_data);\n\tinit_srcu_struct_nodes(sp, is_static);\n\tsp->srcu_gp_seq_needed_exp = 0;\n\tsp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&sp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn sp->sda ? 0 : -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ACCESS_PRIVATE(sp, lock)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_PRIVATE",
          "args": [
            "sp",
            "lock"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&sp->dep_map",
            "name",
            "key",
            "0"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_init_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3148-3152",
          "snippet": "void lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "(void *)sp",
            "sizeof(*sp)"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "debug_check_no_locks_freed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4322-4344",
          "snippet": "void debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint __init_srcu_struct(struct srcu_struct *sp, const char *name,\n\t\t       struct lock_class_key *key)\n{\n\t/* Don't re-initialize a lock while it is held. */\n\tdebug_check_no_locks_freed((void *)sp, sizeof(*sp));\n\tlockdep_init_map(&sp->dep_map, name, key, 0);\n\tspin_lock_init(&ACCESS_PRIVATE(sp, lock));\n\treturn init_srcu_struct_fields(sp, false);\n}"
  },
  {
    "function_name": "init_srcu_struct_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "179-196",
    "snippet": "static int init_srcu_struct_fields(struct srcu_struct *sp, bool is_static)\n{\n\tmutex_init(&sp->srcu_cb_mutex);\n\tmutex_init(&sp->srcu_gp_mutex);\n\tsp->srcu_idx = 0;\n\tsp->srcu_gp_seq = 0;\n\tsp->srcu_barrier_seq = 0;\n\tmutex_init(&sp->srcu_barrier_mutex);\n\tatomic_set(&sp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&sp->work, process_srcu);\n\tif (!is_static)\n\t\tsp->sda = alloc_percpu(struct srcu_data);\n\tinit_srcu_struct_nodes(sp, is_static);\n\tsp->srcu_gp_seq_needed_exp = 0;\n\tsp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&sp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn sp->sda ? 0 : -ENOMEM;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&sp->srcu_gp_seq_needed",
            "0"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_mono_fast_ns",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_mono_fast_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "469-472",
          "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_srcu_struct_nodes",
          "args": [
            "sp",
            "is_static"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "init_srcu_struct_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "95-171",
          "snippet": "static void init_srcu_struct_nodes(struct srcu_struct *sp, bool is_static)\n{\n\tint cpu;\n\tint i;\n\tint level = 0;\n\tint levelspread[RCU_NUM_LVLS];\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\tstruct srcu_node *snp_first;\n\n\t/* Work out the overall tree geometry. */\n\tsp->level[0] = &sp->node[0];\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\tsp->level[i] = sp->level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Each pass through this loop initializes one srcu_node structure. */\n\tsrcu_for_each_node_breadth_first(sp, snp) {\n\t\tspin_lock_init(&ACCESS_PRIVATE(snp, lock));\n\t\tWARN_ON_ONCE(ARRAY_SIZE(snp->srcu_have_cbs) !=\n\t\t\t     ARRAY_SIZE(snp->srcu_data_have_cbs));\n\t\tfor (i = 0; i < ARRAY_SIZE(snp->srcu_have_cbs); i++) {\n\t\t\tsnp->srcu_have_cbs[i] = 0;\n\t\t\tsnp->srcu_data_have_cbs[i] = 0;\n\t\t}\n\t\tsnp->srcu_gp_seq_needed_exp = 0;\n\t\tsnp->grplo = -1;\n\t\tsnp->grphi = -1;\n\t\tif (snp == &sp->node[0]) {\n\t\t\t/* Root node, special case. */\n\t\t\tsnp->srcu_parent = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Non-root node. */\n\t\tif (snp == sp->level[level + 1])\n\t\t\tlevel++;\n\t\tsnp->srcu_parent = sp->level[level - 1] +\n\t\t\t\t   (snp - sp->level[level]) /\n\t\t\t\t   levelspread[level - 1];\n\t}\n\n\t/*\n\t * Initialize the per-CPU srcu_data array, which feeds into the\n\t * leaves of the srcu_node tree.\n\t */\n\tWARN_ON_ONCE(ARRAY_SIZE(sdp->srcu_lock_count) !=\n\t\t     ARRAY_SIZE(sdp->srcu_unlock_count));\n\tlevel = rcu_num_lvls - 1;\n\tsnp_first = sp->level[level];\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\tspin_lock_init(&ACCESS_PRIVATE(sdp, lock));\n\t\trcu_segcblist_init(&sdp->srcu_cblist);\n\t\tsdp->srcu_cblist_invoking = false;\n\t\tsdp->srcu_gp_seq_needed = sp->srcu_gp_seq;\n\t\tsdp->srcu_gp_seq_needed_exp = sp->srcu_gp_seq;\n\t\tsdp->mynode = &snp_first[cpu / levelspread[level]];\n\t\tfor (snp = sdp->mynode; snp != NULL; snp = snp->srcu_parent) {\n\t\t\tif (snp->grplo < 0)\n\t\t\t\tsnp->grplo = cpu;\n\t\t\tsnp->grphi = cpu;\n\t\t}\n\t\tsdp->cpu = cpu;\n\t\tINIT_DELAYED_WORK(&sdp->work, srcu_invoke_callbacks);\n\t\tsdp->sp = sp;\n\t\tsdp->grpmask = 1 << (cpu - sdp->mynode->grplo);\n\t\tif (is_static)\n\t\t\tcontinue;\n\n\t\t/* Dynamically allocated, better be no srcu_read_locks()! */\n\t\tfor (i = 0; i < ARRAY_SIZE(sdp->srcu_lock_count); i++) {\n\t\t\tsdp->srcu_lock_count[i] = 0;\n\t\t\tsdp->srcu_unlock_count[i] = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void init_srcu_struct_nodes(struct srcu_struct *sp, bool is_static)\n{\n\tint cpu;\n\tint i;\n\tint level = 0;\n\tint levelspread[RCU_NUM_LVLS];\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\tstruct srcu_node *snp_first;\n\n\t/* Work out the overall tree geometry. */\n\tsp->level[0] = &sp->node[0];\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\tsp->level[i] = sp->level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Each pass through this loop initializes one srcu_node structure. */\n\tsrcu_for_each_node_breadth_first(sp, snp) {\n\t\tspin_lock_init(&ACCESS_PRIVATE(snp, lock));\n\t\tWARN_ON_ONCE(ARRAY_SIZE(snp->srcu_have_cbs) !=\n\t\t\t     ARRAY_SIZE(snp->srcu_data_have_cbs));\n\t\tfor (i = 0; i < ARRAY_SIZE(snp->srcu_have_cbs); i++) {\n\t\t\tsnp->srcu_have_cbs[i] = 0;\n\t\t\tsnp->srcu_data_have_cbs[i] = 0;\n\t\t}\n\t\tsnp->srcu_gp_seq_needed_exp = 0;\n\t\tsnp->grplo = -1;\n\t\tsnp->grphi = -1;\n\t\tif (snp == &sp->node[0]) {\n\t\t\t/* Root node, special case. */\n\t\t\tsnp->srcu_parent = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Non-root node. */\n\t\tif (snp == sp->level[level + 1])\n\t\t\tlevel++;\n\t\tsnp->srcu_parent = sp->level[level - 1] +\n\t\t\t\t   (snp - sp->level[level]) /\n\t\t\t\t   levelspread[level - 1];\n\t}\n\n\t/*\n\t * Initialize the per-CPU srcu_data array, which feeds into the\n\t * leaves of the srcu_node tree.\n\t */\n\tWARN_ON_ONCE(ARRAY_SIZE(sdp->srcu_lock_count) !=\n\t\t     ARRAY_SIZE(sdp->srcu_unlock_count));\n\tlevel = rcu_num_lvls - 1;\n\tsnp_first = sp->level[level];\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\tspin_lock_init(&ACCESS_PRIVATE(sdp, lock));\n\t\trcu_segcblist_init(&sdp->srcu_cblist);\n\t\tsdp->srcu_cblist_invoking = false;\n\t\tsdp->srcu_gp_seq_needed = sp->srcu_gp_seq;\n\t\tsdp->srcu_gp_seq_needed_exp = sp->srcu_gp_seq;\n\t\tsdp->mynode = &snp_first[cpu / levelspread[level]];\n\t\tfor (snp = sdp->mynode; snp != NULL; snp = snp->srcu_parent) {\n\t\t\tif (snp->grplo < 0)\n\t\t\t\tsnp->grplo = cpu;\n\t\t\tsnp->grphi = cpu;\n\t\t}\n\t\tsdp->cpu = cpu;\n\t\tINIT_DELAYED_WORK(&sdp->work, srcu_invoke_callbacks);\n\t\tsdp->sp = sp;\n\t\tsdp->grpmask = 1 << (cpu - sdp->mynode->grplo);\n\t\tif (is_static)\n\t\t\tcontinue;\n\n\t\t/* Dynamically allocated, better be no srcu_read_locks()! */\n\t\tfor (i = 0; i < ARRAY_SIZE(sdp->srcu_lock_count); i++) {\n\t\t\tsdp->srcu_lock_count[i] = 0;\n\t\t\tsdp->srcu_unlock_count[i] = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structsrcu_data"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&sp->work",
            "process_srcu"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sp->srcu_barrier_cpu_cnt",
            "0"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sp->srcu_barrier_mutex"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1604-1612",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic int init_srcu_struct_fields(struct srcu_struct *sp, bool is_static)\n{\n\tmutex_init(&sp->srcu_cb_mutex);\n\tmutex_init(&sp->srcu_gp_mutex);\n\tsp->srcu_idx = 0;\n\tsp->srcu_gp_seq = 0;\n\tsp->srcu_barrier_seq = 0;\n\tmutex_init(&sp->srcu_barrier_mutex);\n\tatomic_set(&sp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&sp->work, process_srcu);\n\tif (!is_static)\n\t\tsp->sda = alloc_percpu(struct srcu_data);\n\tinit_srcu_struct_nodes(sp, is_static);\n\tsp->srcu_gp_seq_needed_exp = 0;\n\tsp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&sp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn sp->sda ? 0 : -ENOMEM;\n}"
  },
  {
    "function_name": "init_srcu_struct_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
    "lines": "95-171",
    "snippet": "static void init_srcu_struct_nodes(struct srcu_struct *sp, bool is_static)\n{\n\tint cpu;\n\tint i;\n\tint level = 0;\n\tint levelspread[RCU_NUM_LVLS];\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\tstruct srcu_node *snp_first;\n\n\t/* Work out the overall tree geometry. */\n\tsp->level[0] = &sp->node[0];\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\tsp->level[i] = sp->level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Each pass through this loop initializes one srcu_node structure. */\n\tsrcu_for_each_node_breadth_first(sp, snp) {\n\t\tspin_lock_init(&ACCESS_PRIVATE(snp, lock));\n\t\tWARN_ON_ONCE(ARRAY_SIZE(snp->srcu_have_cbs) !=\n\t\t\t     ARRAY_SIZE(snp->srcu_data_have_cbs));\n\t\tfor (i = 0; i < ARRAY_SIZE(snp->srcu_have_cbs); i++) {\n\t\t\tsnp->srcu_have_cbs[i] = 0;\n\t\t\tsnp->srcu_data_have_cbs[i] = 0;\n\t\t}\n\t\tsnp->srcu_gp_seq_needed_exp = 0;\n\t\tsnp->grplo = -1;\n\t\tsnp->grphi = -1;\n\t\tif (snp == &sp->node[0]) {\n\t\t\t/* Root node, special case. */\n\t\t\tsnp->srcu_parent = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Non-root node. */\n\t\tif (snp == sp->level[level + 1])\n\t\t\tlevel++;\n\t\tsnp->srcu_parent = sp->level[level - 1] +\n\t\t\t\t   (snp - sp->level[level]) /\n\t\t\t\t   levelspread[level - 1];\n\t}\n\n\t/*\n\t * Initialize the per-CPU srcu_data array, which feeds into the\n\t * leaves of the srcu_node tree.\n\t */\n\tWARN_ON_ONCE(ARRAY_SIZE(sdp->srcu_lock_count) !=\n\t\t     ARRAY_SIZE(sdp->srcu_unlock_count));\n\tlevel = rcu_num_lvls - 1;\n\tsnp_first = sp->level[level];\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\tspin_lock_init(&ACCESS_PRIVATE(sdp, lock));\n\t\trcu_segcblist_init(&sdp->srcu_cblist);\n\t\tsdp->srcu_cblist_invoking = false;\n\t\tsdp->srcu_gp_seq_needed = sp->srcu_gp_seq;\n\t\tsdp->srcu_gp_seq_needed_exp = sp->srcu_gp_seq;\n\t\tsdp->mynode = &snp_first[cpu / levelspread[level]];\n\t\tfor (snp = sdp->mynode; snp != NULL; snp = snp->srcu_parent) {\n\t\t\tif (snp->grplo < 0)\n\t\t\t\tsnp->grplo = cpu;\n\t\t\tsnp->grphi = cpu;\n\t\t}\n\t\tsdp->cpu = cpu;\n\t\tINIT_DELAYED_WORK(&sdp->work, srcu_invoke_callbacks);\n\t\tsdp->sp = sp;\n\t\tsdp->grpmask = 1 << (cpu - sdp->mynode->grplo);\n\t\tif (is_static)\n\t\t\tcontinue;\n\n\t\t/* Dynamically allocated, better be no srcu_read_locks()! */\n\t\tfor (i = 0; i < ARRAY_SIZE(sdp->srcu_lock_count); i++) {\n\t\t\tsdp->srcu_lock_count[i] = 0;\n\t\t\tsdp->srcu_unlock_count[i] = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "sdp->srcu_lock_count"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&sdp->work",
            "srcu_invoke_callbacks"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_init",
          "args": [
            "&sdp->srcu_cblist"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "63-74",
          "snippet": "void rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++)\n\t\trsclp->tails[i] = &rsclp->head;\n\trsclp->len = 0;\n\trsclp->len_lazy = 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++)\n\t\trsclp->tails[i] = &rsclp->head;\n\trsclp->len = 0;\n\trsclp->len_lazy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ACCESS_PRIVATE(sdp, lock)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_PRIVATE",
          "args": [
            "sdp",
            "lock"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sp->sda",
            "cpu"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ARRAY_SIZE(sdp->srcu_lock_count) !=\n\t\t     ARRAY_SIZE(sdp->srcu_unlock_count)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "sdp->srcu_unlock_count"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "sdp->srcu_lock_count"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "snp->srcu_have_cbs"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ARRAY_SIZE(snp->srcu_have_cbs) !=\n\t\t\t     ARRAY_SIZE(snp->srcu_data_have_cbs)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "snp->srcu_data_have_cbs"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "snp->srcu_have_cbs"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ACCESS_PRIVATE(snp, lock)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_PRIVATE",
          "args": [
            "snp",
            "lock"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_for_each_node_breadth_first",
          "args": [
            "sp",
            "snp"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_init_levelspread",
          "args": [
            "levelspread",
            "num_rcu_lvl"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_init_levelspread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "314-333",
          "snippet": "static inline void rcu_init_levelspread(int *levelspread, const int *levelcnt)\n{\n\tint i;\n\n\tif (rcu_fanout_exact) {\n\t\tlevelspread[rcu_num_lvls - 1] = rcu_fanout_leaf;\n\t\tfor (i = rcu_num_lvls - 2; i >= 0; i--)\n\t\t\tlevelspread[i] = RCU_FANOUT;\n\t} else {\n\t\tint ccur;\n\t\tint cprv;\n\n\t\tcprv = nr_cpu_ids;\n\t\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\t\tccur = levelcnt[i];\n\t\t\tlevelspread[i] = (cprv + ccur - 1) / ccur;\n\t\t\tcprv = ccur;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_init_levelspread(int *levelspread, const int *levelcnt)\n{\n\tint i;\n\n\tif (rcu_fanout_exact) {\n\t\tlevelspread[rcu_num_lvls - 1] = rcu_fanout_leaf;\n\t\tfor (i = rcu_num_lvls - 2; i >= 0; i--)\n\t\t\tlevelspread[i] = RCU_FANOUT;\n\t} else {\n\t\tint ccur;\n\t\tint cprv;\n\n\t\tcprv = nr_cpu_ids;\n\t\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\t\tccur = levelcnt[i];\n\t\t\tlevelspread[i] = (cprv + ccur - 1) / ccur;\n\t\t\tcprv = ccur;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void init_srcu_struct_nodes(struct srcu_struct *sp, bool is_static)\n{\n\tint cpu;\n\tint i;\n\tint level = 0;\n\tint levelspread[RCU_NUM_LVLS];\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\tstruct srcu_node *snp_first;\n\n\t/* Work out the overall tree geometry. */\n\tsp->level[0] = &sp->node[0];\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\tsp->level[i] = sp->level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Each pass through this loop initializes one srcu_node structure. */\n\tsrcu_for_each_node_breadth_first(sp, snp) {\n\t\tspin_lock_init(&ACCESS_PRIVATE(snp, lock));\n\t\tWARN_ON_ONCE(ARRAY_SIZE(snp->srcu_have_cbs) !=\n\t\t\t     ARRAY_SIZE(snp->srcu_data_have_cbs));\n\t\tfor (i = 0; i < ARRAY_SIZE(snp->srcu_have_cbs); i++) {\n\t\t\tsnp->srcu_have_cbs[i] = 0;\n\t\t\tsnp->srcu_data_have_cbs[i] = 0;\n\t\t}\n\t\tsnp->srcu_gp_seq_needed_exp = 0;\n\t\tsnp->grplo = -1;\n\t\tsnp->grphi = -1;\n\t\tif (snp == &sp->node[0]) {\n\t\t\t/* Root node, special case. */\n\t\t\tsnp->srcu_parent = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Non-root node. */\n\t\tif (snp == sp->level[level + 1])\n\t\t\tlevel++;\n\t\tsnp->srcu_parent = sp->level[level - 1] +\n\t\t\t\t   (snp - sp->level[level]) /\n\t\t\t\t   levelspread[level - 1];\n\t}\n\n\t/*\n\t * Initialize the per-CPU srcu_data array, which feeds into the\n\t * leaves of the srcu_node tree.\n\t */\n\tWARN_ON_ONCE(ARRAY_SIZE(sdp->srcu_lock_count) !=\n\t\t     ARRAY_SIZE(sdp->srcu_unlock_count));\n\tlevel = rcu_num_lvls - 1;\n\tsnp_first = sp->level[level];\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\tspin_lock_init(&ACCESS_PRIVATE(sdp, lock));\n\t\trcu_segcblist_init(&sdp->srcu_cblist);\n\t\tsdp->srcu_cblist_invoking = false;\n\t\tsdp->srcu_gp_seq_needed = sp->srcu_gp_seq;\n\t\tsdp->srcu_gp_seq_needed_exp = sp->srcu_gp_seq;\n\t\tsdp->mynode = &snp_first[cpu / levelspread[level]];\n\t\tfor (snp = sdp->mynode; snp != NULL; snp = snp->srcu_parent) {\n\t\t\tif (snp->grplo < 0)\n\t\t\t\tsnp->grplo = cpu;\n\t\t\tsnp->grphi = cpu;\n\t\t}\n\t\tsdp->cpu = cpu;\n\t\tINIT_DELAYED_WORK(&sdp->work, srcu_invoke_callbacks);\n\t\tsdp->sp = sp;\n\t\tsdp->grpmask = 1 << (cpu - sdp->mynode->grplo);\n\t\tif (is_static)\n\t\t\tcontinue;\n\n\t\t/* Dynamically allocated, better be no srcu_read_locks()! */\n\t\tfor (i = 0; i < ARRAY_SIZE(sdp->srcu_lock_count); i++) {\n\t\t\tsdp->srcu_lock_count[i] = 0;\n\t\t\tsdp->srcu_unlock_count[i] = 0;\n\t\t}\n\t}\n}"
  }
]