[
  {
    "function_name": "strict_iomem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1599-1606",
    "snippet": "static int __init strict_iomem(char *str)\n{\n\tif (strstr(str, \"relaxed\"))\n\t\tstrict_iomem_checks = 0;\n\tif (strstr(str, \"strict\"))\n\t\tstrict_iomem_checks = 1;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"strict\""
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"relaxed\""
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __init strict_iomem(char *str)\n{\n\tif (strstr(str, \"relaxed\"))\n\t\tstrict_iomem_checks = 0;\n\tif (strstr(str, \"strict\"))\n\t\tstrict_iomem_checks = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "resource_list_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1590-1596",
    "snippet": "void resource_list_free(struct list_head *head)\n{\n\tstruct resource_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, head, node)\n\t\tresource_list_destroy_entry(entry);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resource_list_destroy_entry",
          "args": [
            "entry"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "entry",
            "tmp",
            "head",
            "node"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nvoid resource_list_free(struct list_head *head)\n{\n\tstruct resource_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, head, node)\n\t\tresource_list_destroy_entry(entry);\n}"
  },
  {
    "function_name": "resource_list_create_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1575-1587",
    "snippet": "struct resource_entry *resource_list_create_entry(struct resource *res,\n\t\t\t\t\t\t  size_t extra_size)\n{\n\tstruct resource_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry) + extra_size, GFP_KERNEL);\n\tif (entry) {\n\t\tINIT_LIST_HEAD(&entry->node);\n\t\tentry->res = res ? res : &entry->__res;\n\t}\n\n\treturn entry;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&entry->node"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*entry) + extra_size",
            "GFP_KERNEL"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource_entry *resource_list_create_entry(struct resource *res,\n\t\t\t\t\t\t  size_t extra_size)\n{\n\tstruct resource_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry) + extra_size, GFP_KERNEL);\n\tif (entry) {\n\t\tINIT_LIST_HEAD(&entry->node);\n\t\tentry->res = res ? res : &entry->__res;\n\t}\n\n\treturn entry;\n}"
  },
  {
    "function_name": "iomem_is_exclusive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1535-1573",
    "snippet": "bool iomem_is_exclusive(u64 addr)\n{\n\tstruct resource *p = &iomem_resource;\n\tbool err = false;\n\tloff_t l;\n\tint size = PAGE_SIZE;\n\n\tif (!strict_iomem_checks)\n\t\treturn false;\n\n\taddr = addr & PAGE_MASK;\n\n\tread_lock(&resource_lock);\n\tfor (p = p->child; p ; p = r_next(NULL, p, &l)) {\n\t\t/*\n\t\t * We can probably skip the resources without\n\t\t * IORESOURCE_IO attribute?\n\t\t */\n\t\tif (p->start >= addr + size)\n\t\t\tbreak;\n\t\tif (p->end < addr)\n\t\t\tcontinue;\n\t\t/*\n\t\t * A resource is exclusive if IORESOURCE_EXCLUSIVE is set\n\t\t * or CONFIG_IO_STRICT_DEVMEM is enabled and the\n\t\t * resource is busy.\n\t\t */\n\t\tif ((p->flags & IORESOURCE_BUSY) == 0)\n\t\t\tcontinue;\n\t\tif (IS_ENABLED(CONFIG_IO_STRICT_DEVMEM)\n\t\t\t\t|| p->flags & IORESOURCE_EXCLUSIVE) {\n\t\t\terr = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn err;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IO_STRICT_DEVMEM"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_next",
          "args": [
            "NULL",
            "p",
            "&l"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "r_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "76-81",
          "snippet": "static void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p, false);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nbool iomem_is_exclusive(u64 addr)\n{\n\tstruct resource *p = &iomem_resource;\n\tbool err = false;\n\tloff_t l;\n\tint size = PAGE_SIZE;\n\n\tif (!strict_iomem_checks)\n\t\treturn false;\n\n\taddr = addr & PAGE_MASK;\n\n\tread_lock(&resource_lock);\n\tfor (p = p->child; p ; p = r_next(NULL, p, &l)) {\n\t\t/*\n\t\t * We can probably skip the resources without\n\t\t * IORESOURCE_IO attribute?\n\t\t */\n\t\tif (p->start >= addr + size)\n\t\t\tbreak;\n\t\tif (p->end < addr)\n\t\t\tcontinue;\n\t\t/*\n\t\t * A resource is exclusive if IORESOURCE_EXCLUSIVE is set\n\t\t * or CONFIG_IO_STRICT_DEVMEM is enabled and the\n\t\t * resource is busy.\n\t\t */\n\t\tif ((p->flags & IORESOURCE_BUSY) == 0)\n\t\t\tcontinue;\n\t\tif (IS_ENABLED(CONFIG_IO_STRICT_DEVMEM)\n\t\t\t\t|| p->flags & IORESOURCE_EXCLUSIVE) {\n\t\t\terr = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "iomem_map_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1485-1523",
    "snippet": "int iomem_map_sanity_check(resource_size_t addr, unsigned long size)\n{\n\tstruct resource *p = &iomem_resource;\n\tint err = 0;\n\tloff_t l;\n\n\tread_lock(&resource_lock);\n\tfor (p = p->child; p ; p = r_next(NULL, p, &l)) {\n\t\t/*\n\t\t * We can probably skip the resources without\n\t\t * IORESOURCE_IO attribute?\n\t\t */\n\t\tif (p->start >= addr + size)\n\t\t\tcontinue;\n\t\tif (p->end < addr)\n\t\t\tcontinue;\n\t\tif (PFN_DOWN(p->start) <= PFN_DOWN(addr) &&\n\t\t    PFN_DOWN(p->end) >= PFN_DOWN(addr + size - 1))\n\t\t\tcontinue;\n\t\t/*\n\t\t * if a resource is \"BUSY\", it's not a hardware resource\n\t\t * but a driver mapping of such a resource; we don't want\n\t\t * to warn for those; some drivers legitimately map only\n\t\t * partial hardware resources. (example: vesafb)\n\t\t */\n\t\tif (p->flags & IORESOURCE_BUSY)\n\t\t\tcontinue;\n\n\t\tprintk(KERN_WARNING \"resource sanity check: requesting [mem %#010llx-%#010llx], which spans more than %s %pR\\n\",\n\t\t       (unsigned long long)addr,\n\t\t       (unsigned long long)(addr + size - 1),\n\t\t       p->name, p);\n\t\terr = -1;\n\t\tbreak;\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn err;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"resource sanity check: requesting [mem %#010llx-%#010llx], which spans more than %s %pR\\n\"",
            "(unsigned long long)addr",
            "(unsigned long long)(addr + size - 1)",
            "p->name",
            "p"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "addr + size - 1"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "p->end"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "addr"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "p->start"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_next",
          "args": [
            "NULL",
            "p",
            "&l"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "r_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "76-81",
          "snippet": "static void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p, false);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nint iomem_map_sanity_check(resource_size_t addr, unsigned long size)\n{\n\tstruct resource *p = &iomem_resource;\n\tint err = 0;\n\tloff_t l;\n\n\tread_lock(&resource_lock);\n\tfor (p = p->child; p ; p = r_next(NULL, p, &l)) {\n\t\t/*\n\t\t * We can probably skip the resources without\n\t\t * IORESOURCE_IO attribute?\n\t\t */\n\t\tif (p->start >= addr + size)\n\t\t\tcontinue;\n\t\tif (p->end < addr)\n\t\t\tcontinue;\n\t\tif (PFN_DOWN(p->start) <= PFN_DOWN(addr) &&\n\t\t    PFN_DOWN(p->end) >= PFN_DOWN(addr + size - 1))\n\t\t\tcontinue;\n\t\t/*\n\t\t * if a resource is \"BUSY\", it's not a hardware resource\n\t\t * but a driver mapping of such a resource; we don't want\n\t\t * to warn for those; some drivers legitimately map only\n\t\t * partial hardware resources. (example: vesafb)\n\t\t */\n\t\tif (p->flags & IORESOURCE_BUSY)\n\t\t\tcontinue;\n\n\t\tprintk(KERN_WARNING \"resource sanity check: requesting [mem %#010llx-%#010llx], which spans more than %s %pR\\n\",\n\t\t       (unsigned long long)addr,\n\t\t       (unsigned long long)(addr + size - 1),\n\t\t       p->name, p);\n\t\terr = -1;\n\t\tbreak;\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "reserve_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1439-1478",
    "snippet": "static int __init reserve_setup(char *str)\n{\n\tstatic int reserved;\n\tstatic struct resource reserve[MAXRESERVE];\n\n\tfor (;;) {\n\t\tunsigned int io_start, io_num;\n\t\tint x = reserved;\n\t\tstruct resource *parent;\n\n\t\tif (get_option(&str, &io_start) != 2)\n\t\t\tbreak;\n\t\tif (get_option(&str, &io_num) == 0)\n\t\t\tbreak;\n\t\tif (x < MAXRESERVE) {\n\t\t\tstruct resource *res = reserve + x;\n\n\t\t\t/*\n\t\t\t * If the region starts below 0x10000, we assume it's\n\t\t\t * I/O port space; otherwise assume it's memory.\n\t\t\t */\n\t\t\tif (io_start < 0x10000) {\n\t\t\t\tres->flags = IORESOURCE_IO;\n\t\t\t\tparent = &ioport_resource;\n\t\t\t} else {\n\t\t\t\tres->flags = IORESOURCE_MEM;\n\t\t\t\tparent = &iomem_resource;\n\t\t\t}\n\t\t\tres->name = \"reserved\";\n\t\t\tres->start = io_start;\n\t\t\tres->end = io_start + io_num - 1;\n\t\t\tres->flags |= IORESOURCE_BUSY;\n\t\t\tres->desc = IORES_DESC_NONE;\n\t\t\tres->child = NULL;\n\t\t\tif (request_resource(parent, res) == 0)\n\t\t\t\treserved = x+1;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define MAXRESERVE 4"
    ],
    "globals_used": [
      "struct resource ioport_resource = {\n\t.name\t= \"PCI IO\",\n\t.start\t= 0,\n\t.end\t= IO_SPACE_LIMIT,\n\t.flags\t= IORESOURCE_IO,\n};",
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "request_resource",
          "args": [
            "parent",
            "res"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "request_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "295-301",
          "snippet": "int request_resource(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\tconflict = request_resource_conflict(root, new);\n\treturn conflict ? -EBUSY : 0;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint request_resource(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\tconflict = request_resource_conflict(root, new);\n\treturn conflict ? -EBUSY : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&io_num"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&io_start"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\n#define MAXRESERVE 4\n\nstruct resource ioport_resource = {\n\t.name\t= \"PCI IO\",\n\t.start\t= 0,\n\t.end\t= IO_SPACE_LIMIT,\n\t.flags\t= IORESOURCE_IO,\n};\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\n\nstatic int __init reserve_setup(char *str)\n{\n\tstatic int reserved;\n\tstatic struct resource reserve[MAXRESERVE];\n\n\tfor (;;) {\n\t\tunsigned int io_start, io_num;\n\t\tint x = reserved;\n\t\tstruct resource *parent;\n\n\t\tif (get_option(&str, &io_start) != 2)\n\t\t\tbreak;\n\t\tif (get_option(&str, &io_num) == 0)\n\t\t\tbreak;\n\t\tif (x < MAXRESERVE) {\n\t\t\tstruct resource *res = reserve + x;\n\n\t\t\t/*\n\t\t\t * If the region starts below 0x10000, we assume it's\n\t\t\t * I/O port space; otherwise assume it's memory.\n\t\t\t */\n\t\t\tif (io_start < 0x10000) {\n\t\t\t\tres->flags = IORESOURCE_IO;\n\t\t\t\tparent = &ioport_resource;\n\t\t\t} else {\n\t\t\t\tres->flags = IORESOURCE_MEM;\n\t\t\t\tparent = &iomem_resource;\n\t\t\t}\n\t\t\tres->name = \"reserved\";\n\t\t\tres->start = io_start;\n\t\t\tres->end = io_start + io_num - 1;\n\t\t\tres->flags |= IORESOURCE_BUSY;\n\t\t\tres->desc = IORES_DESC_NONE;\n\t\t\tres->child = NULL;\n\t\t\tif (request_resource(parent, res) == 0)\n\t\t\t\treserved = x+1;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "__devm_release_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1424-1432",
    "snippet": "void __devm_release_region(struct device *dev, struct resource *parent,\n\t\t\t   resource_size_t start, resource_size_t n)\n{\n\tstruct region_devres match_data = { parent, start, n };\n\n\t__release_region(parent, start, n);\n\tWARN_ON(devres_destroy(dev, devm_region_release, devm_region_match,\n\t\t\t       &match_data));\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "devres_destroy(dev, devm_region_release, devm_region_match,\n\t\t\t       &match_data)"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_destroy",
          "args": [
            "dev",
            "devm_region_release",
            "devm_region_match",
            "&match_data"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__release_region",
          "args": [
            "parent",
            "start",
            "n"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "__release_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "1159-1197",
          "snippet": "void __release_region(struct resource *parent, resource_size_t start,\n\t\t      resource_size_t n)\n{\n\tstruct resource **p;\n\tresource_size_t end;\n\n\tp = &parent->child;\n\tend = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *res = *p;\n\n\t\tif (!res)\n\t\t\tbreak;\n\t\tif (res->start <= start && res->end >= end) {\n\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\t\tp = &res->child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res->start != start || res->end != end)\n\t\t\t\tbreak;\n\t\t\t*p = res->sibling;\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tif (res->flags & IORESOURCE_MUXED)\n\t\t\t\twake_up(&muxed_resource_wait);\n\t\t\tfree_resource(res);\n\t\t\treturn;\n\t\t}\n\t\tp = &res->sibling;\n\t}\n\n\twrite_unlock(&resource_lock);\n\n\tprintk(KERN_WARNING \"Trying to free nonexistent resource \"\n\t\t\"<%016llx-%016llx>\\n\", (unsigned long long)start,\n\t\t(unsigned long long)end);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);\n\nvoid __release_region(struct resource *parent, resource_size_t start,\n\t\t      resource_size_t n)\n{\n\tstruct resource **p;\n\tresource_size_t end;\n\n\tp = &parent->child;\n\tend = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *res = *p;\n\n\t\tif (!res)\n\t\t\tbreak;\n\t\tif (res->start <= start && res->end >= end) {\n\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\t\tp = &res->child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res->start != start || res->end != end)\n\t\t\t\tbreak;\n\t\t\t*p = res->sibling;\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tif (res->flags & IORESOURCE_MUXED)\n\t\t\t\twake_up(&muxed_resource_wait);\n\t\t\tfree_resource(res);\n\t\t\treturn;\n\t\t}\n\t\tp = &res->sibling;\n\t}\n\n\twrite_unlock(&resource_lock);\n\n\tprintk(KERN_WARNING \"Trying to free nonexistent resource \"\n\t\t\"<%016llx-%016llx>\\n\", (unsigned long long)start,\n\t\t(unsigned long long)end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nvoid __devm_release_region(struct device *dev, struct resource *parent,\n\t\t\t   resource_size_t start, resource_size_t n)\n{\n\tstruct region_devres match_data = { parent, start, n };\n\n\t__release_region(parent, start, n);\n\tWARN_ON(devres_destroy(dev, devm_region_release, devm_region_match,\n\t\t\t       &match_data));\n}"
  },
  {
    "function_name": "__devm_request_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1398-1421",
    "snippet": "struct resource *\n__devm_request_region(struct device *dev, struct resource *parent,\n\t\t      resource_size_t start, resource_size_t n, const char *name)\n{\n\tstruct region_devres *dr = NULL;\n\tstruct resource *res;\n\n\tdr = devres_alloc(devm_region_release, sizeof(struct region_devres),\n\t\t\t  GFP_KERNEL);\n\tif (!dr)\n\t\treturn NULL;\n\n\tdr->parent = parent;\n\tdr->start = start;\n\tdr->n = n;\n\n\tres = __request_region(parent, start, n, name, 0);\n\tif (res)\n\t\tdevres_add(dev, dr);\n\telse\n\t\tdevres_free(dr);\n\n\treturn res;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "dr"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "dr"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__request_region",
          "args": [
            "parent",
            "start",
            "n",
            "name",
            "0"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "__request_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "1100-1148",
          "snippet": "struct resource * __request_region(struct resource *parent,\n\t\t\t\t   resource_size_t start, resource_size_t n,\n\t\t\t\t   const char *name, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct resource *res = alloc_resource(GFP_KERNEL);\n\n\tif (!res)\n\t\treturn NULL;\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tres->flags = resource_type(parent) | resource_ext_type(parent);\n\t\tres->flags |= IORESOURCE_BUSY | flags;\n\t\tres->desc = parent->desc;\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\tif (conflict != parent) {\n\t\t\tif (!(conflict->flags & IORESOURCE_BUSY)) {\n\t\t\t\tparent = conflict;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (conflict->flags & flags & IORESOURCE_MUXED) {\n\t\t\tadd_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_lock(&resource_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Uhhuh, that didn't work out.. */\n\t\tfree_resource(res);\n\t\tres = NULL;\n\t\tbreak;\n\t}\n\twrite_unlock(&resource_lock);\n\treturn res;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);\n\nstruct resource * __request_region(struct resource *parent,\n\t\t\t\t   resource_size_t start, resource_size_t n,\n\t\t\t\t   const char *name, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct resource *res = alloc_resource(GFP_KERNEL);\n\n\tif (!res)\n\t\treturn NULL;\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tres->flags = resource_type(parent) | resource_ext_type(parent);\n\t\tres->flags |= IORESOURCE_BUSY | flags;\n\t\tres->desc = parent->desc;\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\tif (conflict != parent) {\n\t\t\tif (!(conflict->flags & IORESOURCE_BUSY)) {\n\t\t\t\tparent = conflict;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (conflict->flags & flags & IORESOURCE_MUXED) {\n\t\t\tadd_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_lock(&resource_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Uhhuh, that didn't work out.. */\n\t\tfree_resource(res);\n\t\tres = NULL;\n\t\tbreak;\n\t}\n\twrite_unlock(&resource_lock);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "devm_region_release",
            "sizeof(struct region_devres)",
            "GFP_KERNEL"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource *\n__devm_request_region(struct device *dev, struct resource *parent,\n\t\t      resource_size_t start, resource_size_t n, const char *name)\n{\n\tstruct region_devres *dr = NULL;\n\tstruct resource *res;\n\n\tdr = devres_alloc(devm_region_release, sizeof(struct region_devres),\n\t\t\t  GFP_KERNEL);\n\tif (!dr)\n\t\treturn NULL;\n\n\tdr->parent = parent;\n\tdr->start = start;\n\tdr->n = n;\n\n\tres = __request_region(parent, start, n, name, 0);\n\tif (res)\n\t\tdevres_add(dev, dr);\n\telse\n\t\tdevres_free(dr);\n\n\treturn res;\n}"
  },
  {
    "function_name": "devm_region_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1390-1396",
    "snippet": "static int devm_region_match(struct device *dev, void *res, void *match_data)\n{\n\tstruct region_devres *this = res, *match = match_data;\n\n\treturn this->parent == match->parent &&\n\t\tthis->start == match->start && this->n == match->n;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int devm_region_match(struct device *dev, void *res, void *match_data)\n{\n\tstruct region_devres *this = res, *match = match_data;\n\n\treturn this->parent == match->parent &&\n\t\tthis->start == match->start && this->n == match->n;\n}"
  },
  {
    "function_name": "devm_region_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1383-1388",
    "snippet": "static void devm_region_release(struct device *dev, void *res)\n{\n\tstruct region_devres *this = res;\n\n\t__release_region(this->parent, this->start, this->n);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__release_region",
          "args": [
            "this->parent",
            "this->start",
            "this->n"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "__release_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "1159-1197",
          "snippet": "void __release_region(struct resource *parent, resource_size_t start,\n\t\t      resource_size_t n)\n{\n\tstruct resource **p;\n\tresource_size_t end;\n\n\tp = &parent->child;\n\tend = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *res = *p;\n\n\t\tif (!res)\n\t\t\tbreak;\n\t\tif (res->start <= start && res->end >= end) {\n\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\t\tp = &res->child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res->start != start || res->end != end)\n\t\t\t\tbreak;\n\t\t\t*p = res->sibling;\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tif (res->flags & IORESOURCE_MUXED)\n\t\t\t\twake_up(&muxed_resource_wait);\n\t\t\tfree_resource(res);\n\t\t\treturn;\n\t\t}\n\t\tp = &res->sibling;\n\t}\n\n\twrite_unlock(&resource_lock);\n\n\tprintk(KERN_WARNING \"Trying to free nonexistent resource \"\n\t\t\"<%016llx-%016llx>\\n\", (unsigned long long)start,\n\t\t(unsigned long long)end);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);\n\nvoid __release_region(struct resource *parent, resource_size_t start,\n\t\t      resource_size_t n)\n{\n\tstruct resource **p;\n\tresource_size_t end;\n\n\tp = &parent->child;\n\tend = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *res = *p;\n\n\t\tif (!res)\n\t\t\tbreak;\n\t\tif (res->start <= start && res->end >= end) {\n\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\t\tp = &res->child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res->start != start || res->end != end)\n\t\t\t\tbreak;\n\t\t\t*p = res->sibling;\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tif (res->flags & IORESOURCE_MUXED)\n\t\t\t\twake_up(&muxed_resource_wait);\n\t\t\tfree_resource(res);\n\t\t\treturn;\n\t\t}\n\t\tp = &res->sibling;\n\t}\n\n\twrite_unlock(&resource_lock);\n\n\tprintk(KERN_WARNING \"Trying to free nonexistent resource \"\n\t\t\"<%016llx-%016llx>\\n\", (unsigned long long)start,\n\t\t(unsigned long long)end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void devm_region_release(struct device *dev, void *res)\n{\n\tstruct region_devres *this = res;\n\n\t__release_region(this->parent, this->start, this->n);\n}"
  },
  {
    "function_name": "devm_release_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1370-1374",
    "snippet": "void devm_release_resource(struct device *dev, struct resource *new)\n{\n\tWARN_ON(devres_release(dev, devm_resource_release, devm_resource_match,\n\t\t\t       new));\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "devres_release(dev, devm_resource_release, devm_resource_match,\n\t\t\t       new)"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_release",
          "args": [
            "dev",
            "devm_resource_release",
            "devm_resource_match",
            "new"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nvoid devm_release_resource(struct device *dev, struct resource *new)\n{\n\tWARN_ON(devres_release(dev, devm_resource_release, devm_resource_match,\n\t\t\t       new));\n}"
  },
  {
    "function_name": "devm_resource_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1356-1361",
    "snippet": "static int devm_resource_match(struct device *dev, void *res, void *data)\n{\n\tstruct resource **ptr = res;\n\n\treturn *ptr == data;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int devm_resource_match(struct device *dev, void *res, void *data)\n{\n\tstruct resource **ptr = res;\n\n\treturn *ptr == data;\n}"
  },
  {
    "function_name": "devm_request_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1332-1353",
    "snippet": "int devm_request_resource(struct device *dev, struct resource *root,\n\t\t\t  struct resource *new)\n{\n\tstruct resource *conflict, **ptr;\n\n\tptr = devres_alloc(devm_resource_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\t*ptr = new;\n\n\tconflict = request_resource_conflict(root, new);\n\tif (conflict) {\n\t\tdev_err(dev, \"resource collision: %pR conflicts with %s %pR\\n\",\n\t\t\tnew, conflict->name, conflict);\n\t\tdevres_free(ptr);\n\t\treturn -EBUSY;\n\t}\n\n\tdevres_add(dev, ptr);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "ptr"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "ptr"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"resource collision: %pR conflicts with %s %pR\\n\"",
            "new",
            "conflict->name",
            "conflict"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_resource_conflict",
          "args": [
            "root",
            "new"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "request_resource_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "278-286",
          "snippet": "struct resource *request_resource_conflict(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __request_resource(root, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstruct resource *request_resource_conflict(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __request_resource(root, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}"
        }
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "devm_resource_release",
            "sizeof(*ptr)",
            "GFP_KERNEL"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint devm_request_resource(struct device *dev, struct resource *root,\n\t\t\t  struct resource *new)\n{\n\tstruct resource *conflict, **ptr;\n\n\tptr = devres_alloc(devm_resource_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\t*ptr = new;\n\n\tconflict = request_resource_conflict(root, new);\n\tif (conflict) {\n\t\tdev_err(dev, \"resource collision: %pR conflicts with %s %pR\\n\",\n\t\t\tnew, conflict->name, conflict);\n\t\tdevres_free(ptr);\n\t\treturn -EBUSY;\n\t}\n\n\tdevres_add(dev, ptr);\n\treturn 0;\n}"
  },
  {
    "function_name": "devm_resource_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1307-1312",
    "snippet": "static void devm_resource_release(struct device *dev, void *ptr)\n{\n\tstruct resource **r = ptr;\n\n\trelease_resource(*r);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_resource",
          "args": [
            "*r"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "release_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "309-317",
          "snippet": "int release_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, true);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nint release_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, true);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void devm_resource_release(struct device *dev, void *ptr)\n{\n\tstruct resource **r = ptr;\n\n\trelease_resource(*r);\n}"
  },
  {
    "function_name": "release_mem_region_adjustable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1221-1301",
    "snippet": "int release_mem_region_adjustable(struct resource *parent,\n\t\t\t\t  resource_size_t start, resource_size_t size)\n{\n\tstruct resource **p;\n\tstruct resource *res;\n\tstruct resource *new_res;\n\tresource_size_t end;\n\tint ret = -EINVAL;\n\n\tend = start + size - 1;\n\tif ((start < parent->start) || (end > parent->end))\n\t\treturn ret;\n\n\t/* The alloc_resource() result gets checked later */\n\tnew_res = alloc_resource(GFP_KERNEL);\n\n\tp = &parent->child;\n\twrite_lock(&resource_lock);\n\n\twhile ((res = *p)) {\n\t\tif (res->start >= end)\n\t\t\tbreak;\n\n\t\t/* look for the next resource if it does not fit into */\n\t\tif (res->start > start || res->end < end) {\n\t\t\tp = &res->sibling;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(res->flags & IORESOURCE_MEM))\n\t\t\tbreak;\n\n\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\tp = &res->child;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* found the target resource; let's adjust accordingly */\n\t\tif (res->start == start && res->end == end) {\n\t\t\t/* free the whole entry */\n\t\t\t*p = res->sibling;\n\t\t\tfree_resource(res);\n\t\t\tret = 0;\n\t\t} else if (res->start == start && res->end != end) {\n\t\t\t/* adjust the start */\n\t\t\tret = __adjust_resource(res, end + 1,\n\t\t\t\t\t\tres->end - end);\n\t\t} else if (res->start != start && res->end == end) {\n\t\t\t/* adjust the end */\n\t\t\tret = __adjust_resource(res, res->start,\n\t\t\t\t\t\tstart - res->start);\n\t\t} else {\n\t\t\t/* split into two entries */\n\t\t\tif (!new_res) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnew_res->name = res->name;\n\t\t\tnew_res->start = end + 1;\n\t\t\tnew_res->end = res->end;\n\t\t\tnew_res->flags = res->flags;\n\t\t\tnew_res->desc = res->desc;\n\t\t\tnew_res->parent = res->parent;\n\t\t\tnew_res->sibling = res->sibling;\n\t\t\tnew_res->child = NULL;\n\n\t\t\tret = __adjust_resource(res, res->start,\n\t\t\t\t\t\tstart - res->start);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tres->sibling = new_res;\n\t\t\tnew_res = NULL;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\twrite_unlock(&resource_lock);\n\tfree_resource(new_res);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_resource",
          "args": [
            "new_res"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "free_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "149-162",
          "snippet": "static void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__adjust_resource",
          "args": [
            "res",
            "res->start",
            "start - res->start"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "__adjust_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "912-947",
          "snippet": "static int __adjust_resource(struct resource *res, resource_size_t start,\n\t\t\t\tresource_size_t size)\n{\n\tstruct resource *tmp, *parent = res->parent;\n\tresource_size_t end = start + size - 1;\n\tint result = -EBUSY;\n\n\tif (!parent)\n\t\tgoto skip;\n\n\tif ((start < parent->start) || (end > parent->end))\n\t\tgoto out;\n\n\tif (res->sibling && (res->sibling->start <= end))\n\t\tgoto out;\n\n\ttmp = parent->child;\n\tif (tmp != res) {\n\t\twhile (tmp->sibling != res)\n\t\t\ttmp = tmp->sibling;\n\t\tif (start <= tmp->end)\n\t\t\tgoto out;\n\t}\n\nskip:\n\tfor (tmp = res->child; tmp; tmp = tmp->sibling)\n\t\tif ((tmp->start < start) || (tmp->end > end))\n\t\t\tgoto out;\n\n\tres->start = start;\n\tres->end = end;\n\tresult = 0;\n\n out:\n\treturn result;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __adjust_resource(struct resource *res, resource_size_t start,\n\t\t\t\tresource_size_t size)\n{\n\tstruct resource *tmp, *parent = res->parent;\n\tresource_size_t end = start + size - 1;\n\tint result = -EBUSY;\n\n\tif (!parent)\n\t\tgoto skip;\n\n\tif ((start < parent->start) || (end > parent->end))\n\t\tgoto out;\n\n\tif (res->sibling && (res->sibling->start <= end))\n\t\tgoto out;\n\n\ttmp = parent->child;\n\tif (tmp != res) {\n\t\twhile (tmp->sibling != res)\n\t\t\ttmp = tmp->sibling;\n\t\tif (start <= tmp->end)\n\t\t\tgoto out;\n\t}\n\nskip:\n\tfor (tmp = res->child; tmp; tmp = tmp->sibling)\n\t\tif ((tmp->start < start) || (tmp->end > end))\n\t\t\tgoto out;\n\n\tres->start = start;\n\tres->end = end;\n\tresult = 0;\n\n out:\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_resource",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "164-181",
          "snippet": "static struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nint release_mem_region_adjustable(struct resource *parent,\n\t\t\t\t  resource_size_t start, resource_size_t size)\n{\n\tstruct resource **p;\n\tstruct resource *res;\n\tstruct resource *new_res;\n\tresource_size_t end;\n\tint ret = -EINVAL;\n\n\tend = start + size - 1;\n\tif ((start < parent->start) || (end > parent->end))\n\t\treturn ret;\n\n\t/* The alloc_resource() result gets checked later */\n\tnew_res = alloc_resource(GFP_KERNEL);\n\n\tp = &parent->child;\n\twrite_lock(&resource_lock);\n\n\twhile ((res = *p)) {\n\t\tif (res->start >= end)\n\t\t\tbreak;\n\n\t\t/* look for the next resource if it does not fit into */\n\t\tif (res->start > start || res->end < end) {\n\t\t\tp = &res->sibling;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(res->flags & IORESOURCE_MEM))\n\t\t\tbreak;\n\n\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\tp = &res->child;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* found the target resource; let's adjust accordingly */\n\t\tif (res->start == start && res->end == end) {\n\t\t\t/* free the whole entry */\n\t\t\t*p = res->sibling;\n\t\t\tfree_resource(res);\n\t\t\tret = 0;\n\t\t} else if (res->start == start && res->end != end) {\n\t\t\t/* adjust the start */\n\t\t\tret = __adjust_resource(res, end + 1,\n\t\t\t\t\t\tres->end - end);\n\t\t} else if (res->start != start && res->end == end) {\n\t\t\t/* adjust the end */\n\t\t\tret = __adjust_resource(res, res->start,\n\t\t\t\t\t\tstart - res->start);\n\t\t} else {\n\t\t\t/* split into two entries */\n\t\t\tif (!new_res) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnew_res->name = res->name;\n\t\t\tnew_res->start = end + 1;\n\t\t\tnew_res->end = res->end;\n\t\t\tnew_res->flags = res->flags;\n\t\t\tnew_res->desc = res->desc;\n\t\t\tnew_res->parent = res->parent;\n\t\t\tnew_res->sibling = res->sibling;\n\t\t\tnew_res->child = NULL;\n\n\t\t\tret = __adjust_resource(res, res->start,\n\t\t\t\t\t\tstart - res->start);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tres->sibling = new_res;\n\t\t\tnew_res = NULL;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\twrite_unlock(&resource_lock);\n\tfree_resource(new_res);\n\treturn ret;\n}"
  },
  {
    "function_name": "__release_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1159-1197",
    "snippet": "void __release_region(struct resource *parent, resource_size_t start,\n\t\t      resource_size_t n)\n{\n\tstruct resource **p;\n\tresource_size_t end;\n\n\tp = &parent->child;\n\tend = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *res = *p;\n\n\t\tif (!res)\n\t\t\tbreak;\n\t\tif (res->start <= start && res->end >= end) {\n\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\t\tp = &res->child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res->start != start || res->end != end)\n\t\t\t\tbreak;\n\t\t\t*p = res->sibling;\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tif (res->flags & IORESOURCE_MUXED)\n\t\t\t\twake_up(&muxed_resource_wait);\n\t\t\tfree_resource(res);\n\t\t\treturn;\n\t\t}\n\t\tp = &res->sibling;\n\t}\n\n\twrite_unlock(&resource_lock);\n\n\tprintk(KERN_WARNING \"Trying to free nonexistent resource \"\n\t\t\"<%016llx-%016llx>\\n\", (unsigned long long)start,\n\t\t(unsigned long long)end);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);",
      "static DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Trying to free nonexistent resource \"\n\t\t\"<%016llx-%016llx>\\n\"",
            "(unsigned long long)start",
            "(unsigned long long)end"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_resource",
          "args": [
            "res"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "free_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "149-162",
          "snippet": "static void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&muxed_resource_wait"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);\n\nvoid __release_region(struct resource *parent, resource_size_t start,\n\t\t      resource_size_t n)\n{\n\tstruct resource **p;\n\tresource_size_t end;\n\n\tp = &parent->child;\n\tend = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *res = *p;\n\n\t\tif (!res)\n\t\t\tbreak;\n\t\tif (res->start <= start && res->end >= end) {\n\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\t\tp = &res->child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res->start != start || res->end != end)\n\t\t\t\tbreak;\n\t\t\t*p = res->sibling;\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tif (res->flags & IORESOURCE_MUXED)\n\t\t\t\twake_up(&muxed_resource_wait);\n\t\t\tfree_resource(res);\n\t\t\treturn;\n\t\t}\n\t\tp = &res->sibling;\n\t}\n\n\twrite_unlock(&resource_lock);\n\n\tprintk(KERN_WARNING \"Trying to free nonexistent resource \"\n\t\t\"<%016llx-%016llx>\\n\", (unsigned long long)start,\n\t\t(unsigned long long)end);\n}"
  },
  {
    "function_name": "__request_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1100-1148",
    "snippet": "struct resource * __request_region(struct resource *parent,\n\t\t\t\t   resource_size_t start, resource_size_t n,\n\t\t\t\t   const char *name, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct resource *res = alloc_resource(GFP_KERNEL);\n\n\tif (!res)\n\t\treturn NULL;\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tres->flags = resource_type(parent) | resource_ext_type(parent);\n\t\tres->flags |= IORESOURCE_BUSY | flags;\n\t\tres->desc = parent->desc;\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\tif (conflict != parent) {\n\t\t\tif (!(conflict->flags & IORESOURCE_BUSY)) {\n\t\t\t\tparent = conflict;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (conflict->flags & flags & IORESOURCE_MUXED) {\n\t\t\tadd_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_lock(&resource_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Uhhuh, that didn't work out.. */\n\t\tfree_resource(res);\n\t\tres = NULL;\n\t\tbreak;\n\t}\n\twrite_unlock(&resource_lock);\n\treturn res;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);",
      "static DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_resource",
          "args": [
            "res"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "free_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "149-162",
          "snippet": "static void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&muxed_resource_wait",
            "&wait"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "remove_wait_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "39-46",
          "snippet": "void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&muxed_resource_wait",
            "&wait"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "add_wait_queue_exclusive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "28-36",
          "snippet": "void add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__request_resource",
          "args": [
            "parent",
            "res"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "__request_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "184-210",
          "snippet": "static struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "resource_ext_type",
          "args": [
            "parent"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resource_type",
          "args": [
            "parent"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_resource",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "164-181",
          "snippet": "static struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);\n\nstruct resource * __request_region(struct resource *parent,\n\t\t\t\t   resource_size_t start, resource_size_t n,\n\t\t\t\t   const char *name, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct resource *res = alloc_resource(GFP_KERNEL);\n\n\tif (!res)\n\t\treturn NULL;\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tres->flags = resource_type(parent) | resource_ext_type(parent);\n\t\tres->flags |= IORESOURCE_BUSY | flags;\n\t\tres->desc = parent->desc;\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\tif (conflict != parent) {\n\t\t\tif (!(conflict->flags & IORESOURCE_BUSY)) {\n\t\t\t\tparent = conflict;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (conflict->flags & flags & IORESOURCE_MUXED) {\n\t\t\tadd_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_lock(&resource_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Uhhuh, that didn't work out.. */\n\t\tfree_resource(res);\n\t\tres = NULL;\n\t\tbreak;\n\t}\n\twrite_unlock(&resource_lock);\n\treturn res;\n}"
  },
  {
    "function_name": "resource_alignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1067-1077",
    "snippet": "resource_size_t resource_alignment(struct resource *res)\n{\n\tswitch (res->flags & (IORESOURCE_SIZEALIGN | IORESOURCE_STARTALIGN)) {\n\tcase IORESOURCE_SIZEALIGN:\n\t\treturn resource_size(res);\n\tcase IORESOURCE_STARTALIGN:\n\t\treturn res->start;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "res"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nresource_size_t resource_alignment(struct resource *res)\n{\n\tswitch (res->flags & (IORESOURCE_SIZEALIGN | IORESOURCE_STARTALIGN)) {\n\tcase IORESOURCE_SIZEALIGN:\n\t\treturn resource_size(res);\n\tcase IORESOURCE_STARTALIGN:\n\t\treturn res->start;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "reserve_region_with_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "1032-1059",
    "snippet": "void __init\nreserve_region_with_split(struct resource *root, resource_size_t start,\n\t\t\t  resource_size_t end, const char *name)\n{\n\tint abort = 0;\n\n\twrite_lock(&resource_lock);\n\tif (root->start > start || root->end < end) {\n\t\tpr_err(\"requested range [0x%llx-0x%llx] not in root %pr\\n\",\n\t\t       (unsigned long long)start, (unsigned long long)end,\n\t\t       root);\n\t\tif (start > root->end || end < root->start)\n\t\t\tabort = 1;\n\t\telse {\n\t\t\tif (end > root->end)\n\t\t\t\tend = root->end;\n\t\t\tif (start < root->start)\n\t\t\t\tstart = root->start;\n\t\t\tpr_err(\"fixing request to [0x%llx-0x%llx]\\n\",\n\t\t\t       (unsigned long long)start,\n\t\t\t       (unsigned long long)end);\n\t\t}\n\t\tdump_stack();\n\t}\n\tif (!abort)\n\t\t__reserve_region_with_split(root, start, end, name);\n\twrite_unlock(&resource_lock);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__reserve_region_with_split",
          "args": [
            "root",
            "start",
            "end",
            "name"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "__reserve_region_with_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "971-1030",
          "snippet": "static void __init\n__reserve_region_with_split(struct resource *root, resource_size_t start,\n\t\t\t    resource_size_t end, const char *name)\n{\n\tstruct resource *parent = root;\n\tstruct resource *conflict;\n\tstruct resource *res = alloc_resource(GFP_ATOMIC);\n\tstruct resource *next_res = NULL;\n\tint type = resource_type(root);\n\n\tif (!res)\n\t\treturn;\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = end;\n\tres->flags = type | IORESOURCE_BUSY;\n\tres->desc = IORES_DESC_NONE;\n\n\twhile (1) {\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict) {\n\t\t\tif (!next_res)\n\t\t\t\tbreak;\n\t\t\tres = next_res;\n\t\t\tnext_res = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* conflict covered whole area */\n\t\tif (conflict->start <= res->start &&\n\t\t\t\tconflict->end >= res->end) {\n\t\t\tfree_resource(res);\n\t\t\tWARN_ON(next_res);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* failed, split and try again */\n\t\tif (conflict->start > res->start) {\n\t\t\tend = res->end;\n\t\t\tres->end = conflict->start - 1;\n\t\t\tif (conflict->end < end) {\n\t\t\t\tnext_res = alloc_resource(GFP_ATOMIC);\n\t\t\t\tif (!next_res) {\n\t\t\t\t\tfree_resource(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext_res->name = name;\n\t\t\t\tnext_res->start = conflict->end + 1;\n\t\t\t\tnext_res->end = end;\n\t\t\t\tnext_res->flags = type | IORESOURCE_BUSY;\n\t\t\t\tnext_res->desc = IORES_DESC_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tres->start = conflict->end + 1;\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __init\n__reserve_region_with_split(struct resource *root, resource_size_t start,\n\t\t\t    resource_size_t end, const char *name)\n{\n\tstruct resource *parent = root;\n\tstruct resource *conflict;\n\tstruct resource *res = alloc_resource(GFP_ATOMIC);\n\tstruct resource *next_res = NULL;\n\tint type = resource_type(root);\n\n\tif (!res)\n\t\treturn;\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = end;\n\tres->flags = type | IORESOURCE_BUSY;\n\tres->desc = IORES_DESC_NONE;\n\n\twhile (1) {\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict) {\n\t\t\tif (!next_res)\n\t\t\t\tbreak;\n\t\t\tres = next_res;\n\t\t\tnext_res = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* conflict covered whole area */\n\t\tif (conflict->start <= res->start &&\n\t\t\t\tconflict->end >= res->end) {\n\t\t\tfree_resource(res);\n\t\t\tWARN_ON(next_res);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* failed, split and try again */\n\t\tif (conflict->start > res->start) {\n\t\t\tend = res->end;\n\t\t\tres->end = conflict->start - 1;\n\t\t\tif (conflict->end < end) {\n\t\t\t\tnext_res = alloc_resource(GFP_ATOMIC);\n\t\t\t\tif (!next_res) {\n\t\t\t\t\tfree_resource(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext_res->name = name;\n\t\t\t\tnext_res->start = conflict->end + 1;\n\t\t\t\tnext_res->end = end;\n\t\t\t\tnext_res->flags = type | IORESOURCE_BUSY;\n\t\t\t\tnext_res->desc = IORES_DESC_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tres->start = conflict->end + 1;\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"fixing request to [0x%llx-0x%llx]\\n\"",
            "(unsigned long long)start",
            "(unsigned long long)end"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"requested range [0x%llx-0x%llx] not in root %pr\\n\"",
            "(unsigned long long)start",
            "(unsigned long long)end",
            "root"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nvoid __init\nreserve_region_with_split(struct resource *root, resource_size_t start,\n\t\t\t  resource_size_t end, const char *name)\n{\n\tint abort = 0;\n\n\twrite_lock(&resource_lock);\n\tif (root->start > start || root->end < end) {\n\t\tpr_err(\"requested range [0x%llx-0x%llx] not in root %pr\\n\",\n\t\t       (unsigned long long)start, (unsigned long long)end,\n\t\t       root);\n\t\tif (start > root->end || end < root->start)\n\t\t\tabort = 1;\n\t\telse {\n\t\t\tif (end > root->end)\n\t\t\t\tend = root->end;\n\t\t\tif (start < root->start)\n\t\t\t\tstart = root->start;\n\t\t\tpr_err(\"fixing request to [0x%llx-0x%llx]\\n\",\n\t\t\t       (unsigned long long)start,\n\t\t\t       (unsigned long long)end);\n\t\t}\n\t\tdump_stack();\n\t}\n\tif (!abort)\n\t\t__reserve_region_with_split(root, start, end, name);\n\twrite_unlock(&resource_lock);\n}"
  },
  {
    "function_name": "__reserve_region_with_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "971-1030",
    "snippet": "static void __init\n__reserve_region_with_split(struct resource *root, resource_size_t start,\n\t\t\t    resource_size_t end, const char *name)\n{\n\tstruct resource *parent = root;\n\tstruct resource *conflict;\n\tstruct resource *res = alloc_resource(GFP_ATOMIC);\n\tstruct resource *next_res = NULL;\n\tint type = resource_type(root);\n\n\tif (!res)\n\t\treturn;\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = end;\n\tres->flags = type | IORESOURCE_BUSY;\n\tres->desc = IORES_DESC_NONE;\n\n\twhile (1) {\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict) {\n\t\t\tif (!next_res)\n\t\t\t\tbreak;\n\t\t\tres = next_res;\n\t\t\tnext_res = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* conflict covered whole area */\n\t\tif (conflict->start <= res->start &&\n\t\t\t\tconflict->end >= res->end) {\n\t\t\tfree_resource(res);\n\t\t\tWARN_ON(next_res);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* failed, split and try again */\n\t\tif (conflict->start > res->start) {\n\t\t\tend = res->end;\n\t\t\tres->end = conflict->start - 1;\n\t\t\tif (conflict->end < end) {\n\t\t\t\tnext_res = alloc_resource(GFP_ATOMIC);\n\t\t\t\tif (!next_res) {\n\t\t\t\t\tfree_resource(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext_res->name = name;\n\t\t\t\tnext_res->start = conflict->end + 1;\n\t\t\t\tnext_res->end = end;\n\t\t\t\tnext_res->flags = type | IORESOURCE_BUSY;\n\t\t\t\tnext_res->desc = IORES_DESC_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tres->start = conflict->end + 1;\n\t\t}\n\t}\n\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_resource",
          "args": [
            "res"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "free_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "149-162",
          "snippet": "static void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_resource",
          "args": [
            "GFP_ATOMIC"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "164-181",
          "snippet": "static struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct resource *bootmem_resource_free;",
            "static DEFINE_SPINLOCK(bootmem_resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "next_res"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__request_resource",
          "args": [
            "parent",
            "res"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "__request_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "184-210",
          "snippet": "static struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "resource_type",
          "args": [
            "root"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __init\n__reserve_region_with_split(struct resource *root, resource_size_t start,\n\t\t\t    resource_size_t end, const char *name)\n{\n\tstruct resource *parent = root;\n\tstruct resource *conflict;\n\tstruct resource *res = alloc_resource(GFP_ATOMIC);\n\tstruct resource *next_res = NULL;\n\tint type = resource_type(root);\n\n\tif (!res)\n\t\treturn;\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = end;\n\tres->flags = type | IORESOURCE_BUSY;\n\tres->desc = IORES_DESC_NONE;\n\n\twhile (1) {\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict) {\n\t\t\tif (!next_res)\n\t\t\t\tbreak;\n\t\t\tres = next_res;\n\t\t\tnext_res = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* conflict covered whole area */\n\t\tif (conflict->start <= res->start &&\n\t\t\t\tconflict->end >= res->end) {\n\t\t\tfree_resource(res);\n\t\t\tWARN_ON(next_res);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* failed, split and try again */\n\t\tif (conflict->start > res->start) {\n\t\t\tend = res->end;\n\t\t\tres->end = conflict->start - 1;\n\t\t\tif (conflict->end < end) {\n\t\t\t\tnext_res = alloc_resource(GFP_ATOMIC);\n\t\t\t\tif (!next_res) {\n\t\t\t\t\tfree_resource(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext_res->name = name;\n\t\t\t\tnext_res->start = conflict->end + 1;\n\t\t\t\tnext_res->end = end;\n\t\t\t\tnext_res->flags = type | IORESOURCE_BUSY;\n\t\t\t\tnext_res->desc = IORES_DESC_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tres->start = conflict->end + 1;\n\t\t}\n\t}\n\n}"
  },
  {
    "function_name": "adjust_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "959-968",
    "snippet": "int adjust_resource(struct resource *res, resource_size_t start,\n\t\t    resource_size_t size)\n{\n\tint result;\n\n\twrite_lock(&resource_lock);\n\tresult = __adjust_resource(res, start, size);\n\twrite_unlock(&resource_lock);\n\treturn result;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__adjust_resource",
          "args": [
            "res",
            "start",
            "size"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "__adjust_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "912-947",
          "snippet": "static int __adjust_resource(struct resource *res, resource_size_t start,\n\t\t\t\tresource_size_t size)\n{\n\tstruct resource *tmp, *parent = res->parent;\n\tresource_size_t end = start + size - 1;\n\tint result = -EBUSY;\n\n\tif (!parent)\n\t\tgoto skip;\n\n\tif ((start < parent->start) || (end > parent->end))\n\t\tgoto out;\n\n\tif (res->sibling && (res->sibling->start <= end))\n\t\tgoto out;\n\n\ttmp = parent->child;\n\tif (tmp != res) {\n\t\twhile (tmp->sibling != res)\n\t\t\ttmp = tmp->sibling;\n\t\tif (start <= tmp->end)\n\t\t\tgoto out;\n\t}\n\nskip:\n\tfor (tmp = res->child; tmp; tmp = tmp->sibling)\n\t\tif ((tmp->start < start) || (tmp->end > end))\n\t\t\tgoto out;\n\n\tres->start = start;\n\tres->end = end;\n\tresult = 0;\n\n out:\n\treturn result;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __adjust_resource(struct resource *res, resource_size_t start,\n\t\t\t\tresource_size_t size)\n{\n\tstruct resource *tmp, *parent = res->parent;\n\tresource_size_t end = start + size - 1;\n\tint result = -EBUSY;\n\n\tif (!parent)\n\t\tgoto skip;\n\n\tif ((start < parent->start) || (end > parent->end))\n\t\tgoto out;\n\n\tif (res->sibling && (res->sibling->start <= end))\n\t\tgoto out;\n\n\ttmp = parent->child;\n\tif (tmp != res) {\n\t\twhile (tmp->sibling != res)\n\t\t\ttmp = tmp->sibling;\n\t\tif (start <= tmp->end)\n\t\t\tgoto out;\n\t}\n\nskip:\n\tfor (tmp = res->child; tmp; tmp = tmp->sibling)\n\t\tif ((tmp->start < start) || (tmp->end > end))\n\t\t\tgoto out;\n\n\tres->start = start;\n\tres->end = end;\n\tresult = 0;\n\n out:\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nint adjust_resource(struct resource *res, resource_size_t start,\n\t\t    resource_size_t size)\n{\n\tint result;\n\n\twrite_lock(&resource_lock);\n\tresult = __adjust_resource(res, start, size);\n\twrite_unlock(&resource_lock);\n\treturn result;\n}"
  },
  {
    "function_name": "__adjust_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "912-947",
    "snippet": "static int __adjust_resource(struct resource *res, resource_size_t start,\n\t\t\t\tresource_size_t size)\n{\n\tstruct resource *tmp, *parent = res->parent;\n\tresource_size_t end = start + size - 1;\n\tint result = -EBUSY;\n\n\tif (!parent)\n\t\tgoto skip;\n\n\tif ((start < parent->start) || (end > parent->end))\n\t\tgoto out;\n\n\tif (res->sibling && (res->sibling->start <= end))\n\t\tgoto out;\n\n\ttmp = parent->child;\n\tif (tmp != res) {\n\t\twhile (tmp->sibling != res)\n\t\t\ttmp = tmp->sibling;\n\t\tif (start <= tmp->end)\n\t\t\tgoto out;\n\t}\n\nskip:\n\tfor (tmp = res->child; tmp; tmp = tmp->sibling)\n\t\tif ((tmp->start < start) || (tmp->end > end))\n\t\t\tgoto out;\n\n\tres->start = start;\n\tres->end = end;\n\tresult = 0;\n\n out:\n\treturn result;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __adjust_resource(struct resource *res, resource_size_t start,\n\t\t\t\tresource_size_t size)\n{\n\tstruct resource *tmp, *parent = res->parent;\n\tresource_size_t end = start + size - 1;\n\tint result = -EBUSY;\n\n\tif (!parent)\n\t\tgoto skip;\n\n\tif ((start < parent->start) || (end > parent->end))\n\t\tgoto out;\n\n\tif (res->sibling && (res->sibling->start <= end))\n\t\tgoto out;\n\n\ttmp = parent->child;\n\tif (tmp != res) {\n\t\twhile (tmp->sibling != res)\n\t\t\ttmp = tmp->sibling;\n\t\tif (start <= tmp->end)\n\t\t\tgoto out;\n\t}\n\nskip:\n\tfor (tmp = res->child; tmp; tmp = tmp->sibling)\n\t\tif ((tmp->start < start) || (tmp->end > end))\n\t\t\tgoto out;\n\n\tres->start = start;\n\tres->end = end;\n\tresult = 0;\n\n out:\n\treturn result;\n}"
  },
  {
    "function_name": "remove_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "901-909",
    "snippet": "int remove_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, false);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release_resource",
          "args": [
            "old",
            "false"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "__release_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "212-239",
          "snippet": "static int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nint remove_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, false);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}"
  },
  {
    "function_name": "insert_resource_expand_to_fit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "860-884",
    "snippet": "void insert_resource_expand_to_fit(struct resource *root, struct resource *new)\n{\n\tif (new->parent)\n\t\treturn;\n\n\twrite_lock(&resource_lock);\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tconflict = __insert_resource(root, new);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\tif (conflict == root)\n\t\t\tbreak;\n\n\t\t/* Ok, expand resource to cover the conflict, then try again .. */\n\t\tif (conflict->start < new->start)\n\t\t\tnew->start = conflict->start;\n\t\tif (conflict->end > new->end)\n\t\t\tnew->end = conflict->end;\n\n\t\tprintk(\"Expanded resource %s due to conflict with %s\\n\", new->name, conflict->name);\n\t}\n\twrite_unlock(&resource_lock);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Expanded resource %s due to conflict with %s\\n\"",
            "new->name",
            "conflict->name"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__insert_resource",
          "args": [
            "root",
            "new"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "758-805",
          "snippet": "static struct resource * __insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *first, *next;\n\n\tfor (;; parent = first) {\n\t\tfirst = __request_resource(parent, new);\n\t\tif (!first)\n\t\t\treturn first;\n\n\t\tif (first == parent)\n\t\t\treturn first;\n\t\tif (WARN_ON(first == new))\t/* duplicated insertion */\n\t\t\treturn first;\n\n\t\tif ((first->start > new->start) || (first->end < new->end))\n\t\t\tbreak;\n\t\tif ((first->start == new->start) && (first->end == new->end))\n\t\t\tbreak;\n\t}\n\n\tfor (next = first; ; next = next->sibling) {\n\t\t/* Partial overlap? Bad, and unfixable */\n\t\tif (next->start < new->start || next->end > new->end)\n\t\t\treturn next;\n\t\tif (!next->sibling)\n\t\t\tbreak;\n\t\tif (next->sibling->start > new->end)\n\t\t\tbreak;\n\t}\n\n\tnew->parent = parent;\n\tnew->sibling = next->sibling;\n\tnew->child = first;\n\n\tnext->sibling = NULL;\n\tfor (next = first; next; next = next->sibling)\n\t\tnext->parent = new;\n\n\tif (parent->child == first) {\n\t\tparent->child = new;\n\t} else {\n\t\tnext = parent->child;\n\t\twhile (next->sibling != first)\n\t\t\tnext = next->sibling;\n\t\tnext->sibling = new;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *first, *next;\n\n\tfor (;; parent = first) {\n\t\tfirst = __request_resource(parent, new);\n\t\tif (!first)\n\t\t\treturn first;\n\n\t\tif (first == parent)\n\t\t\treturn first;\n\t\tif (WARN_ON(first == new))\t/* duplicated insertion */\n\t\t\treturn first;\n\n\t\tif ((first->start > new->start) || (first->end < new->end))\n\t\t\tbreak;\n\t\tif ((first->start == new->start) && (first->end == new->end))\n\t\t\tbreak;\n\t}\n\n\tfor (next = first; ; next = next->sibling) {\n\t\t/* Partial overlap? Bad, and unfixable */\n\t\tif (next->start < new->start || next->end > new->end)\n\t\t\treturn next;\n\t\tif (!next->sibling)\n\t\t\tbreak;\n\t\tif (next->sibling->start > new->end)\n\t\t\tbreak;\n\t}\n\n\tnew->parent = parent;\n\tnew->sibling = next->sibling;\n\tnew->child = first;\n\n\tnext->sibling = NULL;\n\tfor (next = first; next; next = next->sibling)\n\t\tnext->parent = new;\n\n\tif (parent->child == first) {\n\t\tparent->child = new;\n\t} else {\n\t\tnext = parent->child;\n\t\twhile (next->sibling != first)\n\t\t\tnext = next->sibling;\n\t\tnext->sibling = new;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nvoid insert_resource_expand_to_fit(struct resource *root, struct resource *new)\n{\n\tif (new->parent)\n\t\treturn;\n\n\twrite_lock(&resource_lock);\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tconflict = __insert_resource(root, new);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\tif (conflict == root)\n\t\t\tbreak;\n\n\t\t/* Ok, expand resource to cover the conflict, then try again .. */\n\t\tif (conflict->start < new->start)\n\t\t\tnew->start = conflict->start;\n\t\tif (conflict->end > new->end)\n\t\t\tnew->end = conflict->end;\n\n\t\tprintk(\"Expanded resource %s due to conflict with %s\\n\", new->name, conflict->name);\n\t}\n\twrite_unlock(&resource_lock);\n}"
  },
  {
    "function_name": "insert_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "843-849",
    "snippet": "int insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\tconflict = insert_resource_conflict(parent, new);\n\treturn conflict ? -EBUSY : 0;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_resource_conflict",
          "args": [
            "parent",
            "new"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "insert_resource_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "823-831",
          "snippet": "struct resource *insert_resource_conflict(struct resource *parent, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __insert_resource(parent, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstruct resource *insert_resource_conflict(struct resource *parent, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __insert_resource(parent, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\tconflict = insert_resource_conflict(parent, new);\n\treturn conflict ? -EBUSY : 0;\n}"
  },
  {
    "function_name": "insert_resource_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "823-831",
    "snippet": "struct resource *insert_resource_conflict(struct resource *parent, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __insert_resource(parent, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__insert_resource",
          "args": [
            "parent",
            "new"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "758-805",
          "snippet": "static struct resource * __insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *first, *next;\n\n\tfor (;; parent = first) {\n\t\tfirst = __request_resource(parent, new);\n\t\tif (!first)\n\t\t\treturn first;\n\n\t\tif (first == parent)\n\t\t\treturn first;\n\t\tif (WARN_ON(first == new))\t/* duplicated insertion */\n\t\t\treturn first;\n\n\t\tif ((first->start > new->start) || (first->end < new->end))\n\t\t\tbreak;\n\t\tif ((first->start == new->start) && (first->end == new->end))\n\t\t\tbreak;\n\t}\n\n\tfor (next = first; ; next = next->sibling) {\n\t\t/* Partial overlap? Bad, and unfixable */\n\t\tif (next->start < new->start || next->end > new->end)\n\t\t\treturn next;\n\t\tif (!next->sibling)\n\t\t\tbreak;\n\t\tif (next->sibling->start > new->end)\n\t\t\tbreak;\n\t}\n\n\tnew->parent = parent;\n\tnew->sibling = next->sibling;\n\tnew->child = first;\n\n\tnext->sibling = NULL;\n\tfor (next = first; next; next = next->sibling)\n\t\tnext->parent = new;\n\n\tif (parent->child == first) {\n\t\tparent->child = new;\n\t} else {\n\t\tnext = parent->child;\n\t\twhile (next->sibling != first)\n\t\t\tnext = next->sibling;\n\t\tnext->sibling = new;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *first, *next;\n\n\tfor (;; parent = first) {\n\t\tfirst = __request_resource(parent, new);\n\t\tif (!first)\n\t\t\treturn first;\n\n\t\tif (first == parent)\n\t\t\treturn first;\n\t\tif (WARN_ON(first == new))\t/* duplicated insertion */\n\t\t\treturn first;\n\n\t\tif ((first->start > new->start) || (first->end < new->end))\n\t\t\tbreak;\n\t\tif ((first->start == new->start) && (first->end == new->end))\n\t\t\tbreak;\n\t}\n\n\tfor (next = first; ; next = next->sibling) {\n\t\t/* Partial overlap? Bad, and unfixable */\n\t\tif (next->start < new->start || next->end > new->end)\n\t\t\treturn next;\n\t\tif (!next->sibling)\n\t\t\tbreak;\n\t\tif (next->sibling->start > new->end)\n\t\t\tbreak;\n\t}\n\n\tnew->parent = parent;\n\tnew->sibling = next->sibling;\n\tnew->child = first;\n\n\tnext->sibling = NULL;\n\tfor (next = first; next; next = next->sibling)\n\t\tnext->parent = new;\n\n\tif (parent->child == first) {\n\t\tparent->child = new;\n\t} else {\n\t\tnext = parent->child;\n\t\twhile (next->sibling != first)\n\t\t\tnext = next->sibling;\n\t\tnext->sibling = new;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstruct resource *insert_resource_conflict(struct resource *parent, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __insert_resource(parent, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}"
  },
  {
    "function_name": "__insert_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "758-805",
    "snippet": "static struct resource * __insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *first, *next;\n\n\tfor (;; parent = first) {\n\t\tfirst = __request_resource(parent, new);\n\t\tif (!first)\n\t\t\treturn first;\n\n\t\tif (first == parent)\n\t\t\treturn first;\n\t\tif (WARN_ON(first == new))\t/* duplicated insertion */\n\t\t\treturn first;\n\n\t\tif ((first->start > new->start) || (first->end < new->end))\n\t\t\tbreak;\n\t\tif ((first->start == new->start) && (first->end == new->end))\n\t\t\tbreak;\n\t}\n\n\tfor (next = first; ; next = next->sibling) {\n\t\t/* Partial overlap? Bad, and unfixable */\n\t\tif (next->start < new->start || next->end > new->end)\n\t\t\treturn next;\n\t\tif (!next->sibling)\n\t\t\tbreak;\n\t\tif (next->sibling->start > new->end)\n\t\t\tbreak;\n\t}\n\n\tnew->parent = parent;\n\tnew->sibling = next->sibling;\n\tnew->child = first;\n\n\tnext->sibling = NULL;\n\tfor (next = first; next; next = next->sibling)\n\t\tnext->parent = new;\n\n\tif (parent->child == first) {\n\t\tparent->child = new;\n\t} else {\n\t\tnext = parent->child;\n\t\twhile (next->sibling != first)\n\t\t\tnext = next->sibling;\n\t\tnext->sibling = new;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "first == new"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__request_resource",
          "args": [
            "parent",
            "new"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "__request_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "184-210",
          "snippet": "static struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *first, *next;\n\n\tfor (;; parent = first) {\n\t\tfirst = __request_resource(parent, new);\n\t\tif (!first)\n\t\t\treturn first;\n\n\t\tif (first == parent)\n\t\t\treturn first;\n\t\tif (WARN_ON(first == new))\t/* duplicated insertion */\n\t\t\treturn first;\n\n\t\tif ((first->start > new->start) || (first->end < new->end))\n\t\t\tbreak;\n\t\tif ((first->start == new->start) && (first->end == new->end))\n\t\t\tbreak;\n\t}\n\n\tfor (next = first; ; next = next->sibling) {\n\t\t/* Partial overlap? Bad, and unfixable */\n\t\tif (next->start < new->start || next->end > new->end)\n\t\t\treturn next;\n\t\tif (!next->sibling)\n\t\t\tbreak;\n\t\tif (next->sibling->start > new->end)\n\t\t\tbreak;\n\t}\n\n\tnew->parent = parent;\n\tnew->sibling = next->sibling;\n\tnew->child = first;\n\n\tnext->sibling = NULL;\n\tfor (next = first; next; next = next->sibling)\n\t\tnext->parent = new;\n\n\tif (parent->child == first) {\n\t\tparent->child = new;\n\t} else {\n\t\tnext = parent->child;\n\t\twhile (next->sibling != first)\n\t\t\tnext = next->sibling;\n\t\tnext->sibling = new;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "lookup_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "740-752",
    "snippet": "struct resource *lookup_resource(struct resource *root, resource_size_t start)\n{\n\tstruct resource *res;\n\n\tread_lock(&resource_lock);\n\tfor (res = root->child; res; res = res->sibling) {\n\t\tif (res->start == start)\n\t\t\tbreak;\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn res;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstruct resource *lookup_resource(struct resource *root, resource_size_t start)\n{\n\tstruct resource *res;\n\n\tread_lock(&resource_lock);\n\tfor (res = root->child; res; res = res->sibling) {\n\t\tif (res->start == start)\n\t\t\tbreak;\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn res;\n}"
  },
  {
    "function_name": "allocate_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "696-729",
    "snippet": "int allocate_resource(struct resource *root, struct resource *new,\n\t\t      resource_size_t size, resource_size_t min,\n\t\t      resource_size_t max, resource_size_t align,\n\t\t      resource_size_t (*alignf)(void *,\n\t\t\t\t\t\tconst struct resource *,\n\t\t\t\t\t\tresource_size_t,\n\t\t\t\t\t\tresource_size_t),\n\t\t      void *alignf_data)\n{\n\tint err;\n\tstruct resource_constraint constraint;\n\n\tif (!alignf)\n\t\talignf = simple_align_resource;\n\n\tconstraint.min = min;\n\tconstraint.max = max;\n\tconstraint.align = align;\n\tconstraint.alignf = alignf;\n\tconstraint.alignf_data = alignf_data;\n\n\tif ( new->parent ) {\n\t\t/* resource is already allocated, try reallocating with\n\t\t   the new constraints */\n\t\treturn reallocate_resource(root, new, size, &constraint);\n\t}\n\n\twrite_lock(&resource_lock);\n\terr = find_resource(root, new, size, &constraint);\n\tif (err >= 0 && __request_resource(root, new))\n\t\terr = -EBUSY;\n\twrite_unlock(&resource_lock);\n\treturn err;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__request_resource",
          "args": [
            "root",
            "new"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "__request_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "184-210",
          "snippet": "static struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_resource",
          "args": [
            "root",
            "new",
            "size",
            "&constraint"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "find_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "628-633",
          "snippet": "static int find_resource(struct resource *root, struct resource *new,\n\t\t\tresource_size_t size,\n\t\t\tstruct resource_constraint  *constraint)\n{\n\treturn  __find_resource(root, NULL, new, size, constraint);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int find_resource(struct resource *root, struct resource *new,\n\t\t\tresource_size_t size,\n\t\t\tstruct resource_constraint  *constraint)\n{\n\treturn  __find_resource(root, NULL, new, size, constraint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reallocate_resource",
          "args": [
            "root",
            "new",
            "size",
            "&constraint"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "reallocate_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "645-681",
          "snippet": "static int reallocate_resource(struct resource *root, struct resource *old,\n\t\t\t       resource_size_t newsize,\n\t\t\t       struct resource_constraint *constraint)\n{\n\tint err=0;\n\tstruct resource new = *old;\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\n\tif ((err = __find_resource(root, old, &new, newsize, constraint)))\n\t\tgoto out;\n\n\tif (resource_contains(&new, old)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t\tgoto out;\n\t}\n\n\tif (old->child) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (resource_contains(old, &new)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t} else {\n\t\t__release_resource(old, true);\n\t\t*old = new;\n\t\tconflict = __request_resource(root, old);\n\t\tBUG_ON(conflict);\n\t}\nout:\n\twrite_unlock(&resource_lock);\n\treturn err;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic int reallocate_resource(struct resource *root, struct resource *old,\n\t\t\t       resource_size_t newsize,\n\t\t\t       struct resource_constraint *constraint)\n{\n\tint err=0;\n\tstruct resource new = *old;\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\n\tif ((err = __find_resource(root, old, &new, newsize, constraint)))\n\t\tgoto out;\n\n\tif (resource_contains(&new, old)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t\tgoto out;\n\t}\n\n\tif (old->child) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (resource_contains(old, &new)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t} else {\n\t\t__release_resource(old, true);\n\t\t*old = new;\n\t\tconflict = __request_resource(root, old);\n\t\tBUG_ON(conflict);\n\t}\nout:\n\twrite_unlock(&resource_lock);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nint allocate_resource(struct resource *root, struct resource *new,\n\t\t      resource_size_t size, resource_size_t min,\n\t\t      resource_size_t max, resource_size_t align,\n\t\t      resource_size_t (*alignf)(void *,\n\t\t\t\t\t\tconst struct resource *,\n\t\t\t\t\t\tresource_size_t,\n\t\t\t\t\t\tresource_size_t),\n\t\t      void *alignf_data)\n{\n\tint err;\n\tstruct resource_constraint constraint;\n\n\tif (!alignf)\n\t\talignf = simple_align_resource;\n\n\tconstraint.min = min;\n\tconstraint.max = max;\n\tconstraint.align = align;\n\tconstraint.alignf = alignf;\n\tconstraint.alignf_data = alignf_data;\n\n\tif ( new->parent ) {\n\t\t/* resource is already allocated, try reallocating with\n\t\t   the new constraints */\n\t\treturn reallocate_resource(root, new, size, &constraint);\n\t}\n\n\twrite_lock(&resource_lock);\n\terr = find_resource(root, new, size, &constraint);\n\tif (err >= 0 && __request_resource(root, new))\n\t\terr = -EBUSY;\n\twrite_unlock(&resource_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "reallocate_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "645-681",
    "snippet": "static int reallocate_resource(struct resource *root, struct resource *old,\n\t\t\t       resource_size_t newsize,\n\t\t\t       struct resource_constraint *constraint)\n{\n\tint err=0;\n\tstruct resource new = *old;\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\n\tif ((err = __find_resource(root, old, &new, newsize, constraint)))\n\t\tgoto out;\n\n\tif (resource_contains(&new, old)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t\tgoto out;\n\t}\n\n\tif (old->child) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (resource_contains(old, &new)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t} else {\n\t\t__release_resource(old, true);\n\t\t*old = new;\n\t\tconflict = __request_resource(root, old);\n\t\tBUG_ON(conflict);\n\t}\nout:\n\twrite_unlock(&resource_lock);\n\treturn err;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "conflict"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__request_resource",
          "args": [
            "root",
            "old"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "__request_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "184-210",
          "snippet": "static struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release_resource",
          "args": [
            "old",
            "true"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "__release_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "212-239",
          "snippet": "static int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resource_contains",
          "args": [
            "old",
            "&new"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resource_contains",
          "args": [
            "&new",
            "old"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_resource",
          "args": [
            "root",
            "old",
            "&new",
            "newsize",
            "constraint"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "__find_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "569-623",
          "snippet": "static int __find_resource(struct resource *root, struct resource *old,\n\t\t\t struct resource *new,\n\t\t\t resource_size_t  size,\n\t\t\t struct resource_constraint *constraint)\n{\n\tstruct resource *this = root->child;\n\tstruct resource tmp = *new, avail, alloc;\n\n\ttmp.start = root->start;\n\t/*\n\t * Skip past an allocated resource that starts at 0, since the assignment\n\t * of this->start - 1 to tmp->end below would cause an underflow.\n\t */\n\tif (this && this->start == root->start) {\n\t\ttmp.start = (this == old) ? old->start : this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\tfor(;;) {\n\t\tif (this)\n\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;\n\t\telse\n\t\t\ttmp.end = root->end;\n\n\t\tif (tmp.end < tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->min, constraint->max);\n\t\tarch_remove_reservations(&tmp);\n\n\t\t/* Check for overflow after ALIGN() */\n\t\tavail.start = ALIGN(tmp.start, constraint->align);\n\t\tavail.end = tmp.end;\n\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;\n\t\tif (avail.start >= tmp.start) {\n\t\t\talloc.flags = avail.flags;\n\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,\n\t\t\t\t\tsize, constraint->align);\n\t\t\talloc.end = alloc.start + size - 1;\n\t\t\tif (alloc.start <= alloc.end &&\n\t\t\t    resource_contains(&avail, &alloc)) {\n\t\t\t\tnew->start = alloc.start;\n\t\t\t\tnew->end = alloc.end;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\nnext:\t\tif (!this || this->end == root->end)\n\t\t\tbreak;\n\n\t\tif (this != old)\n\t\t\ttmp.start = this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\treturn -EBUSY;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __find_resource(struct resource *root, struct resource *old,\n\t\t\t struct resource *new,\n\t\t\t resource_size_t  size,\n\t\t\t struct resource_constraint *constraint)\n{\n\tstruct resource *this = root->child;\n\tstruct resource tmp = *new, avail, alloc;\n\n\ttmp.start = root->start;\n\t/*\n\t * Skip past an allocated resource that starts at 0, since the assignment\n\t * of this->start - 1 to tmp->end below would cause an underflow.\n\t */\n\tif (this && this->start == root->start) {\n\t\ttmp.start = (this == old) ? old->start : this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\tfor(;;) {\n\t\tif (this)\n\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;\n\t\telse\n\t\t\ttmp.end = root->end;\n\n\t\tif (tmp.end < tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->min, constraint->max);\n\t\tarch_remove_reservations(&tmp);\n\n\t\t/* Check for overflow after ALIGN() */\n\t\tavail.start = ALIGN(tmp.start, constraint->align);\n\t\tavail.end = tmp.end;\n\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;\n\t\tif (avail.start >= tmp.start) {\n\t\t\talloc.flags = avail.flags;\n\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,\n\t\t\t\t\tsize, constraint->align);\n\t\t\talloc.end = alloc.start + size - 1;\n\t\t\tif (alloc.start <= alloc.end &&\n\t\t\t    resource_contains(&avail, &alloc)) {\n\t\t\t\tnew->start = alloc.start;\n\t\t\t\tnew->end = alloc.end;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\nnext:\t\tif (!this || this->end == root->end)\n\t\t\tbreak;\n\n\t\tif (this != old)\n\t\t\ttmp.start = this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic int reallocate_resource(struct resource *root, struct resource *old,\n\t\t\t       resource_size_t newsize,\n\t\t\t       struct resource_constraint *constraint)\n{\n\tint err=0;\n\tstruct resource new = *old;\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\n\tif ((err = __find_resource(root, old, &new, newsize, constraint)))\n\t\tgoto out;\n\n\tif (resource_contains(&new, old)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t\tgoto out;\n\t}\n\n\tif (old->child) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (resource_contains(old, &new)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t} else {\n\t\t__release_resource(old, true);\n\t\t*old = new;\n\t\tconflict = __request_resource(root, old);\n\t\tBUG_ON(conflict);\n\t}\nout:\n\twrite_unlock(&resource_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "find_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "628-633",
    "snippet": "static int find_resource(struct resource *root, struct resource *new,\n\t\t\tresource_size_t size,\n\t\t\tstruct resource_constraint  *constraint)\n{\n\treturn  __find_resource(root, NULL, new, size, constraint);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__find_resource",
          "args": [
            "root",
            "NULL",
            "new",
            "size",
            "constraint"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "__find_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "569-623",
          "snippet": "static int __find_resource(struct resource *root, struct resource *old,\n\t\t\t struct resource *new,\n\t\t\t resource_size_t  size,\n\t\t\t struct resource_constraint *constraint)\n{\n\tstruct resource *this = root->child;\n\tstruct resource tmp = *new, avail, alloc;\n\n\ttmp.start = root->start;\n\t/*\n\t * Skip past an allocated resource that starts at 0, since the assignment\n\t * of this->start - 1 to tmp->end below would cause an underflow.\n\t */\n\tif (this && this->start == root->start) {\n\t\ttmp.start = (this == old) ? old->start : this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\tfor(;;) {\n\t\tif (this)\n\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;\n\t\telse\n\t\t\ttmp.end = root->end;\n\n\t\tif (tmp.end < tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->min, constraint->max);\n\t\tarch_remove_reservations(&tmp);\n\n\t\t/* Check for overflow after ALIGN() */\n\t\tavail.start = ALIGN(tmp.start, constraint->align);\n\t\tavail.end = tmp.end;\n\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;\n\t\tif (avail.start >= tmp.start) {\n\t\t\talloc.flags = avail.flags;\n\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,\n\t\t\t\t\tsize, constraint->align);\n\t\t\talloc.end = alloc.start + size - 1;\n\t\t\tif (alloc.start <= alloc.end &&\n\t\t\t    resource_contains(&avail, &alloc)) {\n\t\t\t\tnew->start = alloc.start;\n\t\t\t\tnew->end = alloc.end;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\nnext:\t\tif (!this || this->end == root->end)\n\t\t\tbreak;\n\n\t\tif (this != old)\n\t\t\ttmp.start = this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\treturn -EBUSY;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __find_resource(struct resource *root, struct resource *old,\n\t\t\t struct resource *new,\n\t\t\t resource_size_t  size,\n\t\t\t struct resource_constraint *constraint)\n{\n\tstruct resource *this = root->child;\n\tstruct resource tmp = *new, avail, alloc;\n\n\ttmp.start = root->start;\n\t/*\n\t * Skip past an allocated resource that starts at 0, since the assignment\n\t * of this->start - 1 to tmp->end below would cause an underflow.\n\t */\n\tif (this && this->start == root->start) {\n\t\ttmp.start = (this == old) ? old->start : this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\tfor(;;) {\n\t\tif (this)\n\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;\n\t\telse\n\t\t\ttmp.end = root->end;\n\n\t\tif (tmp.end < tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->min, constraint->max);\n\t\tarch_remove_reservations(&tmp);\n\n\t\t/* Check for overflow after ALIGN() */\n\t\tavail.start = ALIGN(tmp.start, constraint->align);\n\t\tavail.end = tmp.end;\n\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;\n\t\tif (avail.start >= tmp.start) {\n\t\t\talloc.flags = avail.flags;\n\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,\n\t\t\t\t\tsize, constraint->align);\n\t\t\talloc.end = alloc.start + size - 1;\n\t\t\tif (alloc.start <= alloc.end &&\n\t\t\t    resource_contains(&avail, &alloc)) {\n\t\t\t\tnew->start = alloc.start;\n\t\t\t\tnew->end = alloc.end;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\nnext:\t\tif (!this || this->end == root->end)\n\t\t\tbreak;\n\n\t\tif (this != old)\n\t\t\ttmp.start = this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\treturn -EBUSY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int find_resource(struct resource *root, struct resource *new,\n\t\t\tresource_size_t size,\n\t\t\tstruct resource_constraint  *constraint)\n{\n\treturn  __find_resource(root, NULL, new, size, constraint);\n}"
  },
  {
    "function_name": "__find_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "569-623",
    "snippet": "static int __find_resource(struct resource *root, struct resource *old,\n\t\t\t struct resource *new,\n\t\t\t resource_size_t  size,\n\t\t\t struct resource_constraint *constraint)\n{\n\tstruct resource *this = root->child;\n\tstruct resource tmp = *new, avail, alloc;\n\n\ttmp.start = root->start;\n\t/*\n\t * Skip past an allocated resource that starts at 0, since the assignment\n\t * of this->start - 1 to tmp->end below would cause an underflow.\n\t */\n\tif (this && this->start == root->start) {\n\t\ttmp.start = (this == old) ? old->start : this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\tfor(;;) {\n\t\tif (this)\n\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;\n\t\telse\n\t\t\ttmp.end = root->end;\n\n\t\tif (tmp.end < tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->min, constraint->max);\n\t\tarch_remove_reservations(&tmp);\n\n\t\t/* Check for overflow after ALIGN() */\n\t\tavail.start = ALIGN(tmp.start, constraint->align);\n\t\tavail.end = tmp.end;\n\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;\n\t\tif (avail.start >= tmp.start) {\n\t\t\talloc.flags = avail.flags;\n\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,\n\t\t\t\t\tsize, constraint->align);\n\t\t\talloc.end = alloc.start + size - 1;\n\t\t\tif (alloc.start <= alloc.end &&\n\t\t\t    resource_contains(&avail, &alloc)) {\n\t\t\t\tnew->start = alloc.start;\n\t\t\t\tnew->end = alloc.end;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\nnext:\t\tif (!this || this->end == root->end)\n\t\t\tbreak;\n\n\t\tif (this != old)\n\t\t\ttmp.start = this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\treturn -EBUSY;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resource_contains",
          "args": [
            "&avail",
            "&alloc"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "constraint->alignf",
          "args": [
            "constraint->alignf_data",
            "&avail",
            "size",
            "constraint->align"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "tmp.start",
            "constraint->align"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_remove_reservations",
          "args": [
            "&tmp"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "arch_remove_reservations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "544-546",
          "snippet": "void __weak arch_remove_reservations(struct resource *avail)\n{\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nvoid __weak arch_remove_reservations(struct resource *avail)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "resource_clip",
          "args": [
            "&tmp",
            "constraint->min",
            "constraint->max"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "resource_clip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "556-563",
          "snippet": "static void resource_clip(struct resource *res, resource_size_t min,\n\t\t\t  resource_size_t max)\n{\n\tif (res->start < min)\n\t\tres->start = min;\n\tif (res->end > max)\n\t\tres->end = max;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void resource_clip(struct resource *res, resource_size_t min,\n\t\t\t  resource_size_t max)\n{\n\tif (res->start < min)\n\t\tres->start = min;\n\tif (res->end > max)\n\t\tres->end = max;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __find_resource(struct resource *root, struct resource *old,\n\t\t\t struct resource *new,\n\t\t\t resource_size_t  size,\n\t\t\t struct resource_constraint *constraint)\n{\n\tstruct resource *this = root->child;\n\tstruct resource tmp = *new, avail, alloc;\n\n\ttmp.start = root->start;\n\t/*\n\t * Skip past an allocated resource that starts at 0, since the assignment\n\t * of this->start - 1 to tmp->end below would cause an underflow.\n\t */\n\tif (this && this->start == root->start) {\n\t\ttmp.start = (this == old) ? old->start : this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\tfor(;;) {\n\t\tif (this)\n\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;\n\t\telse\n\t\t\ttmp.end = root->end;\n\n\t\tif (tmp.end < tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->min, constraint->max);\n\t\tarch_remove_reservations(&tmp);\n\n\t\t/* Check for overflow after ALIGN() */\n\t\tavail.start = ALIGN(tmp.start, constraint->align);\n\t\tavail.end = tmp.end;\n\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;\n\t\tif (avail.start >= tmp.start) {\n\t\t\talloc.flags = avail.flags;\n\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,\n\t\t\t\t\tsize, constraint->align);\n\t\t\talloc.end = alloc.start + size - 1;\n\t\t\tif (alloc.start <= alloc.end &&\n\t\t\t    resource_contains(&avail, &alloc)) {\n\t\t\t\tnew->start = alloc.start;\n\t\t\t\tnew->end = alloc.end;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\nnext:\t\tif (!this || this->end == root->end)\n\t\t\tbreak;\n\n\t\tif (this != old)\n\t\t\ttmp.start = this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\treturn -EBUSY;\n}"
  },
  {
    "function_name": "resource_clip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "556-563",
    "snippet": "static void resource_clip(struct resource *res, resource_size_t min,\n\t\t\t  resource_size_t max)\n{\n\tif (res->start < min)\n\t\tres->start = min;\n\tif (res->end > max)\n\t\tres->end = max;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void resource_clip(struct resource *res, resource_size_t min,\n\t\t\t  resource_size_t max)\n{\n\tif (res->start < min)\n\t\tres->start = min;\n\tif (res->end > max)\n\t\tres->end = max;\n}"
  },
  {
    "function_name": "simple_align_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "548-554",
    "snippet": "static resource_size_t simple_align_resource(void *data,\n\t\t\t\t\t     const struct resource *avail,\n\t\t\t\t\t     resource_size_t size,\n\t\t\t\t\t     resource_size_t align)\n{\n\treturn avail->start;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic resource_size_t simple_align_resource(void *data,\n\t\t\t\t\t     const struct resource *avail,\n\t\t\t\t\t     resource_size_t size,\n\t\t\t\t\t     resource_size_t align)\n{\n\treturn avail->start;\n}"
  },
  {
    "function_name": "arch_remove_reservations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "544-546",
    "snippet": "void __weak arch_remove_reservations(struct resource *avail)\n{\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nvoid __weak arch_remove_reservations(struct resource *avail)\n{\n}"
  },
  {
    "function_name": "region_intersects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "512-541",
    "snippet": "int region_intersects(resource_size_t start, size_t size, unsigned long flags,\n\t\t      unsigned long desc)\n{\n\tresource_size_t end = start + size - 1;\n\tint type = 0; int other = 0;\n\tstruct resource *p;\n\n\tread_lock(&resource_lock);\n\tfor (p = iomem_resource.child; p ; p = p->sibling) {\n\t\tbool is_type = (((p->flags & flags) == flags) &&\n\t\t\t\t((desc == IORES_DESC_NONE) ||\n\t\t\t\t (desc == p->desc)));\n\n\t\tif (start >= p->start && start <= p->end)\n\t\t\tis_type ? type++ : other++;\n\t\tif (end >= p->start && end <= p->end)\n\t\t\tis_type ? type++ : other++;\n\t\tif (p->start >= start && p->end <= end)\n\t\t\tis_type ? type++ : other++;\n\t}\n\tread_unlock(&resource_lock);\n\n\tif (other == 0)\n\t\treturn type ? REGION_INTERSECTS : REGION_DISJOINT;\n\n\tif (type)\n\t\treturn REGION_MIXED;\n\n\treturn REGION_DISJOINT;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nint region_intersects(resource_size_t start, size_t size, unsigned long flags,\n\t\t      unsigned long desc)\n{\n\tresource_size_t end = start + size - 1;\n\tint type = 0; int other = 0;\n\tstruct resource *p;\n\n\tread_lock(&resource_lock);\n\tfor (p = iomem_resource.child; p ; p = p->sibling) {\n\t\tbool is_type = (((p->flags & flags) == flags) &&\n\t\t\t\t((desc == IORES_DESC_NONE) ||\n\t\t\t\t (desc == p->desc)));\n\n\t\tif (start >= p->start && start <= p->end)\n\t\t\tis_type ? type++ : other++;\n\t\tif (end >= p->start && end <= p->end)\n\t\t\tis_type ? type++ : other++;\n\t\tif (p->start >= start && p->end <= end)\n\t\t\tis_type ? type++ : other++;\n\t}\n\tread_unlock(&resource_lock);\n\n\tif (other == 0)\n\t\treturn type ? REGION_INTERSECTS : REGION_DISJOINT;\n\n\tif (type)\n\t\treturn REGION_MIXED;\n\n\treturn REGION_DISJOINT;\n}"
  },
  {
    "function_name": "page_is_ram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "486-489",
    "snippet": "int __weak page_is_ram(unsigned long pfn)\n{\n\treturn walk_system_ram_range(pfn, 1, NULL, __is_ram) == 1;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_system_ram_range",
          "args": [
            "pfn",
            "1",
            "NULL",
            "__is_ram"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "walk_system_ram_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "449-473",
          "snippet": "int walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\t  void *arg, int (*func)(unsigned long, unsigned long, void *))\n{\n\tresource_size_t start, end;\n\tunsigned long flags;\n\tstruct resource res;\n\tunsigned long pfn, end_pfn;\n\tint ret = -1;\n\n\tstart = (u64) start_pfn << PAGE_SHIFT;\n\tend = ((u64)(start_pfn + nr_pages) << PAGE_SHIFT) - 1;\n\tflags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, IORES_DESC_NONE,\n\t\t\t\t    true, &res)) {\n\t\tpfn = (res.start + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tend_pfn = (res.end + 1) >> PAGE_SHIFT;\n\t\tif (end_pfn > pfn)\n\t\t\tret = (*func)(pfn, end_pfn - pfn, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstart = res.end + 1;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\t  void *arg, int (*func)(unsigned long, unsigned long, void *))\n{\n\tresource_size_t start, end;\n\tunsigned long flags;\n\tstruct resource res;\n\tunsigned long pfn, end_pfn;\n\tint ret = -1;\n\n\tstart = (u64) start_pfn << PAGE_SHIFT;\n\tend = ((u64)(start_pfn + nr_pages) << PAGE_SHIFT) - 1;\n\tflags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, IORES_DESC_NONE,\n\t\t\t\t    true, &res)) {\n\t\tpfn = (res.start + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tend_pfn = (res.end + 1) >> PAGE_SHIFT;\n\t\tif (end_pfn > pfn)\n\t\t\tret = (*func)(pfn, end_pfn - pfn, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstart = res.end + 1;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint __weak page_is_ram(unsigned long pfn)\n{\n\treturn walk_system_ram_range(pfn, 1, NULL, __is_ram) == 1;\n}"
  },
  {
    "function_name": "__is_ram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "477-480",
    "snippet": "static int __is_ram(unsigned long pfn, unsigned long nr_pages, void *arg)\n{\n\treturn 1;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __is_ram(unsigned long pfn, unsigned long nr_pages, void *arg)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "walk_system_ram_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "449-473",
    "snippet": "int walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\t  void *arg, int (*func)(unsigned long, unsigned long, void *))\n{\n\tresource_size_t start, end;\n\tunsigned long flags;\n\tstruct resource res;\n\tunsigned long pfn, end_pfn;\n\tint ret = -1;\n\n\tstart = (u64) start_pfn << PAGE_SHIFT;\n\tend = ((u64)(start_pfn + nr_pages) << PAGE_SHIFT) - 1;\n\tflags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, IORES_DESC_NONE,\n\t\t\t\t    true, &res)) {\n\t\tpfn = (res.start + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tend_pfn = (res.end + 1) >> PAGE_SHIFT;\n\t\tif (end_pfn > pfn)\n\t\t\tret = (*func)(pfn, end_pfn - pfn, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstart = res.end + 1;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "pfn",
            "end_pfn - pfn",
            "arg"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_iomem_res",
          "args": [
            "start",
            "end",
            "flags",
            "IORES_DESC_NONE",
            "true",
            "&res"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_iomem_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "333-370",
          "snippet": "static int find_next_iomem_res(resource_size_t start, resource_size_t end,\n\t\t\t       unsigned long flags, unsigned long desc,\n\t\t\t       bool first_lvl, struct resource *res)\n{\n\tstruct resource *p;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tread_lock(&resource_lock);\n\n\tfor (p = iomem_resource.child; p; p = next_resource(p, first_lvl)) {\n\t\tif ((p->flags & flags) != flags)\n\t\t\tcontinue;\n\t\tif ((desc != IORES_DESC_NONE) && (desc != p->desc))\n\t\t\tcontinue;\n\t\tif (p->start > end) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif ((p->end >= start) && (p->start <= end))\n\t\t\tbreak;\n\t}\n\n\tread_unlock(&resource_lock);\n\tif (!p)\n\t\treturn -1;\n\n\t/* copy data */\n\tres->start = max(start, p->start);\n\tres->end = min(end, p->end);\n\tres->flags = p->flags;\n\tres->desc = p->desc;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic int find_next_iomem_res(resource_size_t start, resource_size_t end,\n\t\t\t       unsigned long flags, unsigned long desc,\n\t\t\t       bool first_lvl, struct resource *res)\n{\n\tstruct resource *p;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tread_lock(&resource_lock);\n\n\tfor (p = iomem_resource.child; p; p = next_resource(p, first_lvl)) {\n\t\tif ((p->flags & flags) != flags)\n\t\t\tcontinue;\n\t\tif ((desc != IORES_DESC_NONE) && (desc != p->desc))\n\t\t\tcontinue;\n\t\tif (p->start > end) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif ((p->end >= start) && (p->start <= end))\n\t\t\tbreak;\n\t}\n\n\tread_unlock(&resource_lock);\n\tif (!p)\n\t\treturn -1;\n\n\t/* copy data */\n\tres->start = max(start, p->start);\n\tres->end = min(end, p->end);\n\tres->flags = p->flags;\n\tres->desc = p->desc;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "start_pfn + nr_pages"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\t  void *arg, int (*func)(unsigned long, unsigned long, void *))\n{\n\tresource_size_t start, end;\n\tunsigned long flags;\n\tstruct resource res;\n\tunsigned long pfn, end_pfn;\n\tint ret = -1;\n\n\tstart = (u64) start_pfn << PAGE_SHIFT;\n\tend = ((u64)(start_pfn + nr_pages) << PAGE_SHIFT) - 1;\n\tflags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, IORES_DESC_NONE,\n\t\t\t\t    true, &res)) {\n\t\tpfn = (res.start + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tend_pfn = (res.end + 1) >> PAGE_SHIFT;\n\t\tif (end_pfn > pfn)\n\t\t\tret = (*func)(pfn, end_pfn - pfn, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstart = res.end + 1;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "walk_mem_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "433-440",
    "snippet": "int walk_mem_res(u64 start, u64 end, void *arg,\n\t\t int (*func)(struct resource *, void *))\n{\n\tunsigned long flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\n\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, true,\n\t\t\t\t     arg, func);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__walk_iomem_res_desc",
          "args": [
            "start",
            "end",
            "flags",
            "IORES_DESC_NONE",
            "true",
            "arg",
            "func"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "__walk_iomem_res_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "372-390",
          "snippet": "static int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t bool first_lvl, void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -1;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, first_lvl, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t bool first_lvl, void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -1;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, first_lvl, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint walk_mem_res(u64 start, u64 end, void *arg,\n\t\t int (*func)(struct resource *, void *))\n{\n\tunsigned long flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\n\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, true,\n\t\t\t\t     arg, func);\n}"
  },
  {
    "function_name": "walk_system_ram_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "420-427",
    "snippet": "int walk_system_ram_res(u64 start, u64 end, void *arg,\n\t\t\tint (*func)(struct resource *, void *))\n{\n\tunsigned long flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\n\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, true,\n\t\t\t\t     arg, func);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__walk_iomem_res_desc",
          "args": [
            "start",
            "end",
            "flags",
            "IORES_DESC_NONE",
            "true",
            "arg",
            "func"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "__walk_iomem_res_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "372-390",
          "snippet": "static int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t bool first_lvl, void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -1;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, first_lvl, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t bool first_lvl, void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -1;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, first_lvl, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint walk_system_ram_res(u64 start, u64 end, void *arg,\n\t\t\tint (*func)(struct resource *, void *))\n{\n\tunsigned long flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\n\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, true,\n\t\t\t\t     arg, func);\n}"
  },
  {
    "function_name": "walk_iomem_res_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "406-410",
    "snippet": "int walk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start,\n\t\tu64 end, void *arg, int (*func)(struct resource *, void *))\n{\n\treturn __walk_iomem_res_desc(start, end, flags, desc, false, arg, func);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__walk_iomem_res_desc",
          "args": [
            "start",
            "end",
            "flags",
            "desc",
            "false",
            "arg",
            "func"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "__walk_iomem_res_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "372-390",
          "snippet": "static int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t bool first_lvl, void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -1;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, first_lvl, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t bool first_lvl, void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -1;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, first_lvl, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint walk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start,\n\t\tu64 end, void *arg, int (*func)(struct resource *, void *))\n{\n\treturn __walk_iomem_res_desc(start, end, flags, desc, false, arg, func);\n}"
  },
  {
    "function_name": "__walk_iomem_res_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "372-390",
    "snippet": "static int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t bool first_lvl, void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -1;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, first_lvl, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "&res",
            "arg"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_iomem_res",
          "args": [
            "start",
            "end",
            "flags",
            "desc",
            "first_lvl",
            "&res"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_iomem_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "333-370",
          "snippet": "static int find_next_iomem_res(resource_size_t start, resource_size_t end,\n\t\t\t       unsigned long flags, unsigned long desc,\n\t\t\t       bool first_lvl, struct resource *res)\n{\n\tstruct resource *p;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tread_lock(&resource_lock);\n\n\tfor (p = iomem_resource.child; p; p = next_resource(p, first_lvl)) {\n\t\tif ((p->flags & flags) != flags)\n\t\t\tcontinue;\n\t\tif ((desc != IORES_DESC_NONE) && (desc != p->desc))\n\t\t\tcontinue;\n\t\tif (p->start > end) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif ((p->end >= start) && (p->start <= end))\n\t\t\tbreak;\n\t}\n\n\tread_unlock(&resource_lock);\n\tif (!p)\n\t\treturn -1;\n\n\t/* copy data */\n\tres->start = max(start, p->start);\n\tres->end = min(end, p->end);\n\tres->flags = p->flags;\n\tres->desc = p->desc;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic int find_next_iomem_res(resource_size_t start, resource_size_t end,\n\t\t\t       unsigned long flags, unsigned long desc,\n\t\t\t       bool first_lvl, struct resource *res)\n{\n\tstruct resource *p;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tread_lock(&resource_lock);\n\n\tfor (p = iomem_resource.child; p; p = next_resource(p, first_lvl)) {\n\t\tif ((p->flags & flags) != flags)\n\t\t\tcontinue;\n\t\tif ((desc != IORES_DESC_NONE) && (desc != p->desc))\n\t\t\tcontinue;\n\t\tif (p->start > end) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif ((p->end >= start) && (p->start <= end))\n\t\t\tbreak;\n\t}\n\n\tread_unlock(&resource_lock);\n\tif (!p)\n\t\treturn -1;\n\n\t/* copy data */\n\tres->start = max(start, p->start);\n\tres->end = min(end, p->end);\n\tres->flags = p->flags;\n\tres->desc = p->desc;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t bool first_lvl, void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -1;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, first_lvl, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_next_iomem_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "333-370",
    "snippet": "static int find_next_iomem_res(resource_size_t start, resource_size_t end,\n\t\t\t       unsigned long flags, unsigned long desc,\n\t\t\t       bool first_lvl, struct resource *res)\n{\n\tstruct resource *p;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tread_lock(&resource_lock);\n\n\tfor (p = iomem_resource.child; p; p = next_resource(p, first_lvl)) {\n\t\tif ((p->flags & flags) != flags)\n\t\t\tcontinue;\n\t\tif ((desc != IORES_DESC_NONE) && (desc != p->desc))\n\t\t\tcontinue;\n\t\tif (p->start > end) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif ((p->end >= start) && (p->start <= end))\n\t\t\tbreak;\n\t}\n\n\tread_unlock(&resource_lock);\n\tif (!p)\n\t\treturn -1;\n\n\t/* copy data */\n\tres->start = max(start, p->start);\n\tres->end = min(end, p->end);\n\tres->flags = p->flags;\n\tres->desc = p->desc;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};",
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "p->end"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "start",
            "p->start"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_resource",
          "args": [
            "p",
            "first_lvl"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "next_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "63-74",
          "snippet": "static struct resource *next_resource(struct resource *p, bool sibling_only)\n{\n\t/* Caller wants to traverse through siblings only */\n\tif (sibling_only)\n\t\treturn p->sibling;\n\n\tif (p->child)\n\t\treturn p->child;\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *next_resource(struct resource *p, bool sibling_only)\n{\n\t/* Caller wants to traverse through siblings only */\n\tif (sibling_only)\n\t\treturn p->sibling;\n\n\tif (p->child)\n\t\treturn p->child;\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic int find_next_iomem_res(resource_size_t start, resource_size_t end,\n\t\t\t       unsigned long flags, unsigned long desc,\n\t\t\t       bool first_lvl, struct resource *res)\n{\n\tstruct resource *p;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tread_lock(&resource_lock);\n\n\tfor (p = iomem_resource.child; p; p = next_resource(p, first_lvl)) {\n\t\tif ((p->flags & flags) != flags)\n\t\t\tcontinue;\n\t\tif ((desc != IORES_DESC_NONE) && (desc != p->desc))\n\t\t\tcontinue;\n\t\tif (p->start > end) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif ((p->end >= start) && (p->start <= end))\n\t\t\tbreak;\n\t}\n\n\tread_unlock(&resource_lock);\n\tif (!p)\n\t\treturn -1;\n\n\t/* copy data */\n\tres->start = max(start, p->start);\n\tres->end = min(end, p->end);\n\tres->flags = p->flags;\n\tres->desc = p->desc;\n\treturn 0;\n}"
  },
  {
    "function_name": "release_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "309-317",
    "snippet": "int release_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, true);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release_resource",
          "args": [
            "old",
            "true"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "__release_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "212-239",
          "snippet": "static int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nint release_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, true);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}"
  },
  {
    "function_name": "request_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "295-301",
    "snippet": "int request_resource(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\tconflict = request_resource_conflict(root, new);\n\treturn conflict ? -EBUSY : 0;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "request_resource_conflict",
          "args": [
            "root",
            "new"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "request_resource_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "278-286",
          "snippet": "struct resource *request_resource_conflict(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __request_resource(root, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstruct resource *request_resource_conflict(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __request_resource(root, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nint request_resource(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\tconflict = request_resource_conflict(root, new);\n\treturn conflict ? -EBUSY : 0;\n}"
  },
  {
    "function_name": "request_resource_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "278-286",
    "snippet": "struct resource *request_resource_conflict(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __request_resource(root, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__request_resource",
          "args": [
            "root",
            "new"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "__request_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "184-210",
          "snippet": "static struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstruct resource *request_resource_conflict(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __request_resource(root, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}"
  },
  {
    "function_name": "release_child_resources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "264-269",
    "snippet": "void release_child_resources(struct resource *r)\n{\n\twrite_lock(&resource_lock);\n\t__release_child_resources(r);\n\twrite_unlock(&resource_lock);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release_child_resources",
          "args": [
            "r"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "__release_child_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "241-262",
          "snippet": "static void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nvoid release_child_resources(struct resource *r)\n{\n\twrite_lock(&resource_lock);\n\t__release_child_resources(r);\n\twrite_unlock(&resource_lock);\n}"
  },
  {
    "function_name": "__release_child_resources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "241-262",
    "snippet": "static void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "tmp"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"release child resource %pR\\n\"",
            "tmp"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release_child_resources",
          "args": [
            "tmp"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "__release_child_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "241-262",
          "snippet": "static void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}"
  },
  {
    "function_name": "__release_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "212-239",
    "snippet": "static int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "__request_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "184-210",
    "snippet": "static struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}"
  },
  {
    "function_name": "alloc_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "164-181",
    "snippet": "static struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct resource *bootmem_resource_free;",
      "static DEFINE_SPINLOCK(bootmem_resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct resource)",
            "flags"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "res",
            "0",
            "sizeof(struct resource)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bootmem_resource_lock"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bootmem_resource_lock"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic struct resource *alloc_resource(gfp_t flags)\n{\n\tstruct resource *res = NULL;\n\n\tspin_lock(&bootmem_resource_lock);\n\tif (bootmem_resource_free) {\n\t\tres = bootmem_resource_free;\n\t\tbootmem_resource_free = res->sibling;\n\t}\n\tspin_unlock(&bootmem_resource_lock);\n\n\tif (res)\n\t\tmemset(res, 0, sizeof(struct resource));\n\telse\n\t\tres = kzalloc(sizeof(struct resource), flags);\n\n\treturn res;\n}"
  },
  {
    "function_name": "free_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "149-162",
    "snippet": "static void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct resource *bootmem_resource_free;",
      "static DEFINE_SPINLOCK(bootmem_resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "res"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bootmem_resource_lock"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bootmem_resource_lock"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "virt_to_head_page(res)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "res"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *bootmem_resource_free;\nstatic DEFINE_SPINLOCK(bootmem_resource_lock);\n\nstatic void free_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\n\tif (!PageSlab(virt_to_head_page(res))) {\n\t\tspin_lock(&bootmem_resource_lock);\n\t\tres->sibling = bootmem_resource_free;\n\t\tbootmem_resource_free = res;\n\t\tspin_unlock(&bootmem_resource_lock);\n\t} else {\n\t\tkfree(res);\n\t}\n}"
  },
  {
    "function_name": "ioresources_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "138-144",
    "snippet": "static int __init ioresources_init(void)\n{\n\tproc_create_seq_data(\"ioports\", 0, NULL, &resource_op,\n\t\t\t&ioport_resource);\n\tproc_create_seq_data(\"iomem\", 0, NULL, &resource_op, &iomem_resource);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource ioport_resource = {\n\t.name\t= \"PCI IO\",\n\t.start\t= 0,\n\t.end\t= IO_SPACE_LIMIT,\n\t.flags\t= IORESOURCE_IO,\n};",
      "struct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_seq_data",
          "args": [
            "\"iomem\"",
            "0",
            "NULL",
            "&resource_op",
            "&iomem_resource"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_seq_data",
          "args": [
            "\"ioports\"",
            "0",
            "NULL",
            "&resource_op",
            "&ioport_resource"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstruct resource ioport_resource = {\n\t.name\t= \"PCI IO\",\n\t.start\t= 0,\n\t.end\t= IO_SPACE_LIMIT,\n\t.flags\t= IORESOURCE_IO,\n};\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\n\nstatic int __init ioresources_init(void)\n{\n\tproc_create_seq_data(\"ioports\", 0, NULL, &resource_op,\n\t\t\t&ioport_resource);\n\tproc_create_seq_data(\"iomem\", 0, NULL, &resource_op, &iomem_resource);\n\treturn 0;\n}"
  },
  {
    "function_name": "r_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "104-129",
    "snippet": "static int r_show(struct seq_file *m, void *v)\n{\n\tstruct resource *root = PDE_DATA(file_inode(m->file));\n\tstruct resource *r = v, *p;\n\tunsigned long long start, end;\n\tint width = root->end < 0x10000 ? 4 : 8;\n\tint depth;\n\n\tfor (depth = 0, p = r; depth < MAX_IORES_LEVEL; depth++, p = p->parent)\n\t\tif (p->parent == root)\n\t\t\tbreak;\n\n\tif (file_ns_capable(m->file, &init_user_ns, CAP_SYS_ADMIN)) {\n\t\tstart = r->start;\n\t\tend = r->end;\n\t} else {\n\t\tstart = end = 0;\n\t}\n\n\tseq_printf(m, \"%*s%0*llx-%0*llx : %s\\n\",\n\t\t\tdepth * 2, \"\",\n\t\t\twidth, start,\n\t\t\twidth, end,\n\t\t\tr->name ? r->name : \"<BAD>\");\n\treturn 0;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*s%0*llx-%0*llx : %s\\n\"",
            "depth * 2",
            "\"\"",
            "width",
            "start",
            "width",
            "end",
            "r->name ? r->name : \"<BAD>\""
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_ns_capable",
          "args": [
            "m->file",
            "&init_user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "file_ns_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "448-458",
          "snippet": "bool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap) == 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "file_inode(m->file)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "m->file"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic int r_show(struct seq_file *m, void *v)\n{\n\tstruct resource *root = PDE_DATA(file_inode(m->file));\n\tstruct resource *r = v, *p;\n\tunsigned long long start, end;\n\tint width = root->end < 0x10000 ? 4 : 8;\n\tint depth;\n\n\tfor (depth = 0, p = r; depth < MAX_IORES_LEVEL; depth++, p = p->parent)\n\t\tif (p->parent == root)\n\t\t\tbreak;\n\n\tif (file_ns_capable(m->file, &init_user_ns, CAP_SYS_ADMIN)) {\n\t\tstart = r->start;\n\t\tend = r->end;\n\t} else {\n\t\tstart = end = 0;\n\t}\n\n\tseq_printf(m, \"%*s%0*llx-%0*llx : %s\\n\",\n\t\t\tdepth * 2, \"\",\n\t\t\twidth, start,\n\t\t\twidth, end,\n\t\t\tr->name ? r->name : \"<BAD>\");\n\treturn 0;\n}"
  },
  {
    "function_name": "r_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "98-102",
    "snippet": "static void r_stop(struct seq_file *m, void *v)\n\t__releases(resource_lock)\n{\n\tread_unlock(&resource_lock);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&resource_lock"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "resource_lock"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic void r_stop(struct seq_file *m, void *v)\n\t__releases(resource_lock)\n{\n\tread_unlock(&resource_lock);\n}"
  },
  {
    "function_name": "r_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "87-96",
    "snippet": "static void *r_start(struct seq_file *m, loff_t *pos)\n\t__acquires(resource_lock)\n{\n\tstruct resource *p = PDE_DATA(file_inode(m->file));\n\tloff_t l = 0;\n\tread_lock(&resource_lock);\n\tfor (p = p->child; p && l < *pos; p = r_next(m, p, &l))\n\t\t;\n\treturn p;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(resource_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "r_next",
          "args": [
            "m",
            "p",
            "&l"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "r_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "76-81",
          "snippet": "static void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p, false);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&resource_lock"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "file_inode(m->file)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "m->file"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "resource_lock"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic void *r_start(struct seq_file *m, loff_t *pos)\n\t__acquires(resource_lock)\n{\n\tstruct resource *p = PDE_DATA(file_inode(m->file));\n\tloff_t l = 0;\n\tread_lock(&resource_lock);\n\tfor (p = p->child; p && l < *pos; p = r_next(m, p, &l))\n\t\t;\n\treturn p;\n}"
  },
  {
    "function_name": "r_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "76-81",
    "snippet": "static void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p, false);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_resource",
          "args": [
            "p",
            "false"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "next_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "63-74",
          "snippet": "static struct resource *next_resource(struct resource *p, bool sibling_only)\n{\n\t/* Caller wants to traverse through siblings only */\n\tif (sibling_only)\n\t\treturn p->sibling;\n\n\tif (p->child)\n\t\treturn p->child;\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *next_resource(struct resource *p, bool sibling_only)\n{\n\t/* Caller wants to traverse through siblings only */\n\tif (sibling_only)\n\t\treturn p->sibling;\n\n\tif (p->child)\n\t\treturn p->child;\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p, false);\n}"
  },
  {
    "function_name": "next_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
    "lines": "63-74",
    "snippet": "static struct resource *next_resource(struct resource *p, bool sibling_only)\n{\n\t/* Caller wants to traverse through siblings only */\n\tif (sibling_only)\n\t\treturn p->sibling;\n\n\tif (p->child)\n\t\treturn p->child;\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <linux/resource_ext.h>",
      "#include <linux/mm.h>",
      "#include <linux/pfn.h>",
      "#include <linux/device.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/ioport.h>",
      "#include <linux/errno.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic struct resource *next_resource(struct resource *p, bool sibling_only)\n{\n\t/* Caller wants to traverse through siblings only */\n\tif (sibling_only)\n\t\treturn p->sibling;\n\n\tif (p->child)\n\t\treturn p->child;\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}"
  }
]